#!/usr/bin/perl
package Components;

use File::Basename;
use Component;
use LibraryWriters;

sub new
{
  my $class = shift;
  my ($name, $component) = @_;
  #$key = $component->GetLanguage() . "_" . $pm . ":" . $component->GetCell();
  $key = $component->GetLanguage() . ":" . $component->GetName();
  my $components = {$key, $component};
  my $this = { Name		=> $name,
				Components  => $components
  };

  bless($this);
  return $this;
}

sub SetName
{
  my $self = shift;
  my $name = shift;
  $self->{Name} = $name;
}

sub GetName
{
  my $self = shift;
  return $self->{Name};
}

sub GetComponents
{
  my $self = shift;
  return $self->{Components};
}

sub AddComponent
{
  my $self = shift;
  my $component = shift;

  $components = $self->{Components};
  $key =  $component->GetLanguage() . ":" . $component->GetName();
  $oldComponent = $components->{$key};

  if (defined $oldComponent)
  {
    $oldComponent->MergeComponent($component);
  }
  else
  {
    $components->{$key} = $component;
  }
}

sub DeleteComponent
{
  my $self = shift;
  my $component = shift;

  $components = $self->{Components};
  $key =  $component->GetLanguage() . ":" . $component->GetName();
  delete $components->{$key};
}

sub FindComponentByKey
{
  my $self = shift;
  my $component = shift;

  $components = $self->{Components};
  $key =  $component->GetLanguage() . ":" . $component->GetName();
  $component1 = $components->{$key};
  return $component1;
}

sub FindComponentByName
{
  my $self = shift;
  my $name = shift;

  $components = $self->{Components};
  foreach $component (values %$components)
  {
    if ($name eq $component->GetName())
    {
      return $component;
    }
  }
  return undef;
}

sub Merge
{
  my $self = shift;
  my $components = shift;

  $components1 = $self->{Components};
  $components2 = $components->{Components};

  while (($key2, $component2) = each %$components2)
  {
    $components1->{$key2} = $component2;
  }
}

sub Dump
{
  my $self = shift;
  my $components = $self->{Components};
  print "Components:$self->{Name}=\n";

  my $componentCount = 0;
  my @records = ();
  my $record = "";
  foreach $component (values %$components)
  {
    $componentCount++;
    $record = $component->DumpToString();
    push @records, $record;
  }
  foreach $record (sort @records)
  {
    print $record;
  }

  print ";\n" if ($componentCount > 0);
}

sub DumpToFile
{
  my $self = shift;
  my $outfile = shift;
  if (!defined $outfile)
  {
    $outfile = $self->GetName();
  }
  my $components = $self->{Components};

  my @componentValues = values %$components;
  if ((scalar @componentValues) == 0)
  {
    warn "No output for empty Components ($outfile).\n";
    return;
  }

  print "Writing file $outfile ...\n\n" if($debug);
  open(OUT, "> $outfile") or die "Unable to open file <$outfile> for output\n";
  $components = $self->{Components};
  print OUT "Components:$outfile=\n";
  print OUT "::\n";

  my $componentCount = 0;
  my @records = ();
  my $record = "";
  foreach $component (values %$components)
  {
    $record = $component->DumpToString();
    push @records, $record;
  }
  foreach $record (sort @records)
  {
    print OUT $record;
  }

  print OUT ";;\n";
}

sub DumpToVhdlString
{
  my $self = shift;
  my $library = shift;
  my $translates = shift;
  my $components = $self->{Components};
  my $componentCount = 0;
  my @records = ();
  my $record = "";

  foreach $component (values %$components)
  {
    $componentCount++;
    my $cname = $component->GetName();
    foreach my $translate (@$translates)
    {
      print "Finding translate state - $translate vs $cname ...\n";
      if ($translate eq $cname)
      {
        $translate_offon = 1;
        last;
      }
    }
    $record = $component->DumpToVhdlString($library, $translate_offon);
    Push(\@records, $record);
  }
  my $string;
  foreach $record (sort @records)
  {
    $string .=$record;
  }
  return $string;
}

sub WriteVhdlComponentsFile
{
  my $self = shift;
  my $outputfile = shift;
  my $library = shift;
  my $translates = shift;
  my $timestamp = scalar localtime;
  my $components = $self->{Components};   
  my $numofcomponents = scalar (keys %$components);
   
  open(VHD, "> $outputfile")
     or die "Unable to open file <$outputfile> for output.\n";

  print "Writing Vhdl component file $outputfile ...\n" if($debug);

  my $output_filename = basename($outputfile); 

  print VHD "--**************************************************************\n";
  print VHD "--  Copyright (c) 2011 Xilinx, Inc.  All rights reserved.\n";         
  print VHD "--  File Name    : $output_filename\n";
  print VHD "--  Library      : $library\n";
  print VHD "--  Release      : 11.1\n";
  print VHD "--  Entity Count : $numofcomponents\n";
  #print VHD "--  Time         : $timestamp\n";
  print VHD "--  Generated by : gencomp.pl\n";
  print VHD "--**************************************************************\n\n";
   
  print VHD "library IEEE;\n";
  print VHD "use IEEE.STD_LOGIC_1164.all;\n";
   
  if ($library eq 'simprim')
  {
    print VHD "library VITAL2000;\n";
    print VHD "use VITAL2000.VITAL_Timing.all;\n";
  }
   
  print VHD "package VCOMPONENTS is\n";

  print VHD "attribute BOX_TYPE : string;\n" if ($library eq 'unisim');

  print VHD <<HEADER;


-- synopsys translate_off

-----------------------------------------
-----------   FPGA Globals --------------
-----------------------------------------
signal GSR : std_logic := '0';
signal GTS : std_logic := '0';
signal GWE : std_logic;
signal PLL_LOCKG : std_logic := 'H';
signal PROGB_GLBL : std_logic;
signal CCLKO_GLBL : std_logic;
signal FCSBO_GLBL : std_logic;
signal DO_GLBL : std_logic_vector(3 downto 0);
signal DI_GLBL : std_logic_vector(3 downto 0);

-----------------------------------------
-----------   CPLD Globals --------------
-----------------------------------------
signal PRLD : std_logic := '0';

-----------------------------------------
-----------   JTAG Globals --------------
-----------------------------------------
signal JTAG_TDO_GLBL  : std_logic;
signal JTAG_TDI_GLBL  : std_logic;
signal JTAG_TMS_GLBL  : std_logic;
signal JTAG_TCK_GLBL  : std_logic;
signal JTAG_TRST_GLBL : std_logic;

signal JTAG_CAPTURE_GLBL : std_logic;
signal JTAG_RESET_GLBL : std_logic;
signal JTAG_SHIFT_GLBL : std_logic;
signal JTAG_UPDATE_GLBL : std_logic;
signal JTAG_RUNTEST_GLBL : std_logic;

signal JTAG_SEL1_GLBL : std_logic := '0';
signal JTAG_SEL2_GLBL : std_logic := '0';
signal JTAG_SEL3_GLBL : std_logic := '0';
signal JTAG_SEL4_GLBL : std_logic := '0';

signal JTAG_USER_TDO1_GLBL : std_logic := 'Z';
signal JTAG_USER_TDO2_GLBL : std_logic := 'Z';
signal JTAG_USER_TDO3_GLBL : std_logic := 'Z';
signal JTAG_USER_TDO4_GLBL : std_logic := 'Z';

-- synopsys translate_on

-- START COMPONENT
HEADER

  print VHD $self->DumpToVhdlString($library, $translates);
 
  print VHD <<TAIL;
-- END COMPONENT

end VCOMPONENTS;
TAIL
}

sub DumpToVerilogString
{
  my $self = shift;
  my $translates = shift;
  my $components = $self->{Components};
  my $componentCount = 0;
  my @records = ();
  my $record = "";

  foreach $component (values %$components)
  {
    $componentCount++;
    my $translate_offon = 0;
    my $cname = $component->GetName();
    foreach my $translate (@$translates)
    {
      print "Finding translate state - $translate vs $cname ...\n";
      if ($translate eq $cname)
      {
        $translate_offon = 1;
        last;
      }
    }
    $record = $component->DumpToVerilogString($translate_offon);
    Push(\@records, $record);
  }
  my $string;
  foreach $record (sort @records)
  {
    $string .=$record;
  }
  return $string;
}

sub WriteVerilogComponentsFile
{
  my $self = shift;
  my $outputfile = shift;
  my $library = shift;
  my $translates = shift;
  my $timestamp = scalar localtime;
  my $components = $self->{Components};   
  my $numofcomponents = scalar (keys %$components);
   
  open(VLG, "> $outputfile")
      or die "Unable to open file <$outputfile> for output.\n";

  print "Writing Verilog component file $outputfile ...\n" if($debug);

  my $output_filename = basename($outputfile); 

  print VLG "//**************************************************************\n";
  print VLG "//  Copyright (c) 2011 Xilinx, Inc.  All rights reserved.\n";         
  print VLG "//  File Name    : $output_filename\n";
  print VLG "//  Library      : $library\n";
  print VLG "//  Release      : 11.1\n";
  print VLG "//  Module Count : $numofcomponents\n";
  #print VLG "//  Time         : $timestamp\n";
  print VLG "//  Generated by : gencomp.pl\n";
  print VLG "//**************************************************************\n\n";
   
  print VLG "// START COMPONENTS\n\n";

  print VLG $self->DumpToVerilogString($translates);
 
  print VLG "\n// END COMPONENTS\n";
}

sub FilterIt
{
  my $self = shift;
  my $filters = shift;
  my $components = $self->{Components};
  foreach $component (values %$components)
  {
    my $name = $component->GetName();
    foreach my $filter (@$filters)
    {
      my $fcompname = $filter->GetName();
      my $properties = $filter->GetProperties();
      if (($name eq $fcompname) || ($fcompname eq "*") || ($fcompname eq ""))
      {            
        if ((keys %$properties) == 0) # ignore_module
        {
          $self->DeleteComponent($component);               
        }
        else
        {
          foreach my $key (keys %$properties)
          {
            $property = $properties->{$key};
            my $pn = $property->GetName();
            $comp_properties = $component->GetProperties();
            foreach $key (keys %$comp_properties)
            {
              if ($key eq $pn)
              {
                #print "Deleting property '$pn' on component '$name''...\n";  
                delete $comp_properties->{$key};
                last;
              }
            }
          }
        }
        #last;
      }
    }
  }   
}

1;
