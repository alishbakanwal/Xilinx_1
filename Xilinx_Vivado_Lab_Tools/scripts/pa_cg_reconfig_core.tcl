# COPYRIGHT NOTICE
# Copyright 1986-1999, 2001-2009 Xilinx, Inc. All Rights Reserved.
#
# FILE: pa_cg_reconfig_core.tcl
#
# This script reconfigures a coregen core
#

source "$tclUtilsPath"

##########################################
# Recustomize CORE Generator 2.0 IP core #
##########################################

set result 1

set logPath [file dirname $cgProjectPath]
set xmsgLogFile [$iIPEngine SetXmsgsLog "$logPath/_xmsgs/cg.xmsgs"]
if { [ catch { set coregenLogFile [$iIPEngine SetLog "$logPath/coregen.log"] } ] } {
   puts "Error writing coregen.log"
}

global env
set env(XIL_CG_API_LOCKCOMPONENTNAME) 1

# open existing project
if { [string trim $repoPaths] ne "" } {  
  $iRepositoryManager SetRepositoryList [toStringContainer $repoPaths]
}

#  Reload the repositories unless there is an explicit discovery of a
# flag-set-to-false from PlanAhead. This "fails safe" into previous
# "always reload everything" CoreGen behaviour if the flag either
# isn't detected or isn't set (the two cases below).
if { ![info exists reloadAllCoreGenRepositories] } {
  $iRepositoryManager RefreshAllRepositories
} elseif { $reloadAllCoreGenRepositories } {
  $iRepositoryManager RefreshAllRepositories
}

#   We need to be aware of the IP metadata type when generating the output products for the IP.
# We can call "setValue" on IP-XACT IP because the parameters are declared in the metadata;
# this means that we can invoke CoreGen through the TGI without having to tell it to read files
# that define its parameterisation.
#   Unfortunately, we can't call setValue on an XCD or ChipScope IP without having first run batch
# mode customization in the current session (and thus running the Tcl IP Model to identify and
# create the available parameters).
#   CoreGen can get around this by assuming that XCO contents are valid; it migrates the XCO file
# into a CGC file which it can then open as a project containing a single component instance with
# parameters that have already had their values set. We avoid this where possible because of the
# added complexity and time; it should save a second per CoreGen invocation.
#   Where the CGC file for a migrated project exists, it should be assumed that the parameters
# already exist, and that we don't need to re-migrate the project.
#   Note that where the XCO has been migrated into a new CGC, there is no need to set the
# parameter values on the IP instance.

set ipIdentifier [$iRepositoryManager GetComponentID     $vlnv]
set ipType       [$iTGIHelper         getComponentIpType $ipIdentifier]
set designID     ""
set migrated     false

if { $ipType eq "SPIRIT" } {
   # Ensure that any existing CGC file is deleted. Note that non-existence doesn't trigger an error.
   file delete -force $cgProjectPath
   set designID [$iProjectManager NewProject         "$cgProjectPath" "xilinx.com:projects:${ipName}:${productVersion}"]
} elseif {[file exists "$cgProjectPath"]} {
   set designID [$iProjectManager OpenProject        "$cgProjectPath"]
} elseif {[$iProjectManager MigrateProject "$ipFile" "$cgProjectPath" "xilinx.com:projects:${ipName}:${productVersion}"]} {
   set designID [$iProjectManager OpenProject        "$cgProjectPath"]
   set migrated true
} else {
   puts "ERROR: Unable to migrate CoreGen project from ${ipFile}"
}

if { $designID eq "" } {
   puts "ERROR: Unable to open a CoreGen project for ${ipName}"
} else {

   # set project options
   $iTGIHelper setDesignPart     $designID "$cgPartSpec"
   $iTGIHelper setDesignLanguage $designID "$hdlType"

   # The reasoning in the comments above applies; if this is IP-XACT or PSF IP, we can just add
   # it to the new project. If it's XCD IP, we access the instance in the existing project.
   
   if { $ipType eq "SPIRIT" } {
      # create new component instance in project
      set componentInstanceID [$iTGI addComponentInstance $designID $vlnv $ipName "" "Generated by PlanAhead/Vivado"]
   } else {
      # access the migrated component instance in project
      set componentInstanceID [$iTGI getComponentInstanceID $designID $ipName]
   }

   set componentID [$iTGI getComponentInstanceComponentID $componentInstanceID]

   if { $componentInstanceID eq "" } {
      puts "ERROR: Unable to find component instance ${ipName} within project"
   } elseif { $componentID eq "" } {
      puts "ERROR: Unable to find component $vlnv within repository"
   } else {

      #  If an XCO has been migrated to create a CGC, then the parameter values are already
      # up-to-date, and set to the correct values. If it has not been migrated, we need to
      # bring the CoreGen parameter values into alignment with those of the IP instance.
      if { !$migrated } {
         # Set the user parameters from the Rodin IP instance on the newly-created CoreGen instance.
         foreach userParameter $userParameters {
            set userParameterFound  false
            set userParameterName   [lindex $userParameter 0]
            set userParameterValue  [lindex $userParameter 1]
            set userParameterIDs    [$iTGI getParameterIDs $componentInstanceID]
            for {$userParameterIDs GetIterator parameterIDItr} {![$parameterIDItr IsEnd]} {$parameterIDItr Next} {
               set parameterID    [$parameterIDItr CurrentItem]
               set parameterName  [$iTGI getName  $parameterID]
               set parameterValue [$iTGI getValue $parameterID]

               if { [string equal -nocase $parameterName $userParameterName] } {
                  $iTGI setValue $parameterID $userParameterValue
                  set userParameterFound true
                  break
               }
            }
            if { !$userParameterFound } {
               puts "ERROR: Failed to set missing parameter '$userParameterName' to value '$userParameterValue'."
            } else {
               puts "Set parameter '$userParameterName' to value '$userParameterValue'."
            }
         }
      }

      set generatorChainIDs [$iTGIHelper getGeneratorChainIDs  $componentID]

      # chain groups specified at: 
      #  http://ipwiki/twiki/bin/view/Software/CoreGen2Design#Generator_Chain_Groups

      $iStringContainer Clear
      set group "COREGEN"
      $iStringContainer Add group
      set generatorChainIDs [$iGenerationManager FilterChainIDsByGroup $generatorChainIDs $iStringContainer "AND"]

      $iStringContainer Clear
      foreach chain $chains { 
         set group $chain
         $iStringContainer Add group
      }

      set generatorChainIDs [$iGenerationManager FilterChainIDsByGroup $generatorChainIDs $iStringContainer "OR"]
      set result            [$iGenerationManager Generate $componentInstanceID $generatorChainIDs]

      if { $result == 0 } {
         # generate BOM file
         if { [catch { GenerateBOMFile "$bomFilePath" $componentInstanceID $generatorChainIDs } results ] } {
            puts "ERROR processing BOM - $results"
            set result 1
         } else {
            puts "Generated BOM file '$bomFilePath'."
         }
      } else {
         puts "Error generating ${ipName}"
      }
      $iProjectManager SaveProject $designID
   }
   $iProjectManager CloseProject $designID
}

return $result

# XSIP watermark, do not delete 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
