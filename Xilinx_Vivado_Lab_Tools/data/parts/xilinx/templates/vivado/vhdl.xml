<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="template.xsl"?>
<RootFolder label="VHDL" treetype="folder" language="VHDL">
	<Folder label="Common Constructs" treetype="folder">
		<SubFolder label="Architecture, Component &amp; Entity" treetype="folder">
			<Template label="Architecture Declaration" treetype="template">

architecture &lt;arch_name&gt; of &lt;entity_name&gt; is
   -- declarative_items (signal declarations, component declarations, etc.)
begin
   -- architecture body
end &lt;arch_name&gt;;
			</Template>
			<Template label="Component Declaration" treetype="template">

component &lt;component_name&gt;
generic (
   &lt;generic_name&gt; : &lt;type&gt; := &lt;value&gt;;
   &lt;other generics&gt;...
);
port (
   &lt;port_name&gt; : &lt;mode&gt; &lt;type&gt;;
   &lt;other ports&gt;...
);
end component;
			</Template>
			<Template label="Component Instantiation" treetype="template">

&lt;instance_name&gt; : &lt;component_name&gt;
generic map (
   &lt;generic_name&gt; =&gt; &lt;value&gt;,
   &lt;other generics&gt;...
)
port map (
   &lt;port_name&gt; =&gt; &lt;signal_name&gt;,
   &lt;other ports&gt;...
);
			</Template>
			<Template label="Entity Declaration" treetype="template">

entity &lt;entity_name&gt; is
generic (
   &lt;generic_name&gt; : &lt;type&gt; := &lt;value&gt;;
   &lt;other generics&gt;...
);
port (
   &lt;port_name&gt; : &lt;mode&gt; &lt;type&gt;;
   &lt;other ports&gt;...
);
end &lt;entity_name&gt;;
			</Template>
		</SubFolder>
		<SubFolder label="Comments" treetype="folder">
			<Template label="Sample File Header" treetype="template">
--------------------------------------------------------------------------------
-- Company: &lt;Company Name&gt;
-- Engineer: &lt;Engineer Name&gt;
--
-- Create Date: &lt;date&gt;
-- Design Name: &lt;name_of_top-level_design&gt;
-- Component Name: &lt;name_of_this_component&gt;
-- Target Device: &lt;target device&gt;
-- Tool versions: &lt;tool_versions&gt;
-- Description:
--    &lt;Description here&gt;
-- Dependencies:
--    &lt;Dependencies here&gt;
-- Revision:
--    &lt;Code_revision_information&gt;
-- Additional Comments:
--    &lt;Additional_comments&gt;
--------------------------------------------------------------------------------
			</Template>
			<Template label="Single Line(--)" treetype="template">
-- Comment here

			</Template>
		</SubFolder>
		<SubFolder label="Conversion Functions" treetype="folder">
			<SubFolder label="IEEE-NUMERIC_STD" treetype="folder">
				<Template label="INTEGER to SIGNED" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.numeric_std.all;

&lt;signed_sig&gt; = TO_SIGNED(&lt;int_sig&gt;, &lt;integer_size&gt;);
				</Template>
				<Template label="INTEGER to UNSIGNED" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.numeric_std.all;

&lt;unsigned_sig&gt; = TO_UNSIGNED(&lt;int_sig&gt;, &lt;integer_size&gt;);
				</Template>
				<Template label="SIGNED to INTEGER" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.numeric_std.all;

&lt;int_sig&gt; = TO_INTEGER(&lt;signed_sig&gt;);
				</Template>
				<Template label="UNSIGNED to INTEGER" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.numeric_std.all;

&lt;int_sig&gt; = TO_INTEGER(&lt;unsigned_sig&gt;);
				</Template>
			</SubFolder>
			<SubFolder label="IEEE-STD_LOGIC_1164" treetype="folder">
				<Template label="BIT to STD_ULOGIC" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.std_logic_1164.all;

&lt;sul_sig&gt; = To_StdUlogic(&lt;bit_sig&gt;);
				</Template>
				<Template label="BIT_VECTOR to STD_LOGIC_VECTOR" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.std_logic_1164.all;

&lt;slv_sig&gt; = To_StdLogicVector(&lt;bv_sig&gt;);
				</Template>
				<Template label="BIT_VECTOR to STD_ULOGIC_VECTOR" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.std_logic_1164.all;

&lt;sulv_sig&gt; = To_StdULogicVector(&lt;bv_sig&gt;);
				</Template>
				<Template label="STD_LOGIC_VECTOR to BIT_VECTOR" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.std_logic_1164.all;

&lt;bv_sig&gt; = To_bitvector(&lt;slv_sig&gt;);
				</Template>
				<Template label="STD_LOGIC_VECTOR to STD_ULOGIC_VECTOR" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.std_logic_1164.all;

&lt;sulv_sig&gt; = To_StdULogicVector(&lt;slv_sig&gt;);
				</Template>
				<Template label="STD_ULOGIC to BIT" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.std_logic_1164.all;

&lt;bit_sig&gt; = To_bit(&lt;sul_sig&gt;);
				</Template>
				<Template label="STD_ULOGIC_VECTOR to BIT_VECTOR" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.std_logic_1164.all;

&lt;bv_sig&gt; = To_bitvector(&lt;sulv_sig&gt;);
				</Template>
				<Template label="STD_ULOGIC_VECTOR to STD_LOGIC_VECTOR" treetype="template">
--The following library will need to be declared for this function:
--library IEEE;
--use IEEE.std_logic_1164.all;

&lt;slv_sig&gt; = To_StdLogicVector(&lt;sulv_sig&gt;);
				</Template>
			</SubFolder>
			<Template label="Info" treetype="template">
-- How To Use Conversion Functions
-- ===============================
--
-- The VHDL langauge allows the usage of conversion functions. These conversion
-- functions are generally used to convert from one type to another.
-- There are multiple conversion functions provided in different libraries.
-- This is why it is important to reference the correct library in which the
-- conversion function is available
--
-- To make it easier a couple of examples of using conversion functions are
-- provided below.

			</Template>
		</SubFolder>
		<SubFolder label="Library Declarations/Use" treetype="folder">
			<Template label="Commonly Used" treetype="template">
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use IEEE.std_logic_unsigned.all;

			</Template>
			<SubFolder label="IEEE" treetype="folder">
				<Template label="Declaration" treetype="template">
library IEEE;
				</Template>
				<SubFolder label="Packages" treetype="folder">
					<Template label="math_complex" treetype="template">
use IEEE.math_complex.all;
					</Template>
					<Template label="math_real" treetype="template">
use IEEE.math_real.all;
					</Template>
					<Template label="numeric_bit" treetype="template">
use IEEE.numeric_bit.all;
					</Template>
					<Template label="numeric_std" treetype="template">
use IEEE.numeric_std.all;
					</Template>
					<Template label="std_logic_misc" treetype="template">
use IEEE.std_logic_misc.all;
					</Template>
					<Template label="std_logic_signed" treetype="template">
use IEEE.std_logic_signed.all;
					</Template>
					<Template label="std_logic_textio" treetype="template">
use std.textio.all;
					</Template>
					<Template label="std_logic_unsigned" treetype="template">
use IEEE.std_logic_unsigned.all;
					</Template>
					<Template label="std_logic_1164" treetype="template">
use IEEE.std_logic_1164.all;
					</Template>
				</SubFolder>
			</SubFolder>
			<Template label="User Defined" treetype="template">
library &lt;LIB_NAME&gt;;
use &lt;LIB_NAME&gt;.&lt;PACKAGE_NAME&gt;.all
			</Template>
		</SubFolder>
		<SubFolder label="Operators" treetype="folder">
			<Template label="Arithmetic" treetype="template">

--The following are the arithmetic operators as defined by the VHDL language.

   +   ---- Addition
   -   ---- Subtraction
   *   ---- Multiplication
   /   ---- Divide
   mod ---- Modulus
   **  ---- Power Operator (i.e. 2**8 returns 256)
			</Template>
			<Template label="Bitwise" treetype="template">

--The following operators can be used on two single bits to produce a single bit
--output or two equivelent sized bused signals where the operations are performed
--on each bit of the bus. In the case of the Invert, only one signal or bus is
--provided and the operation occurs on each bit of the signal.

   NOT  ---- Invert a single-bit signal or each bit in a bus
   AND  ---- AND two single bits or each bit between two buses
   OR   ---- OR two single bits or each bit between two buses
   XOR  ---- XOR two single bits or each bit between two buses
   XNOR ---- XNOR two single bits or each bit between two buses

			</Template>
			<Template label="Concatenate" treetype="template">

--The following operators either concatenates several bits into a bus or replicate
--a bit or combination of bits multiple times.

   a &amp; b &amp; c ---- Concatenate a, b and c into a bus

			</Template>
			<Template label="Logical" treetype="template">

--The following logical operators are used in conditional TRUE/FALSE statements
--such as an if statement in order to specify the condition fo the operation.

   NOT ---- Not True
   AND ---- Both Inputs True
   OR  ---- Either Input True
   =   ---- Inputs Equal
   /=  ---- Inputs Not Equal
   &lt;   ---- Less-than
   &lt;=  ---- Less-than or Equal
   &gt;   ---- Greater-than
   &gt;=  ---- Greater-than or Equal

			</Template>
			<SubFolder label="Rotate Left" treetype="folder">
				<Template label="Signed" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;signed_sig&gt; rol &lt;shift_amount_in_integer&gt;;
				</Template>
				<Template label="Unsigned" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;unsigned_sig&gt; rol &lt;shift_amount_in_integer&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="Rotate Right" treetype="folder">
				<Template label="Signed" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;signed_sig&gt; ror &lt;shift_amount_in_integer&gt;;
				</Template>
				<Template label="Unsigned" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;unsigned_sig&gt; ror &lt;shift_amount_in_integer&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="Shift Left Arithmetic" treetype="folder">
				<Template label="Signed" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;signed_sig&gt; sla &lt;shift_amount_in_integer&gt;;
				</Template>
				<Template label="Unsigned" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;unsigned_sig&gt; sla &lt;shift_amount_in_integer&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="Shift Left Logical" treetype="folder">
				<Template label="Signed" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;signed_sig&gt; sll &lt;shift_amount_in_integer&gt;;
				</Template>
				<Template label="Unsigned" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;unsigned_sig&gt; sll &lt;shift_amount_in_integer&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="Shift Right Arithmetic" treetype="folder">
				<Template label="Signed" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;signed_sig&gt; sra &lt;shift_amount_in_integer&gt;;
				</Template>
				<Template label="Unsigned" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;unsigned_sig&gt; sra &lt;shift_amount_in_integer&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="Shift Right Logical" treetype="folder">
				<Template label="Signed" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;signed_sig&gt; srl &lt;shift_amount_in_integer&gt;;
				</Template>
				<Template label="Unsigned" treetype="template">
--The IEEE.numeric_std library will need to be acessed for these functions

&lt;unsigned_sig&gt; srl &lt;shift_amount_in_integer&gt;;
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Ports" treetype="folder">
			<SubFolder label="Bidirectional (inout)" treetype="folder">
				<Template label="1-bit" treetype="template">
   &lt;port_name&gt; : inout std_logic;
				</Template>
				<Template label="2-bit" treetype="template">
   &lt;port_name&gt; : inout std_logic_vector(1 downto 0);
				</Template>
				<Template label="3-bit" treetype="template">
   &lt;port_name&gt; : inout std_logic_vector(2 downto 0);
				</Template>
				<Template label="4-bit" treetype="template">
   &lt;port_name&gt; : inout std_logic_vector(3 downto 0);
				</Template>
				<Template label="8-bit" treetype="template">
   &lt;port_name&gt; : inout std_logic_vector(7 downto 0);
				</Template>
				<Template label="16-bit" treetype="template">
   &lt;port_name&gt; : inout std_logic_vector(15 downto 0);
				</Template>
				<Template label="32-bit" treetype="template">
   &lt;port_name&gt; : inout std_logic_vector(31 downto 0);
				</Template>
				<Template label="64-bit" treetype="template">
   &lt;port_name&gt; : inout std_logic_vector(63 downto 0);
				</Template>
			</SubFolder>
			<SubFolder label="Input" treetype="folder">
				<Template label="1-bit" treetype="template">
   &lt;port_name&gt; : in std_logic;
				</Template>
				<Template label="2-bit" treetype="template">
   &lt;port_name&gt; : in std_logic_vector(1 downto 0);
				</Template>
				<Template label="3-bit" treetype="template">
   &lt;port_name&gt; : in std_logic_vector(2 downto 0);
				</Template>
				<Template label="4-bit" treetype="template">
   &lt;port_name&gt; : in std_logic_vector(3 downto 0);
				</Template>
				<Template label="8-bit" treetype="template">
   &lt;port_name&gt; : in std_logic_vector(7 downto 0);
				</Template>
				<Template label="16-bit" treetype="template">
   &lt;port_name&gt; : in std_logic_vector(15 downto 0);
				</Template>
				<Template label="32-bit" treetype="template">
   &lt;port_name&gt; : in std_logic_vector(31 downto 0);
				</Template>
				<Template label="64-bit" treetype="template">
   &lt;port_name&gt; : in std_logic_vector(63 downto 0);
				</Template>
			</SubFolder>
			<SubFolder label="Output" treetype="folder">
				<Template label="1-bit" treetype="template">
   &lt;port_name&gt; : out std_logic;
				</Template>
				<Template label="2-bit" treetype="template">
   &lt;port_name&gt; : out std_logic_vector(1 downto 0);
				</Template>
				<Template label="3-bit" treetype="template">
   &lt;port_name&gt; : out std_logic_vector(2 downto 0);
				</Template>
				<Template label="4-bit" treetype="template">
   &lt;port_name&gt; : out std_logic_vector(3 downto 0);
				</Template>
				<Template label="8-bit" treetype="template">
   &lt;port_name&gt; : out std_logic_vector(7 downto 0);
				</Template>
				<Template label="16-bit" treetype="template">
   &lt;port_name&gt; : out std_logic_vector(15 downto 0);
				</Template>
				<Template label="32-bit" treetype="template">
   &lt;port_name&gt; : out std_logic_vector(31 downto 0);
				</Template>
				<Template label="64-bit" treetype="template">
   &lt;port_name&gt; : out std_logic_vector(63 downto 0);
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Predefined Attributes" treetype="folder">
			<SubFolder label="Arrays" treetype="folder">
				<Template label="Left-bound of Index" treetype="template">
&lt;array_id&gt;'left(&lt;expr&gt;)
				</Template>
				<Template label="'left down/to 'right" treetype="template">
&lt;array_id&gt;'range(&lt;expr&gt;)
				</Template>
				<Template label="Length of Dimension" treetype="template">
&lt;array_id&gt;'length(&lt;expr&gt;)
				</Template>
				<Template label="Lower-bound of Index" treetype="template">
&lt;array_id&gt;'lower(&lt;expr&gt;)
				</Template>
				<Template label="Right-bound of Index" treetype="template">
&lt;array_id&gt;'right(&lt;expr&gt;)
				</Template>
				<Template label="'right down/to 'left" treetype="template">
&lt;array_id&gt;'reverse_range(&lt;expr&gt;)
				</Template>
				<Template label="'right &gt;= 'left" treetype="template">
&lt;array_id&gt;'ascending(&lt;expr&gt;)
				</Template>
				<Template label="Upper-bound of Index" treetype="template">
&lt;array_id&gt;'upper(&lt;expr&gt;)
				</Template>
			</SubFolder>
			<SubFolder label="Objects" treetype="folder">
				<Template label="Name of Object" treetype="template">
&lt;object_id&gt;'simple_value
				</Template>
				<Template label="Pathname of Object" treetype="template">
&lt;object_id&gt;'instance_name
				</Template>
				<Template label="Pathname to Object" treetype="template">
&lt;object_id&gt;'path_name
				</Template>
			</SubFolder>
			<SubFolder label="Signals" treetype="folder">
				<Template label="Active Driving Predicate" treetype="template">
&lt;signal_id&gt;'driving
				</Template>
				<Template label="Activity on Signal" treetype="template">
&lt;signal_id&gt;'active
				</Template>
				<Template label="Delayed Copy of Signal" treetype="template">
&lt;signal_id&gt;'delayed(&lt;TIME&gt;)
				</Template>
				<Template label="Event on Signal" treetype="template">
&lt;signal_id&gt;'event
				</Template>
				<Template label="Signals Activity on Signal" treetype="template">
&lt;signal_id&gt;'quiet(&lt;TIME&gt;)
				</Template>
				<Template label="Signals Event on Signal" treetype="template">
&lt;signal_id&gt;'stable(&lt;TIME&gt;)
				</Template>
				<Template label="Time since Last Active" treetype="template">
&lt;signal_id&gt;'last_active
				</Template>
				<Template label="Time since Last Event" treetype="template">
&lt;signal_id&gt;'last_event
				</Template>
				<Template label="Toggles if Signal Active" treetype="template">
&lt;signal_id&gt;'transaction
				</Template>
				<Template label="Value before Last Event" treetype="template">
&lt;signal_id&gt;'last_value
				</Template>
				<Template label="Value of Driver" treetype="template">
&lt;signal_id&gt;'driving_value
				</Template>
			</SubFolder>
			<SubFolder label="Types" treetype="folder">
				<Template label="Ascending Type Predicate" treetype="template">
&lt;type_id&gt;'ascending
				</Template>
				<Template label="Base type" treetype="template">
&lt;type_id&gt;'base
				</Template>
				<Template label="Left-bound Value" treetype="template">
&lt;type_id&gt;'left
				</Template>
				<Template label="Lower-bound Value" treetype="template">
&lt;type_id&gt;'low
				</Template>
				<Template label="Next Value in Order" treetype="template">
&lt;type_id&gt;'succ(&lt;expr&gt;)
				</Template>
				<Template label="Position within Type" treetype="template">
&lt;type_id&gt;'pos(&lt;expr&gt;)
				</Template>
				<Template label="Previous Value in Order" treetype="template">
&lt;type_id&gt;'pred(&lt;expr&gt;)
				</Template>
				<Template label="Right-bound Value" treetype="template">
&lt;type_id&gt;'right
				</Template>
				<Template label="String Image of Value" treetype="template">
&lt;type_id&gt;'image(&lt;expr&gt;)
				</Template>
				<Template label="Upper-bound Value" treetype="template">
&lt;type_id&gt;'high
				</Template>
				<Template label="Value at Position" treetype="template">
&lt;type_id&gt;'val(&lt;expr&gt;)
				</Template>
				<Template label="Value of String Image" treetype="template">
&lt;type_id&gt;'value(&lt;string&gt;)
				</Template>
				<Template label="Value to the Left in Order" treetype="template">
&lt;type_id&gt;'leftof(&lt;expr&gt;)
				</Template>
				<Template label="Value to the Right in Order" treetype="template">
&lt;type_id&gt;'rightof(&lt;expr&gt;)
				</Template>
			</SubFolder>
		</SubFolder>
		<Template label="Predefined Types" treetype="template">
STD_LOGIC              --'U','X','0','1','Z','W','L','H','-'
STD_LOGIC_VECTOR       --Natural Range of STD_LOGIC
BOOLEAN                --True or False
INTEGER                --32 or 64 bits
NATURAL                --Integers &gt;= 0
POSITIVE               --Integers &gt; 0
REAL                   --Floating-point
BIT                    --'0','1'
BIT_VECTOR(Natural)    --Array of bits
CHARACTER              --7-bit ASCII
STRING(POSITIVE)       --Array of charachters
TIME                   --hr, min, sec, ms, us, ns, ps, fs
DELAY_LENGTH           --Time &gt;= 0
		</Template>
		<SubFolder label="User Defined Functions &amp; Procedures" treetype="folder">
			<Template label="Calling a Function (named notation)" treetype="template">
   &lt;signal_name&gt; = &lt;function_name&gt;(&lt;input1&gt; =&gt; &lt;insig1&gt;, &lt;input2&gt; =&gt; &lt;insig2&gt;, ...);
			</Template>
			<Template label="Calling a Function (positional notation)" treetype="template">
   &lt;signal_name&gt; = &lt;function_name&gt;(&lt;comma_separated_inputs&gt;);
			</Template>
			<Template label="Calling a Procedure (named notation)" treetype="template">
   &lt;procedure_name&gt;(&lt;input1&gt; =&gt; &lt;insig1&gt;, ... , &lt;output1&gt; =&gt; &lt;outsig1&gt;, ...);
			</Template>
			<Template label="Calling a Procedure (positional notation)" treetype="template">
   &lt;procedure_name&gt;(&lt;comma_separated_inputs&gt;,&lt;comma_separated_outputs&gt;);
			</Template>
			<Template label="Function Body" treetype="template">
   function &lt;FUNC_NAME&gt; (&lt;comma_separated_inputs&gt; : &lt;type&gt;;
                         &lt;comma_separated_inputs&gt; : &lt;type&gt;) return &lt;type&gt; is
      -- subprogram_declarative_items (constant declarations, variable declarations, etc.)
   begin
      -- function body
   end &lt;FUNC_NAME&gt;;
			</Template>
			<Template label="Function Declaration" treetype="template">
   function &lt;FUNC_NAME&gt; (&lt;comma_separated_inputs&gt; : &lt;type&gt;;
                         &lt;comma_separated_inputs&gt; : &lt;type&gt;) return &lt;type&gt;;
			</Template>
			<Template label="Procedure Body" treetype="template">
   procedure &lt;PROC_NAME&gt; (&lt;comma_separated_inputs&gt; : in &lt;type&gt;;
                          &lt;comma_separated_outputs&gt; : out &lt;type&gt;) is
      -- subprogram_declarative_items (constant declarations, variable declarations, etc.)
   begin
      -- procedure body
   end &lt;PROC_NAME&gt;;
			</Template>
			<Template label="Procedure Declaration" treetype="template">
   procedure &lt;PROC_NAME&gt; (&lt;comma_separated_inputs&gt; : in &lt;type&gt;;
                          &lt;comma_separated_outputs&gt; : out &lt;type&gt;);
			</Template>
		</SubFolder>
	</Folder>
	<Folder label="Device Macro Instantiation" treetype="folder">
		<SubFolder label="Artix-7" treetype="folder">
			<SubFolder label="DSP48" treetype="folder">
				<Template label="Add and Multiply Accumulate (ADDMACC_MACRO)" treetype="template">
-- ADDMACC_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (ADDMACC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ADDMACC_MACRO: Add and Multiple Accumulate Function implemented in a DSP48E
   --                Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   ADDMACC_MACRO_inst : ADDMACC_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",  -- Target Device: "7SERIES", "VIRTEX6", "SPARTAN6" 
      LATENCY =&gt; 4,         -- Desired clock cycle latency, 1-4
      WIDTH_PREADD =&gt; 25,   -- Pre-Adder input bus width, 1-25
      WIDTH_MULTIPLIER =&gt; 18, -- Multiplier input bus width, 1-18     
      WIDTH_PRODUCT =&gt; 48)    -- MACC output width, 1-48
   port map (
      PRODUCT =&gt; PRODUCT,     -- MACC result output, width defined by WIDTH_PRODUCT generic 
      MULTIPLIER =&gt; MULTIPLIER, -- Multiplier data input, width determined by WIDTH_MULTIPLIER generic
      PREADDER1 =&gt; PREADDER1,   -- Preadder data input, width determined by WIDTH_PREADDER generic 
      PREADDER2 =&gt; PREADDER2,   -- Preadder data input, width determined by WIDTH_PREADDER generic 
      CARRYIN =&gt; CARRYIN, -- 1-bit carry-in input
      CE =&gt; CE,      -- 1-bit input clock enable
      CLK =&gt; CLK,    -- 1-bit clock input
      LOAD =&gt; LOAD, -- 1-bit accumulator load input
      LOAD_DATA =&gt; LOAD_DATA, -- Accumulator load data input, width defined by WIDTH_PRODUCT generic
      RST =&gt; RST    -- 1-bit input active high synchronous reset
   );
   -- End of ADDMACC_MACRO_inst instantiation

				</Template>
				<Template label="Add / Subtract (ADDSUB_MACRO)" treetype="template">
-- ADDSUB_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (ADDSUB_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ADDSUB_MACRO: Variable width &amp; latency - Adder / Subtrator implemented in a DSP48E
   --               Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   ADDSUB_MACRO_inst : ADDSUB_MACRO
   generic map (
      DEVICE =&gt; "7SERIES", -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      LATENCY =&gt; 2,        -- Desired clock cycle latency, 0-2
      WIDTH =&gt; 48)         -- Input / Output bus width, 1-48
   port map (
      CARRYOUT =&gt; CARRYOUT, -- 1-bit carry-out output signal
      RESULT =&gt; RESULT,     -- Add/sub result output, width defined by WIDTH generic
      A =&gt; A,               -- Input A bus, width defined by WIDTH generic
      ADD_SUB =&gt; ADD_SUB,   -- 1-bit add/sub input, high selects add, low selects subtract
      B =&gt; B,               -- Input B bus, width defined by WIDTH generic
      CARRYIN =&gt; CARRYIN,   -- 1-bit carry-in input
      CE =&gt; CE,             -- 1-bit clock enable input
      CLK =&gt;CLK,           -- 1-bit clock input
      RST =&gt; RST            -- 1-bit active high synchronous reset
   );
   -- End of ADDSUB_MACRO_inst instantiation

				</Template>
				<Template label="Counter w/ Terminal Count (COUNTER_TC_MACRO)" treetype="template">
--COUNTER_TC_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (COUNTER_TC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- COUNTER_TC_MACRO: Counter with terminal count implemented in a DSP48E
   --                   Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   COUNTER_TC_MACRO_inst : COUNTER_TC_MACRO
   generic map (
      COUNT_BY =&gt; X"000000000001", -- Count by value
      DEVICE =&gt; "7SERIES",         -- Target Device: "VIRTEX5", "7SERIES" 
      DIRECTION =&gt; "UP",            -- Counter direction "UP" or "DOWN" 
      RESET_UPON_TC =&gt; "FALSE",      -- Reset counter upon terminal count, TRUE or FALSE
      TC_VALUE =&gt; X"000000000000", -- Terminal count value
      WIDTH_DATA =&gt; 48)            -- Counter output bus width, 1-48
   port map (
      Q =&gt; Q,        -- Counter ouput, width determined by WIDTH_DATA generic 
      TC =&gt; TC,      -- 1-bit terminal count output, high = terminal count is reached
      CLK =&gt; CLK,    -- 1-bit clock input
      CE =&gt; CE,      -- 1-bit clock enable input
      RST =&gt; RST       -- 1-bit active high synchronous reset
   );
   -- End of COUNTER_TC_MACRO_inst instantiation

				</Template>
				<Template label="Equality Comparator (EQ_COMPARE_MACRO)" treetype="template">
--EQ_COMPARE_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (EQ_COMPARE_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EQ_COMPARE_MACRO: Equiality Comparator implemented in a DSP48E
   --                   Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   EQ_COMPARE_MACRO_inst : EQ_COMPARE_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",         -- Target Device: "VIRTEX5", "7SERIES" 
      LATENCY =&gt; 2,                -- Desired clock cycle latency, 0-2
      MASK =&gt; X"000000000000",     -- Select bits to be masked, must set 
                                   -- SEL_MASK = "MASK" 
      SEL_MASK =&gt; "MASK",          -- "MASK" = use MASK generic,
                                   -- "DYNAMIC_PATTERN = use DYNAMIC_PATTERN input bus
      SEL_PATTERN =&gt; "DYNAMIC_PATTERN", -- "DYNAMIC_PATTERN" = use DYNAMIC_PATTERN input bus
                                        -- "STATIC_PATTERN" = use STATIC_PATTERN generic
      STATIC_PATTERN =&gt; X"000000000000", -- Specify static pattern, 
                                         -- must set SEL_PATTERN = "STATIC_PATTERN
      WIDTH =&gt; 48)            -- Comparator output bus width, 1-48
   port map (
      Q =&gt; Q,        -- 1-bit output indicating a match 
      CE =&gt; CE,      -- 1-bit active high input clock enable input
      CLK =&gt; CLK,    -- 1-bit positive edge clock input
      DATA_IN =&gt; DATA_IN, -- Input Data Bus, width determined by WIDTH generic
      DYNAMIC_PATTERN, =&gt; DYNAMIC_PATTERN, -- Input Dynamic Match/Mask Bus, width determined by WIDTH generic
      RST =&gt; RST       -- 1-bit input active high reset
   );
   -- End of EQ_COMPARE_MACRO_inst instantiation

				</Template>
				<Template label="Loadable Counter (COUNTER_LOAD_MACRO)" treetype="template">
--COUNTER_LOAD_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (COUNTER_LOAD_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- COUNTER_LOAD_MACRO: Loadable variable counter implemented in a DSP48E
   --                     Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   COUNTER_LOAD_MACRO_inst : COUNTER_LOAD_MACRO
   generic map (
      COUNT_BY =&gt; X"000000000001", -- Count by value
      DEVICE =&gt; "7SERIES",         -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      WIDTH_DATA =&gt; 48)            -- Counter output bus width, 1-48
   port map (
      Q =&gt; Q,                 -- Counter ouput, width determined by WIDTH_DATA generic 
      CLK =&gt; CLK,             -- 1-bit clock input
      CE =&gt; CE,               -- 1-bit clock enable input
      DIRECTION =&gt; DIRECTION, -- 1-bit up/down count direction input, high is count up
      LOAD =&gt; LOAD,           -- 1-bit active high load input
      LOAD_DATA =&gt; LOAD_DATA, -- Counter load data, width determined by WIDTH_DATA generic 
      RST =&gt; RST              -- 1-bit active high synchronous reset
   );
   -- End of COUNTER_LOAD_MACRO_inst instantiation

				</Template>
				<Template label="Multiplier (MULT_MACRO)" treetype="template">
-- MULT_MACRO    : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (MULT_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MULT_MACRO: Multiply Function implemented in a DSP48E
   --             Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   MULT_MACRO_inst : MULT_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",    -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      LATENCY =&gt; 3,           -- Desired clock cycle latency, 0-4
      WIDTH_A =&gt; 18,          -- Multiplier A-input bus width, 1-25 
      WIDTH_B =&gt; 18)          -- Multiplier B-input bus width, 1-18
   port map (
      P =&gt; P,     -- Multiplier ouput bus, width determined by WIDTH_P generic 
      A =&gt; A,     -- Multiplier input A bus, width determined by WIDTH_A generic 
      B =&gt; B,     -- Multiplier input B bus, width determined by WIDTH_B generic 
      CE =&gt; CE,   -- 1-bit active high input clock enable
      CLK =&gt; CLK, -- 1-bit positive edge clock input
      RST =&gt; RST  -- 1-bit input active high reset
   );
   -- End of MULT_MACRO_inst instantiation
				</Template>
				<Template label="Multiply Accumulate (MACC_MACRO)" treetype="template">
-- MACC_MACRO    : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (MACC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MACC_MACRO: Multiple Accumulate Function implemented in a DSP48E
   --             Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   MACC_MACRO_inst : MACC_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",  -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      LATENCY =&gt; 3,         -- Desired clock cycle latency, 1-4
      WIDTH_A =&gt; 25,        -- Multiplier A-input bus width, 1-25
      WIDTH_B =&gt; 18,        -- Multiplier B-input bus width, 1-18     
      WIDTH_P =&gt; 48)        -- Accumulator output bus width, 1-48
   port map (
      P =&gt; P,     -- MACC ouput bus, width determined by WIDTH_P generic 
      A =&gt; A,     -- MACC input A bus, width determined by WIDTH_A generic 
      ADDSUB =&gt; ADDSUB, -- 1-bit add/sub input, high selects add, low selects subtract
      B =&gt; B,           -- MACC input B bus, width determined by WIDTH_B generic 
      CARRYIN =&gt; CARRYIN, -- 1-bit carry-in input to accumulator
      CE =&gt; CE,      -- 1-bit active high input clock enable
      CLK =&gt; CLK,    -- 1-bit positive edge clock input
      LOAD =&gt; LOAD, -- 1-bit active high input load accumulator enable
      LOAD_DATA =&gt; LOAD_DATA, -- Load accumulator input data, 
                              -- width determined by WIDTH_P generic
      RST =&gt; RST    -- 1-bit input active high reset
   );
   
-- End of MACC_MACRO_inst instantiation

				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<Template label="Dual Clock FIFO (FIFO_DUALCLOCK_MACRO)" treetype="template">
--FIFO_DUALCLOCK_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (FIFO_DUALCLOCK_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO_DUALCLOCK_MACRO: Dual-Clock First-In, First-Out (FIFO) RAM Buffer
   --                       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   -----------------------------------------------------------------
   -- DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width --
   -- ===========|===========|============|=======================--
   --   37-72    |  "36Kb"   |     512    |         9-bit         --
   --   19-36    |  "36Kb"   |    1024    |        10-bit         --
   --   19-36    |  "18Kb"   |     512    |         9-bit         --
   --   10-18    |  "36Kb"   |    2048    |        11-bit         --
   --   10-18    |  "18Kb"   |    1024    |        10-bit         --
   --    5-9     |  "36Kb"   |    4096    |        12-bit         --
   --    5-9     |  "18Kb"   |    2048    |        11-bit         --
   --    1-4     |  "36Kb"   |    8192    |        13-bit         --
   --    1-4     |  "18Kb"   |    4096    |        12-bit         --
   -----------------------------------------------------------------

   FIFO_DUALCLOCK_MACRO_inst : FIFO_DUALCLOCK_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",            -- Target Device: "VIRTEX5", "VIRTEX6", "7SERIES" 
      ALMOST_FULL_OFFSET =&gt; X"0080",  -- Sets almost full threshold
      ALMOST_EMPTY_OFFSET =&gt; X"0080", -- Sets the almost empty threshold
      DATA_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      FIFO_SIZE =&gt; "18Kb",            -- Target BRAM, "18Kb" or "36Kb" 
      FIRST_WORD_FALL_THROUGH =&gt; FALSE) -- Sets the FIFO FWFT to TRUE or FALSE
   port map (
      ALMOSTEMPTY =&gt; ALMOSTEMPTY,   -- 1-bit output almost empty
      ALMOSTFULL =&gt; ALMOSTFULL,     -- 1-bit output almost full
      DO =&gt; DO,                     -- Output data, width defined by DATA_WIDTH parameter
      EMPTY =&gt; EMPTY,               -- 1-bit output empty
      FULL =&gt; FULL,                 -- 1-bit output full
      RDCOUNT =&gt; RDCOUNT,           -- Output read count, width determined by FIFO depth
      RDERR =&gt; RDERR,               -- 1-bit output read error
      WRCOUNT =&gt; WRCOUNT,           -- Output write count, width determined by FIFO depth
      WRERR =&gt; WRERR,               -- 1-bit output write error
      DI =&gt; DI,                     -- Input data, width defined by DATA_WIDTH parameter
      RDCLK =&gt; RDCLK,               -- 1-bit input read clock
      RDEN =&gt; RDEN,                 -- 1-bit input read enable
      RST =&gt; RST,                   -- 1-bit input reset
      WRCLK =&gt; WRCLK,               -- 1-bit input write clock
      WREN =&gt; WREN                  -- 1-bit input write enable
   );
   -- End of FIFO_DUALCLOCK_MACRO_inst instantiation

				</Template>
				<Template label="Simple Dual Port RAM (BRAM_SDP_MACRO)" treetype="template">
--BRAM_SDP_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (BRAM_SDP_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BRAM_SDP_MACRO: Simple Dual Port RAM
   --                 Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   -----------------------------------------------------------------------
   --  READ_WIDTH | BRAM_SIZE | READ Depth  | RDADDR Width |            --
   -- WRITE_WIDTH |           | WRITE Depth | WRADDR Width |  WE Width  --
   -- ============|===========|=============|==============|============--
   --    37-72    |  "36Kb"   |      512    |     9-bit    |    8-bit   --
   --    19-36    |  "36Kb"   |     1024    |    10-bit    |    4-bit   --
   --    19-36    |  "18Kb"   |      512    |     9-bit    |    4-bit   --
   --    10-18    |  "36Kb"   |     2048    |    11-bit    |    2-bit   --
   --    10-18    |  "18Kb"   |     1024    |    10-bit    |    2-bit   --
   --     5-9     |  "36Kb"   |     4096    |    12-bit    |    1-bit   --
   --     5-9     |  "18Kb"   |     2048    |    11-bit    |    1-bit   --
   --     3-4     |  "36Kb"   |     8192    |    13-bit    |    1-bit   --
   --     3-4     |  "18Kb"   |     4096    |    12-bit    |    1-bit   --
   --       2     |  "36Kb"   |    16384    |    14-bit    |    1-bit   --
   --       2     |  "18Kb"   |     8192    |    13-bit    |    1-bit   --
   --       1     |  "36Kb"   |    32768    |    15-bit    |    1-bit   --
   --       1     |  "18Kb"   |    16384    |    14-bit    |    1-bit   --
   -----------------------------------------------------------------------


   BRAM_SDP_MACRO_inst : BRAM_SDP_MACRO
   generic map (
      BRAM_SIZE =&gt; "18Kb", -- Target BRAM, "18Kb" or "36Kb" 
      DEVICE =&gt; "7SERIES", -- Target device: "VIRTEX5", "VIRTEX6", "7SERIES", "SPARTAN6" 
      WRITE_WIDTH =&gt; 0,    -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      READ_WIDTH =&gt; 0,     -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      DO_REG =&gt; 0, -- Optional output register (0 or 1)
      INIT_FILE =&gt; "NONE",
      SIM_COLLISION_CHECK =&gt; "ALL", -- Collision check enable "ALL", "WARNING_ONLY", 
                                    -- "GENERATE_X_ONLY" or "NONE"       
      SRVAL =&gt; X"000000000000000000", --  Set/Reset value for port output
      WRITE_MODE =&gt; "WRITE_FIRST", -- Specify "READ_FIRST" for same clock or synchronous clocks
                                   --  Specify "WRITE_FIRST for asynchrononous clocks on ports
      INIT =&gt; X"000000000000000000", --  Initial values on output port
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INITP_xx are for the parity bits
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
   port map (
      DO =&gt; DO,         -- Output read data port, width defined by READ_WIDTH parameter
      DI =&gt; DI,         -- Input write data port, width defined by WRITE_WIDTH parameter
      RDADDR =&gt; RDADDR, -- Input read address, width defined by read port depth
      RDCLK =&gt; RDCLK,   -- 1-bit input read clock
      RDEN =&gt; RDEN,     -- 1-bit input read port enable
      REGCE =&gt; REGCE,   -- 1-bit input read output register enable
      RST =&gt; RST,       -- 1-bit input reset 
      WE =&gt; WE,         -- Input write enable, width defined by write port depth
      WRADDR =&gt; WRADDR, -- Input write address, width defined by write port depth
      WRCLK =&gt; WRCLK,   -- 1-bit input write clock
      WREN =&gt; WREN      -- 1-bit input write port enable
   );
   -- End of BRAM_SDP_MACRO_inst instantiation
				</Template>
				<Template label="Single Port RAM (BRAM_SINGLE_MACRO)" treetype="template">
--BRAM_SINGLE_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (BRAM_SINGLE_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BRAM_SINGLE_MACRO: Single Port RAM
   --                    Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   ---------------------------------------------------------------------
   --  READ_WIDTH | BRAM_SIZE | READ Depth  | ADDR Width |            --
   -- WRITE_WIDTH |           | WRITE Depth |            |  WE Width  --
   -- ============|===========|=============|============|============--
   --    37-72    |  "36Kb"   |      512    |    9-bit   |    8-bit   --
   --    19-36    |  "36Kb"   |     1024    |   10-bit   |    4-bit   --
   --    19-36    |  "18Kb"   |      512    |    9-bit   |    4-bit   --
   --    10-18    |  "36Kb"   |     2048    |   11-bit   |    2-bit   --
   --    10-18    |  "18Kb"   |     1024    |   10-bit   |    2-bit   --
   --     5-9     |  "36Kb"   |     4096    |   12-bit   |    1-bit   --
   --     5-9     |  "18Kb"   |     2048    |   11-bit   |    1-bit   --
   --     3-4     |  "36Kb"   |     8192    |   13-bit   |    1-bit   --
   --     3-4     |  "18Kb"   |     4096    |   12-bit   |    1-bit   --
   --       2     |  "36Kb"   |    16384    |   14-bit   |    1-bit   --
   --       2     |  "18Kb"   |     8192    |   13-bit   |    1-bit   --
   --       1     |  "36Kb"   |    32768    |   15-bit   |    1-bit   --
   --       1     |  "18Kb"   |    16384    |   14-bit   |    1-bit   --
   ---------------------------------------------------------------------

   BRAM_SINGLE_MACRO_inst : BRAM_SINGLE_MACRO
   generic map (
      BRAM_SIZE =&gt; "18Kb", -- Target BRAM, "18Kb" or "36Kb" 
      DEVICE =&gt; "7SERIES", -- Target Device: "VIRTEX5", "7SERIES", "VIRTEX6, "SPARTAN6" 
      DO_REG =&gt; 0, -- Optional output register (0 or 1)
      INIT =&gt; X"000000000000000000",   --  Initial values on output port
      INIT_FILE =&gt; "NONE",
      WRITE_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      READ_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      SRVAL =&gt; X"000000000000000000",   -- Set/Reset value for port output
      WRITE_MODE =&gt; "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INITP_xx are for the parity bits
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      DO =&gt; DO,      -- Output data, width defined by READ_WIDTH parameter
      ADDR =&gt; ADDR,  -- Input address, width defined by read/write port depth
      CLK =&gt; CLK,    -- 1-bit input clock
      DI =&gt; DI,      -- Input data port, width defined by WRITE_WIDTH parameter
      EN =&gt; EN,      -- 1-bit input RAM enable
      REGCE =&gt; REGCE, -- 1-bit input output register enable
      RST =&gt; RST,    -- 1-bit input reset
      WE =&gt; WE       -- Input write enable, width defined by write port depth
   );

   -- End of BRAM_SINGLE_MACRO_inst instantiation

				</Template>
				<Template label="Synchronous FIFO (FIFO_SYNC_MACRO)" treetype="template">
--FIFO_SYNC_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (FIFO_SYNC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO_SYNC_MACRO: Synchronous First-In, First-Out (FIFO) RAM Buffer
   --                  Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   -----------------------------------------------------------------
   -- DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width --
   -- ===========|===========|============|=======================--
   --   37-72    |  "36Kb"   |     512    |         9-bit         --
   --   19-36    |  "36Kb"   |    1024    |        10-bit         --
   --   19-36    |  "18Kb"   |     512    |         9-bit         --
   --   10-18    |  "36Kb"   |    2048    |        11-bit         --
   --   10-18    |  "18Kb"   |    1024    |        10-bit         --
   --    5-9     |  "36Kb"   |    4096    |        12-bit         --
   --    5-9     |  "18Kb"   |    2048    |        11-bit         --
   --    1-4     |  "36Kb"   |    8192    |        13-bit         --
   --    1-4     |  "18Kb"   |    4096    |        12-bit         --
   -----------------------------------------------------------------


   FIFO_SYNC_MACRO_inst : FIFO_SYNC_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",            -- Target Device: "VIRTEX5, "VIRTEX6", "7SERIES" 
      ALMOST_FULL_OFFSET =&gt; X"0080",  -- Sets almost full threshold
      ALMOST_EMPTY_OFFSET =&gt; X"0080", -- Sets the almost empty threshold
      DATA_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      FIFO_SIZE =&gt; "18Kb")            -- Target BRAM, "18Kb" or "36Kb" 
   port map (
      ALMOSTEMPTY =&gt; ALMOSTEMPTY,   -- 1-bit output almost empty
      ALMOSTFULL =&gt; ALMOSTFULL,     -- 1-bit output almost full
      DO =&gt; DO,                     -- Output data, width defined by DATA_WIDTH parameter
      EMPTY =&gt; EMPTY,               -- 1-bit output empty
      FULL =&gt; FULL,                 -- 1-bit output full
      RDCOUNT =&gt; RDCOUNT,           -- Output read count, width determined by FIFO depth
      RDERR =&gt; RDERR,               -- 1-bit output read error
      WRCOUNT =&gt; WRCOUNT,           -- Output write count, width determined by FIFO depth
      WRERR =&gt; WRERR,               -- 1-bit output write error
      CLK =&gt; CLK,                   -- 1-bit input clock
      DI =&gt; DI,                     -- Input data, width defined by DATA_WIDTH parameter
      RDEN =&gt; RDEN,                 -- 1-bit input read enable
      RST =&gt; RST,                   -- 1-bit input reset
      WREN =&gt; WREN                  -- 1-bit input write enable
   );
   -- End of FIFO_SYNC_MACRO_inst instantiation

				</Template>
				<Template label="True Dual Port RAM (BRAM_TDP_MACRO)" treetype="template">
--BRAM_TDP_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (BRAM_TDP_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BRAM_TDP_MACRO: True Dual Port RAM
   --                 Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   --------------------------------------------------------------------------
   -- DATA_WIDTH_A/B | BRAM_SIZE | RAM Depth | ADDRA/B Width | WEA/B Width --
   -- ===============|===========|===========|===============|=============--
   --     19-36      |  "36Kb"   |    1024   |    10-bit     |    4-bit    --
   --     10-18      |  "36Kb"   |    2048   |    11-bit     |    2-bit    --
   --     10-18      |  "18Kb"   |    1024   |    10-bit     |    2-bit    --
   --      5-9       |  "36Kb"   |    4096   |    12-bit     |    1-bit    --
   --      5-9       |  "18Kb"   |    2048   |    11-bit     |    1-bit    --
   --      3-4       |  "36Kb"   |    8192   |    13-bit     |    1-bit    --
   --      3-4       |  "18Kb"   |    4096   |    12-bit     |    1-bit    --
   --        2       |  "36Kb"   |   16384   |    14-bit     |    1-bit    --
   --        2       |  "18Kb"   |    8192   |    13-bit     |    1-bit    --
   --        1       |  "36Kb"   |   32768   |    15-bit     |    1-bit    --
   --        1       |  "18Kb"   |   16384   |    14-bit     |    1-bit    --
   --------------------------------------------------------------------------
   
   BRAM_TDP_MACRO_inst : BRAM_TDP_MACRO
   generic map (
      BRAM_SIZE =&gt; "18Kb", -- Target BRAM, "18Kb" or "36Kb" 
      DEVICE =&gt; "7SERIES", -- Target Device: "VIRTEX5", "VIRTEX6", "7SERIES", "SPARTAN6" 
      DOA_REG =&gt; 0, -- Optional port A output register (0 or 1)
      DOB_REG =&gt; 0, -- Optional port B output register (0 or 1)
      INIT_A =&gt; X"000000000", -- Initial values on A output port
      INIT_B =&gt; X"000000000", -- Initial values on B output port
      INIT_FILE =&gt; "NONE",
      READ_WIDTH_A =&gt; 0,   -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      READ_WIDTH_B =&gt; 0,   -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      SIM_COLLISION_CHECK =&gt; "ALL", -- Collision check enable "ALL", "WARNING_ONLY", 
                                    -- "GENERATE_X_ONLY" or "NONE" 
      SRVAL_A =&gt; X"000000000",   -- Set/Reset value for A port output
      SRVAL_B =&gt; X"000000000",   -- Set/Reset value for B port output
      WRITE_MODE_A =&gt; "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      WRITE_MODE_B =&gt; "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      WRITE_WIDTH_A =&gt; 0, -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      WRITE_WIDTH_B =&gt; 0, -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INITP_xx are for the parity bits
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      DOA =&gt; DOA,       -- Output port-A data, width defined by READ_WIDTH_A parameter
      DOB =&gt; DOB,       -- Output port-B data, width defined by READ_WIDTH_B parameter
      ADDRA =&gt; ADDRA,   -- Input port-A address, width defined by Port A depth
      ADDRB =&gt; ADDRB,   -- Input port-B address, width defined by Port B depth
      CLKA =&gt; CLKA,     -- 1-bit input port-A clock
      CLKB =&gt; CLKB,     -- 1-bit input port-B clock
      DIA =&gt; DIA,       -- Input port-A data, width defined by WRITE_WIDTH_A parameter
      DIB =&gt; DIB,       -- Input port-B data, width defined by WRITE_WIDTH_B parameter
      ENA =&gt; ENA,       -- 1-bit input port-A enable
      ENB =&gt; ENB,       -- 1-bit input port-B enable
      REGCEA =&gt; REGCEA, -- 1-bit input port-A output register enable
      REGCEB =&gt; REGCEB, -- 1-bit input port-B output register enable
      RSTA =&gt; RSTA,     -- 1-bit input port-A reset
      RSTB =&gt; RSTB,     -- 1-bit input port-B reset
      WEA =&gt; WEA,       -- Input port-A write enable, width defined by Port A depth
      WEB =&gt; WEB        -- Input port-B write enable, width defined by Port B depth
   );
   
-- End of BRAM_TDP_MACRO_inst instantiation
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Kintex-7" treetype="folder">
			<SubFolder label="DSP48" treetype="folder">
				<Template label="Add and Multiply Accumulate (ADDMACC_MACRO)" treetype="template">
-- ADDMACC_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (ADDMACC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ADDMACC_MACRO: Add and Multiple Accumulate Function implemented in a DSP48E
   --                Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   ADDMACC_MACRO_inst : ADDMACC_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",  -- Target Device: "7SERIES", "VIRTEX6", "SPARTAN6" 
      LATENCY =&gt; 4,         -- Desired clock cycle latency, 1-4
      WIDTH_PREADD =&gt; 25,   -- Pre-Adder input bus width, 1-25
      WIDTH_MULTIPLIER =&gt; 18, -- Multiplier input bus width, 1-18     
      WIDTH_PRODUCT =&gt; 48)    -- MACC output width, 1-48
   port map (
      PRODUCT =&gt; PRODUCT,     -- MACC result output, width defined by WIDTH_PRODUCT generic 
      MULTIPLIER =&gt; MULTIPLIER, -- Multiplier data input, width determined by WIDTH_MULTIPLIER generic
      PREADDER1 =&gt; PREADDER1,   -- Preadder data input, width determined by WIDTH_PREADDER generic 
      PREADDER2 =&gt; PREADDER2,   -- Preadder data input, width determined by WIDTH_PREADDER generic 
      CARRYIN =&gt; CARRYIN, -- 1-bit carry-in input
      CE =&gt; CE,      -- 1-bit input clock enable
      CLK =&gt; CLK,    -- 1-bit clock input
      LOAD =&gt; LOAD, -- 1-bit accumulator load input
      LOAD_DATA =&gt; LOAD_DATA, -- Accumulator load data input, width defined by WIDTH_PRODUCT generic
      RST =&gt; RST    -- 1-bit input active high synchronous reset
   );
   -- End of ADDMACC_MACRO_inst instantiation

				</Template>
				<Template label="Add / Subtract (ADDSUB_MACRO)" treetype="template">
-- ADDSUB_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (ADDSUB_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ADDSUB_MACRO: Variable width &amp; latency - Adder / Subtrator implemented in a DSP48E
   --               Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   ADDSUB_MACRO_inst : ADDSUB_MACRO
   generic map (
      DEVICE =&gt; "7SERIES", -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      LATENCY =&gt; 2,        -- Desired clock cycle latency, 0-2
      WIDTH =&gt; 48)         -- Input / Output bus width, 1-48
   port map (
      CARRYOUT =&gt; CARRYOUT, -- 1-bit carry-out output signal
      RESULT =&gt; RESULT,     -- Add/sub result output, width defined by WIDTH generic
      A =&gt; A,               -- Input A bus, width defined by WIDTH generic
      ADD_SUB =&gt; ADD_SUB,   -- 1-bit add/sub input, high selects add, low selects subtract
      B =&gt; B,               -- Input B bus, width defined by WIDTH generic
      CARRYIN =&gt; CARRYIN,   -- 1-bit carry-in input
      CE =&gt; CE,             -- 1-bit clock enable input
      CLK =&gt;CLK,           -- 1-bit clock input
      RST =&gt; RST            -- 1-bit active high synchronous reset
   );
   -- End of ADDSUB_MACRO_inst instantiation

				</Template>
				<Template label="Counter w/ Terminal Count (COUNTER_TC_MACRO)" treetype="template">
--COUNTER_TC_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (COUNTER_TC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- COUNTER_TC_MACRO: Counter with terminal count implemented in a DSP48E
   --                   Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   COUNTER_TC_MACRO_inst : COUNTER_TC_MACRO
   generic map (
      COUNT_BY =&gt; X"000000000001", -- Count by value
      DEVICE =&gt; "7SERIES",         -- Target Device: "VIRTEX5", "7SERIES" 
      DIRECTION =&gt; "UP",            -- Counter direction "UP" or "DOWN" 
      RESET_UPON_TC =&gt; "FALSE",      -- Reset counter upon terminal count, TRUE or FALSE
      TC_VALUE =&gt; X"000000000000", -- Terminal count value
      WIDTH_DATA =&gt; 48)            -- Counter output bus width, 1-48
   port map (
      Q =&gt; Q,        -- Counter ouput, width determined by WIDTH_DATA generic 
      TC =&gt; TC,      -- 1-bit terminal count output, high = terminal count is reached
      CLK =&gt; CLK,    -- 1-bit clock input
      CE =&gt; CE,      -- 1-bit clock enable input
      RST =&gt; RST       -- 1-bit active high synchronous reset
   );
   -- End of COUNTER_TC_MACRO_inst instantiation

				</Template>
				<Template label="Equality Comparator (EQ_COMPARE_MACRO)" treetype="template">
--EQ_COMPARE_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (EQ_COMPARE_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EQ_COMPARE_MACRO: Equiality Comparator implemented in a DSP48E
   --                   Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   EQ_COMPARE_MACRO_inst : EQ_COMPARE_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",         -- Target Device: "VIRTEX5", "7SERIES" 
      LATENCY =&gt; 2,                -- Desired clock cycle latency, 0-2
      MASK =&gt; X"000000000000",     -- Select bits to be masked, must set 
                                   -- SEL_MASK = "MASK" 
      SEL_MASK =&gt; "MASK",          -- "MASK" = use MASK generic,
                                   -- "DYNAMIC_PATTERN = use DYNAMIC_PATTERN input bus
      SEL_PATTERN =&gt; "DYNAMIC_PATTERN", -- "DYNAMIC_PATTERN" = use DYNAMIC_PATTERN input bus
                                        -- "STATIC_PATTERN" = use STATIC_PATTERN generic
      STATIC_PATTERN =&gt; X"000000000000", -- Specify static pattern, 
                                         -- must set SEL_PATTERN = "STATIC_PATTERN
      WIDTH =&gt; 48)            -- Comparator output bus width, 1-48
   port map (
      Q =&gt; Q,        -- 1-bit output indicating a match 
      CE =&gt; CE,      -- 1-bit active high input clock enable input
      CLK =&gt; CLK,    -- 1-bit positive edge clock input
      DATA_IN =&gt; DATA_IN, -- Input Data Bus, width determined by WIDTH generic
      DYNAMIC_PATTERN, =&gt; DYNAMIC_PATTERN, -- Input Dynamic Match/Mask Bus, width determined by WIDTH generic
      RST =&gt; RST       -- 1-bit input active high reset
   );
   -- End of EQ_COMPARE_MACRO_inst instantiation

				</Template>
				<Template label="Loadable Counter (COUNTER_LOAD_MACRO)" treetype="template">
--COUNTER_LOAD_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (COUNTER_LOAD_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- COUNTER_LOAD_MACRO: Loadable variable counter implemented in a DSP48E
   --                     Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   COUNTER_LOAD_MACRO_inst : COUNTER_LOAD_MACRO
   generic map (
      COUNT_BY =&gt; X"000000000001", -- Count by value
      DEVICE =&gt; "7SERIES",         -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      WIDTH_DATA =&gt; 48)            -- Counter output bus width, 1-48
   port map (
      Q =&gt; Q,                 -- Counter ouput, width determined by WIDTH_DATA generic 
      CLK =&gt; CLK,             -- 1-bit clock input
      CE =&gt; CE,               -- 1-bit clock enable input
      DIRECTION =&gt; DIRECTION, -- 1-bit up/down count direction input, high is count up
      LOAD =&gt; LOAD,           -- 1-bit active high load input
      LOAD_DATA =&gt; LOAD_DATA, -- Counter load data, width determined by WIDTH_DATA generic 
      RST =&gt; RST              -- 1-bit active high synchronous reset
   );
   -- End of COUNTER_LOAD_MACRO_inst instantiation

				</Template>
				<Template label="Multiplier (MULT_MACRO)" treetype="template">
-- MULT_MACRO    : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (MULT_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MULT_MACRO: Multiply Function implemented in a DSP48E
   --             Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   MULT_MACRO_inst : MULT_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",    -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      LATENCY =&gt; 3,           -- Desired clock cycle latency, 0-4
      WIDTH_A =&gt; 18,          -- Multiplier A-input bus width, 1-25 
      WIDTH_B =&gt; 18)          -- Multiplier B-input bus width, 1-18
   port map (
      P =&gt; P,     -- Multiplier ouput bus, width determined by WIDTH_P generic 
      A =&gt; A,     -- Multiplier input A bus, width determined by WIDTH_A generic 
      B =&gt; B,     -- Multiplier input B bus, width determined by WIDTH_B generic 
      CE =&gt; CE,   -- 1-bit active high input clock enable
      CLK =&gt; CLK, -- 1-bit positive edge clock input
      RST =&gt; RST  -- 1-bit input active high reset
   );
   -- End of MULT_MACRO_inst instantiation
				</Template>
				<Template label="Multiply Accumulate (MACC_MACRO)" treetype="template">
-- MACC_MACRO    : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (MACC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MACC_MACRO: Multiple Accumulate Function implemented in a DSP48E
   --             Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   MACC_MACRO_inst : MACC_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",  -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      LATENCY =&gt; 3,         -- Desired clock cycle latency, 1-4
      WIDTH_A =&gt; 25,        -- Multiplier A-input bus width, 1-25
      WIDTH_B =&gt; 18,        -- Multiplier B-input bus width, 1-18     
      WIDTH_P =&gt; 48)        -- Accumulator output bus width, 1-48
   port map (
      P =&gt; P,     -- MACC ouput bus, width determined by WIDTH_P generic 
      A =&gt; A,     -- MACC input A bus, width determined by WIDTH_A generic 
      ADDSUB =&gt; ADDSUB, -- 1-bit add/sub input, high selects add, low selects subtract
      B =&gt; B,           -- MACC input B bus, width determined by WIDTH_B generic 
      CARRYIN =&gt; CARRYIN, -- 1-bit carry-in input to accumulator
      CE =&gt; CE,      -- 1-bit active high input clock enable
      CLK =&gt; CLK,    -- 1-bit positive edge clock input
      LOAD =&gt; LOAD, -- 1-bit active high input load accumulator enable
      LOAD_DATA =&gt; LOAD_DATA, -- Load accumulator input data, 
                              -- width determined by WIDTH_P generic
      RST =&gt; RST    -- 1-bit input active high reset
   );
   
-- End of MACC_MACRO_inst instantiation

				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<Template label="Dual Clock FIFO (FIFO_DUALCLOCK_MACRO)" treetype="template">
--FIFO_DUALCLOCK_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (FIFO_DUALCLOCK_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO_DUALCLOCK_MACRO: Dual-Clock First-In, First-Out (FIFO) RAM Buffer
   --                       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   -----------------------------------------------------------------
   -- DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width --
   -- ===========|===========|============|=======================--
   --   37-72    |  "36Kb"   |     512    |         9-bit         --
   --   19-36    |  "36Kb"   |    1024    |        10-bit         --
   --   19-36    |  "18Kb"   |     512    |         9-bit         --
   --   10-18    |  "36Kb"   |    2048    |        11-bit         --
   --   10-18    |  "18Kb"   |    1024    |        10-bit         --
   --    5-9     |  "36Kb"   |    4096    |        12-bit         --
   --    5-9     |  "18Kb"   |    2048    |        11-bit         --
   --    1-4     |  "36Kb"   |    8192    |        13-bit         --
   --    1-4     |  "18Kb"   |    4096    |        12-bit         --
   -----------------------------------------------------------------

   FIFO_DUALCLOCK_MACRO_inst : FIFO_DUALCLOCK_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",            -- Target Device: "VIRTEX5", "VIRTEX6", "7SERIES" 
      ALMOST_FULL_OFFSET =&gt; X"0080",  -- Sets almost full threshold
      ALMOST_EMPTY_OFFSET =&gt; X"0080", -- Sets the almost empty threshold
      DATA_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      FIFO_SIZE =&gt; "18Kb",            -- Target BRAM, "18Kb" or "36Kb" 
      FIRST_WORD_FALL_THROUGH =&gt; FALSE) -- Sets the FIFO FWFT to TRUE or FALSE
   port map (
      ALMOSTEMPTY =&gt; ALMOSTEMPTY,   -- 1-bit output almost empty
      ALMOSTFULL =&gt; ALMOSTFULL,     -- 1-bit output almost full
      DO =&gt; DO,                     -- Output data, width defined by DATA_WIDTH parameter
      EMPTY =&gt; EMPTY,               -- 1-bit output empty
      FULL =&gt; FULL,                 -- 1-bit output full
      RDCOUNT =&gt; RDCOUNT,           -- Output read count, width determined by FIFO depth
      RDERR =&gt; RDERR,               -- 1-bit output read error
      WRCOUNT =&gt; WRCOUNT,           -- Output write count, width determined by FIFO depth
      WRERR =&gt; WRERR,               -- 1-bit output write error
      DI =&gt; DI,                     -- Input data, width defined by DATA_WIDTH parameter
      RDCLK =&gt; RDCLK,               -- 1-bit input read clock
      RDEN =&gt; RDEN,                 -- 1-bit input read enable
      RST =&gt; RST,                   -- 1-bit input reset
      WRCLK =&gt; WRCLK,               -- 1-bit input write clock
      WREN =&gt; WREN                  -- 1-bit input write enable
   );
   -- End of FIFO_DUALCLOCK_MACRO_inst instantiation

				</Template>
				<Template label="Simple Dual Port RAM (BRAM_SDP_MACRO)" treetype="template">
--BRAM_SDP_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (BRAM_SDP_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BRAM_SDP_MACRO: Simple Dual Port RAM
   --                 Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   -----------------------------------------------------------------------
   --  READ_WIDTH | BRAM_SIZE | READ Depth  | RDADDR Width |            --
   -- WRITE_WIDTH |           | WRITE Depth | WRADDR Width |  WE Width  --
   -- ============|===========|=============|==============|============--
   --    37-72    |  "36Kb"   |      512    |     9-bit    |    8-bit   --
   --    19-36    |  "36Kb"   |     1024    |    10-bit    |    4-bit   --
   --    19-36    |  "18Kb"   |      512    |     9-bit    |    4-bit   --
   --    10-18    |  "36Kb"   |     2048    |    11-bit    |    2-bit   --
   --    10-18    |  "18Kb"   |     1024    |    10-bit    |    2-bit   --
   --     5-9     |  "36Kb"   |     4096    |    12-bit    |    1-bit   --
   --     5-9     |  "18Kb"   |     2048    |    11-bit    |    1-bit   --
   --     3-4     |  "36Kb"   |     8192    |    13-bit    |    1-bit   --
   --     3-4     |  "18Kb"   |     4096    |    12-bit    |    1-bit   --
   --       2     |  "36Kb"   |    16384    |    14-bit    |    1-bit   --
   --       2     |  "18Kb"   |     8192    |    13-bit    |    1-bit   --
   --       1     |  "36Kb"   |    32768    |    15-bit    |    1-bit   --
   --       1     |  "18Kb"   |    16384    |    14-bit    |    1-bit   --
   -----------------------------------------------------------------------


   BRAM_SDP_MACRO_inst : BRAM_SDP_MACRO
   generic map (
      BRAM_SIZE =&gt; "18Kb", -- Target BRAM, "18Kb" or "36Kb" 
      DEVICE =&gt; "7SERIES", -- Target device: "VIRTEX5", "VIRTEX6", "7SERIES", "SPARTAN6" 
      WRITE_WIDTH =&gt; 0,    -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      READ_WIDTH =&gt; 0,     -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      DO_REG =&gt; 0, -- Optional output register (0 or 1)
      INIT_FILE =&gt; "NONE",
      SIM_COLLISION_CHECK =&gt; "ALL", -- Collision check enable "ALL", "WARNING_ONLY", 
                                    -- "GENERATE_X_ONLY" or "NONE"       
      SRVAL =&gt; X"000000000000000000", --  Set/Reset value for port output
      WRITE_MODE =&gt; "WRITE_FIRST", -- Specify "READ_FIRST" for same clock or synchronous clocks
                                   --  Specify "WRITE_FIRST for asynchrononous clocks on ports
      INIT =&gt; X"000000000000000000", --  Initial values on output port
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INITP_xx are for the parity bits
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
   port map (
      DO =&gt; DO,         -- Output read data port, width defined by READ_WIDTH parameter
      DI =&gt; DI,         -- Input write data port, width defined by WRITE_WIDTH parameter
      RDADDR =&gt; RDADDR, -- Input read address, width defined by read port depth
      RDCLK =&gt; RDCLK,   -- 1-bit input read clock
      RDEN =&gt; RDEN,     -- 1-bit input read port enable
      REGCE =&gt; REGCE,   -- 1-bit input read output register enable
      RST =&gt; RST,       -- 1-bit input reset 
      WE =&gt; WE,         -- Input write enable, width defined by write port depth
      WRADDR =&gt; WRADDR, -- Input write address, width defined by write port depth
      WRCLK =&gt; WRCLK,   -- 1-bit input write clock
      WREN =&gt; WREN      -- 1-bit input write port enable
   );
   -- End of BRAM_SDP_MACRO_inst instantiation
				</Template>
				<Template label="Single Port RAM (BRAM_SINGLE_MACRO)" treetype="template">
--BRAM_SINGLE_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (BRAM_SINGLE_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BRAM_SINGLE_MACRO: Single Port RAM
   --                    Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   ---------------------------------------------------------------------
   --  READ_WIDTH | BRAM_SIZE | READ Depth  | ADDR Width |            --
   -- WRITE_WIDTH |           | WRITE Depth |            |  WE Width  --
   -- ============|===========|=============|============|============--
   --    37-72    |  "36Kb"   |      512    |    9-bit   |    8-bit   --
   --    19-36    |  "36Kb"   |     1024    |   10-bit   |    4-bit   --
   --    19-36    |  "18Kb"   |      512    |    9-bit   |    4-bit   --
   --    10-18    |  "36Kb"   |     2048    |   11-bit   |    2-bit   --
   --    10-18    |  "18Kb"   |     1024    |   10-bit   |    2-bit   --
   --     5-9     |  "36Kb"   |     4096    |   12-bit   |    1-bit   --
   --     5-9     |  "18Kb"   |     2048    |   11-bit   |    1-bit   --
   --     3-4     |  "36Kb"   |     8192    |   13-bit   |    1-bit   --
   --     3-4     |  "18Kb"   |     4096    |   12-bit   |    1-bit   --
   --       2     |  "36Kb"   |    16384    |   14-bit   |    1-bit   --
   --       2     |  "18Kb"   |     8192    |   13-bit   |    1-bit   --
   --       1     |  "36Kb"   |    32768    |   15-bit   |    1-bit   --
   --       1     |  "18Kb"   |    16384    |   14-bit   |    1-bit   --
   ---------------------------------------------------------------------

   BRAM_SINGLE_MACRO_inst : BRAM_SINGLE_MACRO
   generic map (
      BRAM_SIZE =&gt; "18Kb", -- Target BRAM, "18Kb" or "36Kb" 
      DEVICE =&gt; "7SERIES", -- Target Device: "VIRTEX5", "7SERIES", "VIRTEX6, "SPARTAN6" 
      DO_REG =&gt; 0, -- Optional output register (0 or 1)
      INIT =&gt; X"000000000000000000",   --  Initial values on output port
      INIT_FILE =&gt; "NONE",
      WRITE_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      READ_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      SRVAL =&gt; X"000000000000000000",   -- Set/Reset value for port output
      WRITE_MODE =&gt; "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INITP_xx are for the parity bits
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      DO =&gt; DO,      -- Output data, width defined by READ_WIDTH parameter
      ADDR =&gt; ADDR,  -- Input address, width defined by read/write port depth
      CLK =&gt; CLK,    -- 1-bit input clock
      DI =&gt; DI,      -- Input data port, width defined by WRITE_WIDTH parameter
      EN =&gt; EN,      -- 1-bit input RAM enable
      REGCE =&gt; REGCE, -- 1-bit input output register enable
      RST =&gt; RST,    -- 1-bit input reset
      WE =&gt; WE       -- Input write enable, width defined by write port depth
   );

   -- End of BRAM_SINGLE_MACRO_inst instantiation

				</Template>
				<Template label="Synchronous FIFO (FIFO_SYNC_MACRO)" treetype="template">
--FIFO_SYNC_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (FIFO_SYNC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO_SYNC_MACRO: Synchronous First-In, First-Out (FIFO) RAM Buffer
   --                  Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   -----------------------------------------------------------------
   -- DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width --
   -- ===========|===========|============|=======================--
   --   37-72    |  "36Kb"   |     512    |         9-bit         --
   --   19-36    |  "36Kb"   |    1024    |        10-bit         --
   --   19-36    |  "18Kb"   |     512    |         9-bit         --
   --   10-18    |  "36Kb"   |    2048    |        11-bit         --
   --   10-18    |  "18Kb"   |    1024    |        10-bit         --
   --    5-9     |  "36Kb"   |    4096    |        12-bit         --
   --    5-9     |  "18Kb"   |    2048    |        11-bit         --
   --    1-4     |  "36Kb"   |    8192    |        13-bit         --
   --    1-4     |  "18Kb"   |    4096    |        12-bit         --
   -----------------------------------------------------------------


   FIFO_SYNC_MACRO_inst : FIFO_SYNC_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",            -- Target Device: "VIRTEX5, "VIRTEX6", "7SERIES" 
      ALMOST_FULL_OFFSET =&gt; X"0080",  -- Sets almost full threshold
      ALMOST_EMPTY_OFFSET =&gt; X"0080", -- Sets the almost empty threshold
      DATA_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      FIFO_SIZE =&gt; "18Kb")            -- Target BRAM, "18Kb" or "36Kb" 
   port map (
      ALMOSTEMPTY =&gt; ALMOSTEMPTY,   -- 1-bit output almost empty
      ALMOSTFULL =&gt; ALMOSTFULL,     -- 1-bit output almost full
      DO =&gt; DO,                     -- Output data, width defined by DATA_WIDTH parameter
      EMPTY =&gt; EMPTY,               -- 1-bit output empty
      FULL =&gt; FULL,                 -- 1-bit output full
      RDCOUNT =&gt; RDCOUNT,           -- Output read count, width determined by FIFO depth
      RDERR =&gt; RDERR,               -- 1-bit output read error
      WRCOUNT =&gt; WRCOUNT,           -- Output write count, width determined by FIFO depth
      WRERR =&gt; WRERR,               -- 1-bit output write error
      CLK =&gt; CLK,                   -- 1-bit input clock
      DI =&gt; DI,                     -- Input data, width defined by DATA_WIDTH parameter
      RDEN =&gt; RDEN,                 -- 1-bit input read enable
      RST =&gt; RST,                   -- 1-bit input reset
      WREN =&gt; WREN                  -- 1-bit input write enable
   );
   -- End of FIFO_SYNC_MACRO_inst instantiation

				</Template>
				<Template label="True Dual Port RAM (BRAM_TDP_MACRO)" treetype="template">
--BRAM_TDP_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (BRAM_TDP_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BRAM_TDP_MACRO: True Dual Port RAM
   --                 Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   --------------------------------------------------------------------------
   -- DATA_WIDTH_A/B | BRAM_SIZE | RAM Depth | ADDRA/B Width | WEA/B Width --
   -- ===============|===========|===========|===============|=============--
   --     19-36      |  "36Kb"   |    1024   |    10-bit     |    4-bit    --
   --     10-18      |  "36Kb"   |    2048   |    11-bit     |    2-bit    --
   --     10-18      |  "18Kb"   |    1024   |    10-bit     |    2-bit    --
   --      5-9       |  "36Kb"   |    4096   |    12-bit     |    1-bit    --
   --      5-9       |  "18Kb"   |    2048   |    11-bit     |    1-bit    --
   --      3-4       |  "36Kb"   |    8192   |    13-bit     |    1-bit    --
   --      3-4       |  "18Kb"   |    4096   |    12-bit     |    1-bit    --
   --        2       |  "36Kb"   |   16384   |    14-bit     |    1-bit    --
   --        2       |  "18Kb"   |    8192   |    13-bit     |    1-bit    --
   --        1       |  "36Kb"   |   32768   |    15-bit     |    1-bit    --
   --        1       |  "18Kb"   |   16384   |    14-bit     |    1-bit    --
   --------------------------------------------------------------------------
   
   BRAM_TDP_MACRO_inst : BRAM_TDP_MACRO
   generic map (
      BRAM_SIZE =&gt; "18Kb", -- Target BRAM, "18Kb" or "36Kb" 
      DEVICE =&gt; "7SERIES", -- Target Device: "VIRTEX5", "VIRTEX6", "7SERIES", "SPARTAN6" 
      DOA_REG =&gt; 0, -- Optional port A output register (0 or 1)
      DOB_REG =&gt; 0, -- Optional port B output register (0 or 1)
      INIT_A =&gt; X"000000000", -- Initial values on A output port
      INIT_B =&gt; X"000000000", -- Initial values on B output port
      INIT_FILE =&gt; "NONE",
      READ_WIDTH_A =&gt; 0,   -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      READ_WIDTH_B =&gt; 0,   -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      SIM_COLLISION_CHECK =&gt; "ALL", -- Collision check enable "ALL", "WARNING_ONLY", 
                                    -- "GENERATE_X_ONLY" or "NONE" 
      SRVAL_A =&gt; X"000000000",   -- Set/Reset value for A port output
      SRVAL_B =&gt; X"000000000",   -- Set/Reset value for B port output
      WRITE_MODE_A =&gt; "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      WRITE_MODE_B =&gt; "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      WRITE_WIDTH_A =&gt; 0, -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      WRITE_WIDTH_B =&gt; 0, -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INITP_xx are for the parity bits
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      DOA =&gt; DOA,       -- Output port-A data, width defined by READ_WIDTH_A parameter
      DOB =&gt; DOB,       -- Output port-B data, width defined by READ_WIDTH_B parameter
      ADDRA =&gt; ADDRA,   -- Input port-A address, width defined by Port A depth
      ADDRB =&gt; ADDRB,   -- Input port-B address, width defined by Port B depth
      CLKA =&gt; CLKA,     -- 1-bit input port-A clock
      CLKB =&gt; CLKB,     -- 1-bit input port-B clock
      DIA =&gt; DIA,       -- Input port-A data, width defined by WRITE_WIDTH_A parameter
      DIB =&gt; DIB,       -- Input port-B data, width defined by WRITE_WIDTH_B parameter
      ENA =&gt; ENA,       -- 1-bit input port-A enable
      ENB =&gt; ENB,       -- 1-bit input port-B enable
      REGCEA =&gt; REGCEA, -- 1-bit input port-A output register enable
      REGCEB =&gt; REGCEB, -- 1-bit input port-B output register enable
      RSTA =&gt; RSTA,     -- 1-bit input port-A reset
      RSTB =&gt; RSTB,     -- 1-bit input port-B reset
      WEA =&gt; WEA,       -- Input port-A write enable, width defined by Port A depth
      WEB =&gt; WEB        -- Input port-B write enable, width defined by Port B depth
   );
   
-- End of BRAM_TDP_MACRO_inst instantiation
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Virtex-7" treetype="folder">
			<SubFolder label="DSP48" treetype="folder">
				<Template label="Add and Multiply Accumulate (ADDMACC_MACRO)" treetype="template">
-- ADDMACC_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (ADDMACC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ADDMACC_MACRO: Add and Multiple Accumulate Function implemented in a DSP48E
   --                Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   ADDMACC_MACRO_inst : ADDMACC_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",  -- Target Device: "7SERIES", "VIRTEX6", "SPARTAN6" 
      LATENCY =&gt; 4,         -- Desired clock cycle latency, 1-4
      WIDTH_PREADD =&gt; 25,   -- Pre-Adder input bus width, 1-25
      WIDTH_MULTIPLIER =&gt; 18, -- Multiplier input bus width, 1-18     
      WIDTH_PRODUCT =&gt; 48)    -- MACC output width, 1-48
   port map (
      PRODUCT =&gt; PRODUCT,     -- MACC result output, width defined by WIDTH_PRODUCT generic 
      MULTIPLIER =&gt; MULTIPLIER, -- Multiplier data input, width determined by WIDTH_MULTIPLIER generic
      PREADDER1 =&gt; PREADDER1,   -- Preadder data input, width determined by WIDTH_PREADDER generic 
      PREADDER2 =&gt; PREADDER2,   -- Preadder data input, width determined by WIDTH_PREADDER generic 
      CARRYIN =&gt; CARRYIN, -- 1-bit carry-in input
      CE =&gt; CE,      -- 1-bit input clock enable
      CLK =&gt; CLK,    -- 1-bit clock input
      LOAD =&gt; LOAD, -- 1-bit accumulator load input
      LOAD_DATA =&gt; LOAD_DATA, -- Accumulator load data input, width defined by WIDTH_PRODUCT generic
      RST =&gt; RST    -- 1-bit input active high synchronous reset
   );
   -- End of ADDMACC_MACRO_inst instantiation

				</Template>
				<Template label="Add / Subtract (ADDSUB_MACRO)" treetype="template">
-- ADDSUB_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (ADDSUB_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ADDSUB_MACRO: Variable width &amp; latency - Adder / Subtrator implemented in a DSP48E
   --               Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   ADDSUB_MACRO_inst : ADDSUB_MACRO
   generic map (
      DEVICE =&gt; "7SERIES", -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      LATENCY =&gt; 2,        -- Desired clock cycle latency, 0-2
      WIDTH =&gt; 48)         -- Input / Output bus width, 1-48
   port map (
      CARRYOUT =&gt; CARRYOUT, -- 1-bit carry-out output signal
      RESULT =&gt; RESULT,     -- Add/sub result output, width defined by WIDTH generic
      A =&gt; A,               -- Input A bus, width defined by WIDTH generic
      ADD_SUB =&gt; ADD_SUB,   -- 1-bit add/sub input, high selects add, low selects subtract
      B =&gt; B,               -- Input B bus, width defined by WIDTH generic
      CARRYIN =&gt; CARRYIN,   -- 1-bit carry-in input
      CE =&gt; CE,             -- 1-bit clock enable input
      CLK =&gt;CLK,           -- 1-bit clock input
      RST =&gt; RST            -- 1-bit active high synchronous reset
   );
   -- End of ADDSUB_MACRO_inst instantiation

				</Template>
				<Template label="Counter w/ Terminal Count (COUNTER_TC_MACRO)" treetype="template">
--COUNTER_TC_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (COUNTER_TC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- COUNTER_TC_MACRO: Counter with terminal count implemented in a DSP48E
   --                   Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   COUNTER_TC_MACRO_inst : COUNTER_TC_MACRO
   generic map (
      COUNT_BY =&gt; X"000000000001", -- Count by value
      DEVICE =&gt; "7SERIES",         -- Target Device: "VIRTEX5", "7SERIES" 
      DIRECTION =&gt; "UP",            -- Counter direction "UP" or "DOWN" 
      RESET_UPON_TC =&gt; "FALSE",      -- Reset counter upon terminal count, TRUE or FALSE
      TC_VALUE =&gt; X"000000000000", -- Terminal count value
      WIDTH_DATA =&gt; 48)            -- Counter output bus width, 1-48
   port map (
      Q =&gt; Q,        -- Counter ouput, width determined by WIDTH_DATA generic 
      TC =&gt; TC,      -- 1-bit terminal count output, high = terminal count is reached
      CLK =&gt; CLK,    -- 1-bit clock input
      CE =&gt; CE,      -- 1-bit clock enable input
      RST =&gt; RST       -- 1-bit active high synchronous reset
   );
   -- End of COUNTER_TC_MACRO_inst instantiation

				</Template>
				<Template label="Equality Comparator (EQ_COMPARE_MACRO)" treetype="template">
--EQ_COMPARE_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (EQ_COMPARE_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EQ_COMPARE_MACRO: Equiality Comparator implemented in a DSP48E
   --                   Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   EQ_COMPARE_MACRO_inst : EQ_COMPARE_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",         -- Target Device: "VIRTEX5", "7SERIES" 
      LATENCY =&gt; 2,                -- Desired clock cycle latency, 0-2
      MASK =&gt; X"000000000000",     -- Select bits to be masked, must set 
                                   -- SEL_MASK = "MASK" 
      SEL_MASK =&gt; "MASK",          -- "MASK" = use MASK generic,
                                   -- "DYNAMIC_PATTERN = use DYNAMIC_PATTERN input bus
      SEL_PATTERN =&gt; "DYNAMIC_PATTERN", -- "DYNAMIC_PATTERN" = use DYNAMIC_PATTERN input bus
                                        -- "STATIC_PATTERN" = use STATIC_PATTERN generic
      STATIC_PATTERN =&gt; X"000000000000", -- Specify static pattern, 
                                         -- must set SEL_PATTERN = "STATIC_PATTERN
      WIDTH =&gt; 48)            -- Comparator output bus width, 1-48
   port map (
      Q =&gt; Q,        -- 1-bit output indicating a match 
      CE =&gt; CE,      -- 1-bit active high input clock enable input
      CLK =&gt; CLK,    -- 1-bit positive edge clock input
      DATA_IN =&gt; DATA_IN, -- Input Data Bus, width determined by WIDTH generic
      DYNAMIC_PATTERN, =&gt; DYNAMIC_PATTERN, -- Input Dynamic Match/Mask Bus, width determined by WIDTH generic
      RST =&gt; RST       -- 1-bit input active high reset
   );
   -- End of EQ_COMPARE_MACRO_inst instantiation

				</Template>
				<Template label="Loadable Counter (COUNTER_LOAD_MACRO)" treetype="template">
--COUNTER_LOAD_MACRO  : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (COUNTER_LOAD_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- COUNTER_LOAD_MACRO: Loadable variable counter implemented in a DSP48E
   --                     Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   COUNTER_LOAD_MACRO_inst : COUNTER_LOAD_MACRO
   generic map (
      COUNT_BY =&gt; X"000000000001", -- Count by value
      DEVICE =&gt; "7SERIES",         -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      WIDTH_DATA =&gt; 48)            -- Counter output bus width, 1-48
   port map (
      Q =&gt; Q,                 -- Counter ouput, width determined by WIDTH_DATA generic 
      CLK =&gt; CLK,             -- 1-bit clock input
      CE =&gt; CE,               -- 1-bit clock enable input
      DIRECTION =&gt; DIRECTION, -- 1-bit up/down count direction input, high is count up
      LOAD =&gt; LOAD,           -- 1-bit active high load input
      LOAD_DATA =&gt; LOAD_DATA, -- Counter load data, width determined by WIDTH_DATA generic 
      RST =&gt; RST              -- 1-bit active high synchronous reset
   );
   -- End of COUNTER_LOAD_MACRO_inst instantiation

				</Template>
				<Template label="Multiplier (MULT_MACRO)" treetype="template">
-- MULT_MACRO    : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (MULT_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MULT_MACRO: Multiply Function implemented in a DSP48E
   --             Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   MULT_MACRO_inst : MULT_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",    -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      LATENCY =&gt; 3,           -- Desired clock cycle latency, 0-4
      WIDTH_A =&gt; 18,          -- Multiplier A-input bus width, 1-25 
      WIDTH_B =&gt; 18)          -- Multiplier B-input bus width, 1-18
   port map (
      P =&gt; P,     -- Multiplier ouput bus, width determined by WIDTH_P generic 
      A =&gt; A,     -- Multiplier input A bus, width determined by WIDTH_A generic 
      B =&gt; B,     -- Multiplier input B bus, width determined by WIDTH_B generic 
      CE =&gt; CE,   -- 1-bit active high input clock enable
      CLK =&gt; CLK, -- 1-bit positive edge clock input
      RST =&gt; RST  -- 1-bit input active high reset
   );
   -- End of MULT_MACRO_inst instantiation
				</Template>
				<Template label="Multiply Accumulate (MACC_MACRO)" treetype="template">
-- MACC_MACRO    : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (MACC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MACC_MACRO: Multiple Accumulate Function implemented in a DSP48E
   --             Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   MACC_MACRO_inst : MACC_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",  -- Target Device: "VIRTEX5", "7SERIES", "SPARTAN6" 
      LATENCY =&gt; 3,         -- Desired clock cycle latency, 1-4
      WIDTH_A =&gt; 25,        -- Multiplier A-input bus width, 1-25
      WIDTH_B =&gt; 18,        -- Multiplier B-input bus width, 1-18     
      WIDTH_P =&gt; 48)        -- Accumulator output bus width, 1-48
   port map (
      P =&gt; P,     -- MACC ouput bus, width determined by WIDTH_P generic 
      A =&gt; A,     -- MACC input A bus, width determined by WIDTH_A generic 
      ADDSUB =&gt; ADDSUB, -- 1-bit add/sub input, high selects add, low selects subtract
      B =&gt; B,           -- MACC input B bus, width determined by WIDTH_B generic 
      CARRYIN =&gt; CARRYIN, -- 1-bit carry-in input to accumulator
      CE =&gt; CE,      -- 1-bit active high input clock enable
      CLK =&gt; CLK,    -- 1-bit positive edge clock input
      LOAD =&gt; LOAD, -- 1-bit active high input load accumulator enable
      LOAD_DATA =&gt; LOAD_DATA, -- Load accumulator input data, 
                              -- width determined by WIDTH_P generic
      RST =&gt; RST    -- 1-bit input active high reset
   );
   
-- End of MACC_MACRO_inst instantiation

				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<Template label="Dual Clock FIFO (FIFO_DUALCLOCK_MACRO)" treetype="template">
--FIFO_DUALCLOCK_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (FIFO_DUALCLOCK_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO_DUALCLOCK_MACRO: Dual-Clock First-In, First-Out (FIFO) RAM Buffer
   --                       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   -----------------------------------------------------------------
   -- DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width --
   -- ===========|===========|============|=======================--
   --   37-72    |  "36Kb"   |     512    |         9-bit         --
   --   19-36    |  "36Kb"   |    1024    |        10-bit         --
   --   19-36    |  "18Kb"   |     512    |         9-bit         --
   --   10-18    |  "36Kb"   |    2048    |        11-bit         --
   --   10-18    |  "18Kb"   |    1024    |        10-bit         --
   --    5-9     |  "36Kb"   |    4096    |        12-bit         --
   --    5-9     |  "18Kb"   |    2048    |        11-bit         --
   --    1-4     |  "36Kb"   |    8192    |        13-bit         --
   --    1-4     |  "18Kb"   |    4096    |        12-bit         --
   -----------------------------------------------------------------

   FIFO_DUALCLOCK_MACRO_inst : FIFO_DUALCLOCK_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",            -- Target Device: "VIRTEX5", "VIRTEX6", "7SERIES" 
      ALMOST_FULL_OFFSET =&gt; X"0080",  -- Sets almost full threshold
      ALMOST_EMPTY_OFFSET =&gt; X"0080", -- Sets the almost empty threshold
      DATA_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      FIFO_SIZE =&gt; "18Kb",            -- Target BRAM, "18Kb" or "36Kb" 
      FIRST_WORD_FALL_THROUGH =&gt; FALSE) -- Sets the FIFO FWFT to TRUE or FALSE
   port map (
      ALMOSTEMPTY =&gt; ALMOSTEMPTY,   -- 1-bit output almost empty
      ALMOSTFULL =&gt; ALMOSTFULL,     -- 1-bit output almost full
      DO =&gt; DO,                     -- Output data, width defined by DATA_WIDTH parameter
      EMPTY =&gt; EMPTY,               -- 1-bit output empty
      FULL =&gt; FULL,                 -- 1-bit output full
      RDCOUNT =&gt; RDCOUNT,           -- Output read count, width determined by FIFO depth
      RDERR =&gt; RDERR,               -- 1-bit output read error
      WRCOUNT =&gt; WRCOUNT,           -- Output write count, width determined by FIFO depth
      WRERR =&gt; WRERR,               -- 1-bit output write error
      DI =&gt; DI,                     -- Input data, width defined by DATA_WIDTH parameter
      RDCLK =&gt; RDCLK,               -- 1-bit input read clock
      RDEN =&gt; RDEN,                 -- 1-bit input read enable
      RST =&gt; RST,                   -- 1-bit input reset
      WRCLK =&gt; WRCLK,               -- 1-bit input write clock
      WREN =&gt; WREN                  -- 1-bit input write enable
   );
   -- End of FIFO_DUALCLOCK_MACRO_inst instantiation

				</Template>
				<Template label="Simple Dual Port RAM (BRAM_SDP_MACRO)" treetype="template">
--BRAM_SDP_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (BRAM_SDP_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BRAM_SDP_MACRO: Simple Dual Port RAM
   --                 Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   -----------------------------------------------------------------------
   --  READ_WIDTH | BRAM_SIZE | READ Depth  | RDADDR Width |            --
   -- WRITE_WIDTH |           | WRITE Depth | WRADDR Width |  WE Width  --
   -- ============|===========|=============|==============|============--
   --    37-72    |  "36Kb"   |      512    |     9-bit    |    8-bit   --
   --    19-36    |  "36Kb"   |     1024    |    10-bit    |    4-bit   --
   --    19-36    |  "18Kb"   |      512    |     9-bit    |    4-bit   --
   --    10-18    |  "36Kb"   |     2048    |    11-bit    |    2-bit   --
   --    10-18    |  "18Kb"   |     1024    |    10-bit    |    2-bit   --
   --     5-9     |  "36Kb"   |     4096    |    12-bit    |    1-bit   --
   --     5-9     |  "18Kb"   |     2048    |    11-bit    |    1-bit   --
   --     3-4     |  "36Kb"   |     8192    |    13-bit    |    1-bit   --
   --     3-4     |  "18Kb"   |     4096    |    12-bit    |    1-bit   --
   --       2     |  "36Kb"   |    16384    |    14-bit    |    1-bit   --
   --       2     |  "18Kb"   |     8192    |    13-bit    |    1-bit   --
   --       1     |  "36Kb"   |    32768    |    15-bit    |    1-bit   --
   --       1     |  "18Kb"   |    16384    |    14-bit    |    1-bit   --
   -----------------------------------------------------------------------


   BRAM_SDP_MACRO_inst : BRAM_SDP_MACRO
   generic map (
      BRAM_SIZE =&gt; "18Kb", -- Target BRAM, "18Kb" or "36Kb" 
      DEVICE =&gt; "7SERIES", -- Target device: "VIRTEX5", "VIRTEX6", "7SERIES", "SPARTAN6" 
      WRITE_WIDTH =&gt; 0,    -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      READ_WIDTH =&gt; 0,     -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      DO_REG =&gt; 0, -- Optional output register (0 or 1)
      INIT_FILE =&gt; "NONE",
      SIM_COLLISION_CHECK =&gt; "ALL", -- Collision check enable "ALL", "WARNING_ONLY", 
                                    -- "GENERATE_X_ONLY" or "NONE"       
      SRVAL =&gt; X"000000000000000000", --  Set/Reset value for port output
      WRITE_MODE =&gt; "WRITE_FIRST", -- Specify "READ_FIRST" for same clock or synchronous clocks
                                   --  Specify "WRITE_FIRST for asynchrononous clocks on ports
      INIT =&gt; X"000000000000000000", --  Initial values on output port
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INITP_xx are for the parity bits
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
   port map (
      DO =&gt; DO,         -- Output read data port, width defined by READ_WIDTH parameter
      DI =&gt; DI,         -- Input write data port, width defined by WRITE_WIDTH parameter
      RDADDR =&gt; RDADDR, -- Input read address, width defined by read port depth
      RDCLK =&gt; RDCLK,   -- 1-bit input read clock
      RDEN =&gt; RDEN,     -- 1-bit input read port enable
      REGCE =&gt; REGCE,   -- 1-bit input read output register enable
      RST =&gt; RST,       -- 1-bit input reset 
      WE =&gt; WE,         -- Input write enable, width defined by write port depth
      WRADDR =&gt; WRADDR, -- Input write address, width defined by write port depth
      WRCLK =&gt; WRCLK,   -- 1-bit input write clock
      WREN =&gt; WREN      -- 1-bit input write port enable
   );
   -- End of BRAM_SDP_MACRO_inst instantiation
				</Template>
				<Template label="Single Port RAM (BRAM_SINGLE_MACRO)" treetype="template">
--BRAM_SINGLE_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (BRAM_SINGLE_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BRAM_SINGLE_MACRO: Single Port RAM
   --                    Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   ---------------------------------------------------------------------
   --  READ_WIDTH | BRAM_SIZE | READ Depth  | ADDR Width |            --
   -- WRITE_WIDTH |           | WRITE Depth |            |  WE Width  --
   -- ============|===========|=============|============|============--
   --    37-72    |  "36Kb"   |      512    |    9-bit   |    8-bit   --
   --    19-36    |  "36Kb"   |     1024    |   10-bit   |    4-bit   --
   --    19-36    |  "18Kb"   |      512    |    9-bit   |    4-bit   --
   --    10-18    |  "36Kb"   |     2048    |   11-bit   |    2-bit   --
   --    10-18    |  "18Kb"   |     1024    |   10-bit   |    2-bit   --
   --     5-9     |  "36Kb"   |     4096    |   12-bit   |    1-bit   --
   --     5-9     |  "18Kb"   |     2048    |   11-bit   |    1-bit   --
   --     3-4     |  "36Kb"   |     8192    |   13-bit   |    1-bit   --
   --     3-4     |  "18Kb"   |     4096    |   12-bit   |    1-bit   --
   --       2     |  "36Kb"   |    16384    |   14-bit   |    1-bit   --
   --       2     |  "18Kb"   |     8192    |   13-bit   |    1-bit   --
   --       1     |  "36Kb"   |    32768    |   15-bit   |    1-bit   --
   --       1     |  "18Kb"   |    16384    |   14-bit   |    1-bit   --
   ---------------------------------------------------------------------

   BRAM_SINGLE_MACRO_inst : BRAM_SINGLE_MACRO
   generic map (
      BRAM_SIZE =&gt; "18Kb", -- Target BRAM, "18Kb" or "36Kb" 
      DEVICE =&gt; "7SERIES", -- Target Device: "VIRTEX5", "7SERIES", "VIRTEX6, "SPARTAN6" 
      DO_REG =&gt; 0, -- Optional output register (0 or 1)
      INIT =&gt; X"000000000000000000",   --  Initial values on output port
      INIT_FILE =&gt; "NONE",
      WRITE_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      READ_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      SRVAL =&gt; X"000000000000000000",   -- Set/Reset value for port output
      WRITE_MODE =&gt; "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INITP_xx are for the parity bits
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      DO =&gt; DO,      -- Output data, width defined by READ_WIDTH parameter
      ADDR =&gt; ADDR,  -- Input address, width defined by read/write port depth
      CLK =&gt; CLK,    -- 1-bit input clock
      DI =&gt; DI,      -- Input data port, width defined by WRITE_WIDTH parameter
      EN =&gt; EN,      -- 1-bit input RAM enable
      REGCE =&gt; REGCE, -- 1-bit input output register enable
      RST =&gt; RST,    -- 1-bit input reset
      WE =&gt; WE       -- Input write enable, width defined by write port depth
   );

   -- End of BRAM_SINGLE_MACRO_inst instantiation

				</Template>
				<Template label="Synchronous FIFO (FIFO_SYNC_MACRO)" treetype="template">
--FIFO_SYNC_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (FIFO_SYNC_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO_SYNC_MACRO: Synchronous First-In, First-Out (FIFO) RAM Buffer
   --                  Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   -----------------------------------------------------------------
   -- DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width --
   -- ===========|===========|============|=======================--
   --   37-72    |  "36Kb"   |     512    |         9-bit         --
   --   19-36    |  "36Kb"   |    1024    |        10-bit         --
   --   19-36    |  "18Kb"   |     512    |         9-bit         --
   --   10-18    |  "36Kb"   |    2048    |        11-bit         --
   --   10-18    |  "18Kb"   |    1024    |        10-bit         --
   --    5-9     |  "36Kb"   |    4096    |        12-bit         --
   --    5-9     |  "18Kb"   |    2048    |        11-bit         --
   --    1-4     |  "36Kb"   |    8192    |        13-bit         --
   --    1-4     |  "18Kb"   |    4096    |        12-bit         --
   -----------------------------------------------------------------


   FIFO_SYNC_MACRO_inst : FIFO_SYNC_MACRO
   generic map (
      DEVICE =&gt; "7SERIES",            -- Target Device: "VIRTEX5, "VIRTEX6", "7SERIES" 
      ALMOST_FULL_OFFSET =&gt; X"0080",  -- Sets almost full threshold
      ALMOST_EMPTY_OFFSET =&gt; X"0080", -- Sets the almost empty threshold
      DATA_WIDTH =&gt; 0,   -- Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      FIFO_SIZE =&gt; "18Kb")            -- Target BRAM, "18Kb" or "36Kb" 
   port map (
      ALMOSTEMPTY =&gt; ALMOSTEMPTY,   -- 1-bit output almost empty
      ALMOSTFULL =&gt; ALMOSTFULL,     -- 1-bit output almost full
      DO =&gt; DO,                     -- Output data, width defined by DATA_WIDTH parameter
      EMPTY =&gt; EMPTY,               -- 1-bit output empty
      FULL =&gt; FULL,                 -- 1-bit output full
      RDCOUNT =&gt; RDCOUNT,           -- Output read count, width determined by FIFO depth
      RDERR =&gt; RDERR,               -- 1-bit output read error
      WRCOUNT =&gt; WRCOUNT,           -- Output write count, width determined by FIFO depth
      WRERR =&gt; WRERR,               -- 1-bit output write error
      CLK =&gt; CLK,                   -- 1-bit input clock
      DI =&gt; DI,                     -- Input data, width defined by DATA_WIDTH parameter
      RDEN =&gt; RDEN,                 -- 1-bit input read enable
      RST =&gt; RST,                   -- 1-bit input reset
      WREN =&gt; WREN                  -- 1-bit input write enable
   );
   -- End of FIFO_SYNC_MACRO_inst instantiation

				</Template>
				<Template label="True Dual Port RAM (BRAM_TDP_MACRO)" treetype="template">
--BRAM_TDP_MACRO : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : (BRAM_TDP_MACRO_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following four statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

Library UNIMACRO;
use UNIMACRO.vcomponents.all;
--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BRAM_TDP_MACRO: True Dual Port RAM
   --                 Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   -- Note -  This Unimacro model assumes the port directions to be "downto". 
   --         Simulation of this model with "to" in the port directions could lead to erroneous results.

   --------------------------------------------------------------------------
   -- DATA_WIDTH_A/B | BRAM_SIZE | RAM Depth | ADDRA/B Width | WEA/B Width --
   -- ===============|===========|===========|===============|=============--
   --     19-36      |  "36Kb"   |    1024   |    10-bit     |    4-bit    --
   --     10-18      |  "36Kb"   |    2048   |    11-bit     |    2-bit    --
   --     10-18      |  "18Kb"   |    1024   |    10-bit     |    2-bit    --
   --      5-9       |  "36Kb"   |    4096   |    12-bit     |    1-bit    --
   --      5-9       |  "18Kb"   |    2048   |    11-bit     |    1-bit    --
   --      3-4       |  "36Kb"   |    8192   |    13-bit     |    1-bit    --
   --      3-4       |  "18Kb"   |    4096   |    12-bit     |    1-bit    --
   --        2       |  "36Kb"   |   16384   |    14-bit     |    1-bit    --
   --        2       |  "18Kb"   |    8192   |    13-bit     |    1-bit    --
   --        1       |  "36Kb"   |   32768   |    15-bit     |    1-bit    --
   --        1       |  "18Kb"   |   16384   |    14-bit     |    1-bit    --
   --------------------------------------------------------------------------
   
   BRAM_TDP_MACRO_inst : BRAM_TDP_MACRO
   generic map (
      BRAM_SIZE =&gt; "18Kb", -- Target BRAM, "18Kb" or "36Kb" 
      DEVICE =&gt; "7SERIES", -- Target Device: "VIRTEX5", "VIRTEX6", "7SERIES", "SPARTAN6" 
      DOA_REG =&gt; 0, -- Optional port A output register (0 or 1)
      DOB_REG =&gt; 0, -- Optional port B output register (0 or 1)
      INIT_A =&gt; X"000000000", -- Initial values on A output port
      INIT_B =&gt; X"000000000", -- Initial values on B output port
      INIT_FILE =&gt; "NONE",
      READ_WIDTH_A =&gt; 0,   -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      READ_WIDTH_B =&gt; 0,   -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      SIM_COLLISION_CHECK =&gt; "ALL", -- Collision check enable "ALL", "WARNING_ONLY", 
                                    -- "GENERATE_X_ONLY" or "NONE" 
      SRVAL_A =&gt; X"000000000",   -- Set/Reset value for A port output
      SRVAL_B =&gt; X"000000000",   -- Set/Reset value for B port output
      WRITE_MODE_A =&gt; "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      WRITE_MODE_B =&gt; "WRITE_FIRST", -- "WRITE_FIRST", "READ_FIRST" or "NO_CHANGE" 
      WRITE_WIDTH_A =&gt; 0, -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      WRITE_WIDTH_B =&gt; 0, -- Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      -- The following INIT_xx declarations specify the initial contents of the RAM
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INITP_xx are for the parity bits
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      
      -- The next set of INIT_xx are valid when configured as 36Kb
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      DOA =&gt; DOA,       -- Output port-A data, width defined by READ_WIDTH_A parameter
      DOB =&gt; DOB,       -- Output port-B data, width defined by READ_WIDTH_B parameter
      ADDRA =&gt; ADDRA,   -- Input port-A address, width defined by Port A depth
      ADDRB =&gt; ADDRB,   -- Input port-B address, width defined by Port B depth
      CLKA =&gt; CLKA,     -- 1-bit input port-A clock
      CLKB =&gt; CLKB,     -- 1-bit input port-B clock
      DIA =&gt; DIA,       -- Input port-A data, width defined by WRITE_WIDTH_A parameter
      DIB =&gt; DIB,       -- Input port-B data, width defined by WRITE_WIDTH_B parameter
      ENA =&gt; ENA,       -- 1-bit input port-A enable
      ENB =&gt; ENB,       -- 1-bit input port-B enable
      REGCEA =&gt; REGCEA, -- 1-bit input port-A output register enable
      REGCEB =&gt; REGCEB, -- 1-bit input port-B output register enable
      RSTA =&gt; RSTA,     -- 1-bit input port-A reset
      RSTB =&gt; RSTB,     -- 1-bit input port-B reset
      WEA =&gt; WEA,       -- Input port-A write enable, width defined by Port A depth
      WEB =&gt; WEB        -- Input port-B write enable, width defined by Port B depth
   );
   
-- End of BRAM_TDP_MACRO_inst instantiation
				</Template>
			</SubFolder>
		</SubFolder>
	</Folder>
	<Folder label="Device Primitive Instantiation" treetype="folder">
		<SubFolder label="Artix-7" treetype="folder">
			<SubFolder label="Advanced" treetype="folder">
				<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE2)" treetype="template">
-- IBUFDS_GTE2 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_GTE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_GTE2: Gigabit Transceiver Buffer
   --              Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE2_inst : IBUFDS_GTE2
   generic map (
      CLKCM_CFG =&gt; TRUE,    -- Refer to Transceiver User Guide
      CLKRCV_TRST =&gt; TRUE,  -- Refer to Transceiver User Guide
      CLKSWING_CFG =&gt; '11'  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,         -- 1-bit output: Refer to Transceiver User Guide
      ODIV2 =&gt; ODIV2, -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,     -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,         -- 1-bit input: Refer to Transceiver User Guide
      IB =&gt; IB        -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of IBUFDS_GTE2_inst instantiation
				</Template>
				<Template label="XADC Simulation File" treetype="template">
-- Must use valid headers on all columns
-- Comments can be added to the stimulus file using '--'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

-- Time stamp data is in nano seconds (ns)
-- Temperature is recorded in C (degrees centigrade)
-- All other channels are recorded as V (Volts)
-- Valid column headers are:
-- TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
-- VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
-- External analog inputs are differential so VP = 0.5 and VN = 0.1 the
-- input on channel VP/VN in 0.5 - 0.1 = 0.4V

				</Template>
				<Template label="Xilinx Analog-to-Digital Converter (XADC)" treetype="template">
--    XADC     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (XADC_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- XADC: Dual 12-Bit 1MSPS Analog-to-Digital Converter
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   XADC_inst : XADC
   generic map (
      -- INIT_40 - INIT_42: XADC configuration registers
      INIT_40 =&gt; X"0000",
      INIT_41 =&gt; X"0000",
      INIT_42 =&gt; X"0800",
      -- INIT_48 - INIT_4F: Sequence Registers
      INIT_48 =&gt; X"0000",
      INIT_49 =&gt; X"0000",
      INIT_4A =&gt; X"0000",
      INIT_4B =&gt; X"0000",
      INIT_4C =&gt; X"0000",
      INIT_4D =&gt; X"0000",
      INIT_4F =&gt; X"0000",
      INIT_4E =&gt; X"0000",                 -- Sequence register 6
      -- INIT_50 - INIT_58, INIT5C: Alarm Limit Registers
      INIT_50 =&gt; X"0000",
      INIT_51 =&gt; X"0000",
      INIT_52 =&gt; X"0000",
      INIT_53 =&gt; X"0000",
      INIT_54 =&gt; X"0000",
      INIT_55 =&gt; X"0000",
      INIT_56 =&gt; X"0000",
      INIT_57 =&gt; X"0000",
      INIT_58 =&gt; X"0000",
      INIT_5C =&gt; X"0000",
      -- Simulation attributes: Set for proper simulation behavior
      SIM_DEVICE =&gt; "7SERIES",            -- Select target device (values)
      SIM_MONITOR_FILE =&gt; "design.txt"  -- Analog simulation data file name
   )
   port map (
      -- ALARMS: 8-bit (each) output: ALM, OT
      ALM =&gt; ALM,                   -- 8-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      OT =&gt; OT,                     -- 1-bit output: Over-Temperature alarm
      -- Dynamic Reconfiguration Port (DRP): 16-bit (each) output: Dynamic Reconfiguration Ports
      DO =&gt; DO,                     -- 16-bit output: DRP output data bus
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP data ready
      -- STATUS: 1-bit (each) output: XADC status ports
      BUSY =&gt; BUSY,                 -- 1-bit output: ADC busy output
      CHANNEL =&gt; CHANNEL,           -- 5-bit output: Channel selection outputs
      EOC =&gt; EOC,                   -- 1-bit output: End of Conversion
      EOS =&gt; EOS,                   -- 1-bit output: End of Sequence
      JTAGBUSY =&gt; JTAGBUSY,         -- 1-bit output: JTAG DRP transaction in progress output
      JTAGLOCKED =&gt; JTAGLOCKED,     -- 1-bit output: JTAG requested DRP port lock
      JTAGMODIFIED =&gt; JTAGMODIFIED, -- 1-bit output: JTAG Write to the DRP has occurred
      MUXADDR =&gt; MUXADDR,           -- 5-bit output: External MUX channel decode
      -- Auxiliary Analog-Input Pairs: 16-bit (each) input: VAUXP[15:0], VAUXN[15:0]
      VAUXN =&gt; VAUXN,               -- 16-bit input: N-side auxiliary analog input
      VAUXP =&gt; VAUXP,               -- 16-bit input: P-side auxiliary analog input
      -- CONTROL and CLOCK: 1-bit (each) input: Reset, conversion start and clock inputs
      CONVST =&gt; CONVST,             -- 1-bit input: Convert start input
      CONVSTCLK =&gt; CONVSTCLK,       -- 1-bit input: Convert start input
      RESET =&gt; RESET,               -- 1-bit input: Active-high reset
      -- Dedicated Analog Input Pair: 1-bit (each) input: VP/VN
      VN =&gt; VN,                     -- 1-bit input: N-side analog input
      VP =&gt; VP,                     -- 1-bit input: P-side analog input
      -- Dynamic Reconfiguration Port (DRP): 7-bit (each) input: Dynamic Reconfiguration Ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address bus
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable signal
      DI =&gt; DI,                     -- 16-bit input: DRP input data bus
      DWE =&gt; DWE                    -- 1-bit input: DRP write enable
   );

   -- End of XADC_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Arithmetic Functions" treetype="folder">
				<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E1)" treetype="template">
--   DSP48E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DSP48E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DSP48E1: 48-bit Multi-Functional Arithmetic Block
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   DSP48E1_inst : DSP48E1
   generic map (
      -- Feature Control Attributes: Data Path Selection
      A_INPUT =&gt; "DIRECT",               -- Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      B_INPUT =&gt; "DIRECT",               -- Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      USE_DPORT =&gt; FALSE,                -- Select D port usage (TRUE or FALSE)
      USE_MULT =&gt; "MULTIPLY",            -- Select multiplier usage ("MULTIPLY", "DYNAMIC", or "NONE")
      USE_SIMD =&gt; "ONE48",               -- SIMD selection ("ONE48", "TWO24", "FOUR12")
      -- Pattern Detector Attributes: Pattern Detection Configuration
      AUTORESET_PATDET =&gt; "NO_RESET",    -- "NO_RESET", "RESET_MATCH", "RESET_NOT_MATCH" 
      MASK =&gt; X"3fffffffffff",           -- 48-bit mask value for pattern detect (1=ignore)
      PATTERN =&gt; X"000000000000",        -- 48-bit pattern match for pattern detect
      SEL_MASK =&gt; "MASK",                -- "C", "MASK", "ROUNDING_MODE1", "ROUNDING_MODE2" 
      SEL_PATTERN =&gt; "PATTERN",          -- Select pattern value ("PATTERN" or "C")
      USE_PATTERN_DETECT =&gt; "NO_PATDET", -- Enable pattern detect ("PATDET" or "NO_PATDET")
      -- Register Control Attributes: Pipeline Register Configuration
      ACASCREG =&gt; 1,                     -- Number of pipeline stages between A/ACIN and ACOUT (0, 1 or 2)
      ADREG =&gt; 1,                        -- Number of pipeline stages for pre-adder (0 or 1)
      ALUMODEREG =&gt; 1,                   -- Number of pipeline stages for ALUMODE (0 or 1)
      AREG =&gt; 1,                         -- Number of pipeline stages for A (0, 1 or 2)
      BCASCREG =&gt; 1,                     -- Number of pipeline stages between B/BCIN and BCOUT (0, 1 or 2)
      BREG =&gt; 1,                         -- Number of pipeline stages for B (0, 1 or 2)
      CARRYINREG =&gt; 1,                   -- Number of pipeline stages for CARRYIN (0 or 1)
      CARRYINSELREG =&gt; 1,                -- Number of pipeline stages for CARRYINSEL (0 or 1)
      CREG =&gt; 1,                         -- Number of pipeline stages for C (0 or 1)
      DREG =&gt; 1,                         -- Number of pipeline stages for D (0 or 1)
      INMODEREG =&gt; 1,                    -- Number of pipeline stages for INMODE (0 or 1)
      MREG =&gt; 1,                         -- Number of multiplier pipeline stages (0 or 1)
      OPMODEREG =&gt; 1,                    -- Number of pipeline stages for OPMODE (0 or 1)
      PREG =&gt; 1                          -- Number of pipeline stages for P (0 or 1)
   )
   port map (
      -- Cascade: 30-bit (each) output: Cascade Ports
      ACOUT =&gt; ACOUT,                   -- 30-bit output: A port cascade output
      BCOUT =&gt; BCOUT,                   -- 18-bit output: B port cascade output
      CARRYCASCOUT =&gt; CARRYCASCOUT,     -- 1-bit output: Cascade carry output
      MULTSIGNOUT =&gt; MULTSIGNOUT,       -- 1-bit output: Multiplier sign cascade output
      PCOUT =&gt; PCOUT,                   -- 48-bit output: Cascade output
      -- Control: 1-bit (each) output: Control Inputs/Status Bits
      OVERFLOW =&gt; OVERFLOW,             -- 1-bit output: Overflow in add/acc output
      PATTERNBDETECT =&gt; PATTERNBDETECT, -- 1-bit output: Pattern bar detect output
      PATTERNDETECT =&gt; PATTERNDETECT,   -- 1-bit output: Pattern detect output
      UNDERFLOW =&gt; UNDERFLOW,           -- 1-bit output: Underflow in add/acc output
      -- Data: 4-bit (each) output: Data Ports
      CARRYOUT =&gt; CARRYOUT,             -- 4-bit output: Carry output
      P =&gt; P,                           -- 48-bit output: Primary data output
      -- Cascade: 30-bit (each) input: Cascade Ports
      ACIN =&gt; ACIN,                     -- 30-bit input: A cascade data input
      BCIN =&gt; BCIN,                     -- 18-bit input: B cascade input
      CARRYCASCIN =&gt; CARRYCASCIN,       -- 1-bit input: Cascade carry input
      MULTSIGNIN =&gt; MULTSIGNIN,         -- 1-bit input: Multiplier sign input
      PCIN =&gt; PCIN,                     -- 48-bit input: P cascade input
      -- Control: 4-bit (each) input: Control Inputs/Status Bits
      ALUMODE =&gt; ALUMODE,               -- 4-bit input: ALU control input
      CARRYINSEL =&gt; CARRYINSEL,         -- 3-bit input: Carry select input
      CLK =&gt; CLK,                       -- 1-bit input: Clock input
      INMODE =&gt; INMODE,                 -- 5-bit input: INMODE control input
      OPMODE =&gt; OPMODE,                 -- 7-bit input: Operation mode input
      -- Data: 30-bit (each) input: Data Ports
      A =&gt; A,                           -- 30-bit input: A data input
      B =&gt; B,                           -- 18-bit input: B data input
      C =&gt; C,                           -- 48-bit input: C data input
      CARRYIN =&gt; CARRYIN,               -- 1-bit input: Carry input signal
      D =&gt; D,                           -- 25-bit input: D data input
      -- Reset/Clock Enable: 1-bit (each) input: Reset/Clock Enable Inputs
      CEA1 =&gt; CEA1,                     -- 1-bit input: Clock enable input for 1st stage AREG
      CEA2 =&gt; CEA2,                     -- 1-bit input: Clock enable input for 2nd stage AREG
      CEAD =&gt; CEAD,                     -- 1-bit input: Clock enable input for ADREG
      CEALUMODE =&gt; CEALUMODE,           -- 1-bit input: Clock enable input for ALUMODE
      CEB1 =&gt; CEB1,                     -- 1-bit input: Clock enable input for 1st stage BREG
      CEB2 =&gt; CEB2,                     -- 1-bit input: Clock enable input for 2nd stage BREG
      CEC =&gt; CEC,                       -- 1-bit input: Clock enable input for CREG
      CECARRYIN =&gt; CECARRYIN,           -- 1-bit input: Clock enable input for CARRYINREG
      CECTRL =&gt; CECTRL,                 -- 1-bit input: Clock enable input for OPMODEREG and CARRYINSELREG
      CED =&gt; CED,                       -- 1-bit input: Clock enable input for DREG
      CEINMODE =&gt; CEINMODE,             -- 1-bit input: Clock enable input for INMODEREG
      CEM =&gt; CEM,                       -- 1-bit input: Clock enable input for MREG
      CEP =&gt; CEP,                       -- 1-bit input: Clock enable input for PREG
      RSTA =&gt; RSTA,                     -- 1-bit input: Reset input for AREG
      RSTALLCARRYIN =&gt; RSTALLCARRYIN,   -- 1-bit input: Reset input for CARRYINREG
      RSTALUMODE =&gt; RSTALUMODE,         -- 1-bit input: Reset input for ALUMODEREG
      RSTB =&gt; RSTB,                     -- 1-bit input: Reset input for BREG
      RSTC =&gt; RSTC,                     -- 1-bit input: Reset input for CREG
      RSTCTRL =&gt; RSTCTRL,               -- 1-bit input: Reset input for OPMODEREG and CARRYINSELREG
      RSTD =&gt; RSTD,                     -- 1-bit input: Reset input for DREG and ADREG
      RSTINMODE =&gt; RSTINMODE,           -- 1-bit input: Reset input for INMODEREG
      RSTM =&gt; RSTM,                     -- 1-bit input: Reset input for MREG
      RSTP =&gt; RSTP                      -- 1-bit input: Reset input for PREG
   );

   -- End of DSP48E1_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Clock Components" treetype="folder">
				<SubFolder label="Clock Buffers" treetype="folder">
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
--  BUFGCE_1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_1: Global Clock Buffer with Clock Enable and Output State 1
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_1_inst : BUFGCE_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock enable input for I0
      I =&gt; I    -- 1-bit input: Primary clock
   );

   -- End of BUFGCE_1_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
--   BUFGCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE: Global Clock Buffer with Clock Enable
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_inst : BUFGCE
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock enable input for I0
      I =&gt; I    -- 1-bit input: Primary clock
   );

   -- End of BUFGCE_inst instantiation
					</Template>
					<Template label="Global Clock Simple Buffer (BUFG)" treetype="template">
--    BUFG     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG: Global Clock Simple Buffer
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_inst : BUFG
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFG_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer (BUFH)" treetype="template">
--    BUFH     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFH_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFH: HROW Clock Buffer for a Single Clocking Region
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFH_inst : BUFH
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFH_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer with Clock Enable (BUFHCE)" treetype="template">
--   BUFHCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFHCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFHCE: HROW Clock Buffer for a Single Clocking Region with Clock Enable
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFHCE_inst : BUFHCE
   generic map (
      CE_TYPE =&gt; "SYNC", -- "SYNC" (glitchless switching) or "ASYNC" (immediate switch)
      INIT_OUT =&gt; 0      -- Initial output value (0-1)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Active high enable
      I =&gt; I    -- 1-bit input: Clock input
   );

   -- End of BUFHCE_inst instantiation
					</Template>
					<Template label="I/O Clock Buffer (BUFIO)" treetype="template">
--    BUFIO    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFIO_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFIO: Local Clock Buffer for I/O
   --        Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFIO_inst : BUFIO
   port map (
      O =&gt; O, -- 1-bit output: Clock output (connect to I/O clock loads).
      I =&gt; I  -- 1-bit input: Clock input (connect to an IBUF or BUFMR).
   );

   -- End of BUFIO_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer (BUFMR)" treetype="template">
--    BUFMR    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFMR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFMR: Multi-Region Clock Buffer
   --        Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFMR_inst : BUFMR
   port map (
      O =&gt; O, -- 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      I =&gt; I  -- 1-bit input: Clock input (Connect to IBUF)
   );

   -- End of BUFMR_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer with Clock Enable (BUFMRCE)" treetype="template">
--   BUFMRCE   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFMRCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFMRCE: Multi-Region Clock Buffer with Clock Enable
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFMRCE_inst : BUFMRCE
   generic map (
      CE_TYPE =&gt; "SYNC", -- SYNC, ASYNC
      INIT_OUT =&gt; 0      -- Initial output and stopped polarity, (0-1)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      CE =&gt; CE, -- 1-bit input: Active high buffer enable
      I =&gt; I    -- 1-bit input: Clock input (Connect to IBUF)
   );

   -- End of BUFMRCE_inst instantiation
					</Template>
					<Template label="Regional Clock Buffer (BUFR)" treetype="template">
--    BUFR     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFR: Regional Clock Buffer for I/O and Logic Resources within a Clock Region
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFR_inst : BUFR
   generic map (
      BUFR_DIVIDE =&gt; "BYPASS",   -- Values: "BYPASS, 1, 2, 3, 4, 5, 6, 7, 8" 
      SIM_DEVICE =&gt; "7SERIES"  -- Must be set to "7SERIES" 
   )
   port map (
      O =&gt; O,     -- 1-bit output: Clock output port
      CE =&gt; CE,   -- 1-bit input: Active high, clock enable (Divided modes only)
      CLR =&gt; CLR, -- 1-bit input: Active high, asynchronous clear (Divided modes only)
      I =&gt; I      -- 1-bit input: Clock buffer input driven by an IBUF, MMCM or local interconnect
   );

   -- End of BUFR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Clock MUXes" treetype="folder">
					<Template label="2-to-1 Global Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
-- BUFGMUX_CTRL : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_CTRL: 2-to-1 Global Clock MUX Buffer
   --               Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL_inst : BUFGMUX_CTRL
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="Global Clock Control Buffer (BUFGCTRL)" treetype="template">
--  BUFGCTRL   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCTRL: Global Clock Control Buffer
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCTRL_inst : BUFGCTRL
   generic map (
      INIT_OUT =&gt; 0,         -- Initial value of BUFGCTRL output ($VALUES;)
      PRESELECT_I0 =&gt; FALSE, -- BUFGCTRL output uses I0 input ($VALUES;)
      PRESELECT_I1 =&gt; FALSE  -- BUFGCTRL output uses I1 input ($VALUES;)
   )
   port map (
      O =&gt; O,             -- 1-bit output: Clock output
      CE0 =&gt; CE0,         -- 1-bit input: Clock enable input for I0
      CE1 =&gt; CE1,         -- 1-bit input: Clock enable input for I1
      I0 =&gt; I0,           -- 1-bit input: Primary clock
      I1 =&gt; I1,           -- 1-bit input: Secondary clock
      IGNORE0 =&gt; IGNORE0, -- 1-bit input: Clock ignore input for I0
      IGNORE1 =&gt; IGNORE1, -- 1-bit input: Clock ignore input for I1
      S0 =&gt; S0,           -- 1-bit input: Clock select for I0
      S1 =&gt; S1            -- 1-bit input: Clock select for I1
   );

   -- End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer (BUFGMUX)" treetype="template">
--   BUFGMUX   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX: Global Clock Mux Buffer
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_inst : BUFGMUX
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
--  BUFGMUX_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_1: Global Clock Mux Buffer with Output State 1
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1_inst : BUFGMUX_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MMCM / PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCME2_ADV)" treetype="template">
-- MMCME2_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME2_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME2_ADV: Advanced Mixed Mode Clock Manager
   --             Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   MMCME2_ADV_inst : MMCME2_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",      -- Jitter programming (OPTIMIZED, HIGH, LOW)
      CLKFBOUT_MULT_F =&gt; 5.0,        -- Multiply value for all CLKOUT (2.000-64.000).
      CLKFBOUT_PHASE =&gt; 0.0,         -- Phase offset in degrees of CLKFB (-360.000-360.000).
      -- CLKIN_PERIOD: Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      -- CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT0_DIVIDE_F =&gt; 1.0,       -- Divide amount for CLKOUT0 (1.000-128.000).
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.01-0.99).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      CLKOUT4_CASCADE =&gt; FALSE,      -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      COMPENSATION =&gt; "ZHOLD",       -- ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,            -- Master division value (1-106)
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; FALSE,         -- Delays DONE until MMCM is locked (FALSE, TRUE)
      -- Spread Spectrum: Spread Spectrum Attributes
      SS_EN =&gt; "FALSE",              -- Enables spread spectrum (FALSE, TRUE)
      SS_MODE =&gt; "CENTER_HIGH",      -- CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      SS_MOD_PERIOD =&gt; 10000,        -- Spread spectrum modulation period (ns) (VALUES)
      -- USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      CLKFBOUT_USE_FINE_PS =&gt; FALSE,
      CLKOUT0_USE_FINE_PS =&gt; FALSE,
      CLKOUT1_USE_FINE_PS =&gt; FALSE,
      CLKOUT2_USE_FINE_PS =&gt; FALSE,
      CLKOUT3_USE_FINE_PS =&gt; FALSE,
      CLKOUT4_USE_FINE_PS =&gt; FALSE,
      CLKOUT5_USE_FINE_PS =&gt; FALSE,
      CLKOUT6_USE_FINE_PS =&gt; FALSE 
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,           -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,         -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,           -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,         -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,           -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,         -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,           -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,         -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,           -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,           -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,           -- 1-bit output: CLKOUT6
      -- DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      DO =&gt; DO,                     -- 16-bit output: DRP data
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP ready
      -- Dynamic Phase Shift Ports: 1-bit (each) output: Ports used for dynamic phase shifting of the outputs
      PSDONE =&gt; PSDONE,             -- 1-bit output: Phase shift done
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,         -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB,       -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports: 1-bit (each) output: MMCM status ports
      CLKFBSTOPPED =&gt; CLKFBSTOPPED, -- 1-bit output: Feedback clock stopped
      CLKINSTOPPED =&gt; CLKINSTOPPED, -- 1-bit output: Input clock stopped
      LOCKED =&gt; LOCKED,             -- 1-bit output: LOCK
      -- Clock Inputs: 1-bit (each) input: Clock inputs
      CLKIN1 =&gt; CLKIN1,             -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,             -- 1-bit input: Secondary clock
      -- Control Ports: 1-bit (each) input: MMCM control ports
      CLKINSEL =&gt; CLKINSEL,         -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,             -- 1-bit input: Power-down
      RST =&gt; RST,                   -- 1-bit input: Reset
      -- DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable
      DI =&gt; DI,                     -- 16-bit input: DRP data
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- Dynamic Phase Shift Ports: 1-bit (each) input: Ports used for dynamic phase shifting of the outputs
      PSCLK =&gt; PSCLK,               -- 1-bit input: Phase shift clock
      PSEN =&gt; PSEN,                 -- 1-bit input: Phase shift enable
      PSINCDEC =&gt; PSINCDEC,         -- 1-bit input: Phase shift increment/decrement
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN            -- 1-bit input: Feedback clock
   );

   -- End of MMCME2_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase Locked Loop (PLLE2_ADV)" treetype="template">
--  PLLE2_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE2_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE2_ADV: Advanced Phase Locked Loop (PLL)
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   PLLE2_ADV_inst : PLLE2_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",  -- OPTIMIZED, HIGH, LOW
      CLKFBOUT_MULT =&gt; 5,        -- Multiply value for all CLKOUT, (2-64)
      CLKFBOUT_PHASE =&gt; 0.0,     -- Phase offset in degrees of CLKFB, (-360.000-360.000).
      -- CLKIN_PERIOD: Input clock period in nS to ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      -- CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT0_DIVIDE =&gt; 1,
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      -- CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      COMPENSATION =&gt; "ZHOLD",   -- ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,        -- Master division value (1-56)
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; "FALSE"    -- Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,   -- 1-bit output: CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,   -- 1-bit output: CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,   -- 1-bit output: CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,   -- 1-bit output: CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,   -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,   -- 1-bit output: CLKOUT5
      -- DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      DO =&gt; DO,             -- 16-bit output: DRP data
      DRDY =&gt; DRDY,         -- 1-bit output: DRP ready
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT, -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,     -- 1-bit output: LOCK
      -- Clock Inputs: 1-bit (each) input: Clock inputs
      CLKIN1 =&gt; CLKIN1,     -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,     -- 1-bit input: Secondary clock
      -- Control Ports: 1-bit (each) input: PLL control ports
      CLKINSEL =&gt; CLKINSEL, -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,     -- 1-bit input: Power-down
      RST =&gt; RST,           -- 1-bit input: Reset
      -- DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,       -- 7-bit input: DRP address
      DCLK =&gt; DCLK,         -- 1-bit input: DRP clock
      DEN =&gt; DEN,           -- 1-bit input: DRP enable
      DI =&gt; DI,             -- 16-bit input: DRP data
      DWE =&gt; DWE,           -- 1-bit input: DRP write enable
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN    -- 1-bit input: Feedback clock
   );

   -- End of PLLE2_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCME2_BASE)" treetype="template">
-- MMCME2_BASE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME2_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME2_BASE: Base Mixed Mode Clock Manager
   --              Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   MMCME2_BASE_inst : MMCME2_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",  -- Jitter programming (OPTIMIZED, HIGH, LOW)
      CLKFBOUT_MULT_F =&gt; 5.0,    -- Multiply value for all CLKOUT (2.000-64.000).
      CLKFBOUT_PHASE =&gt; 0.0,     -- Phase offset in degrees of CLKFB (-360.000-360.000).
      CLKIN1_PERIOD =&gt; 0.0,      -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT0_DIVIDE_F =&gt; 1.0,   -- Divide amount for CLKOUT0 (1.000-128.000).
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.01-0.99).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      CLKOUT4_CASCADE =&gt; FALSE,  -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      DIVCLK_DIVIDE =&gt; 1,        -- Master division value (1-106)
      REF_JITTER1 =&gt; 0.0,        -- Reference input jitter in UI (0.000-0.999).
      STARTUP_WAIT =&gt; FALSE      -- Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,     -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,   -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,     -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,   -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,     -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,   -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,     -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,   -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,     -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,     -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,     -- 1-bit output: CLKOUT6
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,   -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB, -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports: 1-bit (each) output: MMCM status ports
      LOCKED =&gt; LOCKED,       -- 1-bit output: LOCK
      -- Clock Inputs: 1-bit (each) input: Clock input
      CLKIN1 =&gt; CLKIN1,       -- 1-bit input: Clock
      -- Control Ports: 1-bit (each) input: MMCM control ports
      PWRDWN =&gt; PWRDWN,       -- 1-bit input: Power-down
      RST =&gt; RST,             -- 1-bit input: Reset
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN      -- 1-bit input: Feedback clock
   );

   -- End of MMCME2_BASE_inst instantiation
					</Template>
					<Template label="Base Phase Locked Loop (PLLE2_BASE)" treetype="template">
-- PLLE2_BASE  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE2_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE2_BASE: Base Phase Locked Loop (PLL)
   --             Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   PLLE2_BASE_inst : PLLE2_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",  -- OPTIMIZED, HIGH, LOW
      CLKFBOUT_MULT =&gt; 5,        -- Multiply value for all CLKOUT, (2-64)
      CLKFBOUT_PHASE =&gt; 0.0,     -- Phase offset in degrees of CLKFB, (-360.000-360.000).
      CLKIN1_PERIOD =&gt; 0.0,      -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT0_DIVIDE =&gt; 1,
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      -- CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      DIVCLK_DIVIDE =&gt; 1,        -- Master division value, (1-56)
      REF_JITTER1 =&gt; 0.0,        -- Reference input jitter in UI, (0.000-0.999).
      STARTUP_WAIT =&gt; "FALSE"    -- Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,   -- 1-bit output: CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,   -- 1-bit output: CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,   -- 1-bit output: CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,   -- 1-bit output: CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,   -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,   -- 1-bit output: CLKOUT5
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT, -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,     -- 1-bit output: LOCK
      CLKIN1 =&gt; CLKIN1,     -- 1-bit input: Input clock
      -- Control Ports: 1-bit (each) input: PLL control ports
      PWRDWN =&gt; PWRDWN,     -- 1-bit input: Power-down
      RST =&gt; RST,           -- 1-bit input: Reset
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN    -- 1-bit input: Feedback clock
   );

   -- End of PLLE2_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Config/BSCAN Components" treetype="folder">
				<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
--  EFUSE_USR  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (EFUSE_USR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EFUSE_USR: 32-bit non-volatile design ID
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   EFUSE_USR_inst : EFUSE_USR
   generic map (
      SIM_EFUSE_VALUE =&gt; X"00000000"  -- Value of the 32-bit non-volatile value used in simulation
   )
   port map (
      EFUSEUSR =&gt; EFUSEUSR  -- 32-bit output: User eFUSE register value output
   );

   -- End of EFUSE_USR_inst instantiation
				</Template>
				<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
--   BSCANE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BSCANE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BSCANE2: Boundary-Scan User Instruction
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   BSCANE2_inst : BSCANE2
   generic map (
      JTAG_CHAIN =&gt; 1  -- Value for USER command.
   )
   port map (
      CAPTURE =&gt; CAPTURE, -- 1-bit output: CAPTURE output from TAP controller.
      DRCK =&gt; DRCK,       -- 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                          -- SHIFT are asserted.

      RESET =&gt; RESET,     -- 1-bit output: Reset output for TAP controller.
      RUNTEST =&gt; RUNTEST, -- 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      SEL =&gt; SEL,         -- 1-bit output: USER instruction active output.
      SHIFT =&gt; SHIFT,     -- 1-bit output: SHIFT output from TAP controller.
      TCK =&gt; TCK,         -- 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      TDI =&gt; TDI,         -- 1-bit output: Test Data Input (TDI) output from TAP controller.
      TMS =&gt; TMS,         -- 1-bit output: Test Mode Select output. Fabric connection to TAP.
      UPDATE =&gt; UPDATE,   -- 1-bit output: UPDATE output from TAP controller
      TDO =&gt; TDO          -- 1-bit input: Test Data Output (TDO) input for USER function.
   );

   -- End of BSCANE2_inst instantiation
				</Template>
				<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
-- USR_ACCESSE2 : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (USR_ACCESSE2_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- USR_ACCESSE2: Configuration Data Access
   --               Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2_inst : USR_ACCESSE2
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration Clock output
      DATA =&gt; DATA,           -- 32-bit output: Configuration Data output
      DATAVALID =&gt; DATAVALID  -- 1-bit output: Active high data valid output
   );

   -- End of USR_ACCESSE2_inst instantiation
				</Template>
				<Template label="Configuration Frame Error Correction (FRAME_ECCE2)" treetype="template">
-- FRAME_ECCE2 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FRAME_ECCE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FRAME_ECCE2: Configuration Frame Error Correction
   --              Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   FRAME_ECCE2_inst : FRAME_ECCE2
   generic map (
      FARSRC =&gt; "EFAR",                -- Determines if the output of FAR[25:0] configuration register points
                                       -- to the FAR or EFAR. Sets configuration option register bit CTL0[7].
      FRAME_RBT_IN_FILENAME =&gt; "None"  -- This file is output by the ICAP_E2 model and it contains Frame Data
                                       -- information for the Raw Bitstream (RBT) file. The FRAME_ECCE2 model
                                       -- will parse this file, calculate ECC and output any error conditions.
   )
   port map (
      CRCERROR =&gt; CRCERROR,             -- 1-bit output: Output indicating a CRC error.
      ECCERROR =&gt; ECCERROR,             -- 1-bit output: Output indicating an ECC error.
      ECCERRORSINGLE =&gt; ECCERRORSINGLE, -- 1-bit output: Output Indicating single-bit Frame ECC error detected.
      FAR =&gt; FAR,                       -- 26-bit output: Frame Address Register Value output.
      SYNBIT =&gt; SYNBIT,                 -- 5-bit output: Output bit address of error.
      SYNDROME =&gt; SYNDROME,             -- 13-bit output: Output location of erroneous bit.
      SYNDROMEVALID =&gt; SYNDROMEVALID,   -- 1-bit output: Frame ECC output indicating the SYNDROME output is
                                        -- valid.

      SYNWORD =&gt; SYNWORD                -- 7-bit output: Word output in the frame where an ECC error has been
                                        -- detected.

   );

   -- End of FRAME_ECCE2_inst instantiation
				</Template>
				<Template label="Device DNA Access Port (DNA_PORT)" treetype="template">
--  DNA_PORT   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DNA_PORT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DNA_PORT: Device DNA Access Port
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   DNA_PORT_inst : DNA_PORT
   generic map (
      SIM_DNA_VALUE =&gt; X"000000000000000"  -- Specifies a sample 57-bit DNA value for simulation
   )
   port map (
      DOUT =&gt; DOUT,   -- 1-bit output: DNA output data.
      CLK =&gt; CLK,     -- 1-bit input: Clock input.
      DIN =&gt; DIN,     -- 1-bit input: User data input pin.
      READ =&gt; READ,   -- 1-bit input: Active high load DNA, active low read input.
      SHIFT =&gt; SHIFT  -- 1-bit input: Active high shift enable input.
   );

   -- End of DNA_PORT_inst instantiation
				</Template>
				<Template label="Internal Configuration Access Port (ICAPE2)" treetype="template">
--   ICAPE2    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ICAPE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ICAPE2: Internal Configuration Access Port
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   ICAPE2_inst : ICAPE2
   generic map (
      DEVICE_ID =&gt; X"3651093",     -- Specifies the pre-programmed Device ID value to be used for simulation
                                   -- purposes.
      ICAP_WIDTH =&gt; "X32",         -- Specifies the input and output data width.
      SIM_CFG_FILE_NAME =&gt; "None"  -- Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                   -- model.
   )
   port map (
      O =&gt; O,         -- 32-bit output: Configuration data output bus
      CLK =&gt; CLK,     -- 1-bit input: Clock Input
      CSIB =&gt; CSIB,   -- 1-bit input: Active-Low ICAP Enable
      I =&gt; I,         -- 32-bit input: Configuration data input bus
      RDWRB =&gt; RDWRB  -- 1-bit input: Read/Write Select input
   );

   -- End of ICAPE2_inst instantiation
				</Template>
				<Template label="Register Capture (CAPTUREE2)" treetype="template">
--  CAPTUREE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CAPTUREE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CAPTUREE2: Register Capture
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   CAPTUREE2_inst : CAPTUREE2
   generic map (
      ONESHOT =&gt; "TRUE"  -- Specifies the procedure for performing single readback per CAP trigger.
   )
   port map (
      CAP =&gt; CAP, -- 1-bit input: Capture Input
      CLK =&gt; CLK  -- 1-bit input: Clock Input
   );

   -- End of CAPTUREE2_inst instantiation
				</Template>
				<Template label="STARTUP Block (STARTUPE2)" treetype="template">
--  STARTUPE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (STARTUPE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- STARTUPE2: STARTUP Block
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   STARTUPE2_inst : STARTUPE2
   generic map (
      PROG_USR =&gt; "FALSE",  -- Activate program event security feature. Requires encrypted bitstreams.
      SIM_CCLK_FREQ =&gt; 0.0  -- Set the Configuration Clock Frequency(ns) for simulation.
   )
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration main clock output
      CFGMCLK =&gt; CFGMCLK,     -- 1-bit output: Configuration internal oscillator clock output
      EOS =&gt; EOS,             -- 1-bit output: Active high output signal indicating the End Of Startup.
      PREQ =&gt; PREQ,           -- 1-bit output: PROGRAM request to fabric output
      CLK =&gt; CLK,             -- 1-bit input: User start-up clock input
      GSR =&gt; GSR,             -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port name)
      GTS =&gt; GTS,             -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      KEYCLEARB =&gt; KEYCLEARB, -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      PACK =&gt; PACK,           -- 1-bit input: PROGRAM acknowledge input
      USRCCLKO =&gt; USRCCLKO,   -- 1-bit input: User CCLK input
      USRCCLKTS =&gt; USRCCLKTS, -- 1-bit input: User CCLK 3-state enable input
      USRDONEO =&gt; USRDONEO,   -- 1-bit input: User DONE pin output control
      USRDONETS =&gt; USRDONETS  -- 1-bit input: User DONE 3-state enable output
   );

   -- End of STARTUPE2_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="I/O Components" treetype="folder">
				<SubFolder label="Bi-directional Buffers" treetype="folder">
					<Template label="Differential Buffer (IOBUFDS)" treetype="template">

--   IOBUFDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUFDS_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS: Differential Bi-directional Buffer
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_inst : IOBUFDS
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; TRUE, -- Low Power = TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      SLEW =&gt; "SLOW")       -- Specify the output slew rate
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ input and input termination disable (IOBUFDS_INTERMDISABLE)" treetype="template">

--IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--    VHDL              : the following instance declaration needs to be placed
--  instance            : in the architecture body of the design code.  The
-- declaration          : instance name (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations
--    code              : after the "=&gt;" assignment maybe changed to properly
--                      : connect this function to the design. All inputs must be
--                      : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_INTERMDISABLE: Differential Bi-directional Buffer with Input Termination
   --                        and Input path enable/disable
   --                        May only be placed in High Range (HR) Banks
   --                        Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_INTERMDISABLE_inst : IOBUFDS_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, HIGH Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      SLEW =&gt; "SLOW",   -- Specify the output slew rate
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input termination disable input
      T =&gt; T      -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output (IOBUFDS_DIFF_OUT)" treetype="template">

--IOBUFDS_DIFF_OUT   : In order to incorporate this function into the design,
--    VHDL           : the following instance declaration needs to be placed
--  instance         : in the architecture body of the design code.  The
-- declaration       : instance name (IOBUFDS_DIFF_OUT_inst) and/or the port declarations
--    code           : after the "=&gt;" assignment maybe changed to properly
--                   : connect this function to the design. All inputs must be
--                   : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT: Differential Bi-directional Buffer with Diffirential Output
   --                   Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_inst : IOBUFDS_DIFF_OUT
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; TRUE, -- Low Power - TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25") -- Specify the I/O standard
   port map (
      O =&gt; O,     -- Buffer p-side output
      OB =&gt; OB,   -- Buffer n-side output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      TM =&gt; TM,   -- 3-state enable input, high=input, low=output
      TS =&gt; TS    -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_DIFF_OUT_inst instantiation

					</Template>
					<Template label="Differential Global Clock Buffer w/ Differential Output, INTERM and IBUF disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">

--IOBUFDS_DIFF_OUT_INTERMDISABLE: In order to incorporate this function into the design,
--         VHDL                 : the following instance declaration needs to be placed
--       instance               : in the architecture body of the design code.  The
--      declaration             : instance name (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations
--         code                 : after the "=&gt;" assignment maybe changed to properly
--                              : connect this function to the design. All inputs must be
--                              : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_INTERMDISABLE:  Differential Global Clock Buffer with Differential Output
   --                                  Input Termination and Input Path Disable
   --                                  May only be placed in High Range (HR) Banks
   --                                  Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst : IOBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function, "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer p-side output
      OB =&gt; OB,   -- Buffer n-side output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- input disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input termination disable input 
      TM =&gt; TM,   -- 3-state enable input, high=input, low=output
      TS =&gt; TS    -- 3-state enable input, high=output, low=input
   );
  
   -- End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation

					</Template>
					<Template label="Single-ended Buffer (IOBUF)" treetype="template">

--    IOBUF    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUF_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF: Single-ended Bi-directional Buffer
   --        Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUF_inst : IOBUF
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Buffer inout port (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input, high=input, low=output 
   );
  
   -- End of IOBUF_inst instantiation


					</Template>
					<Template label="Single-ended Buffer w/ input and INTERM disable (IOBUF_INTERMDISABLE)" treetype="template">

-- IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
--       VHDL          : the following instance declaration needs to be placed
--     instance        : in the architecture body of the design code.  The
--   declaration       : instance name (IOBUF_INTERMDISABLE_inst) and/or the port declarations
--       code          : after the "=&gt;" assignment maybe changed to properly
--                     : connect this function to the design. All inputs must be
--                     : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_INTERMDISABLE: Single-ended Bi-directional Buffer with Input Termination
   --                      and Input path enable/disable
   --                      May only be placed in High Range (HR) Banks
   --                      Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUF_INTERMDISABLE_inst : IOBUF_INTERMDISABLE
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT", -- Specify the I/O standard
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - "TRUE", High Performance = "FALSE" 
      USE_IBUFDISABLE =&gt; "TRUE", -- Use IBUFDISABLE function "TRUE" or "FALSE" 
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Buffer inout port (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input termination disable input
      T =&gt; T      -- 3-state enable input, high=input, low=output 
   );
  
   -- End of IOBUF_INTERMDISABLE_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="DDR Registers" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
--    IDDR_2CLK  : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The
--   declaration : instance name (IDDR_2CLK_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design.  All inputs must be 
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   --            Set, Reset and Clock Enable.
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK_inst : IDDR_2CLK 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit primary clock input
      CB =&gt; CB, -- 1-bit secondary clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_2CLK_inst instantiation

					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
--      IDDR     : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The 
--   declaration : instance name (IDDR_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design. All inputs must be
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR: Double Data Rate Input Register with Set, Reset
   --       and Clock Enable. 
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_inst : IDDR 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_inst instantiation

					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
--      ODDR       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (ODDR_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs  
--                 : and outputs must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDR: Output Double Data Rate Output Register with Set, Reset
   --       and Clock Enable. 
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   ODDR_inst : ODDR
   generic map(
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE" or "SAME_EDGE" 
      INIT =&gt; '0',   -- Initial value for Q port ('1' or '0')
      SRTYPE =&gt; "SYNC") -- Reset Type ("ASYNC" or "SYNC")
   port map (
      Q =&gt; Q,   -- 1-bit DDR output
      C =&gt; C,    -- 1-bit clock input
      CE =&gt; CE,  -- 1-bit clock enable input
      D1 =&gt; D1,  -- 1-bit data input (positive edge)
      D2 =&gt; D2,  -- 1-bit data input (negative edge)
      R =&gt; R,    -- 1-bit reset input
      S =&gt; S     -- 1-bit set input
   );
  
   -- End of ODDR_inst instantiation


					</Template>
				</SubFolder>
				<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
--  DCIRESET   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DCIRESET_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DCIRESET: Digitally Controlled Impedance Reset Component
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   DCIRESET_inst : DCIRESET
   port map (
      LOCKED =&gt; LOCKED, -- 1-bit output: LOCK status output
      RST =&gt; RST        -- 1-bit input: Active-high asynchronous reset input
   );

   -- End of DCIRESET_inst instantiation
				</Template>
				<SubFolder label="FIFOs" treetype="folder">
					<Template label="Input FIFO (IN_FIFO)" treetype="template">
--   IN_FIFO   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IN_FIFO_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IN_FIFO: Input First-In, First-Out (FIFO)
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IN_FIFO_inst : IN_FIFO
   generic map (
      ALMOST_EMPTY_VALUE =&gt; 1,          -- Almost empty offset (1-2)
      ALMOST_FULL_VALUE =&gt; 1,           -- Almost full offset (1-2)
      ARRAY_MODE =&gt; "ARRAY_MODE_4_X_8", -- ARRAY_MODE_4_X_8, ARRAY_MODE_4_X_4
      SYNCHRONOUS_MODE =&gt; "FALSE"       -- Clock synchronous (FALSE)
   )
   port map (
      -- FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY, -- 1-bit output: Almost empty
      ALMOSTFULL =&gt; ALMOSTFULL,   -- 1-bit output: Almost full
      EMPTY =&gt; EMPTY,             -- 1-bit output: Empty
      FULL =&gt; FULL,               -- 1-bit output: Full
      -- Q0-Q9: 8-bit (each) output: FIFO Outputs
      Q0 =&gt; Q0,                   -- 8-bit output: Channel 0
      Q1 =&gt; Q1,                   -- 8-bit output: Channel 1
      Q2 =&gt; Q2,                   -- 8-bit output: Channel 2
      Q3 =&gt; Q3,                   -- 8-bit output: Channel 3
      Q4 =&gt; Q4,                   -- 8-bit output: Channel 4
      Q5 =&gt; Q5,                   -- 8-bit output: Channel 5
      Q6 =&gt; Q6,                   -- 8-bit output: Channel 6
      Q7 =&gt; Q7,                   -- 8-bit output: Channel 7
      Q8 =&gt; Q8,                   -- 8-bit output: Channel 8
      Q9 =&gt; Q9,                   -- 8-bit output: Channel 9
      -- D0-D9: 4-bit (each) input: FIFO inputs
      D0 =&gt; D0,                   -- 4-bit input: Channel 0
      D1 =&gt; D1,                   -- 4-bit input: Channel 1
      D2 =&gt; D2,                   -- 4-bit input: Channel 2
      D3 =&gt; D3,                   -- 4-bit input: Channel 3
      D4 =&gt; D4,                   -- 4-bit input: Channel 4
      D5 =&gt; D5,                   -- 8-bit input: Channel 5
      D6 =&gt; D6,                   -- 8-bit input: Channel 6
      D7 =&gt; D7,                   -- 4-bit input: Channel 7
      D8 =&gt; D8,                   -- 4-bit input: Channel 8
      D9 =&gt; D9,                   -- 4-bit input: Channel 9
      -- FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      RDCLK =&gt; RDCLK,             -- 1-bit input: Read clock
      RDEN =&gt; RDEN,               -- 1-bit input: Read enable
      RESET =&gt; RESET,             -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,             -- 1-bit input: Write clock
      WREN =&gt; WREN                -- 1-bit input: Write enable
   );

   -- End of IN_FIFO_inst instantiation
					</Template>
					<Template label="Output FIFO (OUT_FIFO)" treetype="template">
--  OUT_FIFO   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OUT_FIFO_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OUT_FIFO: Output First-In, First-Out (FIFO) Buffer
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   OUT_FIFO_inst : OUT_FIFO
   generic map (
      ALMOST_EMPTY_VALUE =&gt; 1,          -- Almost empty offset (1-2)
      ALMOST_FULL_VALUE =&gt; 1,           -- Almost full offset (1-2)
      ARRAY_MODE =&gt; "ARRAY_MODE_8_X_4", -- ARRAY_MODE_8_X_4, ARRAY_MODE_4_X_4
      OUTPUT_DISABLE =&gt; "FALSE",        -- Disable output (FALSE, TRUE)
      SYNCHRONOUS_MODE =&gt; "FALSE"       -- Must always be set to false.
   )
   port map (
      -- FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY, -- 1-bit output: Almost empty flag
      ALMOSTFULL =&gt; ALMOSTFULL,   -- 1-bit output: Almost full flag
      EMPTY =&gt; EMPTY,             -- 1-bit output: Empty flag
      FULL =&gt; FULL,               -- 1-bit output: Full flag
      -- Q0-Q9: 4-bit (each) output: FIFO Outputs
      Q0 =&gt; Q0,                   -- 4-bit output: Channel 0 output bus
      Q1 =&gt; Q1,                   -- 4-bit output: Channel 1 output bus
      Q2 =&gt; Q2,                   -- 4-bit output: Channel 2 output bus
      Q3 =&gt; Q3,                   -- 4-bit output: Channel 3 output bus
      Q4 =&gt; Q4,                   -- 4-bit output: Channel 4 output bus
      Q5 =&gt; Q5,                   -- 8-bit output: Channel 5 output bus
      Q6 =&gt; Q6,                   -- 8-bit output: Channel 6 output bus
      Q7 =&gt; Q7,                   -- 4-bit output: Channel 7 output bus
      Q8 =&gt; Q8,                   -- 4-bit output: Channel 8 output bus
      Q9 =&gt; Q9,                   -- 4-bit output: Channel 9 output bus
      -- D0-D9: 8-bit (each) input: FIFO inputs
      D0 =&gt; D0,                   -- 8-bit input: Channel 0 input bus
      D1 =&gt; D1,                   -- 8-bit input: Channel 1 input bus
      D2 =&gt; D2,                   -- 8-bit input: Channel 2 input bus
      D3 =&gt; D3,                   -- 8-bit input: Channel 3 input bus
      D4 =&gt; D4,                   -- 8-bit input: Channel 4 input bus
      D5 =&gt; D5,                   -- 8-bit input: Channel 5 input bus
      D6 =&gt; D6,                   -- 8-bit input: Channel 6 input bus
      D7 =&gt; D7,                   -- 8-bit input: Channel 7 input bus
      D8 =&gt; D8,                   -- 8-bit input: Channel 8 input bus
      D9 =&gt; D9,                   -- 8-bit input: Channel 9 input bus
      -- FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      RDCLK =&gt; RDCLK,             -- 1-bit input: Read clock
      RDEN =&gt; RDEN,               -- 1-bit input: Read enable
      RESET =&gt; RESET,             -- 1-bit input: Active high reset
      WRCLK =&gt; WRCLK,             -- 1-bit input: Write clock
      WREN =&gt; WREN                -- 1-bit input: Write enable
   );

   -- End of OUT_FIFO_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Input Buffers" treetype="folder">
					<Template label="Differential Buffer (IBUFDS)" treetype="template">

--   IBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IBUFDS_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS: Differential Input Buffer
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_inst : IBUFDS
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination 
      IBUF_LOW_PWR =&gt; TRUE, -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT")
   port map (
      O =&gt; O,  -- Buffer output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB -- Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ Disable (IBUFDS_IBUFDISABLE)" treetype="template">

--IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IBUFDS_IBUFDISABLE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_IBUFDISABLE: Differential Input Buffer w/ Disable
   --                     Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE_inst : IBUFDS_IBUFDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,  -- Buffer output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, high=disable
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Differential Buffer with Differential Output (IBUFDS_DIFF_OUT)" treetype="template">

--IBUFDS_DIFF_OUT: In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : instance name (IBUFDS_DIFF_OUT_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT: Differential Input Buffer with Differential Output
   --                  Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_inst : IBUFDS_DIFF_OUT
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination 
      IBUF_LOW_PWR =&gt; TRUE, -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT") -- Specify the input I/O standard
   port map (
      O =&gt; O,     -- Buffer diff_p output
      OB =&gt; OB,   -- Buffer diff_n output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB -- Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_DIFF_OUT_inst instantiation


					</Template>
					<Template label="Differential Buffer with Differential Output w/Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">

--IBUFDS_DIFF_OUT_IBUFDISABLE: In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : instance name (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer with Differential Output w/ Disable
   --                              Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE_inst : IBUFDS_DIFF_OUT_IBUFDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power "TRUE" vs. performance "FALSE" setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer diff_p output
      OB =&gt; OB,   -- Buffer diff_n output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, high=disable
   );

   -- End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Differential Buffer with Differential Output w/Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">

--IBUFDS_DIFF_OUT_INTERMDISABLE: In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : instance name (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Differential Output w/ Disable
   --                                Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE_inst : IBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power "TRUE" vs. performance "FALSE" setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer diff_p output
      OB =&gt; OB,   -- Buffer diff_n output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE -- Input termination disable
   );

   -- End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">

--IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IBUFDS_INTERMDISABLE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_INTERMDISABLE: Differential Input Buffer with Input Termination Disable
   --                       May only be placed in High Range (HR) Banks
   --                       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE_inst : IBUFDS_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,  -- Buffer output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE -- Input termination disable
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Single-ended Buffer (IBUF)" treetype="template">

--      IBUF       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (IBUF_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs must be
--                 : connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF: Single-ended Input Buffer
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IBUF_inst : IBUF
   generic map (
      IBUF_LOW_PWR =&gt; TRUE, -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT")
   port map (
      O =&gt; O,     -- Buffer output
      I =&gt; I      -- Buffer input (connect directly to top-level port)
   );
  
   -- End of IBUF_inst instantiation

					</Template>
					<Template label="Single-ended Buffer w/ Disable (IBUF_IBUFDISABLE)" treetype="template">

--IBUF_IBUFDISABLE : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (IBUF_IBUFDISABLE_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs must be
--                 : connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_IBUFDISABLE: Single-ended Input Buffer with Disable
   --                   Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IBUF_IBUFDISABLE_inst : IBUF_IBUFDISABLE
   generic map (
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer output
      I =&gt; I,     -- Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, high=disable
   );
  
   -- End of IBUF_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Single-ended Buffer w/ Termination Disable (IBUF_INTERMDISABLE)" treetype="template">

--IBUF_INTERMDISABLE : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (IBUF_INTERMDISABLE_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs must be
--                 : connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_INTERMDISABLE: Single-ended Input Buffer with Termination Input Disable
   --                     May only be placed in High Range (HR) Banks
   --                     Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IBUF_INTERMDISABLE_inst : IBUF_INTERMDISABLE
   generic map (
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer output
      I =&gt; I,     -- Buffer input (connect directly to top-level port)
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input Termination Disable
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, high=disable
   );
  
   -- End of IBUF_INTERMDISABLE_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="I/O Delay Components" treetype="folder">
					<Template label="Delay Calibration (IDELAYCTRL)" treetype="template">
-- IDELAYCTRL  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  Put the following attribute before the 'begin' statement
--  Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

attribute IODELAY_GROUP : STRING;
attribute IODELAY_GROUP of &lt;label_name&gt;: label is "&lt;iodelay_group_name&gt;";

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYCTRL: IDELAYE2/ODELAYE2 Tap Delay Value Control
   --             Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL_inst : IDELAYCTRL
   port map (
      RDY =&gt; RDY,       -- 1-bit output: Ready output
      REFCLK =&gt; REFCLK, -- 1-bit input: Reference clock input
      RST =&gt; RST        -- 1-bit input: Active high reset input
   );

   -- End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE2)" treetype="template">
--  IDELAYE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  Put the following attribute before the 'begin' statement
--  Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

attribute IODELAY_GROUP : STRING;
attribute IODELAY_GROUP of &lt;label_name&gt;: label is "&lt;iodelay_group_name&gt;";

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYE2: Input Fixed or Variable Delay Element
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYE2_inst : IDELAYE2
   generic map (
      CINVCTRL_SEL =&gt; "FALSE",          -- Enable dynamic clock inversion (FALSE, TRUE)
      DELAY_SRC =&gt; "IDATAIN",           -- Delay input (IDATAIN, DATAIN)
      HIGH_PERFORMANCE_MODE =&gt; "FALSE", -- Reduced jitter ("TRUE"), Reduced power ("FALSE")
      IDELAY_TYPE =&gt; "FIXED",           -- FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      IDELAY_VALUE =&gt; 0,                -- Input delay tap setting (0-31)
      PIPE_SEL =&gt; "FALSE",              -- Select pipelined mode, FALSE, TRUE
      REFCLK_FREQUENCY =&gt; 200.0,        -- IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      SIGNAL_PATTERN =&gt; "DATA"          -- DATA, CLOCK input signal
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 5-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data output
      C =&gt; C,                     -- 1-bit input: Clock input
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CINVCTRL =&gt; CINVCTRL,       -- 1-bit input: Dynamic clock inversion input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 5-bit input: Counter value input
      DATAIN =&gt; DATAIN,           -- 1-bit input: Internal delay data input
      IDATAIN =&gt; IDATAIN,         -- 1-bit input: Data input from the I/O
      INC =&gt; INC,                 -- 1-bit input: Increment / Decrement tap delay input
      LD =&gt; LD,                   -- 1-bit input: Load IDELAY_VALUE input
      LDPIPEEN =&gt; LDPIPEEN,       -- 1-bit input: Enable PIPELINE register to load data input
      REGRST =&gt; REGRST            -- 1-bit input: Active-high reset tap-delay input
   );

   -- End of IDELAYE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="I/O SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer with Bitslip (ISERDESE2)" treetype="template">
--  ISERDESE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ISERDESE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ISERDESE2: Input SERial/DESerializer with Bitslip
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   ISERDESE2_inst : ISERDESE2
   generic map (
      DATA_RATE =&gt; "DDR",           -- DDR, SDR
      DATA_WIDTH =&gt; 4,              -- Parallel data width (2-8,10,14)
      DYN_CLKDIV_INV_EN =&gt; "FALSE", -- Enable DYNCLKDIVINVSEL inversion (FALSE, TRUE)
      DYN_CLK_INV_EN =&gt; "FALSE",    -- Enable DYNCLKINVSEL inversion (FALSE, TRUE)
      -- INIT_Q1 - INIT_Q4: Initial value on the Q outputs (0/1)
      INIT_Q1 =&gt; '0',
      INIT_Q2 =&gt; '0',
      INIT_Q3 =&gt; '0',
      INIT_Q4 =&gt; '0',
      INTERFACE_TYPE =&gt; "MEMORY",   -- MEMORY, MEMORY_DDR3, MEMORY_QDR, NETWORKING, OVERSAMPLE
      IOBDELAY =&gt; "NONE",           -- NONE, BOTH, IBUF, IFD
      NUM_CE =&gt; 2,                  -- Number of clock enables (1,2)
      OFB_USED =&gt; "FALSE",          -- Select OFB path (FALSE, TRUE)
      SERDES_MODE =&gt; "MASTER",      -- MASTER, SLAVE
      -- SRVAL_Q1 - SRVAL_Q4: Q output values when SR is used (0/1)
      SRVAL_Q1 =&gt; '0',
      SRVAL_Q2 =&gt; '0',
      SRVAL_Q3 =&gt; '0',
      SRVAL_Q4 =&gt; '0' 
   )
   port map (
      O =&gt; O,                       -- 1-bit output: Combinatorial output
      -- Q1 - Q8: 1-bit (each) output: Registered data outputs
      Q1 =&gt; Q1,
      Q2 =&gt; Q2,
      Q3 =&gt; Q3,
      Q4 =&gt; Q4,
      Q5 =&gt; Q5,
      Q6 =&gt; Q6,
      Q7 =&gt; Q7,
      Q8 =&gt; Q8,
      -- SHIFTOUT1, SHIFTOUT2: 1-bit (each) output: Data width expansion output ports
      SHIFTOUT1 =&gt; SHIFTOUT1,
      SHIFTOUT2 =&gt; SHIFTOUT2,
      BITSLIP =&gt; BITSLIP,           -- 1-bit input: The BITSLIP pin performs a Bitslip operation synchronous to
                                    -- CLKDIV when asserted (active High). Subsequently, the data seen on the
                                    -- Q1 to Q8 output ports will shift, as in a barrel-shifter operation, one
                                    -- position every time Bitslip is invoked (DDR operation is different from
                                    -- SDR).

      -- CE1, CE2: 1-bit (each) input: Data register clock enable inputs
      CE1 =&gt; CE1,
      CE2 =&gt; CE2,
      CLKDIVP =&gt; CLKDIVP,           -- 1-bit input: TBD
      -- Clocks: 1-bit (each) input: ISERDESE2 clock input ports
      CLK =&gt; CLK,                   -- 1-bit input: High-speed clock
      CLKB =&gt; CLKB,                 -- 1-bit input: High-speed secondary clock
      CLKDIV =&gt; CLKDIV,             -- 1-bit input: Divided clock
      OCLK =&gt; OCLK,                 -- 1-bit input: High speed output clock used when INTERFACE_TYPE="MEMORY" 
      -- Dynamic Clock Inversions: 1-bit (each) input: Dynamic clock inversion pins to switch clock polarity
      DYNCLKDIVSEL =&gt; DYNCLKDIVSEL, -- 1-bit input: Dynamic CLKDIV inversion
      DYNCLKSEL =&gt; DYNCLKSEL,       -- 1-bit input: Dynamic CLK/CLKB inversion
      -- Input Data: 1-bit (each) input: ISERDESE2 data input ports
      D =&gt; D,                       -- 1-bit input: Data input
      DDLY =&gt; DDLY,                 -- 1-bit input: Serial data from IDELAYE2
      OFB =&gt; OFB,                   -- 1-bit input: Data feedback from OSERDESE2
      OCLKB =&gt; OCLKB,               -- 1-bit input: High speed negative edge output clock
      RST =&gt; RST,                   -- 1-bit input: Active high asynchronous reset
      -- SHIFTIN1, SHIFTIN2: 1-bit (each) input: Data width expansion input ports
      SHIFTIN1 =&gt; SHIFTIN1,
      SHIFTIN2 =&gt; SHIFTIN2 
   );

   -- End of ISERDESE2_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer with bitslip (OSERDESE2)" treetype="template">
--  OSERDESE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OSERDESE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OSERDESE2: Output SERial/DESerializer with bitslip
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   OSERDESE2_inst : OSERDESE2
   generic map (
      DATA_RATE_OQ =&gt; "DDR",   -- DDR, SDR
      DATA_RATE_TQ =&gt; "DDR",   -- DDR, BUF, SDR
      DATA_WIDTH =&gt; 4,         -- Parallel data width (2-8,10,14)
      INIT_OQ =&gt; '0',          -- Initial value of OQ output (1'b0,1'b1)
      INIT_TQ =&gt; '0',          -- Initial value of TQ output (1'b0,1'b1)
      SERDES_MODE =&gt; "MASTER", -- MASTER, SLAVE
      SRVAL_OQ =&gt; '0',         -- OQ output value when SR is used (1'b0,1'b1)
      SRVAL_TQ =&gt; '0',         -- TQ output value when SR is used (1'b0,1'b1)
      TBYTE_CTL =&gt; "FALSE",    -- Enable tristate byte operation (FALSE, TRUE)
      TBYTE_SRC =&gt; "FALSE",    -- Tristate byte source (FALSE, TRUE)
      TRISTATE_WIDTH =&gt; 4      -- 3-state converter width (1,4)
   )
   port map (
      OFB =&gt; OFB,             -- 1-bit output: Feedback path for data
      OQ =&gt; OQ,               -- 1-bit output: Data path output
      -- SHIFTOUT1 / SHIFTOUT2: 1-bit (each) output: Data output expansion (1-bit each)
      SHIFTOUT1 =&gt; SHIFTOUT1,
      SHIFTOUT2 =&gt; SHIFTOUT2,
      TBYTEOUT =&gt; TBYTEOUT,   -- 1-bit output: Byte group tristate
      TFB =&gt; TFB,             -- 1-bit output: 3-state control
      TQ =&gt; TQ,               -- 1-bit output: 3-state control
      CLK =&gt; CLK,             -- 1-bit input: High speed clock
      CLKDIV =&gt; CLKDIV,       -- 1-bit input: Divided clock
      -- D1 - D8: 1-bit (each) input: Parallel data inputs (1-bit each)
      D1 =&gt; D1,
      D2 =&gt; D2,
      D3 =&gt; D3,
      D4 =&gt; D4,
      D5 =&gt; D5,
      D6 =&gt; D6,
      D7 =&gt; D7,
      D8 =&gt; D8,
      OCE =&gt; OCE,             -- 1-bit input: Output data clock enable
      RST =&gt; RST,             -- 1-bit input: Reset
      -- SHIFTIN1 / SHIFTIN2: 1-bit (each) input: Data input expansion (1-bit each)
      SHIFTIN1 =&gt; SHIFTIN1,
      SHIFTIN2 =&gt; SHIFTIN2,
      -- T1 - T4: 1-bit (each) input: Parallel 3-state inputs
      T1 =&gt; T1,
      T2 =&gt; T2,
      T3 =&gt; T3,
      T4 =&gt; T4,
      TBYTEIN =&gt; TBYTEIN,     -- 1-bit input: Byte group tristate
      TCE =&gt; TCE              -- 1-bit input: 3-state clock enable
   );

   -- End of OSERDESE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Output" treetype="folder">
					<Template label="Differential Buffer (OBUFDS)" treetype="template">

--   OBUFDS     : In order to incorporate this function into the design,
--    VHDL      : the following instance declaration needs to be placed
--  instance    : in the architecture body of the design code.  The
-- declaration  : instance name (OBUFDS_inst) and/or the port declarations
--    code      : after the "=&gt;" assignment maybe changed to properly
--              : connect this function to the design. All inputs must be
--              : connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--   Xilinx     : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS: Differential Output Buffer
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUFDS_inst : OBUFDS
   generic map (
      IOSTANDARD =&gt; "DEFAULT", -- Specify the output I/O standard
      SLEW =&gt; "SLOW")          -- Specify the output slew rate
   port map (
      O =&gt; O,     -- Diff_p output (connect directly to top-level port)
      OB =&gt; OB,   -- Diff_n output (connect directly to top-level port)
      I =&gt; I      -- Buffer input 
   );
  
   -- End of OBUFDS_inst instantiation

					</Template>
					<Template label="Differential 3-state Buffer (OBUFTDS)" treetype="template">

--   OBUFTDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (OBUFTDS_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFTDS: Differential 3-state Output Buffer
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUFTDS_inst : OBUFTDS
   generic map (
      IOSTANDARD =&gt; "DEFAULT")
   port map (
      O =&gt; O,     -- Diff_p output (connect directly to top-level port)
      OB =&gt; OB,   -- Diff_n output (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input
   );
  
   -- End of OBUFTDS_inst instantiation

					</Template>
					<Template label="Single-ended Buffer (OBUF)" treetype="template">

--    OBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (OBUF_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUF: Single-ended Output Buffer
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUF_inst : OBUF
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output (connect directly to top-level port)
      I =&gt; I      -- Buffer input 
   );
  
   -- End of OBUF_inst instantiation

					</Template>
					<Template label="Single-ended 3-state Buffer (OBUFT)" treetype="template">

--    OBUFT    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (OBUFT_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFT: Single-ended 3-state Output Buffer
   --        Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUFT_inst : OBUFT
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input 
   );
  
   -- End of OBUFT_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Weak drivers" treetype="folder">
					<Template label="KEEPER" treetype="template">

--   KEEPER    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (KEEPER_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design.  

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- KEEPER: I/O Buffer Weak Keeper
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   KEEPER_inst : KEEPER
   port map (
      O =&gt; O     -- Keeper output (connect directly to top-level port)
   );
  
   -- End of KEEPER_inst instantiation


					</Template>
					<Template label="PULLDOWN" treetype="template">

--  PULLDOWN   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (PULLDOWN_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design.  

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLDOWN: I/O Buffer Weak Pull-down
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   PULLDOWN_inst : PULLDOWN
   port map (
      O =&gt; O     -- Pulldown output (connect directly to top-level port)
   );
  
   -- End of PULLDOWN_inst instantiation

					</Template>
					<Template label="PULLUP" treetype="template">

--   PULLUP    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (PULLUP_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLUP: I/O Buffer Weak Pull-up
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   PULLUP_inst : PULLUP
   port map (
      O =&gt; O     -- Pullup output (connect directly to top-level port)
   );
  
   -- End of PULLUP_inst instantiation

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="RAM/ROM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E1)" treetype="template">
--  RAMB18E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB18E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB18E1: 18K-bit Configurable Synchronous Block RAM
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAMB18E1_inst : RAMB18E1
   generic map (
      -- Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      RDADDR_COLLISION_HWCONFIG =&gt; "DELAYED_WRITE",
      -- Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0 or 1)
      DOA_REG =&gt; 0,
      DOB_REG =&gt; 0,
      -- INITP_00 to INITP_07: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_3F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"00000",
      INIT_B =&gt; X"00000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- RAM Mode: "SDP" or "TDP" 
      RAM_MODE =&gt; "TDP",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-72
      READ_WIDTH_B =&gt; 0,                                                               -- 0-18
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-18
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-72
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"00000",
      SRVAL_B =&gt; X"00000",
      -- Simulation Device: Must be set to "7SERIES" for simulation behavior
      SIM_DEVICE =&gt; "7SERIES",
      -- WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      WRITE_MODE_A =&gt; "WRITE_FIRST",
      WRITE_MODE_B =&gt; "WRITE_FIRST" 
   )
   port map (
      -- Port A Data: 16-bit (each) output: Port A data
      DOADO =&gt; DOADO,                 -- 16-bit output: A port data/LSB data
      DOPADOP =&gt; DOPADOP,             -- 2-bit output: A port parity/LSB parity
      -- Port B Data: 16-bit (each) output: Port B data
      DOBDO =&gt; DOBDO,                 -- 16-bit output: B port data/MSB data
      DOPBDOP =&gt; DOPBDOP,             -- 2-bit output: B port parity/MSB parity
      -- Port A Address/Control Signals: 14-bit (each) input: Port A address and control signals (read port
      -- when RAM_MODE="SDP")
      ADDRARDADDR =&gt; ADDRARDADDR,     -- 14-bit input: A port address/Read address
      CLKARDCLK =&gt; CLKARDCLK,         -- 1-bit input: A port clock/Read clock
      ENARDEN =&gt; ENARDEN,             -- 1-bit input: A port enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,     -- 1-bit input: A port register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM, -- 1-bit input: A port set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG, -- 1-bit input: A port register set/reset
      WEA =&gt; WEA,                     -- 2-bit input: A port write enable
      -- Port A Data: 16-bit (each) input: Port A data
      DIADI =&gt; DIADI,                 -- 16-bit input: A port data/LSB data
      DIPADIP =&gt; DIPADIP,             -- 2-bit input: A port parity/LSB parity
      -- Port B Address/Control Signals: 14-bit (each) input: Port B address and control signals (write port
      -- when RAM_MODE="SDP")
      ADDRBWRADDR =&gt; ADDRBWRADDR,     -- 14-bit input: B port address/Write address
      CLKBWRCLK =&gt; CLKBWRCLK,         -- 1-bit input: B port clock/Write clock
      ENBWREN =&gt; ENBWREN,             -- 1-bit input: B port enable/Write enable
      REGCEB =&gt; REGCEB,               -- 1-bit input: B port register enable
      RSTRAMB =&gt; RSTRAMB,             -- 1-bit input: B port set/reset
      RSTREGB =&gt; RSTREGB,             -- 1-bit input: B port register set/reset
      WEBWE =&gt; WEBWE,                 -- 4-bit input: B port write enable/Write enable
      -- Port B Data: 16-bit (each) input: Port B data
      DIBDI =&gt; DIBDI,                 -- 16-bit input: B port data/MSB data
      DIPBDIP =&gt; DIPBDIP              -- 2-bit input: B port parity/MSB parity
   );

   -- End of RAMB18E1_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E1)" treetype="template">
--  RAMB36E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB36E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB36E1: 36K-bit Configurable Synchronous Block RAM
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAMB36E1_inst : RAMB36E1
   generic map (
      -- Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      RDADDR_COLLISION_HWCONFIG =&gt; "DELAYED_WRITE",
      -- Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0 or 1)
      DOA_REG =&gt; 0,
      DOB_REG =&gt; 0,
      EN_ECC_READ =&gt; FALSE,                                                            -- Enable ECC decoder,
                                                                                       -- FALSE, TRUE
      EN_ECC_WRITE =&gt; FALSE,                                                           -- Enable ECC encoder,
                                                                                       -- FALSE, TRUE
      -- INITP_00 to INITP_0F: Initial contents of the parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_7F: Initial contents of the data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"000000000",
      INIT_B =&gt; X"000000000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- RAM Mode: "SDP" or "TDP" 
      RAM_MODE =&gt; "TDP",
      -- RAM_EXTENSION_A, RAM_EXTENSION_B: Selects cascade mode ("UPPER", "LOWER", or "NONE")
      RAM_EXTENSION_A =&gt; "NONE",
      RAM_EXTENSION_B =&gt; "NONE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-72
      READ_WIDTH_B =&gt; 0,                                                               -- 0-36
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-36
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-72
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"000000000",
      SRVAL_B =&gt; X"000000000",
      -- Simulation Device: Must be set to "7SERIES" for simulation behavior
      SIM_DEVICE =&gt; "7SERIES",
      -- WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      WRITE_MODE_A =&gt; "WRITE_FIRST",
      WRITE_MODE_B =&gt; "WRITE_FIRST" 
   )
   port map (
      -- Cascade Signals: 1-bit (each) output: BRAM cascade ports (to create 64kx1)
      CASCADEOUTA =&gt; CASCADEOUTA,     -- 1-bit output: A port cascade
      CASCADEOUTB =&gt; CASCADEOUTB,     -- 1-bit output: B port cascade
      -- ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      RDADDRECC =&gt; RDADDRECC,         -- 9-bit output: ECC read address
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Port A Data: 32-bit (each) output: Port A data
      DOADO =&gt; DOADO,                 -- 32-bit output: A port data/LSB data
      DOPADOP =&gt; DOPADOP,             -- 4-bit output: A port parity/LSB parity
      -- Port B Data: 32-bit (each) output: Port B data
      DOBDO =&gt; DOBDO,                 -- 32-bit output: B port data/MSB data
      DOPBDOP =&gt; DOPBDOP,             -- 4-bit output: B port parity/MSB parity
      -- Cascade Signals: 1-bit (each) input: BRAM cascade ports (to create 64kx1)
      CASCADEINA =&gt; CASCADEINA,       -- 1-bit input: A port cascade
      CASCADEINB =&gt; CASCADEINB,       -- 1-bit input: B port cascade
      -- ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR, -- 1-bit input: Inject a single bit error
      -- Port A Address/Control Signals: 16-bit (each) input: Port A address and control signals (read port
      -- when RAM_MODE="SDP")
      ADDRARDADDR =&gt; ADDRARDADDR,     -- 16-bit input: A port address/Read address
      CLKARDCLK =&gt; CLKARDCLK,         -- 1-bit input: A port clock/Read clock
      ENARDEN =&gt; ENARDEN,             -- 1-bit input: A port enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,     -- 1-bit input: A port register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM, -- 1-bit input: A port set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG, -- 1-bit input: A port register set/reset
      WEA =&gt; WEA,                     -- 4-bit input: A port write enable
      -- Port A Data: 32-bit (each) input: Port A data
      DIADI =&gt; DIADI,                 -- 32-bit input: A port data/LSB data
      DIPADIP =&gt; DIPADIP,             -- 4-bit input: A port parity/LSB parity
      -- Port B Address/Control Signals: 16-bit (each) input: Port B address and control signals (write port
      -- when RAM_MODE="SDP")
      ADDRBWRADDR =&gt; ADDRBWRADDR,     -- 16-bit input: B port address/Write address
      CLKBWRCLK =&gt; CLKBWRCLK,         -- 1-bit input: B port clock/Write clock
      ENBWREN =&gt; ENBWREN,             -- 1-bit input: B port enable/Write enable
      REGCEB =&gt; REGCEB,               -- 1-bit input: B port register enable
      RSTRAMB =&gt; RSTRAMB,             -- 1-bit input: B port set/reset
      RSTREGB =&gt; RSTREGB,             -- 1-bit input: B port register set/reset
      WEBWE =&gt; WEBWE,                 -- 8-bit input: B port write enable/Write enable
      -- Port B Data: 32-bit (each) input: Port B data
      DIBDI =&gt; DIBDI,                 -- 32-bit input: B port data/MSB data
      DIPBDIP =&gt; DIPBDIP              -- 4-bit input: B port parity/MSB parity
   );

   -- End of RAMB36E1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Distributed RAM" treetype="folder">
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 x 1 negedge write (RAM32X1D_1)" treetype="template">

-- RAM32X1D_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_1_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D_1: 32 x 1 negative edge write, asynchronous read 
   --             dual-port distributed RAM (Mapped to SliceM LUT6)
   --             Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1_inst : RAM32X1D_1
   generic map (
      INIT =&gt; X"00000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_1_inst instantiation

						</Template>
						<Template label="32 x 1 posedge write (RAM32X1D)" treetype="template">

--   RAM32X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D: 32 x 1 positive edge write, asynchronous read 
   --              dual-port distributed RAM (Mapped to SliceM LUT6)
   --              Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_inst : RAM32X1D
   generic map (
      INIT =&gt; X"00000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_inst instantiation

						</Template>
						<Template label="64 x 1 negedge write (RAM64X1D_1)" treetype="template">

-- RAM64X1D_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1D: 64 x 1 negative edge write, asynchronous read 
   --           dual-port distributed RAM (Mapped to SliceM LUT6)
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1D_1_inst : RAM64X1D_1
   generic map (
      INIT =&gt; X"0000000000000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      A5 =&gt; A5,       -- R/W address[5] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      DPRA5 =&gt; DPRA5, -- Read-only address[5] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM64X1D_1_inst instantiation

						</Template>
						<Template label="64 x 1 posedge write (RAM64X1D)" treetype="template">

--   RAM64X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1D: 64 x 1 positive edge write, asynchronous read 
   --           dual-port distributed RAM (Mapped to SliceM LUT6)
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1D_inst : RAM64X1D
   generic map (
      INIT =&gt; X"0000000000000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      A5 =&gt; A5,       -- R/W address[5] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      DPRA5 =&gt; DPRA5, -- Read-only address[5] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM64X1D_inst instantiation

						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">

--  RAM128X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read 
   --            dual-port distributed LUT RAM (Mapped to two SliceM LUT6s)
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1D_inst : RAM128X1D
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      DPO =&gt; DPO,     -- Read/Write port 1-bit ouput
      SPO =&gt; SPO,     -- Read port 1-bit output
      A =&gt; A,         -- Read/Write port 7-bit address input
      D =&gt; D,         -- RAM data input
      DPRA =&gt; DPRA,   -- Read port 7-bit address input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1D_inst instantiation

						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">

--   RAM32M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M: 32-deep by 8-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s)
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32M_inst : RAM32M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000")   -- Initial contents of D port
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read/Write port D 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 5-bit address input
      DIA =&gt; DIA, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M_inst instantiation

						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">

--   RAM64M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64M: 64-deep by 4-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s) 
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64M_inst : RAM64M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000")   -- Initial contents of D port
   port map (
      DOA =&gt; DOA, -- Read port A 1-bit output
      DOB =&gt; DOB, -- Read port B 1-bit output
      DOC =&gt; DOC, -- Read port C 1-bit output
      DOD =&gt; DOD, -- Read/Write port D 1-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 6-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 6-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 6-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 6-bit address input
      DIA =&gt; DIA, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM64M_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<SubFolder label="32 Deep (5-bit address)" treetype="folder">
							<Template label="32 x 1 negedge write (RAM32X1S_1)" treetype="template">

-- RAM32X1S_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1S_1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1S_1: 32 x 1 negedge write distributed (LUT) RAM (Mapped to SliceM LUT6)
   --             Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1S_1_inst : RAM32X1S_1
   generic map (
      INIT =&gt; X"00000000")
   port map (
      O =&gt; O,       -- RAM output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D =&gt; D,       -- RAM data input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X1S_1_inst instantiation
							</Template>
							<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">

--  RAM32X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM (Mapped to SliceM LUT6)
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1S_inst : RAM32X1S
   generic map (
      INIT =&gt; X"00000000")
   port map (
      O =&gt; O,       -- RAM output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D =&gt; D,       -- RAM data input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X1S_inst instantiation
							</Template>
							<Template label="32 x 2 posedge write (RAM32X2S)" treetype="template">

--  RAM32X2S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM16X2S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X2S: 32 x 2 posedge write distributed (LUT) RAM (Mapped to SliceM LUT6)
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X2S_inst : RAM32X2S
   generic map (
      INIT_00 =&gt; X"00000000", --  INIT for bit 0 of RAM
      INIT_01 =&gt; X"00000000") --  INIT for bit 1 of RAM
   port map (
      O0 =&gt; O0,     -- RAM data[0] output
      O1 =&gt; O1,     -- RAM data[1] output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D0 =&gt; D0,     -- RAM data[0] input
      D1 =&gt; D1,     -- RAM data[1] input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X2S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="64 Deep (6-bit address)" treetype="folder">
							<Template label="64 X 1 negedge write (RAM64X1S_1)" treetype="template">

--  RAM64X1S_1 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1S_1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1S_1: 64 x 1 negative edge write, asynchronous read single-port distributed RAM (Mapped to SliceM LUT6)
   --             Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1S_1_inst : RAM64X1S_1
   generic map (
      INIT =&gt; X"0000000000000000")
   port map (
      O =&gt; O,        -- 1-bit data output
      A0 =&gt; A0,      -- Address[0] input bit
      A1 =&gt; A1,      -- Address[1] input bit
      A2 =&gt; A2,      -- Address[2] input bit
      A3 =&gt; A3,      -- Address[3] input bit
      A4 =&gt; A4,      -- Address[4] input bit
      A5 =&gt; A5,      -- Address[5] input bit
      D =&gt; D,        -- 1-bit data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64X1S_1_inst instantiation

							</Template>
							<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">

--  RAM64X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port distributed RAM (Mapped to SliceM LUT6)
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1S_inst : RAM64X1S
   generic map (
      INIT =&gt; X"0000000000000000")
   port map (
      O =&gt; O,        -- 1-bit data output
      A0 =&gt; A0,      -- Address[0] input bit
      A1 =&gt; A1,      -- Address[1] input bit
      A2 =&gt; A2,      -- Address[2] input bit
      A3 =&gt; A3,      -- Address[3] input bit
      A4 =&gt; A4,      -- Address[4] input bit
      A5 =&gt; A5,      -- Address[5] input bit
      D =&gt; D,        -- 1-bit data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="128 Deep (7-bit address)" treetype="folder">
							<Template label="128 x 1 negedge write (RAM128X1S_1)" treetype="template">

--RAM128X1S_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S_1: 128-deep x 1 negative edge write, asynchronous read 
   --              single-port distributed RAM (Mapped to SliceM LUT6)
   --              Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation

							</Template>
							<Template label="128 x 1 posedge write (RAM128X1S)" treetype="template">

--  RAM128X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S: 128-deep x 1 positive edge write, asynchronous read 
   --            single-port distributed RAM (Mapped to SliceM LUT6)
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation

							</Template>
						</SubFolder>
						<SubFolder label="256 Deep (8-bit address)" treetype="folder">
							<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">

--  RAM256X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM256X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read 
   --            single-port distributed LUT RAM (Mapped to four SliceM LUT6s)
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM256X1S_inst : RAM256X1S
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      O =&gt; O,  -- Read/Write port 1-bit ouput
      A =&gt; A,  -- Read/Write port 8-bit address input
      D =&gt; D,  -- RAM data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE -- Write enable input
   );

   -- End of RAM256X1S_inst instantiation

							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Distributed ROM" treetype="folder">
					<Template label="32 X 1 (ROM32X1)" treetype="template">

--   ROM32X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM32X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM32X1: 32 x 1 Asynchronous Distributed (LUT) ROM
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM32X1_inst : ROM32X1
   generic map (
      INIT =&gt; X"00000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4  -- ROM address[4]
   );
   -- End of ROM32X1_inst instantiation
					</Template>
					<Template label="64 X 1 (ROM64X1)" treetype="template">

--   ROM64X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM64X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM64X1: 64 x 1 Asynchronous Distributed (LUT) ROM
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM64X1_inst : ROM64X1
   generic map (
      INIT =&gt; X"0000000000000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4, -- ROM address[4]
      A5 =&gt; A5  -- ROM address[5]
   );

   -- End of ROM64X1_inst instantiation
					</Template>
					<Template label="128 X 1 (ROM128X1)" treetype="template">

--  ROM128X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM128X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM128X1: 128 x 1 Asynchronous Distributed (LUT) ROM
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM128X1_inst : ROM128X1
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4, -- ROM address[4]
      A5 =&gt; A5, -- ROM address[5]
      A6 =&gt; A6  -- ROM address[6]
   );

   -- End of ROM128X1_inst instantiation
					</Template>
					<Template label="256 X 1 (ROM256X1)" treetype="template">

--   ROM256X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM256X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM256X1: 256 x 1 Asynchronous Distributed (LUT) ROM
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM256X1_inst : ROM256X1
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4, -- ROM address[4]
      A5 =&gt; A5, -- ROM address[5]
      A6 =&gt; A6,  -- ROM address[6]
      A7 =&gt; A7  -- ROM address[7]
   );

   -- End of ROM256X1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E1)" treetype="template">
--  FIFO18E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO18E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO18E1: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   FIFO18E1_inst : FIFO18E1
   generic map (
      ALMOST_EMPTY_OFFSET =&gt; X"0080",   -- Sets the almost empty threshold
      ALMOST_FULL_OFFSET =&gt; X"0080",    -- Sets almost full threshold
      DATA_WIDTH =&gt; 4,                  -- Sets data width to 4-36
      DO_REG =&gt; 1,                      -- Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      EN_SYN =&gt; FALSE,                  -- Specifies FIFO as dual-clock (FALSE) or Synchronous (TRUE)
      FIFO_MODE =&gt; "FIFO18",            -- Sets mode to FIFO18 or FIFO18_36
      FIRST_WORD_FALL_THROUGH =&gt; FALSE, -- Sets the FIFO FWFT to FALSE, TRUE
      INIT =&gt; X"000000000",             -- Initial values on output port
      SIM_DEVICE =&gt; "7SERIES",          -- Must be set to "7SERIES" for simulation behavior
      SRVAL =&gt; X"000000000"             -- Set/Reset value for output port
   )
   port map (
      -- Read Data: 32-bit (each) output: Read output data
      DO =&gt; DO,                   -- 32-bit output: Data output
      DOP =&gt; DOP,                 -- 4-bit output: Parity data output
      -- Status: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY, -- 1-bit output: Almost empty flag
      ALMOSTFULL =&gt; ALMOSTFULL,   -- 1-bit output: Almost full flag
      EMPTY =&gt; EMPTY,             -- 1-bit output: Empty flag
      FULL =&gt; FULL,               -- 1-bit output: Full flag
      RDCOUNT =&gt; RDCOUNT,         -- 12-bit output: Read count
      RDERR =&gt; RDERR,             -- 1-bit output: Read error
      WRCOUNT =&gt; WRCOUNT,         -- 12-bit output: Write count
      WRERR =&gt; WRERR,             -- 1-bit output: Write error
      -- Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,             -- 1-bit input: Read clock
      RDEN =&gt; RDEN,               -- 1-bit input: Read enable
      REGCE =&gt; REGCE,             -- 1-bit input: Clock enable
      RST =&gt; RST,                 -- 1-bit input: Asynchronous Reset
      RSTREG =&gt; RSTREG,           -- 1-bit input: Output register set/reset
      -- Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      WRCLK =&gt; WRCLK,             -- 1-bit input: Write clock
      WREN =&gt; WREN,               -- 1-bit input: Write enable
      -- Write Data: 32-bit (each) input: Write input data
      DI =&gt; DI,                   -- 32-bit input: Data input
      DIP =&gt; DIP                  -- 4-bit input: Parity input
   );

   -- End of FIFO18E1_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E1)" treetype="template">
--  FIFO36E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO36E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO36E1: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   FIFO36E1_inst : FIFO36E1
   generic map (
      ALMOST_EMPTY_OFFSET =&gt; X"0080",   -- Sets the almost empty threshold
      ALMOST_FULL_OFFSET =&gt; X"0080",    -- Sets almost full threshold
      DATA_WIDTH =&gt; 4,                  -- Sets data width to 4-72
      DO_REG =&gt; 1,                      -- Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      EN_ECC_READ =&gt; FALSE,             -- Enable ECC decoder, FALSE, TRUE
      EN_ECC_WRITE =&gt; FALSE,            -- Enable ECC encoder, FALSE, TRUE
      EN_SYN =&gt; FALSE,                  -- Specifies FIFO as Asynchronous (FALSE) or Synchronous (TRUE)
      FIFO_MODE =&gt; "FIFO36",            -- Sets mode to "FIFO36" or "FIFO36_72" 
      FIRST_WORD_FALL_THROUGH =&gt; FALSE, -- Sets the FIFO FWFT to FALSE, TRUE
      INIT =&gt; X"000000000000000000",    -- Initial values on output port
      SIM_DEVICE =&gt; "7SERIES",          -- Must be set to "7SERIES" for simulation behavior
      SRVAL =&gt; X"000000000000000000"    -- Set/Reset value for output port
   )
   port map (
      -- ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Read Data: 64-bit (each) output: Read output data
      DO =&gt; DO,                       -- 64-bit output: Data output
      DOP =&gt; DOP,                     -- 8-bit output: Parity data output
      -- Status: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY,     -- 1-bit output: Almost empty flag
      ALMOSTFULL =&gt; ALMOSTFULL,       -- 1-bit output: Almost full flag
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty flag
      FULL =&gt; FULL,                   -- 1-bit output: Full flag
      RDCOUNT =&gt; RDCOUNT,             -- 13-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      WRCOUNT =&gt; WRCOUNT,             -- 13-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write error
      -- ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error input
      INJECTSBITERR =&gt; INJECTSBITERR,
      -- Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Clock enable
      RST =&gt; RST,                     -- 1-bit input: Reset
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register set/reset
      -- Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Rising edge write clock.
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data: 64-bit (each) input: Write input data
      DI =&gt; DI,                       -- 64-bit input: Data input
      DIP =&gt; DIP                      -- 8-bit input: Parity input
   );

   -- End of FIFO36E1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Registers &amp; Latches" treetype="folder">
				<SubFolder label="Double Data Rate" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
--    IDDR_2CLK  : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The
--   declaration : instance name (IDDR_2CLK_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design.  All inputs must be 
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   --            Set, Reset and Clock Enable.
   --            Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK_inst : IDDR_2CLK 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit primary clock input
      CB =&gt; CB, -- 1-bit secondary clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_2CLK_inst instantiation

					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
--      IDDR     : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The 
--   declaration : instance name (IDDR_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design. All inputs must be
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR: Double Data Rate Input Register with Set, Reset
   --       and Clock Enable. 
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_inst : IDDR 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_inst instantiation

					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
--      ODDR       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (ODDR_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs  
--                 : and outputs must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDR: Output Double Data Rate Output Register with Set, Reset
   --       and Clock Enable. 
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   ODDR_inst : ODDR
   generic map(
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE" or "SAME_EDGE" 
      INIT =&gt; '0',   -- Initial value for Q port ('1' or '0')
      SRTYPE =&gt; "SYNC") -- Reset Type ("ASYNC" or "SYNC")
   port map (
      Q =&gt; Q,   -- 1-bit DDR output
      C =&gt; C,    -- 1-bit clock input
      CE =&gt; CE,  -- 1-bit clock enable input
      D1 =&gt; D1,  -- 1-bit data input (positive edge)
      D2 =&gt; D2,  -- 1-bit data input (negative edge)
      R =&gt; R,    -- 1-bit reset input
      S =&gt; S     -- 1-bit set input
   );
  
   -- End of ODDR_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Single Data Rate" treetype="folder">
					<Template label="Posedge D-FF /w Async Clear, and CE (FDCE)" treetype="template">

--    FDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDCE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and
   --       Clock Enable (posedge clk).  
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDCE_inst : FDCE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      CLR =&gt; CLR,  -- Asynchronous clear input
      D =&gt; D       -- Data input
   );
  
   -- End of FDCE_inst instantiation
					</Template>
					<Template label="Posedge D-FF /w Async Preset, and CE (FDPE)" treetype="template">

--    FDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDPE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDPE: Single Data Rate D Flip-Flop with Asynchronous Preset and
   --       Clock Enable (posedge clk).  
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDPE_inst : FDPE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      PRE =&gt; PRE,  -- Asynchronous preset input
      D =&gt; D       -- Data input
   );
  
   -- End of FDPE_inst instantiation
					</Template>
					<Template label="Posedge D-FF /w Sync Reset, and CE (FDRE)" treetype="template">

--    FDRE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDRE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
   --       Clock Enable (posedge clk).  
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDRE_inst : FDRE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      R =&gt; R,      -- Synchronous reset input
      D =&gt; D       -- Data input
   );
  
   -- End of FDRE_inst instantiation

					</Template>
					<Template label="Posedge D-FF /w Sync Set, and CE (FDSE)" treetype="template">

--    FDSE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDSE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDSE: Single Data Rate D Flip-Flop with Synchronous Set and
   --       Clock Enable (posedge clk).  
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDSE_inst : FDSE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      S =&gt; S,      -- Synchronous Set input
      D =&gt; D       -- Data input
   );
  
   -- End of FDSE_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Transparent Latch" treetype="folder">
					<Template label="Latch with Async Reset and Gate Enable (LDCE)" treetype="template">

--    LDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LDCE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDCE: Transparent latch with Asynchronous Reset and
   --        Gate Enable.
   --        Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LDCE_inst : LDCE
   generic map (
      INIT =&gt; '0') -- Initial value of latch ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      CLR =&gt; CLR,  -- Asynchronous clear/reset input
      D =&gt; D,      -- Data input
      G =&gt; G,      -- Gate input
      GE =&gt; GE     -- Gate enable input
   );

   -- End of LDCE_inst instantiation

					</Template>
					<Template label="Latch with Async Set and Gate Enable (LDPE)" treetype="template">

--    LDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LDPE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDPE:  Transparent latch with Asynchronous Set and
   --        Gate Enable.
   --        Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LDPE_inst : LDPE
   generic map (
      INIT =&gt; '0') -- Initial value of latch ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      CLR =&gt; CLR,  -- Asynchronous preset/set input
      D =&gt; D,      -- Data input
      G =&gt; G,      -- Gate input
      GE =&gt; GE     -- Gate enable input
   );

   -- End of LDPE_inst instantiation

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Slice/CLB Primitives" treetype="folder">
				<Template label="Carry (CARRY4)" treetype="template">
--    CARRY4       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (CARRY4_inst) and/or the port declarations after the
--      code       : "=&gt;" assignment maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and 
--                 : outputs of this primitive must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CARRY4: Fast Carry Logic Component
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   CARRY4_inst : CARRY4
   port map (
      CO =&gt; CO,         -- 4-bit carry out
      O =&gt; O,           -- 4-bit carry chain XOR data out
      CI =&gt; CI,         -- 1-bit carry cascade input
      CYINIT =&gt; CYINIT, -- 1-bit carry initialization
      DI =&gt; DI,         -- 4-bit carry-MUX data in
      S =&gt; S            -- 4-bit carry-MUX select input
   );

   -- End of CARRY4_inst instantiation

				</Template>
				<SubFolder label="LUTs" treetype="folder">
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
-- The INIT constant for the FPGA LUT primitive is what gives the LUT its 
-- logical value. By default this value is zero thus driving the output to a  
-- zero regardless of the input values (acting as a ground) however in most 
-- cases an new INIT value must be determined in order to specify the logic 
-- function for the LUT primitive.  There are a few methods in which the LUT 
-- value can be determined and two of those methods will be discussed here.
--
-- The Truth Table Method
-- ----------------------
--
--  A common method to determine the desired INIT value for a LUT is using a 
-- truth table.  To do so, simply create a binary truth table of all possible 
-- inputs, specify the desired logic value of the output and then create the 
-- INIT string from those output values.  An example is shown below:
--
-- Example of determining an XOR INIT equation for a LUT4:
--
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | 0 |\
--     |  0  0  0  1 | 1 | \ = 0110 = 6 -----------+
--     |  0  0  1  0 | 1 | /                       |
--     |  0  0  1  1 | 0 |/                        |
--     |-------------|---|                         |
--     |  0  1  0  0 | 1 |\                        |
--     |  0  1  0  1 | 0 | \ = 1001 = 9            |
--     |  0  1  1  0 | 0 | /                       |
--     |  0  1  1  1 | 1 |/                        |                     
--     |-------------|---|               INIT = 6996
--     |  1  0  0  0 | 1 |\                     |
--     |  1  0  0  1 | 0 | \ = 0110 = 9         |
--     |  1  0  1  0 | 0 | /                    |
--     |  1  0  1  1 | 1 |/                     |
--     |-------------|---|                      |
--     |  1  1  0  0 | 0 |\                     |
--     |  1  1  0  1 | 1 | \ = 1001 = 6---------+
--     |  1  1  1  0 | 1 | /
--     |  1  1  1  1 | 0 |/
--     -------------------
--
-- Example of determining a 3-input AND gate:
--
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | 0 |\
--     |  0  0  1 | 0 | \ = 0000 = 0 -----------+
--     |  0  1  0 | 0 | /                       |
--     |  0  1  1 | 0 |/                        |
--     |----------|---|                 INIT = 80 
--     |  1  0  0 | 0 |\                       |
--     |  1  0  1 | 0 | \ = 1000 = 8-----------+
--     |  1  1  0 | 0 | / 
--     |  1  1  1 | 1 |/                      
--     ----------------
--
-- The Equation Method
-- -------------------
--
-- Another method to determine the LUT value is to define constants for each 
-- input to the LUT that correspond to their listed truth value and use those to
-- build the logic equation you are after.  This method is easier to understand 
-- once you have grasped the concept and more self-documenting that the above 
-- method however does require the code to first specify the appropriate 
-- constants.  See the example below.
--
-- Example of specifying the equation (A and B) or (C and D) for a LUT4:
--
   -- The following constants are defined to allow for
   --   equation-based INIT specification.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00"; 


   -- LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; (I3 and I2) or (I1 and I0))
   port map (
      O =&gt; O_LUT,   -- LUT general output
      I0 =&gt; A, -- LUT input
      I1 =&gt; B, -- LUT input
      I2 =&gt; C, -- LUT input
      I3 =&gt; D  -- LUT input
   );
   -- End of LUT4_inst instantiation

-- With the constants specifying all possible cases for the truth table, a 
-- VHDL equation can be written to determine the end INIT value.

						</Template>
						<SubFolder label="INIT Constants" treetype="folder">
							<Template label="LUT1" treetype="template">
   -- The following constant is defined to allow for
   --   equation-based INIT specification for a LUT1.
   constant I0 : BIT_VECTOR(1 downto 0) := "10";
   -- The following constant is defined to allow for
   --   equation-based INIT specification for a LUT1.
   constant I0 : BIT_VECTOR(1 downto 0) := "10";
							</Template>
							<Template label="LUT2" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT2.
   constant I0 : BIT_VECTOR(3 downto 0) := X"A";
   constant I1 : BIT_VECTOR(3 downto 0) := X"C";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT2.
   constant I0 : BIT_VECTOR(3 downto 0) := X"A";
   constant I1 : BIT_VECTOR(3 downto 0) := X"C";
							</Template>
							<Template label="LUT3" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT3.
   constant I0 : BIT_VECTOR(7 downto 0) := X"AA";
   constant I1 : BIT_VECTOR(7 downto 0) := X"CC";
   constant I2 : BIT_VECTOR(7 downto 0) := X"F0";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT3.
   constant I0 : BIT_VECTOR(7 downto 0) := X"AA";
   constant I1 : BIT_VECTOR(7 downto 0) := X"CC";
   constant I2 : BIT_VECTOR(7 downto 0) := X"F0";
							</Template>
							<Template label="LUT4" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT4.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT4.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";
							</Template>
							<Template label="LUT5" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT5.
   constant I0 : BIT_VECTOR(31 downto 0) := X"AAAAAAAA";
   constant I1 : BIT_VECTOR(31 downto 0) := X"CCCCCCCC";
   constant I2 : BIT_VECTOR(31 downto 0) := X"F0F0F0F0";
   constant I3 : BIT_VECTOR(31 downto 0) := X"FF00FF00";
   constant I4 : BIT_VECTOR(31 downto 0) := X"FFFF0000";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT5.
   constant I0 : BIT_VECTOR(31 downto 0) := X"AAAAAAAA";
   constant I1 : BIT_VECTOR(31 downto 0) := X"CCCCCCCC";
   constant I2 : BIT_VECTOR(31 downto 0) := X"F0F0F0F0";
   constant I3 : BIT_VECTOR(31 downto 0) := X"FF00FF00";
   constant I4 : BIT_VECTOR(31 downto 0) := X"FFFF0000";
							</Template>
							<Template label="LUT6" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT6.
   constant I0 : BIT_VECTOR(63 downto 0) := X"AAAAAAAAAAAAAAAA";
   constant I1 : BIT_VECTOR(63 downto 0) := X"CCCCCCCCCCCCCCCC";
   constant I2 : BIT_VECTOR(63 downto 0) := X"F0F0F0F0F0F0F0F0";
   constant I3 : BIT_VECTOR(63 downto 0) := X"FF00FF00FF00FF00";
   constant I4 : BIT_VECTOR(63 downto 0) := X"FFFF0000FFFF0000";
   constant I5 : BIT_VECTOR(63 downto 0) := X"FFFFFFFF00000000";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT6.
   constant I0 : BIT_VECTOR(63 downto 0) := X"AAAAAAAAAAAAAAAA";
   constant I1 : BIT_VECTOR(63 downto 0) := X"CCCCCCCCCCCCCCCC";
   constant I2 : BIT_VECTOR(63 downto 0) := X"F0F0F0F0F0F0F0F0";
   constant I3 : BIT_VECTOR(63 downto 0) := X"FF00FF00FF00FF00";
   constant I4 : BIT_VECTOR(63 downto 0) := X"FFFF0000FFFF0000";
   constant I5 : BIT_VECTOR(63 downto 0) := X"FFFFFFFF00000000";
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
--  Truth Table to determine INIT value for a LUT1
--      ________
--     | I0 | O |
--     |--------|
--     |  0 | ? |\
--     |  1 | ? |/ = 2'b??
--     ----------
--  Truth Table to determine INIT value for a LUT1
--      ________
--     | I0 | O |
--     |--------|
--     |  0 | ? |\
--     |  1 | ? |/ = 2'b??
--     ----------
							</Template>
							<Template label="LUT2" treetype="template">
--  Truth Table to determine INIT value for a LUT2
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
--     |  0  1  0 | ? | /
--     |  0  1  1 | ? |/ 
--      ---------- --- 
--  Truth Table to determine INIT value for a LUT2
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
--     |  0  1  0 | ? | /
--     |  0  1  1 | ? |/ 
--      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
--  Truth Table to determine INIT value for a LUT3
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
--     |  0  1  0 | ? | /                                |
--     |  0  1  1 | ? |/                                 |
--     |----------|---|                       INIT = 8'h?? 
--     |  1  0  0 | ? |\                                |
--     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
--     |  1  1  0 | ? | / 
--     |  1  1  1 | ? |/                      
--     ----------------
--  Truth Table to determine INIT value for a LUT3
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
--     |  0  1  0 | ? | /                                |
--     |  0  1  1 | ? |/                                 |
--     |----------|---|                       INIT = 8'h?? 
--     |  1  0  0 | ? |\                                |
--     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
--     |  1  1  0 | ? | / 
--     |  1  1  1 | ? |/                      
--     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
--  Truth Table to determine INIT value for a LUT4
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | ? |\
--     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
--     |  0  0  1  0 | ? | /                                 |
--     |  0  0  1  1 | ? |/                                  |
--     |-------------|---|                                   |
--     |  0  1  0  0 | ? |\                                  |
--     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
--     |  0  1  1  0 | ? | /                                 |
--     |  0  1  1  1 | ? |/                                  |                     
--     |-------------|---|                     INIT = 16'h????
--     |  1  0  0  0 | ? |\                               |
--     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  0 | ? | /                              |
--     |  1  0  1  1 | ? |/                               |
--     |-------------|---|                                |
--     |  1  1  0  0 | ? |\                               |
--     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  0 | ? | /
--     |  1  1  1  1 | ? |/
--     -------------------
--  Truth Table to determine INIT value for a LUT4
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | ? |\
--     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
--     |  0  0  1  0 | ? | /                                 |
--     |  0  0  1  1 | ? |/                                  |
--     |-------------|---|                                   |
--     |  0  1  0  0 | ? |\                                  |
--     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
--     |  0  1  1  0 | ? | /                                 |
--     |  0  1  1  1 | ? |/                                  |                     
--     |-------------|---|                     INIT = 16'h????
--     |  1  0  0  0 | ? |\                               |
--     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  0 | ? | /                              |
--     |  1  0  1  1 | ? |/                               |
--     |-------------|---|                                |
--     |  1  1  0  0 | ? |\                               |
--     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  0 | ? | /
--     |  1  1  1  1 | ? |/
--     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
--  Truth Table to determine INIT value for a LUT5
--      ____________________
--     | I4 I3 I2 I1 I0 | O |
--     |--------------------|
--     |  0  0  0  0  0 | ? |\
--     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  0  1  0  0 | ? |\                                      |
--     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1 | ? |/                                      |                     
--     |----------------|---|                                       |
--     |  0  1  0  0  0 | ? |\                                      |
--     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  0 | ? | /                                     |
--     |  0  1  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  1  0  0 | ? |\                                      |
--     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1 | ? |/                                      |
--     ----------------------                     INIT = 32'h????????
--     |  1  0  0  0  0 | ? |\                               |
--     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  0  1  0 | ? | /                              |
--     |  1  0  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  0  1  0  0 | ? |\                               |
--     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  1  0 | ? | /                              |
--     |  1  0  1  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  0  0  0 | ? |\                               |
--     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  1  0  1  0 | ? | /                              |
--     |  1  1  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  1  0  0 | ? |\                               |
--     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1 | ? |/
--     ----------------------
--  Truth Table to determine INIT value for a LUT5
--      ____________________
--     | I4 I3 I2 I1 I0 | O |
--     |--------------------|
--     |  0  0  0  0  0 | ? |\
--     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  0  1  0  0 | ? |\                                      |
--     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1 | ? |/                                      |                     
--     |----------------|---|                                       |
--     |  0  1  0  0  0 | ? |\                                      |
--     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  0 | ? | /                                     |
--     |  0  1  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  1  0  0 | ? |\                                      |
--     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1 | ? |/                                      |
--     ----------------------                     INIT = 32'h????????
--     |  1  0  0  0  0 | ? |\                               |
--     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  0  1  0 | ? | /                              |
--     |  1  0  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  0  1  0  0 | ? |\                               |
--     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  1  0 | ? | /                              |
--     |  1  0  1  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  0  0  0 | ? |\                               |
--     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  1  0  1  0 | ? | /                              |
--     |  1  1  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  1  0  0 | ? |\                               |
--     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1 | ? |/
--     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
--  Truth Table to determine INIT value for a LUT6
--      _______________________
--     | I5 I4 I3 I2 I1 I0 | O |
--     |-----------------------|
--     |  0  0  0  0  0  0 | ? |\
--     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  0  1  0  0 | ? |\                                      |
--     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  0  1  1  0 | ? | /                                     |
--     |  0  0  0  1  1  1 | ? |/                                      |                     
--     |-------------------|---|                                       |
--     |  0  0  1  0  0  0 | ? |\                                      |
--     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  0  1  0 | ? | /                                     |
--     |  0  0  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  1  0  0 | ? |\                                      |
--     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1  1 | ? |/                                      |
--     -------------------------                                       |
--     |  0  1  0  0  0  0 | ? |\                                      |
--     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  0  1  0 | ? | /                                     |
--     |  0  1  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  0  1  0  0 | ? |\                                      |
--     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  1  0 | ? | /                                     |
--     |  0  1  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  0  0  0 | ? |\                                      |
--     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  0  1  0 | ? | /                                     |
--     |  0  1  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  1  0  0 | ? |\                                      |
--     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1  1 | ? |/                                      |
--     ------------------------              INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     ------------------------




--  Truth Table to determine INIT value for a LUT6
--      _______________________
--     | I5 I4 I3 I2 I1 I0 | O |
--     |-----------------------|
--     |  0  0  0  0  0  0 | ? |\
--     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  0  1  0  0 | ? |\                                      |
--     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  0  1  1  0 | ? | /                                     |
--     |  0  0  0  1  1  1 | ? |/                                      |                     
--     |-------------------|---|                                       |
--     |  0  0  1  0  0  0 | ? |\                                      |
--     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  0  1  0 | ? | /                                     |
--     |  0  0  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  1  0  0 | ? |\                                      |
--     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1  1 | ? |/                                      |
--     -------------------------                                       |
--     |  0  1  0  0  0  0 | ? |\                                      |
--     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  0  1  0 | ? | /                                     |
--     |  0  1  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  0  1  0  0 | ? |\                                      |
--     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  1  0 | ? | /                                     |
--     |  0  1  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  0  0  0 | ? |\                                      |
--     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  0  1  0 | ? | /                                     |
--     |  0  1  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  1  0  0 | ? |\                                      |
--     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1  1 | ? |/                                      |
--     ------------------------              INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT1" treetype="template">

--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; "00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_inst instantiation


--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-input Look-Up Table with general output
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; "00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_inst instantiation

					</Template>
					<Template label="LUT1_D" treetype="template">

--   LUT1_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_D: 1-input Look-Up Table with general and local outputs
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_D_inst : LUT1_D
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_D_inst instantiation

--     -------------------
--
-- Example of determining a 3-input AND gate:
--
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | 0 |\
--     |  0  0  1 | 0 | \ = 0000 = 0 -----------+
--     |  0  1  0 | 0 | /                       |
--     |  0  1  1 | 0 |/                        |
--     |----------|---|                 INIT = 80 
--     |  1  0  0 | 0 |\                       |
--     |  1  0  1 | 0 | \ = 1000 = 8-----------+
--     |  1  1  0 | 0 | / 
--     |  1  1  1 | 1 |/                      
--     ----------------
--
-- The Equation Method
-- -------------------
--
-- Another method to determine the LUT value is to define constants for each 
-- input to the LUT that correspond to their listed truth value and use those to
-- build the logic equation you are after.  This method is easier to understand 
-- once you have grasped the concept and more self-documenting that the above 
-- method however does require the code to first specify the appropriate 
-- constants.  See the example below.
--
-- Example of specifying the equation (A and B) or (C and D) for a LUT4:
--
   -- The following constants are defined to allow for
   --   equation-based INIT specification.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00"; 


   -- LUT4: 4-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; (I3 and I2) or (I1 and I0))
   port map (
      O =&gt; O_LUT,   -- LUT general output
      I0 =&gt; A, -- LUT input
      I1 =&gt; B, -- LUT input
      I2 =&gt; C, -- LUT input
      I3 =&gt; D  -- LUT input
   );
   -- End of LUT4_inst instantiation

-- With the constants specifying all possible cases for the truth table, a 
-- VHDL equation can be written to determine the end INIT value.


--   LUT1_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_D: 1-input Look-Up Table with general and local outputs
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_D_inst : LUT1_D
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_D_inst instantiation

					</Template>
					<Template label="LUT1_L" treetype="template">

--   LUT1_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_L: 1-input Look-Up Table with local output
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_L_inst : LUT1_L
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_L_inst instantiation


--   LUT1_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_L: 1-input Look-Up Table with local output
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_L_inst : LUT1_L
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_L_inst instantiation

					</Template>
					<Template label="LUT2" treetype="template">

--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_inst instantiation


--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-input Look-Up Table with general output
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_inst instantiation

					</Template>
					<Template label="LUT2_D" treetype="template">

--   LUT2_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_D: 2-input Look-Up Table with general and local outputs
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_D_inst : LUT2_D
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_D_inst instantiation


--   LUT2_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_D: 2-input Look-Up Table with general and local outputs
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_D_inst : LUT2_D
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_D_inst instantiation

					</Template>
					<Template label="LUT2_L" treetype="template">

--   LUT2_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_L: 2-input Look-Up Table with local output
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_L_inst : LUT2_L
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_L_inst instantiation


--   LUT2_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_L: 2-input Look-Up Table with local output
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_L_inst : LUT2_L
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_L_inst instantiation

					</Template>
					<Template label="LUT3" treetype="template">

--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2  -- LUT input
   );

   -- End of LUT3_inst instantiation


--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-input Look-Up Table with general output (Mapped to a LUT6)
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2  -- LUT input
   );

   -- End of LUT3_inst instantiation

					</Template>
					<Template label="LUT3_D" treetype="template">

--   LUT3_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_D: 3-input Look-Up Table with general and local outputs
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_D_inst : LUT3_D
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,  -- LUT local output
      O =&gt; O,    -- LUT general output
      I0 =&gt; I0,  -- LUT input
      I1 =&gt; I1,  -- LUT input
      I2 =&gt; I2   -- LUT input
   );

   -- End of LUT3_D_inst instantiation


--   LUT3_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_D: 3-input Look-Up Table with general and local outputs
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_D_inst : LUT3_D
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,  -- LUT local output
      O =&gt; O,    -- LUT general output
      I0 =&gt; I0,  -- LUT input
      I1 =&gt; I1,  -- LUT input
      I2 =&gt; I2   -- LUT input
   );

   -- End of LUT3_D_inst instantiation

					</Template>
					<Template label="LUT3_L" treetype="template">

--   LUT3_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_L: 3-input Look-Up Table with local output
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_L_inst : LUT3_L
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,   -- LUT local output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2    -- LUT input
   );

   -- End of LUT3_L_inst instantiation


--   LUT3_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_L: 3-input Look-Up Table with local output
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_L_inst : LUT3_L
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,   -- LUT local output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2    -- LUT input
   );

   -- End of LUT3_L_inst instantiation

					</Template>
					<Template label="LUT4" treetype="template">

--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_inst instantiation


--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-input Look-Up Table with general output
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_inst instantiation

					</Template>
					<Template label="LUT4_D" treetype="template">

--   LUT4_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_D: 4-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_D_inst : LUT4_D
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_D_inst instantiation


--   LUT4_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_D: 4-input Look-Up Table with general and local outputs
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_D_inst : LUT4_D
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_D_inst instantiation
					</Template>
					<Template label="LUT4_L" treetype="template">

--   LUT4_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_L: 4-input Look-Up Table with local output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_L_inst : LUT4_L
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_L_inst instantiation


--   LUT4_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_L: 4-input Look-Up Table with local output
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_L_inst : LUT4_L
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_L_inst instantiation

					</Template>
					<Template label="LUT5" treetype="template">

--    LUT5     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT5_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5: 5-input Look-Up Table with general output (Mapped to SliceM LUT6)
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_inst : LUT5
   generic map (
      INIT =&gt; X"00000000") -- Specify LUT Contents
   port map (
      O =&gt; O,  -- LUT general output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2,   -- LUT input
      I3 =&gt; I3,   -- LUT input
      I4 =&gt; I4    -- LUT input 
   );

   -- End of LUT5_inst instantiation

					</Template>
					<Template label="LUT5_D" treetype="template">

--   LUT5_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT5_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5_D: 5-input Look-Up Table with general and local outputs (Mapped to SliceM LUT6)
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_D_inst : LUT5_D
   generic map (
      INIT =&gt; X"00000000") -- Specify LUT contents
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4  -- LUT input
   );

   -- End of LUT5_D_inst instantiation

					</Template>
					<Template label="LUT5_L" treetype="template">

--   LUT5_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT5_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5_L: 5-input Look-Up Table with local output (Mapped to SliceM LUT6)
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_L_inst : LUT5_L
   generic map (
      INIT =&gt; X"00000000") -- Specify LUT Contents
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4  -- LUT input
   );

   -- End of LUT5_L_inst instantiation

					</Template>
					<Template label="LUT6" treetype="template">

--    LUT6     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6: 6-input Look-Up Table with general output
   --       Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_inst : LUT6
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      O =&gt; O,  -- LUT general output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2,   -- LUT input
      I3 =&gt; I3,   -- LUT input
      I4 =&gt; I4,   -- LUT input
      I5 =&gt; I5    -- LUT input 
   );

   -- End of LUT6_inst instantiation

					</Template>
					<Template label="LUT6_D" treetype="template">

--   LUT6_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_D: 6-input Look-Up Table with general and local outputs
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_D_inst : LUT6_D
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT contents
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4, -- LUT input
      I5 =&gt; I5 -- LUT input
   );

   -- End of LUT6_D_inst instantiation
					</Template>
					<Template label="LUT6_L" treetype="template">

--   LUT6_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_L: 6-input Look-Up Table with local output
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_L_inst : LUT6_L
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4, -- LUT input
      I5 =&gt; I5  -- LUT input
   );

   -- End of LUT6_L_inst instantiation

					</Template>
					<Template label="LUT6_2" treetype="template">

--   LUT6_2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_2: 6-input  2 output Look-Up Table
   --         Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_2_inst : LUT6_2
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      O6 =&gt; O6,  -- 6/5-LUT output (1-bit)
      O5 =&gt; O5,  -- 5-LUT output (1-bit)
      I0 =&gt; I0,   -- LUT input (1-bit)
      I1 =&gt; I1,   -- LUT input (1-bit)
      I2 =&gt; I2,   -- LUT input (1-bit)
      I3 =&gt; I3,   -- LUT input (1-bit)
      I4 =&gt; I4,   -- LUT input (1-bit)
      I5 =&gt; I5    -- LUT input (1-bit)
   );

   -- End of LUT6_2_inst instantiation

					</Template>
					<Template label="Reconfigurable LUT (CFGLUT5)" treetype="template">
--     CFGLUT5     : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (CFGLUT5_inst) and/or the port declarations after the
--      code       : "=&gt;" assignment maybe changed to properly reference and
--                 : connect this function to the design.  All inputs
--                 : and outputs must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CFGLUT5: Reconfigurable 5-input LUT (Mapped to SliceM LUT6) 
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   CFGLUT5_inst : CFGLUT5
   generic map (
      INT =&gt; X"00000000")
   port map (
      CDO =&gt; CDO, -- Reconfiguration cascade output
      O5 =&gt; O5,   -- 4-LUT output
      O6 =&gt; O6,   -- 5-LUT output
      CDI =&gt; CDI, -- Reconfiguration data input
      CE =&gt; CE,   -- Reconfiguration enable input
      CLK =&gt; CLK, -- Clock input
      I0 =&gt; I0,   -- Logic data input
      I1 =&gt; I1,   -- Logic data input
      I2 =&gt; I2,   -- Logic data input
      I3 =&gt; I3,   -- Logic data input
      I4 =&gt; I4    -- Logic data input
   );

   -- End of CFGLUT5_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUXFx" treetype="folder">
					<Template label="MUXF7" treetype="template">

--    MUXF7    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF7_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7: CLB MUX to tie two LUT6's together with general output
   --        Artix-7 
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_inst : MUXF7
   port map (
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to LUT6 O6 pin)
      I1 =&gt; I1,  -- Input (tie to LUT6 O6 pin)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF7_inst instantiation

					</Template>
					<Template label="MUXF7_D" treetype="template">

--   MUXF7_D   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF7_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7_D: CLB MUX to tie two LUT6's together with general and local outputs
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_D_inst : MUXF7_D
   port map (
      LO =&gt; LO,  -- Ouptut of MUX to local routing
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to LUT6 O6 pin)
      I1 =&gt; I1,  -- Input (tie to LUT6 O6 pin)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF7_D_inst instantiation

					</Template>
					<Template label="MUXF7_L" treetype="template">

--   MUXF7_L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF7_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7_L: CLB MUX to tie two LUT6's together with local output
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_L_inst : MUXF7_L
   port map (
      LO =&gt; LO,  -- Output of MUX to local routing
      I0 =&gt; I0,  -- Input (tie to LUT6 O6 pin)
      I1 =&gt; I1,  -- Input (tie to LUT6 O6 pin)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF7_L_inst instantiation

					</Template>
					<Template label="MUXF8" treetype="template">

--    MUXF8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF8_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8: CLB MUX to tie two MUXF7's together with general output
   --        Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_inst : MUXF8
   port map (
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to MUXF7 L/LO out)
      I1 =&gt; I1,  -- Input (tie to MUXF7 L/LO out)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF8_inst instantiation

					</Template>
					<Template label="MUXF8_D" treetype="template">

--   MUXF8_D   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF8_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8_D: CLB MUX to tie two MUXF7's together with general and local outputs
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_D_inst : MUXF8_D
   port map (
      LO =&gt; LO,  -- Ouptut of MUX to local routing
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to MUXF7 L/LO out)
      I1 =&gt; I1,  -- Input (tie to MUXF7 L/LO out)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF8_D_inst instantiation

					</Template>
					<Template label="MUXF8_L" treetype="template">

--   MUXF8_L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF8_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8_L: CLB MUX to tie two MUXF7's together with local output
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_L_inst : MUXF8_L
   port map (
      LO =&gt; LO,  -- Output of MUX to local routing
      I0 =&gt; I0,  -- Input (tie to MUXF7 L/LO out)
      I1 =&gt; I1,  -- Input (tie to MUXF7 L/LO out)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF8_L_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Shift Register LUT" treetype="folder">
					<Template label="16-bit /w CE posedge SR (SRL16E)" treetype="template">

--   SRL16E    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (SRL16E_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRL16E: 16-bit shift register LUT with clock enable operating on posedge of clock (Mapped to SliceM LUT6)
   --        Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   SRL16E_inst : SRL16E
   generic map (
      INIT =&gt; X"0000")
   port map (
      Q =&gt; Q,       -- SRL data output
      A0 =&gt; A0,     -- Select[0] input
      A1 =&gt; A1,     -- Select[1] input
      A2 =&gt; A2,     -- Select[2] input
      A3 =&gt; A3,     -- Select[3] input
      CE =&gt; CE,     -- Clock enable input
      CLK =&gt; CLK,   -- Clock input
      D =&gt; D        -- SRL data input
   );

   -- End of SRL16E_inst instantiation

					</Template>
					<Template label="32-bit /w CE posedge SR (SRLC32E)" treetype="template">

--   SRLC32E   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (SRLC32E_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRLC32E: 32-bit variable length shift register LUT
   --          with clock enable (Mapped to a SliceM LUT6)
   --          Artix-7
   -- Xilinx HDL Language Template, version 2016.4
   
   SRLC32E_inst : SRLC32E
   generic map (
      INIT =&gt; X"00000000")
   port map (
      Q =&gt; Q,        -- SRL data output
      Q31 =&gt; Q31,    -- SRL cascade output pin
      A =&gt; A,        -- 5-bit shift depth select input
      CE =&gt; CE,      -- Clock enable input
      CLK =&gt; CLK,    -- Clock input
      D =&gt; D         -- SRL data input
   );

   -- End of SRLC32E_inst instantiation

					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Kintex UltraScale" treetype="folder">
			<SubFolder label="ADVANCED" treetype="folder">
				<SubFolder label="GT" treetype="folder">
					<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE3)" treetype="template">
-- IBUFDS_GTE3 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_GTE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_GTE3: Gigabit Transceiver Buffer
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE3_inst : IBUFDS_GTE3
   generic map (
      REFCLK_EN_TX_PATH =&gt; '0',   -- Refer to Transceiver User Guide
      REFCLK_HROW_CK_SEL =&gt; "00", -- Refer to Transceiver User Guide
      REFCLK_ICNTL_RX =&gt; "00"     -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,         -- 1-bit output: Refer to Transceiver User Guide
      ODIV2 =&gt; ODIV2, -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,     -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,         -- 1-bit input: Refer to Transceiver User Guide
      IB =&gt; IB        -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of IBUFDS_GTE3_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE3_ADV)" treetype="template">
-- OBUFDS_GTE3_ADV : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (OBUFDS_GTE3_ADV_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_GTE3_ADV: Gigabit Transceiver Buffer
   --                  Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE3_ADV_inst : OBUFDS_GTE3_ADV
   generic map (
      REFCLK_EN_TX_PATH =&gt; '1',   -- Refer to Transceiver User Guide
      REFCLK_ICNTL_TX =&gt; "00000"  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,                       -- 1-bit output: Refer to Transceiver User Guide
      OB =&gt; OB,                     -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,                   -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,                       -- 4-bit input: Refer to Transceiver User Guide
      RXRECCLK_SEL =&gt; RXRECCLK_SEL  -- 2-bit input: Refer to Transceiver User Guide
   );

   -- End of OBUFDS_GTE3_ADV_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE3)" treetype="template">
-- OBUFDS_GTE3 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_GTE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_GTE3: Gigabit Transceiver Buffer
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE3_inst : OBUFDS_GTE3
   generic map (
      REFCLK_EN_TX_PATH =&gt; '1',   -- Refer to Transceiver User Guide
      REFCLK_ICNTL_TX =&gt; "00000"  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,     -- 1-bit output: Refer to Transceiver User Guide
      OB =&gt; OB,   -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB, -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I      -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of OBUFDS_GTE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SYSMON" treetype="folder">
					<Template label="SYSMON Simulation File" treetype="template">
-- Must use valid headers on all columns
-- Comments can be added to the stimulus file using '--'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

-- Time stamp data is in nano seconds (ns)
-- Temperature is recorded in C (degrees centigrade)
-- All other channels are recorded as V (Volts)
-- Valid column headers are:
-- TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
-- VUSER0, VUSER1, VUSER2, VUSER3,
-- VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
-- External analog inputs are differential so VP = 0.5 and VN = 0.1 the
-- input on channel VP/VN in 0.5 - 0.1 = 0.4V
					</Template>
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE1)" treetype="template">
--  SYSMONE1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SYSMONE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SYSMONE1: Xilinx Analog-to-Digital Converter and System Monitor
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   SYSMONE1_inst : SYSMONE1
   generic map (
      -- INIT_40 - INIT_44: SYSMON configuration registers
      INIT_40 =&gt; X"0000",
      INIT_41 =&gt; X"0000",
      INIT_42 =&gt; X"0000",
      INIT_43 =&gt; X"0000",
      INIT_44 =&gt; X"0000",
      INIT_45 =&gt; X"0000",               -- Analog Bus Register
      -- INIT_46 - INIT_4F: Sequence Registers
      INIT_46 =&gt; X"0000",
      INIT_47 =&gt; X"0000",
      INIT_48 =&gt; X"0000",
      INIT_49 =&gt; X"0000",
      INIT_4A =&gt; X"0000",
      INIT_4B =&gt; X"0000",
      INIT_4C =&gt; X"0000",
      INIT_4D =&gt; X"0000",
      INIT_4E =&gt; X"0000",
      INIT_4F =&gt; X"0000",
      -- INIT_50 - INIT_5F: Alarm Limit Registers
      INIT_50 =&gt; X"0000",
      INIT_51 =&gt; X"0000",
      INIT_52 =&gt; X"0000",
      INIT_53 =&gt; X"0000",
      INIT_54 =&gt; X"0000",
      INIT_55 =&gt; X"0000",
      INIT_56 =&gt; X"0000",
      INIT_57 =&gt; X"0000",
      INIT_58 =&gt; X"0000",
      INIT_59 =&gt; X"0000",
      INIT_5A =&gt; X"0000",
      INIT_5B =&gt; X"0000",
      INIT_5C =&gt; X"0000",
      INIT_5D =&gt; X"0000",
      INIT_5E =&gt; X"0000",
      INIT_5F =&gt; X"0000",
      -- INIT_60 - INIT_6F: User Supply Alarms
      INIT_60 =&gt; X"0000",
      INIT_61 =&gt; X"0000",
      INIT_62 =&gt; X"0000",
      INIT_63 =&gt; X"0000",
      INIT_64 =&gt; X"0000",
      INIT_65 =&gt; X"0000",
      INIT_66 =&gt; X"0000",
      INIT_67 =&gt; X"0000",
      INIT_68 =&gt; X"0000",
      INIT_69 =&gt; X"0000",
      INIT_6A =&gt; X"0000",
      INIT_6B =&gt; X"0000",
      INIT_6C =&gt; X"0000",
      INIT_6D =&gt; X"0000",
      INIT_6E =&gt; X"0000",
      INIT_6F =&gt; X"0000",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      -- specific pins
      IS_CONVSTCLK_INVERTED =&gt; '0',     -- Optional inversion for CONVSTCLK, 0-1
      IS_DCLK_INVERTED =&gt; '0',          -- Optional inversion for DCLK, 0-1
      -- Simulation attributes: Set for proper simulation behavior
      SIM_MONITOR_FILE =&gt; "design.txt", -- Analog simulation data file name
      -- User Voltage Monitor: SYSMON User voltage monitor
      SYSMON_VUSER0_BANK =&gt; 0,          -- Specify IO Bank for User0
      SYSMON_VUSER0_MONITOR =&gt; "NONE",  -- Specify Voltage for User0
      SYSMON_VUSER1_BANK =&gt; 0,          -- Specify IO Bank for User1
      SYSMON_VUSER1_MONITOR =&gt; "NONE",  -- Specify Voltage for User1
      SYSMON_VUSER2_BANK =&gt; 0,          -- Specify IO Bank for User2
      SYSMON_VUSER2_MONITOR =&gt; "NONE",  -- Specify Voltage for User2
      SYSMON_VUSER3_MONITOR =&gt; "NONE"   -- Specify Voltage for User3
   )
   port map (
      -- ALARMS outputs: ALM, OT
      ALM =&gt; ALM,                   -- 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      OT =&gt; OT,                     -- 1-bit output: Over-Temperature alarm
      -- Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      DO =&gt; DO,                     -- 16-bit output: DRP output data bus
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP data ready
      -- I2C Interface outputs: Ports used with the I2C DRP interface
      I2C_SCLK_TS =&gt; I2C_SCLK_TS,   -- 1-bit output: I2C_SCLK output port
      I2C_SDA_TS =&gt; I2C_SDA_TS,     -- 1-bit output: I2C_SDA_TS output port
      -- STATUS outputs: SYSMON status ports
      BUSY =&gt; BUSY,                 -- 1-bit output: System Monitor busy output
      CHANNEL =&gt; CHANNEL,           -- 6-bit output: Channel selection outputs
      EOC =&gt; EOC,                   -- 1-bit output: End of Conversion
      EOS =&gt; EOS,                   -- 1-bit output: End of Sequence
      JTAGBUSY =&gt; JTAGBUSY,         -- 1-bit output: JTAG DRP transaction in progress output
      JTAGLOCKED =&gt; JTAGLOCKED,     -- 1-bit output: JTAG requested DRP port lock
      JTAGMODIFIED =&gt; JTAGMODIFIED, -- 1-bit output: JTAG Write to the DRP has occurred
      MUXADDR =&gt; MUXADDR,           -- 5-bit output: External MUX channel decode
      -- Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      VAUXN =&gt; VAUXN,               -- 16-bit input: N-side auxiliary analog input
      VAUXP =&gt; VAUXP,               -- 16-bit input: P-side auxiliary analog input
      -- CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      CONVST =&gt; CONVST,             -- 1-bit input: Convert start input
      CONVSTCLK =&gt; CONVSTCLK,       -- 1-bit input: Convert start input
      RESET =&gt; RESET,               -- 1-bit input: Active-High reset
      -- Dedicated Analog Input Pair inputs: VP/VN
      VN =&gt; VN,                     -- 1-bit input: N-side analog input
      VP =&gt; VP,                     -- 1-bit input: P-side analog input
      -- Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      DADDR =&gt; DADDR,               -- 8-bit input: DRP address bus
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable signal
      DI =&gt; DI,                     -- 16-bit input: DRP input data bus
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- I2C Interface inputs: Ports used with the I2C DRP interface
      I2C_SCLK =&gt; I2C_SCLK,         -- 1-bit input: I2C_SCLK input port
      I2C_SDA =&gt; I2C_SDA            -- 1-bit input: I2C_SDA input port
   );

   -- End of SYSMONE1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="ARITHMETIC" treetype="folder">
				<SubFolder label="DSP" treetype="folder">
					<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E2)" treetype="template">
--   DSP48E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DSP48E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DSP48E2: 48-bit Multi-Functional Arithmetic Block
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   DSP48E2_inst : DSP48E2
   generic map (
      -- Feature Control Attributes: Data Path Selection
      AMULTSEL =&gt; "A",                   -- Selects A input to multiplier (A, AD)
      A_INPUT =&gt; "DIRECT",               -- Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      BMULTSEL =&gt; "B",                   -- Selects B input to multiplier (AD, B)
      B_INPUT =&gt; "DIRECT",               -- Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      PREADDINSEL =&gt; "A",                -- Selects input to pre-adder (A, B)
      RND =&gt; X"000000000000",            -- Rounding Constant
      USE_MULT =&gt; "MULTIPLY",            -- Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
      USE_SIMD =&gt; "ONE48",               -- SIMD selection (FOUR12, ONE48, TWO24)
      USE_WIDEXOR =&gt; "FALSE",            -- Use the Wide XOR function (FALSE, TRUE)
      XORSIMD =&gt; "XOR24_48_96",          -- Mode of operation for the Wide XOR (XOR12, XOR24_48_96)
      -- Pattern Detector Attributes: Pattern Detection Configuration
      AUTORESET_PATDET =&gt; "NO_RESET",    -- NO_RESET, RESET_MATCH, RESET_NOT_MATCH
      AUTORESET_PRIORITY =&gt; "RESET",     -- Priority of AUTORESET vs. CEP (CEP, RESET).
      MASK =&gt; X"3fffffffffff",           -- 48-bit mask value for pattern detect (1=ignore)
      PATTERN =&gt; X"000000000000",        -- 48-bit pattern match for pattern detect
      SEL_MASK =&gt; "MASK",                -- C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
      SEL_PATTERN =&gt; "PATTERN",          -- Select pattern value (C, PATTERN)
      USE_PATTERN_DETECT =&gt; "NO_PATDET", -- Enable pattern detect (NO_PATDET, PATDET)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_ALUMODE_INVERTED =&gt; "0000",     -- Optional inversion for ALUMODE
      IS_CARRYIN_INVERTED =&gt; '0',        -- Optional inversion for CARRYIN
      IS_CLK_INVERTED =&gt; '0',            -- Optional inversion for CLK
      IS_INMODE_INVERTED =&gt; "00000",     -- Optional inversion for INMODE
      IS_OPMODE_INVERTED =&gt; "000000000", -- Optional inversion for OPMODE
      IS_RSTALLCARRYIN_INVERTED =&gt; '0',  -- Optional inversion for RSTALLCARRYIN
      IS_RSTALUMODE_INVERTED =&gt; '0',     -- Optional inversion for RSTALUMODE
      IS_RSTA_INVERTED =&gt; '0',           -- Optional inversion for RSTA
      IS_RSTB_INVERTED =&gt; '0',           -- Optional inversion for RSTB
      IS_RSTCTRL_INVERTED =&gt; '0',        -- Optional inversion for RSTCTRL
      IS_RSTC_INVERTED =&gt; '0',           -- Optional inversion for RSTC
      IS_RSTD_INVERTED =&gt; '0',           -- Optional inversion for RSTD
      IS_RSTINMODE_INVERTED =&gt; '0',      -- Optional inversion for RSTINMODE
      IS_RSTM_INVERTED =&gt; '0',           -- Optional inversion for RSTM
      IS_RSTP_INVERTED =&gt; '0',           -- Optional inversion for RSTP
      -- Register Control Attributes: Pipeline Register Configuration
      ACASCREG =&gt; 1,                     -- Number of pipeline stages between A/ACIN and ACOUT (0-2)
      ADREG =&gt; 1,                        -- Pipeline stages for pre-adder (0-1)
      ALUMODEREG =&gt; 1,                   -- Pipeline stages for ALUMODE (0-1)
      AREG =&gt; 1,                         -- Pipeline stages for A (0-2)
      BCASCREG =&gt; 1,                     -- Number of pipeline stages between B/BCIN and BCOUT (0-2)
      BREG =&gt; 1,                         -- Pipeline stages for B (0-2)
      CARRYINREG =&gt; 1,                   -- Pipeline stages for CARRYIN (0-1)
      CARRYINSELREG =&gt; 1,                -- Pipeline stages for CARRYINSEL (0-1)
      CREG =&gt; 1,                         -- Pipeline stages for C (0-1)
      DREG =&gt; 1,                         -- Pipeline stages for D (0-1)
      INMODEREG =&gt; 1,                    -- Pipeline stages for INMODE (0-1)
      MREG =&gt; 1,                         -- Multiplier pipeline stages (0-1)
      OPMODEREG =&gt; 1,                    -- Pipeline stages for OPMODE (0-1)
      PREG =&gt; 1                          -- Number of pipeline stages for P (0-1)
   )
   port map (
      -- Cascade outputs: Cascade Ports
      ACOUT =&gt; ACOUT,                   -- 30-bit output: A port cascade
      BCOUT =&gt; BCOUT,                   -- 18-bit output: B cascade
      CARRYCASCOUT =&gt; CARRYCASCOUT,     -- 1-bit output: Cascade carry
      MULTSIGNOUT =&gt; MULTSIGNOUT,       -- 1-bit output: Multiplier sign cascade
      PCOUT =&gt; PCOUT,                   -- 48-bit output: Cascade output
      -- Control outputs: Control Inputs/Status Bits
      OVERFLOW =&gt; OVERFLOW,             -- 1-bit output: Overflow in add/acc
      PATTERNBDETECT =&gt; PATTERNBDETECT, -- 1-bit output: Pattern bar detect
      PATTERNDETECT =&gt; PATTERNDETECT,   -- 1-bit output: Pattern detect
      UNDERFLOW =&gt; UNDERFLOW,           -- 1-bit output: Underflow in add/acc
      -- Data outputs: Data Ports
      CARRYOUT =&gt; CARRYOUT,             -- 4-bit output: Carry
      P =&gt; P,                           -- 48-bit output: Primary data
      XOROUT =&gt; XOROUT,                 -- 8-bit output: XOR data
      -- Cascade inputs: Cascade Ports
      ACIN =&gt; ACIN,                     -- 30-bit input: A cascade data
      BCIN =&gt; BCIN,                     -- 18-bit input: B cascade
      CARRYCASCIN =&gt; CARRYCASCIN,       -- 1-bit input: Cascade carry
      MULTSIGNIN =&gt; MULTSIGNIN,         -- 1-bit input: Multiplier sign cascade
      PCIN =&gt; PCIN,                     -- 48-bit input: P cascade
      -- Control inputs: Control Inputs/Status Bits
      ALUMODE =&gt; ALUMODE,               -- 4-bit input: ALU control
      CARRYINSEL =&gt; CARRYINSEL,         -- 3-bit input: Carry select
      CLK =&gt; CLK,                       -- 1-bit input: Clock
      INMODE =&gt; INMODE,                 -- 5-bit input: INMODE control
      OPMODE =&gt; OPMODE,                 -- 9-bit input: Operation mode
      -- Data inputs: Data Ports
      A =&gt; A,                           -- 30-bit input: A data
      B =&gt; B,                           -- 18-bit input: B data
      C =&gt; C,                           -- 48-bit input: C data
      CARRYIN =&gt; CARRYIN,               -- 1-bit input: Carry-in
      D =&gt; D,                           -- 27-bit input: D data
      -- Reset/Clock Enable inputs: Reset/Clock Enable Inputs
      CEA1 =&gt; CEA1,                     -- 1-bit input: Clock enable for 1st stage AREG
      CEA2 =&gt; CEA2,                     -- 1-bit input: Clock enable for 2nd stage AREG
      CEAD =&gt; CEAD,                     -- 1-bit input: Clock enable for ADREG
      CEALUMODE =&gt; CEALUMODE,           -- 1-bit input: Clock enable for ALUMODE
      CEB1 =&gt; CEB1,                     -- 1-bit input: Clock enable for 1st stage BREG
      CEB2 =&gt; CEB2,                     -- 1-bit input: Clock enable for 2nd stage BREG
      CEC =&gt; CEC,                       -- 1-bit input: Clock enable for CREG
      CECARRYIN =&gt; CECARRYIN,           -- 1-bit input: Clock enable for CARRYINREG
      CECTRL =&gt; CECTRL,                 -- 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
      CED =&gt; CED,                       -- 1-bit input: Clock enable for DREG
      CEINMODE =&gt; CEINMODE,             -- 1-bit input: Clock enable for INMODEREG
      CEM =&gt; CEM,                       -- 1-bit input: Clock enable for MREG
      CEP =&gt; CEP,                       -- 1-bit input: Clock enable for PREG
      RSTA =&gt; RSTA,                     -- 1-bit input: Reset for AREG
      RSTALLCARRYIN =&gt; RSTALLCARRYIN,   -- 1-bit input: Reset for CARRYINREG
      RSTALUMODE =&gt; RSTALUMODE,         -- 1-bit input: Reset for ALUMODEREG
      RSTB =&gt; RSTB,                     -- 1-bit input: Reset for BREG
      RSTC =&gt; RSTC,                     -- 1-bit input: Reset for CREG
      RSTCTRL =&gt; RSTCTRL,               -- 1-bit input: Reset for OPMODEREG and CARRYINSELREG
      RSTD =&gt; RSTD,                     -- 1-bit input: Reset for DREG and ADREG
      RSTINMODE =&gt; RSTINMODE,           -- 1-bit input: Reset for INMODEREG
      RSTM =&gt; RSTM,                     -- 1-bit input: Reset for MREG
      RSTP =&gt; RSTP                      -- 1-bit input: Reset for PREG
   );

   -- End of DSP48E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="BLOCKRAM" treetype="folder">
				<SubFolder label="BRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E2)" treetype="template">
--  RAMB18E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB18E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB18E2: 18K-bit Configurable Synchronous Block RAM
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAMB18E2_inst : RAMB18E2
   generic map (
      -- CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      CASCADE_ORDER_A =&gt; "NONE",
      CASCADE_ORDER_B =&gt; "NONE",
      -- CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      CLOCK_DOMAINS =&gt; "INDEPENDENT",
      -- Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0, 1)
      DOA_REG =&gt; 1,
      DOB_REG =&gt; 1,
      -- ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      ENADDRENA =&gt; "FALSE",
      ENADDRENB =&gt; "FALSE",
      -- INITP_00 to INITP_07: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_3F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"00000",
      INIT_B =&gt; X"00000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLKARDCLK_INVERTED =&gt; '0',
      IS_CLKBWRCLK_INVERTED =&gt; '0',
      IS_ENARDEN_INVERTED =&gt; '0',
      IS_ENBWREN_INVERTED =&gt; '0',
      IS_RSTRAMARSTRAM_INVERTED =&gt; '0',
      IS_RSTRAMB_INVERTED =&gt; '0',
      IS_RSTREGARSTREG_INVERTED =&gt; '0',
      IS_RSTREGB_INVERTED =&gt; '0',
      -- RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      RDADDRCHANGEA =&gt; "FALSE",
      RDADDRCHANGEB =&gt; "FALSE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-9
      READ_WIDTH_B =&gt; 0,                                                               -- 0-9
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-9
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-9
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"00000",
      SRVAL_B =&gt; X"00000",
      -- Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      SLEEP_ASYNC =&gt; "FALSE",
      -- WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      WRITE_MODE_A =&gt; "NO_CHANGE",
      WRITE_MODE_B =&gt; "NO_CHANGE" 
   )
   port map (
      -- Cascade Signals outputs: Multi-BRAM cascade signals
      CASDOUTA =&gt; CASDOUTA,               -- 16-bit output: Port A cascade output data
      CASDOUTB =&gt; CASDOUTB,               -- 16-bit output: Port B cascade output data
      CASDOUTPA =&gt; CASDOUTPA,             -- 2-bit output: Port A cascade output parity data
      CASDOUTPB =&gt; CASDOUTPB,             -- 2-bit output: Port B cascade output parity data
      -- Port A Data outputs: Port A data
      DOUTADOUT =&gt; DOUTADOUT,             -- 16-bit output: Port A data/LSB data
      DOUTPADOUTP =&gt; DOUTPADOUTP,         -- 2-bit output: Port A parity/LSB parity
      -- Port B Data outputs: Port B data
      DOUTBDOUT =&gt; DOUTBDOUT,             -- 16-bit output: Port B data/MSB data
      DOUTPBDOUTP =&gt; DOUTPBDOUTP,         -- 2-bit output: Port B parity/MSB parity
      -- Cascade Signals inputs: Multi-BRAM cascade signals
      CASDIMUXA =&gt; CASDIMUXA,             -- 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      CASDIMUXB =&gt; CASDIMUXB,             -- 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      CASDINA =&gt; CASDINA,                 -- 16-bit input: Port A cascade input data
      CASDINB =&gt; CASDINB,                 -- 16-bit input: Port B cascade input data
      CASDINPA =&gt; CASDINPA,               -- 2-bit input: Port A cascade input parity data
      CASDINPB =&gt; CASDINPB,               -- 2-bit input: Port B cascade input parity data
      CASDOMUXA =&gt; CASDOMUXA,             -- 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      CASDOMUXB =&gt; CASDOMUXB,             -- 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      CASDOMUXEN_A =&gt; CASDOMUXEN_A,       -- 1-bit input: Port A unregistered output data enable
      CASDOMUXEN_B =&gt; CASDOMUXEN_B,       -- 1-bit input: Port B unregistered output data enable
      CASOREGIMUXA =&gt; CASOREGIMUXA,       -- 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      CASOREGIMUXB =&gt; CASOREGIMUXB,       -- 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      CASOREGIMUXEN_A =&gt; CASOREGIMUXEN_A, -- 1-bit input: Port A registered output data enable
      CASOREGIMUXEN_B =&gt; CASOREGIMUXEN_B, -- 1-bit input: Port B registered output data enable
      -- Port A Address/Control Signals inputs: Port A address and control signals
      ADDRARDADDR =&gt; ADDRARDADDR,         -- 14-bit input: A/Read port address
      ADDRENA =&gt; ADDRENA,                 -- 1-bit input: Active-High A/Read port address enable
      CLKARDCLK =&gt; CLKARDCLK,             -- 1-bit input: A/Read port clock
      ENARDEN =&gt; ENARDEN,                 -- 1-bit input: Port A enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,         -- 1-bit input: Port A register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM,     -- 1-bit input: Port A set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG,     -- 1-bit input: Port A register set/reset
      WEA =&gt; WEA,                         -- 2-bit input: Port A write enable
      -- Port A Data inputs: Port A data
      DINADIN =&gt; DINADIN,                 -- 16-bit input: Port A data/LSB data
      DINPADINP =&gt; DINPADINP,             -- 2-bit input: Port A parity/LSB parity
      -- Port B Address/Control Signals inputs: Port B address and control signals
      ADDRBWRADDR =&gt; ADDRBWRADDR,         -- 14-bit input: B/Write port address
      ADDRENB =&gt; ADDRENB,                 -- 1-bit input: Active-High B/Write port address enable
      CLKBWRCLK =&gt; CLKBWRCLK,             -- 1-bit input: B/Write port clock
      ENBWREN =&gt; ENBWREN,                 -- 1-bit input: Port B enable/Write enable
      REGCEB =&gt; REGCEB,                   -- 1-bit input: Port B register enable
      RSTRAMB =&gt; RSTRAMB,                 -- 1-bit input: Port B set/reset
      RSTREGB =&gt; RSTREGB,                 -- 1-bit input: Port B register set/reset
      SLEEP =&gt; SLEEP,                     -- 1-bit input: Sleep Mode
      WEBWE =&gt; WEBWE,                     -- 4-bit input: Port B write enable/Write enable
      -- Port B Data inputs: Port B data
      DINBDIN =&gt; DINBDIN,                 -- 16-bit input: Port B data/MSB data
      DINPBDINP =&gt; DINPBDINP              -- 2-bit input: Port B parity/MSB parity
   );

   -- End of RAMB18E2_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E2)" treetype="template">
--  RAMB36E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB36E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB36E2: 36K-bit Configurable Synchronous Block RAM
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAMB36E2_inst : RAMB36E2
   generic map (
      -- CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      CASCADE_ORDER_A =&gt; "NONE",
      CASCADE_ORDER_B =&gt; "NONE",
      -- CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      CLOCK_DOMAINS =&gt; "INDEPENDENT",
      DOB_REG =&gt; 1,
      -- Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0, 1)
      DOA_REG =&gt; 1,
      -- ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      ENADDRENA =&gt; "FALSE",
      ENADDRENB =&gt; "FALSE",
      -- EN_ECC_PIPE: ECC pipeline register, "TRUE"/"FALSE" 
      EN_ECC_PIPE =&gt; "FALSE",
      -- EN_ECC_READ: Enable ECC decoder, "TRUE"/"FALSE" 
      EN_ECC_READ =&gt; "FALSE",
      -- EN_ECC_WRITE: Enable ECC encoder, "TRUE"/"FALSE" 
      EN_ECC_WRITE =&gt; "FALSE",
      -- INITP_00 to INITP_0F: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_7F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"000000000",
      INIT_B =&gt; X"000000000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLKARDCLK_INVERTED =&gt; '0',
      IS_CLKBWRCLK_INVERTED =&gt; '0',
      IS_ENARDEN_INVERTED =&gt; '0',
      IS_ENBWREN_INVERTED =&gt; '0',
      IS_RSTRAMARSTRAM_INVERTED =&gt; '0',
      IS_RSTRAMB_INVERTED =&gt; '0',
      IS_RSTREGARSTREG_INVERTED =&gt; '0',
      IS_RSTREGB_INVERTED =&gt; '0',
      -- RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      RDADDRCHANGEA =&gt; "FALSE",
      RDADDRCHANGEB =&gt; "FALSE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-9
      READ_WIDTH_B =&gt; 0,                                                               -- 0-9
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-9
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-9
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"000000000",
      SRVAL_B =&gt; X"000000000",
      -- Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      SLEEP_ASYNC =&gt; "FALSE",
      -- WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      WRITE_MODE_A =&gt; "NO_CHANGE",
      WRITE_MODE_B =&gt; "NO_CHANGE" 
   )
   port map (
      -- Cascade Signals outputs: Multi-BRAM cascade signals
      CASDOUTA =&gt; CASDOUTA,               -- 32-bit output: Port A cascade output data
      CASDOUTB =&gt; CASDOUTB,               -- 32-bit output: Port B cascade output data
      CASDOUTPA =&gt; CASDOUTPA,             -- 4-bit output: Port A cascade output parity data
      CASDOUTPB =&gt; CASDOUTPB,             -- 4-bit output: Port B cascade output parity data
      CASOUTDBITERR =&gt; CASOUTDBITERR,     -- 1-bit output: DBITERR cascade output
      CASOUTSBITERR =&gt; CASOUTSBITERR,     -- 1-bit output: SBITERR cascade output
      -- ECC Signals outputs: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,                 -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,             -- 8-bit output: Generated error correction parity
      RDADDRECC =&gt; RDADDRECC,             -- 9-bit output: ECC Read Address
      SBITERR =&gt; SBITERR,                 -- 1-bit output: Single bit error status
      -- Port A Data outputs: Port A data
      DOUTADOUT =&gt; DOUTADOUT,             -- 32-bit output: Port A ata/LSB data
      DOUTPADOUTP =&gt; DOUTPADOUTP,         -- 4-bit output: Port A parity/LSB parity
      -- Port B Data outputs: Port B data
      DOUTBDOUT =&gt; DOUTBDOUT,             -- 32-bit output: Port B data/MSB data
      DOUTPBDOUTP =&gt; DOUTPBDOUTP,         -- 4-bit output: Port B parity/MSB parity
      -- Cascade Signals inputs: Multi-BRAM cascade signals
      CASDIMUXA =&gt; CASDIMUXA,             -- 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      CASDIMUXB =&gt; CASDIMUXB,             -- 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      CASDINA =&gt; CASDINA,                 -- 32-bit input: Port A cascade input data
      CASDINB =&gt; CASDINB,                 -- 32-bit input: Port B cascade input data
      CASDINPA =&gt; CASDINPA,               -- 4-bit input: Port A cascade input parity data
      CASDINPB =&gt; CASDINPB,               -- 4-bit input: Port B cascade input parity data
      CASDOMUXA =&gt; CASDOMUXA,             -- 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      CASDOMUXB =&gt; CASDOMUXB,             -- 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      CASDOMUXEN_A =&gt; CASDOMUXEN_A,       -- 1-bit input: Port A unregistered output data enable
      CASDOMUXEN_B =&gt; CASDOMUXEN_B,       -- 1-bit input: Port B unregistered output data enable
      CASINDBITERR =&gt; CASINDBITERR,       -- 1-bit input: DBITERR cascade input
      CASINSBITERR =&gt; CASINSBITERR,       -- 1-bit input: SBITERR cascade input
      CASOREGIMUXA =&gt; CASOREGIMUXA,       -- 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      CASOREGIMUXB =&gt; CASOREGIMUXB,       -- 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      CASOREGIMUXEN_A =&gt; CASOREGIMUXEN_A, -- 1-bit input: Port A registered output data enable
      CASOREGIMUXEN_B =&gt; CASOREGIMUXEN_B, -- 1-bit input: Port B registered output data enable
      -- ECC Signals inputs: Error Correction Circuitry ports
      ECCPIPECE =&gt; ECCPIPECE,             -- 1-bit input: ECC Pipeline Register Enable
      INJECTDBITERR =&gt; INJECTDBITERR,     -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR,
      -- Port A Address/Control Signals inputs: Port A address and control signals
      ADDRARDADDR =&gt; ADDRARDADDR,         -- 15-bit input: A/Read port address
      ADDRENA =&gt; ADDRENA,                 -- 1-bit input: Active-High A/Read port address enable
      CLKARDCLK =&gt; CLKARDCLK,             -- 1-bit input: A/Read port clock
      ENARDEN =&gt; ENARDEN,                 -- 1-bit input: Port A enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,         -- 1-bit input: Port A register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM,     -- 1-bit input: Port A set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG,     -- 1-bit input: Port A register set/reset
      SLEEP =&gt; SLEEP,                     -- 1-bit input: Sleep Mode
      WEA =&gt; WEA,                         -- 4-bit input: Port A write enable
      -- Port A Data inputs: Port A data
      DINADIN =&gt; DINADIN,                 -- 32-bit input: Port A data/LSB data
      DINPADINP =&gt; DINPADINP,             -- 4-bit input: Port A parity/LSB parity
      -- Port B Address/Control Signals inputs: Port B address and control signals
      ADDRBWRADDR =&gt; ADDRBWRADDR,         -- 15-bit input: B/Write port address
      ADDRENB =&gt; ADDRENB,                 -- 1-bit input: Active-High B/Write port address enable
      CLKBWRCLK =&gt; CLKBWRCLK,             -- 1-bit input: B/Write port clock
      ENBWREN =&gt; ENBWREN,                 -- 1-bit input: Port B enable/Write enable
      REGCEB =&gt; REGCEB,                   -- 1-bit input: Port B register enable
      RSTRAMB =&gt; RSTRAMB,                 -- 1-bit input: Port B set/reset
      RSTREGB =&gt; RSTREGB,                 -- 1-bit input: Port B register set/reset
      WEBWE =&gt; WEBWE,                     -- 8-bit input: Port B write enable/Write enable
      -- Port B Data inputs: Port B data
      DINBDIN =&gt; DINBDIN,                 -- 32-bit input: Port B data/MSB data
      DINPBDINP =&gt; DINPBDINP              -- 4-bit input: Port B parity/MSB parity
   );

   -- End of RAMB36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E2)" treetype="template">
--  FIFO18E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO18E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO18E2: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FIFO18E2_inst : FIFO18E2
   generic map (
      CASCADE_ORDER =&gt; "NONE",            -- FIRST, LAST, MIDDLE, NONE, PARALLEL
      CLOCK_DOMAINS =&gt; "INDEPENDENT",     -- COMMON, INDEPENDENT
      FIRST_WORD_FALL_THROUGH =&gt; "FALSE", -- FALSE, TRUE
      INIT =&gt; X"000000000",               -- Initial values on output port
      PROG_EMPTY_THRESH =&gt; 256,           -- Programmable Empty Threshold
      PROG_FULL_THRESH =&gt; 256,            -- Programmable Full Threshold
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_RDCLK_INVERTED =&gt; '0',           -- Optional inversion for RDCLK
      IS_RDEN_INVERTED =&gt; '0',            -- Optional inversion for RDEN
      IS_RSTREG_INVERTED =&gt; '0',          -- Optional inversion for RSTREG
      IS_RST_INVERTED =&gt; '0',             -- Optional inversion for RST
      IS_WRCLK_INVERTED =&gt; '0',           -- Optional inversion for WRCLK
      IS_WREN_INVERTED =&gt; '0',            -- Optional inversion for WREN
      RDCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      READ_WIDTH =&gt; 4,                    -- 18-9
      REGISTER_MODE =&gt; "UNREGISTERED",    -- DO_PIPELINED, REGISTERED, UNREGISTERED
      RSTREG_PRIORITY =&gt; "RSTREG",        -- REGCE, RSTREG
      SLEEP_ASYNC =&gt; "FALSE",             -- FALSE, TRUE
      SRVAL =&gt; X"000000000",              -- SET/reset value of the FIFO outputs
      WRCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      WRITE_WIDTH =&gt; 4                    -- 18-9
   )
   port map (
      -- Cascade Signals outputs: Multi-FIFO cascade signals
      CASDOUT =&gt; CASDOUT,             -- 32-bit output: Data cascade output bus
      CASDOUTP =&gt; CASDOUTP,           -- 4-bit output: Parity data cascade output bus
      CASNXTEMPTY =&gt; CASNXTEMPTY,     -- 1-bit output: Cascade next empty
      CASPRVRDEN =&gt; CASPRVRDEN,       -- 1-bit output: Cascade previous read enable
      -- Read Data outputs: Read output data
      DOUT =&gt; DOUT,                   -- 32-bit output: FIFO data output bus
      DOUTP =&gt; DOUTP,                 -- 4-bit output: FIFO parity output bus.
      -- Status outputs: Flags and other FIFO status outputs
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty
      FULL =&gt; FULL,                   -- 1-bit output: Full
      PROGEMPTY =&gt; PROGEMPTY,         -- 1-bit output: Programmable empty
      PROGFULL =&gt; PROGFULL,           -- 1-bit output: Programmable full
      RDCOUNT =&gt; RDCOUNT,             -- 13-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      RDRSTBUSY =&gt; RDRSTBUSY,         -- 1-bit output: Reset busy (sync to RDCLK)
      WRCOUNT =&gt; WRCOUNT,             -- 13-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write Error
      WRRSTBUSY =&gt; WRRSTBUSY,         -- 1-bit output: Reset busy (sync to WRCLK)
      -- Cascade Signals inputs: Multi-FIFO cascade signals
      CASDIN =&gt; CASDIN,               -- 32-bit input: Data cascade input bus
      CASDINP =&gt; CASDINP,             -- 4-bit input: Parity data cascade input bus
      CASDOMUX =&gt; CASDOMUX,           -- 1-bit input: Cascade MUX select
      CASDOMUXEN =&gt; CASDOMUXEN,       -- 1-bit input: Enable for cascade MUX select
      CASNXTRDEN =&gt; CASNXTRDEN,       -- 1-bit input: Cascade next read enable
      CASOREGIMUX =&gt; CASOREGIMUX,     -- 1-bit input: Cascade output MUX select
      CASOREGIMUXEN =&gt; CASOREGIMUXEN, -- 1-bit input: Cascade output MUX select enable
      CASPRVEMPTY =&gt; CASPRVEMPTY,     -- 1-bit input: Cascade previous empty
      -- Read Control Signals inputs: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Output register clock enable
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register reset
      SLEEP =&gt; SLEEP,                 -- 1-bit input: Sleep Mode
      -- Write Control Signals inputs: Write clock and enable input signals
      RST =&gt; RST,                     -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Write clock
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data inputs: Write input data
      DIN =&gt; DIN,                     -- 32-bit input: FIFO data input bus
      DINP =&gt; DINP                    -- 4-bit input: FIFO parity input bus
   );

   -- End of FIFO18E2_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E2)" treetype="template">
--  FIFO36E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO36E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO36E2: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FIFO36E2_inst : FIFO36E2
   generic map (
      CASCADE_ORDER =&gt; "NONE",            -- FIRST, LAST, MIDDLE, NONE, PARALLEL
      CLOCK_DOMAINS =&gt; "INDEPENDENT",     -- COMMON, INDEPENDENT
      EN_ECC_PIPE =&gt; "FALSE",             -- ECC pipeline register, (FALSE, TRUE)
      EN_ECC_READ =&gt; "FALSE",             -- Enable ECC decoder, (FALSE, TRUE)
      EN_ECC_WRITE =&gt; "FALSE",            -- Enable ECC encoder, (FALSE, TRUE)
      FIRST_WORD_FALL_THROUGH =&gt; "FALSE", -- FALSE, TRUE
      INIT =&gt; X"000000000000000000",      -- Initial values on output port
      PROG_EMPTY_THRESH =&gt; 256,           -- Programmable Empty Threshold
      PROG_FULL_THRESH =&gt; 256,            -- Programmable Full Threshold
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_RDCLK_INVERTED =&gt; '0',           -- Optional inversion for RDCLK
      IS_RDEN_INVERTED =&gt; '0',            -- Optional inversion for RDEN
      IS_RSTREG_INVERTED =&gt; '0',          -- Optional inversion for RSTREG
      IS_RST_INVERTED =&gt; '0',             -- Optional inversion for RST
      IS_WRCLK_INVERTED =&gt; '0',           -- Optional inversion for WRCLK
      IS_WREN_INVERTED =&gt; '0',            -- Optional inversion for WREN
      RDCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      READ_WIDTH =&gt; 4,                    -- 18-9
      REGISTER_MODE =&gt; "UNREGISTERED",    -- DO_PIPELINED, REGISTERED, UNREGISTERED
      RSTREG_PRIORITY =&gt; "RSTREG",        -- REGCE, RSTREG
      SLEEP_ASYNC =&gt; "FALSE",             -- FALSE, TRUE
      SRVAL =&gt; X"000000000000000000",     -- SET/reset value of the FIFO outputs
      WRCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      WRITE_WIDTH =&gt; 4                    -- 18-9
   )
   port map (
      -- Cascade Signals outputs: Multi-FIFO cascade signals
      CASDOUT =&gt; CASDOUT,             -- 64-bit output: Data cascade output bus
      CASDOUTP =&gt; CASDOUTP,           -- 8-bit output: Parity data cascade output bus
      CASNXTEMPTY =&gt; CASNXTEMPTY,     -- 1-bit output: Cascade next empty
      CASPRVRDEN =&gt; CASPRVRDEN,       -- 1-bit output: Cascade previous read enable
      -- ECC Signals outputs: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Read Data outputs: Read output data
      DOUT =&gt; DOUT,                   -- 64-bit output: FIFO data output bus
      DOUTP =&gt; DOUTP,                 -- 8-bit output: FIFO parity output bus.
      -- Status outputs: Flags and other FIFO status outputs
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty
      FULL =&gt; FULL,                   -- 1-bit output: Full
      PROGEMPTY =&gt; PROGEMPTY,         -- 1-bit output: Programmable empty
      PROGFULL =&gt; PROGFULL,           -- 1-bit output: Programmable full
      RDCOUNT =&gt; RDCOUNT,             -- 14-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      RDRSTBUSY =&gt; RDRSTBUSY,         -- 1-bit output: Reset busy (sync to RDCLK)
      WRCOUNT =&gt; WRCOUNT,             -- 14-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write Error
      WRRSTBUSY =&gt; WRRSTBUSY,         -- 1-bit output: Reset busy (sync to WRCLK)
      -- Cascade Signals inputs: Multi-FIFO cascade signals
      CASDIN =&gt; CASDIN,               -- 64-bit input: Data cascade input bus
      CASDINP =&gt; CASDINP,             -- 8-bit input: Parity data cascade input bus
      CASDOMUX =&gt; CASDOMUX,           -- 1-bit input: Cascade MUX select input
      CASDOMUXEN =&gt; CASDOMUXEN,       -- 1-bit input: Enable for cascade MUX select
      CASNXTRDEN =&gt; CASNXTRDEN,       -- 1-bit input: Cascade next read enable
      CASOREGIMUX =&gt; CASOREGIMUX,     -- 1-bit input: Cascade output MUX select
      CASOREGIMUXEN =&gt; CASOREGIMUXEN, -- 1-bit input: Cascade output MUX select enable
      CASPRVEMPTY =&gt; CASPRVEMPTY,     -- 1-bit input: Cascade previous empty
      -- ECC Signals inputs: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR, -- 1-bit input: Inject a single bit error
      -- Read Control Signals inputs: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Output register clock enable
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register reset
      SLEEP =&gt; SLEEP,                 -- 1-bit input: Sleep Mode
      -- Write Control Signals inputs: Write clock and enable input signals
      RST =&gt; RST,                     -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Write clock
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data inputs: Write input data
      DIN =&gt; DIN,                     -- 64-bit input: FIFO data input bus
      DINP =&gt; DINP                    -- 8-bit input: FIFO parity input bus
   );

   -- End of FIFO36E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLB" treetype="folder">
				<SubFolder label="CARRY" treetype="folder">
					<Template label="Fast Carry Logic with Look Ahead (CARRY8)" treetype="template">
--   CARRY8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CARRY8_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CARRY8: Fast Carry Logic with Look Ahead
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   CARRY8_inst : CARRY8
   generic map (
      CARRY_TYPE =&gt; "SINGLE_CY8"  -- 8-bit or dual 4-bit carry (DUAL_CY4, SINGLE_CY8)
   )
   port map (
      CO =&gt; CO,         -- 8-bit output: Carry-out
      O =&gt; O,           -- 8-bit output: Carry chain XOR data out
      CI =&gt; CI,         -- 1-bit input: Lower Carry-In
      CI_TOP =&gt; CI_TOP, -- 1-bit input: Upper Carry-In
      DI =&gt; DI,         -- 8-bit input: Carry-MUX data in
      S =&gt; S            -- 8-bit input: Carry-mux select
   );

   -- End of CARRY8_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Two input AND gate implemented in place of a CLB Latch (AND2B1L)" treetype="template">
--   AND2B1L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (AND2B1L_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- AND2B1L: Two input AND gate implemented in place of a CLB Latch
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   AND2B1L_inst : AND2B1L
   generic map (
      IS_SRI_INVERTED =&gt; '0'  -- Optional inversion for SRI
   )
   port map (
      O =&gt; O,     -- 1-bit output: AND gate output
      DI =&gt; DI,   -- 1-bit input: Data input connected to LUT logic
      SRI =&gt; SRI  -- 1-bit input: External CLB data
   );

   -- End of AND2B1L_inst instantiation
					</Template>
					<Template label="Two input OR gate implemented in place of a CLB Latch (OR2L)" treetype="template">
--    OR2L     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OR2L_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OR2L: Two input OR gate implemented in place of a CLB Latch
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OR2L_inst : OR2L
   generic map (
      IS_SRI_INVERTED =&gt; '0'  -- Optional inversion for SRI
   )
   port map (
      O =&gt; O,     -- 1-bit output: OR gate output
      DI =&gt; DI,   -- 1-bit input: Data input connected to LUT logic
      SRI =&gt; SRI  -- 1-bit input: External CLB data
   );

   -- End of OR2L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUT" treetype="folder">
					<Template label="1-Bit Look-Up Table (LUT1)" treetype="template">
--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-Bit Look-Up Table
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; X"0"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0  -- 1-bit input: LUT
   );

   -- End of LUT1_inst instantiation
					</Template>
					<Template label="2-Bit Look-Up Table (LUT2)" treetype="template">
--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-Bit Look-Up Table
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1  -- 1-bit input: LUT
   );

   -- End of LUT2_inst instantiation
					</Template>
					<Template label="3-Bit Look-Up Table (LUT3)" treetype="template">
--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-Bit Look-Up Table
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2  -- 1-bit input: LUT
   );

   -- End of LUT3_inst instantiation
					</Template>
					<Template label="4-Bit Look-Up Table (LUT4)" treetype="template">
--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-Bit Look-Up Table
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3  -- 1-bit input: LUT
   );

   -- End of LUT4_inst instantiation
					</Template>
					<Template label="5-Bit Look-Up Table (LUT5)" treetype="template">
--    LUT5     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT5_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5: 5-Bit Look-Up Table
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_inst : LUT5
   generic map (
      INIT =&gt; X"00000000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3, -- 1-bit input: LUT
      I4 =&gt; I4  -- 1-bit input: LUT
   );

   -- End of LUT5_inst instantiation
					</Template>
					<Template label="5-input Dynamically Reconfigurable Look-Up Table (LUT) (CFGLUT5)" treetype="template">
--   CFGLUT5   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CFGLUT5_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CFGLUT5: 5-input Dynamically Reconfigurable Look-Up Table (LUT)
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   CFGLUT5_inst : CFGLUT5
   generic map (
      INIT =&gt; X"00000000",    -- Initial logic function
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      CDO =&gt; CDO, -- 1-bit output: Reconfiguration cascade
      O5 =&gt; O5,   -- 1-bit output: 4-LUT
      O6 =&gt; O6,   -- 1-bit output: 5-LUT
      CDI =&gt; CDI, -- 1-bit input: Reconfiguration data
      CE =&gt; CE,   -- 1-bit input: Reconfiguration enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      -- LUT Inputs inputs: Logic inputs
      I0 =&gt; I0,
      I1 =&gt; I1,
      I2 =&gt; I2,
      I3 =&gt; I3,
      I4 =&gt; I4 
   );

   -- End of CFGLUT5_inst instantiation
					</Template>
					<Template label="6-Bit Look-Up Table (LUT6)" treetype="template">
--    LUT6     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT6_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6: 6-Bit Look-Up Table
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_inst : LUT6
   generic map (
      INIT =&gt; X"0000000000000000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3, -- 1-bit input: LUT
      I4 =&gt; I4, -- 1-bit input: LUT
      I5 =&gt; I5  -- 1-bit input: LUT
   );

   -- End of LUT6_inst instantiation
					</Template>
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
-- The INIT constant for the FPGA LUT primitive is what gives the LUT its 
-- logical value. By default this value is zero thus driving the output to a  
-- zero regardless of the input values (acting as a ground) however in most 
-- cases an new INIT value must be determined in order to specify the logic 
-- function for the LUT primitive.  There are a few methods in which the LUT 
-- value can be determined and two of those methods will be discussed here.
--
-- The Truth Table Method
-- ----------------------
--
--  A common method to determine the desired INIT value for a LUT is using a 
-- truth table.  To do so, simply create a binary truth table of all possible 
-- inputs, specify the desired logic value of the output and then create the 
-- INIT string from those output values.  An example is shown below:
--
-- Example of determining an XOR INIT equation for a LUT4:
--
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | 0 |\
--     |  0  0  0  1 | 1 | \ = 0110 = 6 -----------+
--     |  0  0  1  0 | 1 | /                       |
--     |  0  0  1  1 | 0 |/                        |
--     |-------------|---|                         |
--     |  0  1  0  0 | 1 |\                        |
--     |  0  1  0  1 | 0 | \ = 1001 = 9            |
--     |  0  1  1  0 | 0 | /                       |
--     |  0  1  1  1 | 1 |/                        |                     
--     |-------------|---|               INIT = 6996
--     |  1  0  0  0 | 1 |\                     |
--     |  1  0  0  1 | 0 | \ = 0110 = 9         |
--     |  1  0  1  0 | 0 | /                    |
--     |  1  0  1  1 | 1 |/                     |
--     |-------------|---|                      |
--     |  1  1  0  0 | 0 |\                     |
--     |  1  1  0  1 | 1 | \ = 1001 = 6---------+
--     |  1  1  1  0 | 1 | /
--     |  1  1  1  1 | 0 |/
--     -------------------
--
-- Example of determining a 3-input AND gate:
--
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | 0 |\
--     |  0  0  1 | 0 | \ = 0000 = 0 -----------+
--     |  0  1  0 | 0 | /                       |
--     |  0  1  1 | 0 |/                        |
--     |----------|---|                 INIT = 80 
--     |  1  0  0 | 0 |\                       |
--     |  1  0  1 | 0 | \ = 1000 = 8-----------+
--     |  1  1  0 | 0 | / 
--     |  1  1  1 | 1 |/                      
--     ----------------
--
-- The Equation Method
-- -------------------
--
-- Another method to determine the LUT value is to define constants for each 
-- input to the LUT that correspond to their listed truth value and use those to
-- build the logic equation you are after.  This method is easier to understand 
-- once you have grasped the concept and more self-documenting that the above 
-- method however does require the code to first specify the appropriate 
-- constants.  See the example below.
--
-- Example of specifying the equation (A and B) or (C and D) for a LUT4:
--
   -- The following constants are defined to allow for
   --   equation-based INIT specification.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00"; 


   -- LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; (I3 and I2) or (I1 and I0))
   port map (
      O =&gt; O_LUT,   -- LUT general output
      I0 =&gt; A, -- LUT input
      I1 =&gt; B, -- LUT input
      I2 =&gt; C, -- LUT input
      I3 =&gt; D  -- LUT input
   );
   -- End of LUT4_inst instantiation

-- With the constants specifying all possible cases for the truth table, a 
-- VHDL equation can be written to determine the end INIT value.

						</Template>
						<SubFolder label="INIT Constants" treetype="folder">
							<Template label="LUT1" treetype="template">
   -- The following constant is defined to allow for
   --   equation-based INIT specification for a LUT1.
   constant I0 : BIT_VECTOR(1 downto 0) := "10";
							</Template>
							<Template label="LUT2" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT2.
   constant I0 : BIT_VECTOR(3 downto 0) := X"A";
   constant I1 : BIT_VECTOR(3 downto 0) := X"C";
							</Template>
							<Template label="LUT3" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT3.
   constant I0 : BIT_VECTOR(7 downto 0) := X"AA";
   constant I1 : BIT_VECTOR(7 downto 0) := X"CC";
   constant I2 : BIT_VECTOR(7 downto 0) := X"F0";
							</Template>
							<Template label="LUT4" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT4.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";
							</Template>
							<Template label="LUT5" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT5.
   constant I0 : BIT_VECTOR(31 downto 0) := X"AAAAAAAA";
   constant I1 : BIT_VECTOR(31 downto 0) := X"CCCCCCCC";
   constant I2 : BIT_VECTOR(31 downto 0) := X"F0F0F0F0";
   constant I3 : BIT_VECTOR(31 downto 0) := X"FF00FF00";
   constant I4 : BIT_VECTOR(31 downto 0) := X"FFFF0000";
							</Template>
							<Template label="LUT6" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT6.
   constant I0 : BIT_VECTOR(63 downto 0) := X"AAAAAAAAAAAAAAAA";
   constant I1 : BIT_VECTOR(63 downto 0) := X"CCCCCCCCCCCCCCCC";
   constant I2 : BIT_VECTOR(63 downto 0) := X"F0F0F0F0F0F0F0F0";
   constant I3 : BIT_VECTOR(63 downto 0) := X"FF00FF00FF00FF00";
   constant I4 : BIT_VECTOR(63 downto 0) := X"FFFF0000FFFF0000";
   constant I5 : BIT_VECTOR(63 downto 0) := X"FFFFFFFF00000000";
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
--  Truth Table to determine INIT value for a LUT1
--      ________
--     | I0 | O |
--     |--------|
--     |  0 | ? |\
--     |  1 | ? |/ = 2'b??
--     ----------
							</Template>
							<Template label="LUT2" treetype="template">
--  Truth Table to determine INIT value for a LUT2
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
--     |  0  1  0 | ? | /
--     |  0  1  1 | ? |/ 
--      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
--  Truth Table to determine INIT value for a LUT3
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
--     |  0  1  0 | ? | /                                |
--     |  0  1  1 | ? |/                                 |
--     |----------|---|                       INIT = 8'h?? 
--     |  1  0  0 | ? |\                                |
--     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
--     |  1  1  0 | ? | / 
--     |  1  1  1 | ? |/                      
--     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
--  Truth Table to determine INIT value for a LUT4
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | ? |\
--     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
--     |  0  0  1  0 | ? | /                                 |
--     |  0  0  1  1 | ? |/                                  |
--     |-------------|---|                                   |
--     |  0  1  0  0 | ? |\                                  |
--     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
--     |  0  1  1  0 | ? | /                                 |
--     |  0  1  1  1 | ? |/                                  |                     
--     |-------------|---|                     INIT = 16'h????
--     |  1  0  0  0 | ? |\                               |
--     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  0 | ? | /                              |
--     |  1  0  1  1 | ? |/                               |
--     |-------------|---|                                |
--     |  1  1  0  0 | ? |\                               |
--     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  0 | ? | /
--     |  1  1  1  1 | ? |/
--     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
--  Truth Table to determine INIT value for a LUT5
--      ____________________
--     | I4 I3 I2 I1 I0 | O |
--     |--------------------|
--     |  0  0  0  0  0 | ? |\
--     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  0  1  0  0 | ? |\                                      |
--     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1 | ? |/                                      |                     
--     |----------------|---|                                       |
--     |  0  1  0  0  0 | ? |\                                      |
--     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  0 | ? | /                                     |
--     |  0  1  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  1  0  0 | ? |\                                      |
--     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1 | ? |/                                      |
--     ----------------------                     INIT = 32'h????????
--     |  1  0  0  0  0 | ? |\                               |
--     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  0  1  0 | ? | /                              |
--     |  1  0  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  0  1  0  0 | ? |\                               |
--     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  1  0 | ? | /                              |
--     |  1  0  1  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  0  0  0 | ? |\                               |
--     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  1  0  1  0 | ? | /                              |
--     |  1  1  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  1  0  0 | ? |\                               |
--     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1 | ? |/
--     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
--  Truth Table to determine INIT value for a LUT6
--      _______________________
--     | I5 I4 I3 I2 I1 I0 | O |
--     |-----------------------|
--     |  0  0  0  0  0  0 | ? |\
--     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  0  1  0  0 | ? |\                                      |
--     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  0  1  1  0 | ? | /                                     |
--     |  0  0  0  1  1  1 | ? |/                                      |                     
--     |-------------------|---|                                       |
--     |  0  0  1  0  0  0 | ? |\                                      |
--     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  0  1  0 | ? | /                                     |
--     |  0  0  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  1  0  0 | ? |\                                      |
--     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1  1 | ? |/                                      |
--     -------------------------                                       |
--     |  0  1  0  0  0  0 | ? |\                                      |
--     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  0  1  0 | ? | /                                     |
--     |  0  1  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  0  1  0  0 | ? |\                                      |
--     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  1  0 | ? | /                                     |
--     |  0  1  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  0  0  0 | ? |\                                      |
--     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  0  1  0 | ? | /                                     |
--     |  0  1  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  1  0  0 | ? |\                                      |
--     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1  1 | ? |/                                      |
--     ------------------------              INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     -----------------------
							</Template>
							<Template label="LUT6_2" treetype="template">
--  Truth Table to determine INIT value for a LUT6_2
--      _____________________________
--     | I5 I4 I3 I2 I1 I0 | O6 | O5 |
--     |-----------------------------|
--     |  0  0  0  0  0  0 |    ?    |\
--     |  0  0  0  0  0  1 |    ?    | \ = 4'b???? = 4'h? -------------+
--     |  0  0  0  0  1  0 |    ?    | /                               |
--     |  0  0  0  0  1  1 |	?    |/				       |
--     |-------------------|---------|                                 |
--     |  0  0  0  1  0  0 |	?    |\                                |
--     |  0  0  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  0  0  1  1  0 |	?    | /                               |
--     |  0  0  0  1  1  1 |	?    |/                                |                     
--     |-------------------|---------|                                 |
--     |  0  0  1  0  0  0 |	?    |\                                |
--     |  0  0  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  0  1  0  1  0 |	?    | /                               |
--     |  0  0  1  0  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  0  1  1  0  0 |	?    |\                                |
--     |  0  0  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  0  1  1  1  0 |	?    | /                               |
--     |  0  0  1  1  1  1 |	?    |/                                |
--     -------------------------------                                 |
--     |  0  1  0  0  0  0 |	?    |\                                |
--     |  0  1  0  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  0  0  1  0 |	?    | /                               |
--     |  0  1  0  0  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  1  0  1  0  0 |	?    |\                                |
--     |  0  1  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  0  1  1  0 |	?    | /                               |
--     |  0  1  0  1  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  1  1  0  0  0 |	?    |\                                |
--     |  0  1  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  1  0  1  0 |	?    | /                               |
--     |  0  1  1  0  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  1  1  1  0  0 |	?    |\                                |
--     |  0  1  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  1  1  1  0 |	?    | /                               |
--     |  0  1  1  1  1  1 |	?    |/                                |
--     ------------------------------        INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT6_2" treetype="template">

--   LUT6_2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_2: 6-input  2 output Look-Up Table
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_2_inst : LUT6_2
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      O6 =&gt; O6,  -- 6/5-LUT output (1-bit)
      O5 =&gt; O5,  -- 5-LUT output (1-bit)
      I0 =&gt; I0,   -- LUT input (1-bit)
      I1 =&gt; I1,   -- LUT input (1-bit)
      I2 =&gt; I2,   -- LUT input (1-bit)
      I3 =&gt; I3,   -- LUT input (1-bit)
      I4 =&gt; I4,   -- LUT input (1-bit)
      I5 =&gt; I5    -- LUT input (1-bit)
   );

   -- End of LUT6_2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUTRAM" treetype="folder">
					<Template label="64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM) (RAM64X8SW)" treetype="template">
--  RAM64X8SW  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAM64X8SW_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X8SW: 64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM)
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X8SW_inst : RAM64X8SW
   generic map (
      INIT_A =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 7
      INIT_B =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 6
      INIT_C =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 5
      INIT_D =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 4
      INIT_E =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 3
      INIT_F =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 2
      INIT_G =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 1
      INIT_H =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 0
      IS_WCLK_INVERTED =&gt; '0'        -- Optional inversion for WCLK
   )
   port map (
      O =&gt; O,       -- 8-bit data output
      A =&gt; A,       -- 6-bit address input
      D =&gt; D,       -- 1-bit input: Write data input
      WCLK =&gt; WCLK, -- 1-bit input: Write clock input
      WE =&gt; WE,     -- 1-bit input: Write enable input
      WSEL =&gt; WSEL  -- 3-bit write select
   );

   -- End of RAM64X8SW_inst instantiation
					</Template>
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 x 1 negedge write (RAM32X1D_1)" treetype="template">

-- RAM32X1D_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_1_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D_1: 32 x 1 negative edge write, asynchronous read 
   --             dual-port distributed RAM
   --             Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1_inst : RAM32X1D_1
   generic map (
      INIT =&gt; X"00000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_1_inst instantiation
						</Template>
						<Template label="32 x 1 posedge write (RAM32X1D)" treetype="template">

--   RAM32X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D: 32 x 1 positive edge write, asynchronous read 
   --              dual-port distributed RAM
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_inst : RAM32X1D
   generic map (
      INIT =&gt; X"00000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_inst instantiation

						</Template>
						<Template label="64 x 1 posedge write (RAM64X1D)" treetype="template">

--   RAM64X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1D: 64 x 1 positive edge write, asynchronous read 
   --           dual-port distributed RAM
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1D_inst : RAM64X1D
   generic map (
      INIT =&gt; X"0000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      A5 =&gt; A5,       -- R/W address[5] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      DPRA5 =&gt; DPRA5, -- Read-only address[5] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM64X1D_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">

--  RAM128X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read 
   --            dual-port distributed LUT RAM
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1D_inst : RAM128X1D
   generic map (
      INIT =&gt; X"00000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read/Write port 1-bit ouput
      SPO =&gt; SPO,     -- Read port 1-bit output
      A =&gt; A,         -- Read/Write port 7-bit address input
      D =&gt; D,         -- RAM data input
      DPRA =&gt; DPRA,   -- Read port 7-bit address input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1D_inst instantiation

						</Template>
						<Template label="256 X 1 posedge write (RAM256X1D)" treetype="template">

--  RAM256X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM256X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM256X1D: 256-deep by 1-wide positive edge write, asynchronous read 
   --            dual-port distributed LUT RAM
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM256X1D_inst : RAM256X1D
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read/Write port 1-bit ouput
      SPO =&gt; SPO,     -- Read port 1-bit output
      A =&gt; A,         -- Read/Write port 8-bit address input
      D =&gt; D,         -- RAM data input
      DPRA =&gt; DPRA,   -- Read port 8-bit address input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM256X1D_inst instantiation


						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">

--   RAM32M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M: 32-deep by 8-wide Multi Port LUT RAM
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32M_inst : RAM32M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",    -- Initial contents of D port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read/Write port D 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 5-bit address input
      DIA =&gt; DIA, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M_inst instantiation


--   RAM32M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M: 32-deep by 8-wide Multi Port LUT RAM
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32M_inst : RAM32M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",    -- Initial contents of D port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read/Write port D 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 5-bit address input
      DIA =&gt; DIA, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M_inst instantiation
						</Template>
						<Template label="32 X 16 (RAM32M16)" treetype="template">
--   RAM32M16  : In order to incorporate this function into the design,
--     VHDL    : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M16_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M16: 32-deep by 16-wide Multi Port LUT RAM
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4
 RAM32M16_inst : RAM32M16
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",   -- Initial contents of D port
      INIT_E =&gt; X"0000000000000000",   -- Initial contents of E port
      INIT_F =&gt; X"0000000000000000",   -- Initial contents of F port
      INIT_G =&gt; X"0000000000000000",   -- Initial contents of G port
      INIT_H =&gt; X"0000000000000000",   -- Initial contents of H port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read port D 2-bit output
      DOE =&gt; DOE, -- Read port E 2-bit output
      DOF =&gt; DOF, -- Read port F 2-bit output
      DOG =&gt; DOG, -- Read port G 2-bit output
      DOH =&gt; DOH, -- Read/write port H 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read port D 5-bit address input
      ADDRE =&gt; ADDRE,   -- Read port E 5-bit address input
      ADDRF =&gt; ADDRF,   -- Read port F 5-bit address input
      ADDRG =&gt; ADDRG,   -- Read port G 5-bit address input
      ADDRH =&gt; ADDRH,   -- Read/write port H 5-bit address input
      DIA =&gt; DIA,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRA
      DIB =&gt; DIB,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRB
      DIC =&gt; DIC,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRC
      DID =&gt; DID,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRD
      DIE =&gt; DIE,       -- RAM 2-bit data write input addressed by ADDRE,
                        -- read addressed by ADDRE
      DIF =&gt; DIF,       -- RAM 2-bit data write input addressed by ADDRF,
                        -- read addressed by ADDRF
      DIG =&gt; DIG,       -- RAM 2-bit data write input addressed by ADDRG,
                        -- read addressed by ADDRG
      DIH =&gt; DIH,       -- RAM 2-bit data write input addressed by ADDRH,
                        -- read addressed by ADDRH
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M16_inst instantiation
						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">

--   RAM64M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64M: 64-deep by 4-wide Multi Port LUT RAM 
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM64M_inst : RAM64M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",    -- Initial contents of D port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 1-bit output
      DOB =&gt; DOB, -- Read port B 1-bit output
      DOC =&gt; DOC, -- Read port C 1-bit output
      DOD =&gt; DOD, -- Read/Write port D 1-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 6-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 6-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 6-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 6-bit address input
      DIA =&gt; DIA, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM64M_inst instantiation

						</Template>
						<Template label="64 X 8 (RAM64M8)" treetype="template">
--   RAM64M8  : In order to incorporate this function into the design,
--     VHDL    : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64M8_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64M8: 64-deep by 8-wide Multi Port LUT RAM
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4
 RAM64M8_inst : RAM64M8
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",   -- Initial contents of D port
      INIT_E =&gt; X"0000000000000000",   -- Initial contents of E port
      INIT_F =&gt; X"0000000000000000",   -- Initial contents of F port
      INIT_G =&gt; X"0000000000000000",   -- Initial contents of G port
      INIT_H =&gt; X"0000000000000000",   -- Initial contents of H port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 1-bit output
      DOB =&gt; DOB, -- Read port B 1-bit output
      DOC =&gt; DOC, -- Read port C 1-bit output
      DOD =&gt; DOD, -- Read port D 1-bit output
      DOE =&gt; DOE, -- Read port E 1-bit output
      DOF =&gt; DOF, -- Read port F 1-bit output
      DOG =&gt; DOG, -- Read port G 1-bit output
      DOH =&gt; DOH, -- Read/write port H 1-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 6-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 6-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 6-bit address input
      ADDRD =&gt; ADDRD,   -- Read port D 6-bit address input
      ADDRE =&gt; ADDRE,   -- Read port E 6-bit address input
      ADDRF =&gt; ADDRF,   -- Read port F 6-bit address input
      ADDRG =&gt; ADDRG,   -- Read port G 6-bit address input
      ADDRH =&gt; ADDRH,   -- Read/write port H 6-bit address input
      DIA =&gt; DIA,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRA
      DIB =&gt; DIB,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRB
      DIC =&gt; DIC,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRC
      DID =&gt; DID,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRD
      DIE =&gt; DIE,       -- RAM 1-bit data write input addressed by ADDRE,
                        -- read addressed by ADDRE
      DIF =&gt; DIF,       -- RAM 1-bit data write input addressed by ADDRF,
                        -- read addressed by ADDRF
      DIG =&gt; DIG,       -- RAM 1-bit data write input addressed by ADDRG,
                        -- read addressed by ADDRG
      DIH =&gt; DIH,       -- RAM 1-bit data write input addressed by ADDRH,
                        -- read addressed by ADDRH
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64M8_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">

--  RAM32X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM 
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1S_inst : RAM32X1S
   generic map (
      INIT =&gt; X"00000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,       -- RAM output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D =&gt; D,       -- RAM data input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X1S_inst instantiation
						</Template>
						<SubFolder label="64 Deep (6-bit address)" treetype="folder">
							<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">

--  RAM64X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port distributed RAM
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1S_inst : RAM64X1S
   generic map (
      INIT =&gt; X"0000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,        -- 1-bit data output
      A0 =&gt; A0,      -- Address[0] input bit
      A1 =&gt; A1,      -- Address[1] input bit
      A2 =&gt; A2,      -- Address[2] input bit
      A3 =&gt; A3,      -- Address[3] input bit
      A4 =&gt; A4,      -- Address[4] input bit
      A5 =&gt; A5,      -- Address[5] input bit
      D =&gt; D,        -- 1-bit data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="128 Deep (7-bit address)" treetype="folder">
							<Template label="128 x 1 negedge write (RAM128X1S_1)" treetype="template">

--RAM128X1S_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S_1: 128-deep x 1 negative edge write, asynchronous read 
   --              single-port distributed RAM
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation
							</Template>
							<Template label="128 x 1 posedge write (RAM128X1S)" treetype="template">

--  RAM128X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S: 128-deep x 1 positive edge write, asynchronous read 
   --            single-port distributed RAM
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation

							</Template>
						</SubFolder>
						<SubFolder label="256 Deep (8-bit address)" treetype="folder">
							<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">

--  RAM256X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM256X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read 
   --            single-port distributed LUT RAM
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM256X1S_inst : RAM256X1S
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,  -- Read/Write port 1-bit ouput
      A =&gt; A,  -- Read/Write port 8-bit address input
      D =&gt; D,  -- RAM data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE -- Write enable input
   );

   -- End of RAM256X1S_inst instantiation

							</Template>
						</SubFolder>
						<SubFolder label="512 Deep (9-bit address)" treetype="folder">
							<Template label="512 X 1 posedge write (RAM512X1S)" treetype="template">

--  RAM512X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM512X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM512X1S: 512-deep by 1-wide positive edge write, asynchronous read 
   --            single-port distributed LUT RAM
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM512X1S_inst : RAM512X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,  -- Read/Write port 1-bit ouput
      A =&gt; A,  -- Read/Write port 9-bit address input
      D =&gt; D,  -- RAM data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE -- Write enable input
   );

   -- End of RAM512X1S_inst instantiation

							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="MUXF" treetype="folder">
					<Template label="CLB MUX to connect two LUT6's Together (MUXF7)" treetype="template">
--    MUXF7    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF7_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7: CLB MUX to connect two LUT6's Together
   --        Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_inst : MUXF7
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to LUT6 output
      I1 =&gt; I1, -- 1-bit input: Connect to LUT6 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF7_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF7's Together (MUXF8)" treetype="template">
--    MUXF8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF8_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8: CLB MUX to connect two MUXF7's Together
   --        Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_inst : MUXF8
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to MUXF7 output
      I1 =&gt; I1, -- 1-bit input: Connect to MUXF7 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF8_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF8's Together (MUXF9)" treetype="template">
--    MUXF9    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF9_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF9: CLB MUX to connect two MUXF8's Together
   --        Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MUXF9_inst : MUXF9
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to MUXF8 output
      I1 =&gt; I1, -- 1-bit input: Connect to MUXF8 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF9_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="16-Bit Shift Register Look-Up Table (LUT) (SRL16E)" treetype="template">
--   SRL16E    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SRL16E_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRL16E: 16-Bit Shift Register Look-Up Table (LUT)
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   SRL16E_inst : SRL16E
   generic map (
      INIT =&gt; X"0000",        -- Initial contents of shift register
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: SRL Data
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      D =&gt; D,     -- 1-bit input: SRL Data
      -- Depth Selection inputs: A0-A3 select SRL depth
      A0 =&gt; A0,
      A1 =&gt; A1,
      A2 =&gt; A2,
      A3 =&gt; A3 
   );

   -- End of SRL16E_inst instantiation
					</Template>
					<Template label="32-Bit Shift Register Look-Up Table (LUT) (SRLC32E)" treetype="template">
--   SRLC32E   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SRLC32E_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRLC32E: 32-Bit Shift Register Look-Up Table (LUT)
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   SRLC32E_inst : SRLC32E
   generic map (
      INIT =&gt; X"00000000",    -- Initial contents of shift register
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: SRL Data
      Q31 =&gt; Q31, -- 1-bit output: SRL Cascade Data
      A =&gt; A,     -- 5-bit input: Selects SRL depth
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      D =&gt; D      -- 1-bit input: SRL Data
   );

   -- End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLOCK" treetype="folder">
				<SubFolder label="BUFFER" treetype="folder">
					<Template label="Clock Buffer Driven by Gigabit Transceiver (BUFG_GT)" treetype="template">
--   BUFG_GT   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_GT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_GT: Clock Buffer Driven by Gigabit Transceiver
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_GT_inst : BUFG_GT
   port map (
      O =&gt; O,             -- 1-bit output: Buffer
      CE =&gt; CE,           -- 1-bit input: Buffer enable
      CEMASK =&gt; CEMASK,   -- 1-bit input: CE Mask
      CLR =&gt; CLR,         -- 1-bit input: Asynchronous clear
      CLRMASK =&gt; CLRMASK, -- 1-bit input: CLR Mask
      DIV =&gt; DIV,         -- 3-bit input: Dynamic divide Value
      I =&gt; I              -- 1-bit input: Buffer
   );

   -- End of BUFG_GT_inst instantiation
					</Template>
					<Template label="General Clock Buffer (BUFG)" treetype="template">
--    BUFG     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG: General Clock Buffer
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_inst : BUFG
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFG_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
--   BUFGCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE: General Clock Buffer with Clock Enable
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_inst : BUFGCE
   generic map (
      CE_TYPE =&gt; "SYNC",     -- ASYNC, SYNC
      IS_CE_INVERTED =&gt; '0', -- Programmable inversion on CE
      IS_I_INVERTED =&gt; '0'   -- Programmable inversion on I
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer
      CE =&gt; CE, -- 1-bit input: Buffer enable
      I =&gt; I    -- 1-bit input: Buffer
   );

   -- End of BUFGCE_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Divide (BUFGCE_DIV)" treetype="template">
-- BUFGCE_DIV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_DIV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_DIV: General Clock Buffer with Divide Function
   --             Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_DIV_inst : BUFGCE_DIV
   generic map (
      BUFGCE_DIVIDE =&gt; 1,     -- 1-8
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CE_INVERTED =&gt; '0',  -- Optional inversion for CE
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_I_INVERTED =&gt; '0'    -- Optional inversion for I
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer
      CE =&gt; CE,   -- 1-bit input: Buffer enable
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      I =&gt; I      -- 1-bit input: Buffer
   );

   -- End of BUFGCE_DIV_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
--  BUFGCE_1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_1: General Clock Buffer with Clock Enable and Output State 1
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_1_inst : BUFGCE_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock buffer active-High enable
      I =&gt; I    -- 1-bit input: Clock input
   );

   -- End of BUFGCE_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="CLOCK_SYNC" treetype="folder">
					<Template label="Synchronizer for BUFG_GT Control Signals (BUFG_GT_SYNC)" treetype="template">
-- BUFG_GT_SYNC : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFG_GT_SYNC_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_GT_SYNC: Synchronizer for BUFG_GT Control Signals
   --               Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_GT_SYNC_inst : BUFG_GT_SYNC
   port map (
      CESYNC =&gt; CESYNC,   -- 1-bit output: Synchronized CE
      CLRSYNC =&gt; CLRSYNC, -- 1-bit output: Synchronized CLR
      CE =&gt; CE,           -- 1-bit input: Asynchronous enable
      CLK =&gt; CLK,         -- 1-bit input: Clock
      CLR =&gt; CLR          -- 1-bit input: Asynchronous clear
   );

   -- End of BUFG_GT_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUX" treetype="folder">
					<Template label="2-to-1 General Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
-- BUFGMUX_CTRL : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_CTRL: 2-to-1 General Clock MUX Buffer
   --               Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL_inst : BUFGMUX_CTRL
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="General Clock Control Buffer (BUFGCTRL)" treetype="template">
--  BUFGCTRL   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCTRL: General Clock Control Buffer
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCTRL_inst : BUFGCTRL
   generic map (
      INIT_OUT =&gt; 0,              -- Initial value of BUFGCTRL output, 0-1
      PRESELECT_I0 =&gt; FALSE,      -- BUFGCTRL output uses I0 input, FALSE, TRUE
      PRESELECT_I1 =&gt; FALSE,      -- BUFGCTRL output uses I1 input, FALSE, TRUE
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CE0_INVERTED =&gt; '0',     -- Optional inversion for CE0
      IS_CE1_INVERTED =&gt; '0',     -- Optional inversion for CE1
      IS_I0_INVERTED =&gt; '0',      -- Optional inversion for I0
      IS_I1_INVERTED =&gt; '0',      -- Optional inversion for I1
      IS_IGNORE0_INVERTED =&gt; '0', -- Optional inversion for IGNORE0
      IS_IGNORE1_INVERTED =&gt; '0', -- Optional inversion for IGNORE1
      IS_S0_INVERTED =&gt; '0',      -- Optional inversion for S0
      IS_S1_INVERTED =&gt; '0'       -- Optional inversion for S1
   )
   port map (
      O =&gt; O,             -- 1-bit output: Clock output
      CE0 =&gt; CE0,         -- 1-bit input: Clock enable input for I0
      CE1 =&gt; CE1,         -- 1-bit input: Clock enable input for I1
      I0 =&gt; I0,           -- 1-bit input: Primary clock
      I1 =&gt; I1,           -- 1-bit input: Secondary clock
      IGNORE0 =&gt; IGNORE0, -- 1-bit input: Clock ignore input for I0
      IGNORE1 =&gt; IGNORE1, -- 1-bit input: Clock ignore input for I1
      S0 =&gt; S0,           -- 1-bit input: Clock select for I0
      S1 =&gt; S1            -- 1-bit input: Clock select for I1
   );

   -- End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer (BUFGMUX)" treetype="template">
--   BUFGMUX   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX: General Clock Mux Buffer
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_inst : BUFGMUX
   generic map (
      CLK_SEL_TYPE =&gt; "SYNC"  -- ASYNC, SYNC
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
--  BUFGMUX_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_1: General Clock Mux Buffer with Output State 1
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1_inst : BUFGMUX_1
   generic map (
      CLK_SEL_TYPE =&gt; "SYNC"  -- ASYNC, SYNC
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME3_ADV)" treetype="template">
-- MMCME3_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME3_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME3_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   --             Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MMCME3_ADV_inst : MMCME3_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",        -- Jitter programming (HIGH, LOW, OPTIMIZED)
      CLKFBOUT_MULT_F =&gt; 5.0,          -- Multiply value for all CLKOUT (2.000-64.000)
      CLKFBOUT_PHASE =&gt; 0.0,           -- Phase offset in degrees of CLKFB (-360.000-360.000)
      -- CLKIN_PERIOD: Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      CLKOUT0_DIVIDE_F =&gt; 1.0,         -- Divide amount for CLKOUT0 (1.000-128.000)
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      -- CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_CASCADE =&gt; "FALSE",
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      COMPENSATION =&gt; "AUTO",          -- AUTO, BUF_IN, EXTERNAL, INTERNAL, ZHOLD
      DIVCLK_DIVIDE =&gt; 1,              -- Master division value (1-106)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0',      -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',       -- Optional inversion for CLKIN1
      IS_CLKIN2_INVERTED =&gt; '0',       -- Optional inversion for CLKIN2
      IS_CLKINSEL_INVERTED =&gt; '0',     -- Optional inversion for CLKINSEL
      IS_PSEN_INVERTED =&gt; '0',         -- Optional inversion for PSEN
      IS_PSINCDEC_INVERTED =&gt; '0',     -- Optional inversion for PSINCDEC
      IS_PWRDWN_INVERTED =&gt; '0',       -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',          -- Optional inversion for RST
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; "FALSE",         -- Delays DONE until MMCM is locked (FALSE, TRUE)
      -- Spread Spectrum: Spread Spectrum Attributes
      SS_EN =&gt; "FALSE",                -- Enables spread spectrum (FALSE, TRUE)
      SS_MODE =&gt; "CENTER_HIGH",        -- CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      SS_MOD_PERIOD =&gt; 10000,          -- Spread spectrum modulation period (ns) (4000-40000)
      -- USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      CLKFBOUT_USE_FINE_PS =&gt; "FALSE",
      CLKOUT0_USE_FINE_PS =&gt; "FALSE",
      CLKOUT1_USE_FINE_PS =&gt; "FALSE",
      CLKOUT2_USE_FINE_PS =&gt; "FALSE",
      CLKOUT3_USE_FINE_PS =&gt; "FALSE",
      CLKOUT4_USE_FINE_PS =&gt; "FALSE",
      CLKOUT5_USE_FINE_PS =&gt; "FALSE",
      CLKOUT6_USE_FINE_PS =&gt; "FALSE" 
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,           -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,         -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,           -- 1-bit output: Primary clock
      CLKOUT1B =&gt; CLKOUT1B,         -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,           -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,         -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,           -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,         -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,           -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,           -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,           -- 1-bit output: CLKOUT6
      -- DRP Ports outputs: Dynamic reconfiguration ports
      DO =&gt; DO,                     -- 16-bit output: DRP data
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP ready
      -- Dynamic Phase Shift Ports outputs: Ports used for dynamic phase shifting of the outputs
      PSDONE =&gt; PSDONE,             -- 1-bit output: Phase shift done
      -- Feedback outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,         -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB,       -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports outputs: MMCM status ports
      CDDCDONE =&gt; CDDCDONE,         -- 1-bit output: Clock dynamic divide done
      CLKFBSTOPPED =&gt; CLKFBSTOPPED, -- 1-bit output: Feedback clock stopped
      CLKINSTOPPED =&gt; CLKINSTOPPED, -- 1-bit output: Input clock stopped
      LOCKED =&gt; LOCKED,             -- 1-bit output: LOCK
      CDDCREQ =&gt; CDDCREQ,           -- 1-bit input: Request to dynamic divide clock
      -- Clock Inputs inputs: Clock inputs
      CLKIN1 =&gt; CLKIN1,             -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,             -- 1-bit input: Secondary clock
      -- Control Ports inputs: MMCM control ports
      CLKINSEL =&gt; CLKINSEL,         -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,             -- 1-bit input: Power-down
      RST =&gt; RST,                   -- 1-bit input: Reset
      -- DRP Ports inputs: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable
      DI =&gt; DI,                     -- 16-bit input: DRP data
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- Dynamic Phase Shift Ports inputs: Ports used for dynamic phase shifting of the outputs
      PSCLK =&gt; PSCLK,               -- 1-bit input: Phase shift clock
      PSEN =&gt; PSEN,                 -- 1-bit input: Phase shift enable
      PSINCDEC =&gt; PSINCDEC,         -- 1-bit input: Phase shift increment/decrement
      -- Feedback inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN            -- 1-bit input: Feedback clock
   );

   -- End of MMCME3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE3_ADV)" treetype="template">
--  PLLE3_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE3_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE3_ADV: Advanced Phase-Locked Loop (PLL)
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   PLLE3_ADV_inst : PLLE3_ADV
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT, (1-19)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB, (-360.000-360.000)
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0 (1-128)
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0 (0.001-0.999)
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0 (-360.000-360.000)
      -- CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1 (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1 (0.001-0.999)
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1 (-360.000-360.000)
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      COMPENSATION =&gt; "AUTO",     -- AUTO, BUF_IN, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value, (1-15)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      -- DRP Ports outputs: Dynamic reconfiguration ports
      DO =&gt; DO,                   -- 16-bit output: DRP data
      DRDY =&gt; DRDY,               -- 1-bit output: DRP ready
      -- Feedback Clocks outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      -- Control Ports inputs: PLL control ports
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST,                 -- 1-bit input: Reset
      -- DRP Ports inputs: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,             -- 7-bit input: DRP address
      DCLK =&gt; DCLK,               -- 1-bit input: DRP clock
      DEN =&gt; DEN,                 -- 1-bit input: DRP enable
      DI =&gt; DI,                   -- 16-bit input: DRP data
      DWE =&gt; DWE,                 -- 1-bit input: DRP write enable
      -- Feedback Clocks inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN          -- 1-bit input: Feedback clock
   );

   -- End of PLLE3_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME3_BASE)" treetype="template">
-- MMCME3_BASE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME3_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME3_BASE: Base Mixed Mode Clock Manager (MMCM)
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MMCME3_BASE_inst : MMCME3_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",   -- Jitter programming (HIGH, LOW, OPTIMIZED)
      CLKFBOUT_MULT_F =&gt; 5.0,     -- Multiply value for all CLKOUT (2.000-64.000)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB (-360.000-360.000)
      CLKIN1_PERIOD =&gt; 0.0,       -- Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE_F =&gt; 1.0,    -- Divide amount for CLKOUT0 (1.000-128.000)
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      -- CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT4_CASCADE =&gt; "FALSE", -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value (1-106)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',  -- Optional inversion for CLKIN1
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER1 =&gt; 0.0,         -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,     -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,   -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,     -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,   -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,     -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,   -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,     -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,   -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,     -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,     -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,     -- 1-bit output: CLKOUT6
      -- Feedback outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,   -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB, -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports outputs: MMCM status ports
      LOCKED =&gt; LOCKED,       -- 1-bit output: LOCK
      -- Clock Inputs inputs: Clock input
      CLKIN1 =&gt; CLKIN1,       -- 1-bit input: Clock
      -- Control Ports inputs: MMCM control ports
      PWRDWN =&gt; PWRDWN,       -- 1-bit input: Power-down
      RST =&gt; RST,             -- 1-bit input: Reset
      -- Feedback inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN      -- 1-bit input: Feedback clock
   );

   -- End of MMCME3_BASE_inst instantiation
					</Template>
					<Template label="Base Phase-Locked Loop (PLL) (PLLE3_BASE)" treetype="template">
-- PLLE3_BASE  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE3_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE3_BASE: Base Phase-Locked Loop (PLL)
   --             Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   PLLE3_BASE_inst : PLLE3_BASE
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT, (1-19)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB, (-360.000-360.000)
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0 (1-128)
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0 (0.001-0.999)
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0 (-360.000-360.000)
      -- CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1 (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1 (0.001-0.999)
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1 (-360.000-360.000)
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value, (1-15)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      -- Feedback Clocks outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      -- Control Ports inputs: PLL control ports
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST,                 -- 1-bit input: Reset
      -- Feedback Clocks inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN          -- 1-bit input: Feedback clock
   );

   -- End of PLLE3_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CONFIGURATION" treetype="folder">
				<SubFolder label="BSCAN" treetype="folder">
					<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
--   BSCANE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BSCANE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BSCANE2: Boundary-Scan User Instruction
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BSCANE2_inst : BSCANE2
   generic map (
      JTAG_CHAIN =&gt; 1  -- Value for USER command
   )
   port map (
      CAPTURE =&gt; CAPTURE, -- 1-bit output: CAPTURE output from TAP controller.
      DRCK =&gt; DRCK,       -- 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                          -- SHIFT are asserted.

      RESET =&gt; RESET,     -- 1-bit output: Reset output for TAP controller.
      RUNTEST =&gt; RUNTEST, -- 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      SEL =&gt; SEL,         -- 1-bit output: USER instruction active output.
      SHIFT =&gt; SHIFT,     -- 1-bit output: SHIFT output from TAP controller.
      TCK =&gt; TCK,         -- 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      TDI =&gt; TDI,         -- 1-bit output: Test Data Input (TDI) output from TAP controller.
      TMS =&gt; TMS,         -- 1-bit output: Test Mode Select output. Fabric connection to TAP.
      UPDATE =&gt; UPDATE,   -- 1-bit output: UPDATE output from TAP controller
      TDO =&gt; TDO          -- 1-bit input: Test Data Output (TDO) input for USER function.
   );

   -- End of BSCANE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DNA" treetype="folder">
					<Template label="Device DNA Access Port (DNA_PORTE2)" treetype="template">
-- DNA_PORTE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DNA_PORTE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DNA_PORTE2: Device DNA Access Port
   --             Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   DNA_PORTE2_inst : DNA_PORTE2
   generic map (
      SIM_DNA_VALUE =&gt; X"000000000000000000000000"  -- Specifies a sample 96-bit DNA value for simulation
   )
   port map (
      DOUT =&gt; DOUT,   -- 1-bit output: DNA output data
      CLK =&gt; CLK,     -- 1-bit input: Clock input
      DIN =&gt; DIN,     -- 1-bit input: User data input pin
      READ =&gt; READ,   -- 1-bit input: Active-High load DNA, active-Low read input
      SHIFT =&gt; SHIFT  -- 1-bit input: Active-High shift enable input
   );

   -- End of DNA_PORTE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="EFUSE" treetype="folder">
					<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
--  EFUSE_USR  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (EFUSE_USR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EFUSE_USR: 32-bit non-volatile design ID
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   EFUSE_USR_inst : EFUSE_USR
   generic map (
      SIM_EFUSE_VALUE =&gt; X"00000000"  -- Value of the 32-bit non-volatile value used in simulation
   )
   port map (
      EFUSEUSR =&gt; EFUSEUSR  -- 32-bit output: User eFUSE register value output
   );

   -- End of EFUSE_USR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="ICAP" treetype="folder">
					<Template label="Internal Configuration Access Port (ICAPE3)" treetype="template">
--   ICAPE3    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ICAPE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ICAPE3: Internal Configuration Access Port
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   ICAPE3_inst : ICAPE3
   generic map (
      DEVICE_ID =&gt; X"03628093",      -- Specifies the pre-programmed Device ID value to be used for simulation
                                     -- purposes.
      ICAP_AUTO_SWITCH =&gt; "DISABLE", -- Enable switch ICAP using sync word
      SIM_CFG_FILE_NAME =&gt; "NONE"    -- Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                     -- model
   )
   port map (
      AVAIL =&gt; AVAIL,     -- 1-bit output: Availability status of ICAP
      O =&gt; O,             -- 32-bit output: Configuration data output bus
      PRDONE =&gt; PRDONE,   -- 1-bit output: Indicates completion of Partial Reconfiguration
      PRERROR =&gt; PRERROR, -- 1-bit output: Indicates Error during Partial Reconfiguration
      CLK =&gt; CLK,         -- 1-bit input: Clock input
      CSIB =&gt; CSIB,       -- 1-bit input: Active-Low ICAP enable
      I =&gt; I,             -- 32-bit input: Configuration data input bus
      RDWRB =&gt; RDWRB      -- 1-bit input: Read/Write Select input
   );

   -- End of ICAPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MASTER_JTAG" treetype="folder">
					<Template label="JTAG Port Access (MASTER_JTAG)" treetype="template">
-- MASTER_JTAG : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MASTER_JTAG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MASTER_JTAG: JTAG Port Access
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MASTER_JTAG_inst : MASTER_JTAG
   port map (
      TDO =&gt; TDO, -- 1-bit output: JTAG TDO output pin
      TCK =&gt; TCK, -- 1-bit input: JTAG TCK input pin
      TDI =&gt; TDI, -- 1-bit input: JTAG TDI input pin
      TMS =&gt; TMS  -- 1-bit input: JTAG TMS input pin
   );

   -- End of MASTER_JTAG_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="STARTUP" treetype="folder">
					<Template label="STARTUP Block (STARTUPE3)" treetype="template">
--  STARTUPE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (STARTUPE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- STARTUPE3: STARTUP Block
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   STARTUPE3_inst : STARTUPE3
   generic map (
      PROG_USR =&gt; "FALSE",  -- Activate program event security feature. Requires encrypted bitstreams.
      SIM_CCLK_FREQ =&gt; 0.0  -- Set the Configuration Clock Frequency (ns) for simulation
   )
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration main clock output
      CFGMCLK =&gt; CFGMCLK,     -- 1-bit output: Configuration internal oscillator clock output
      DI =&gt; DI,               -- 4-bit output: Allow receiving on the D input pin
      EOS =&gt; EOS,             -- 1-bit output: Active-High output signal indicating the End Of Startup
      PREQ =&gt; PREQ,           -- 1-bit output: PROGRAM request to fabric output
      DO =&gt; DO,               -- 4-bit input: Allows control of the D pin output
      DTS =&gt; DTS,             -- 4-bit input: Allows tristate of the D pin
      FCSBO =&gt; FCSBO,         -- 1-bit input: Controls the FCS_B pin for flash access
      FCSBTS =&gt; FCSBTS,       -- 1-bit input: Tristate the FCS_B pin
      GSR =&gt; GSR,             -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port)
      GTS =&gt; GTS,             -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      KEYCLEARB =&gt; KEYCLEARB, -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      PACK =&gt; PACK,           -- 1-bit input: PROGRAM acknowledge input
      USRCCLKO =&gt; USRCCLKO,   -- 1-bit input: User CCLK input
      USRCCLKTS =&gt; USRCCLKTS, -- 1-bit input: User CCLK 3-state enable input
      USRDONEO =&gt; USRDONEO,   -- 1-bit input: User DONE pin output control
      USRDONETS =&gt; USRDONETS  -- 1-bit input: User DONE 3-state enable output
   );

   -- End of STARTUPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="USR_ACCESS" treetype="folder">
					<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
-- USR_ACCESSE2 : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (USR_ACCESSE2_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- USR_ACCESSE2: Configuration Data Access
   --               Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2_inst : USR_ACCESSE2
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration Clock
      DATA =&gt; DATA,           -- 32-bit output: Configuration Data reflecting the contents of the AXSS register
      DATAVALID =&gt; DATAVALID  -- 1-bit output: Active High Data Valid
   );

   -- End of USR_ACCESSE2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="BIDIR_BUFFER" treetype="folder">
					<Template label="Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable (IOBUF_INTERMDISABLE)" treetype="template">
-- IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
--        VHDL         : the following instance declaration needs to be placed
--      instance       : in the body of the design code.  The instance name
--     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations after the
--        code         : "=&gt;" declaration maybe changed to properly reference and
--                     : connect this function to the design.  All inputs and outputs
--                     : must be connected.

--       Library       : In addition to adding the instance declaration, a use
--     declaration     : statement for the UNISIM.vcomponents library needs to be
--         for         : added before the entity declaration.  This library
--       Xilinx        : contains the component declarations for all Xilinx
--     primitives      : primitives and points to the models that will be used
--                     : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_INTERMDISABLE: Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable
   --                      Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_INTERMDISABLE_inst : IOBUF_INTERMDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T                          -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Bidirectional I/O Buffer with Offset Calibration and VREF Tuning (IOBUFE3)" treetype="template">
--   IOBUFE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFE3: Bidirectional I/O Buffer with Offset Calibration and VREF Tuning
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFE3_inst : IOBUFE3
   generic map (
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Buffer inout (connect directly to top-level port)
      OSC =&gt; OSC,                       -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,                 -- 1-bit input: Offset cancellation enable
      T =&gt; T,                           -- 1-bit input: 3-state enable input
      VREF =&gt; VREF                      -- 1-bit input: Vref input from HPIO_VREF
   );

   -- End of IOBUFE3_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
-- IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
--              VHDL              : the following instance declaration needs to be placed
--            instance            : in the body of the design code.  The instance name
--          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations after the
--              code              : "=&gt;" declaration maybe changed to properly reference and
--                                : connect this function to the design.  All inputs and outputs
--                                : must be connected.

--            Library             : In addition to adding the instance declaration, a use
--          declaration           : statement for the UNISIM.vcomponents library needs to be
--              for               : added before the entity declaration.  This library
--             Xilinx             : contains the component declarations for all Xilinx
--           primitives           : primitives and points to the models that will be used
--                                : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable
   --                                 Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst : IOBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                       -- 1-bit output: Buffer diff_n output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Must be tied to a logic '0'
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                     -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,                       -- 1-bit input: 3-state master enable input
      TS =&gt; TS                        -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
-- IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
--          VHDL          : the following instance declaration needs to be placed
--        instance        : in the body of the design code.  The instance name
--      declaration       : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations after the
--          code          : "=&gt;" declaration maybe changed to properly reference and
--                        : connect this function to the design.  All inputs and outputs
--                        : must be connected.

--        Library         : In addition to adding the instance declaration, a use
--      declaration       : statement for the UNISIM.vcomponents library needs to be
--          for           : added before the entity declaration.  This library
--         Xilinx         : contains the component declarations for all Xilinx
--       primitives       : primitives and points to the models that will be used
--                        : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_DCIEN: Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable
   --                         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_DCIEN_inst : IOBUFDS_DIFF_OUT_DCIEN
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                         -- 1-bit output: Buffer diff_n output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Must be tied to a logic '0'
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,                         -- 1-bit input: 3-state master enable input
      TS =&gt; TS                          -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input (IOBUFDS_INTERMDISABLE)" treetype="template">
-- IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--         VHDL          : the following instance declaration needs to be placed
--       instance        : in the body of the design code.  The instance name
--      declaration      : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations after the
--         code          : "=&gt;" declaration maybe changed to properly reference and
--                       : connect this function to the design.  All inputs and outputs
--                       : must be connected.

--        Library        : In addition to adding the instance declaration, a use
--      declaration      : statement for the UNISIM.vcomponents library needs to be
--          for          : added before the entity declaration.  This library
--        Xilinx         : contains the component declarations for all Xilinx
--      primitives       : primitives and points to the models that will be used
--                       : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_INTERMDISABLE: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input
   --                        Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_INTERMDISABLE_inst : IOBUFDS_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                     -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T                          -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DCIEN)" treetype="template">
-- IOBUFDS_DCIEN : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the body of the design code.  The instance name
--  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations after the
--     code      : "=&gt;" declaration maybe changed to properly reference and
--               : connect this function to the design.  All inputs and outputs
--               : must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--  primitives   : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DCIEN: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DCIEN_inst : IOBUFDS_DCIEN
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional I/O Buffer with Offset Calibration (IOBUFDSE3)" treetype="template">
--  IOBUFDSE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFDSE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDSE3: Differential Bidirectional I/O Buffer with Offset Calibration
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDSE3_inst : IOBUFDSE3
   generic map (
      DQS_BIAS =&gt; "FALSE",          -- (FALSE, TRUE)
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      OSC =&gt; OSC,                       -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,                 -- 2-bit input: Offset cancellation enable
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDSE3_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer (IOBUFDS)" treetype="template">
--   IOBUFDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS: Differential Input/Output Buffer
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_inst : IOBUFDS
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer output
      I =&gt; I,     -- 1-bit input: Buffer input
      IO =&gt; IO,   -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T      -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer (IOBUFDS_DIFF_OUT)" treetype="template">
-- IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT: Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer
   --                   Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_inst : IOBUFDS_DIFF_OUT
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,   -- 1-bit output: Buffer diff_n output
      I =&gt; I,     -- 1-bit input: Buffer input
      IO =&gt; IO,   -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,   -- 1-bit input: 3-state master enable input
      TS =&gt; TS    -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Input/Output Buffer DCI Enable (IOBUF_DCIEN)" treetype="template">
-- IOBUF_DCIEN : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUF_DCIEN_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_DCIEN: Input/Output Buffer DCI Enable
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_DCIEN_inst : IOBUF_DCIEN
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Input/Output Buffer (IOBUF)" treetype="template">
--    IOBUF    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF: Input/Output Buffer
   --        Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_inst : IOBUF
   port map (
      O =&gt; O,   -- 1-bit output: Buffer output
      I =&gt; I,   -- 1-bit input: Buffer input
      IO =&gt; IO, -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T    -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="BITSLICE" treetype="folder">
					<Template label="BITSLICE_CONTROL (BITSLICE_CONTROL)" treetype="template">
-- BITSLICE_CONTROL : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (BITSLICE_CONTROL_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BITSLICE_CONTROL: BITSLICE_CONTROL for control using Native Mode
   --                   Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BITSLICE_CONTROL_inst : BITSLICE_CONTROL
   generic map (
      DIV_MODE =&gt; "DIV2",               -- Controller DIV2/DIV4 mode (DIV2, DIV4)
      EN_CLK_TO_EXT_NORTH =&gt; "DISABLE", -- Enable clock forwarding to north
      EN_CLK_TO_EXT_SOUTH =&gt; "DISABLE", -- Enable clock forwarding to south
      EN_DYN_ODLY_MODE =&gt; "FALSE",      -- Enable dynamic output delay mode
      EN_OTHER_NCLK =&gt; "FALSE",         -- Select the NCLK from the other BITSLICE_CONTROL in the nibble
                                        -- (FALSE, TRUE)
      EN_OTHER_PCLK =&gt; "FALSE",         -- Select the PCLK from the other BITSLICE_CONTROL in the nibble
                                        -- (FALSE, TRUE)
      IDLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for input delays
      INV_RXCLK =&gt; "FALSE",             -- Invert clock path from IOB to upper RX bitslice
      ODLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for output delays
      QDLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for clock delays
      READ_IDLE_COUNT =&gt; X"00",         -- Gap count between read bursts for ODT control counter (0-3f)
      REFCLK_SRC =&gt; "PLLCLK",           -- Select the input clock for the delay control (PLLCLK, REFCLK)
      ROUNDING_FACTOR =&gt; 16,            -- Rounding factor in BISC spec (128-8)
      RXGATE_EXTEND =&gt; "FALSE",         -- Reserved for use by MIG Memory Controller. Do Not Change.
      RX_CLK_PHASE_N =&gt; "SHIFT_0",      -- Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                        -- SHIFT_90)
      RX_CLK_PHASE_P =&gt; "SHIFT_0",      -- Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                        -- SHIFT_90)
      RX_GATING =&gt; "DISABLE",           -- ENABLE/DISABLE read DQS gating
      SELF_CALIBRATE =&gt; "ENABLE",       -- Enable BISC of nibble controlled by BITSLICE_CONTROL
      SERIAL_MODE =&gt; "FALSE",           -- Put BITSLICE read paths into serial mode (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE",       -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                        -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TX_GATING =&gt; "DISABLE"            -- ENABLE/DISABLE clock gating in WClkgen
   )
   port map (
      CLK_TO_EXT_NORTH =&gt; CLK_TO_EXT_NORTH,       -- 1-bit output: Inter-byte clock going to north
                                                  -- BITSLICE_CONTROL

      CLK_TO_EXT_SOUTH =&gt; CLK_TO_EXT_SOUTH,       -- 1-bit output: Inter-byte clock going to south
                                                  -- BITSLICE_CONTROL

      DLY_RDY =&gt; DLY_RDY,                         -- 1-bit output: Fixed delay calibration complete
      DYN_DCI =&gt; DYN_DCI,                         -- 7-bit output: Direct control of IOB DCI when using a
                                                  -- memory interface

      NCLK_NIBBLE_OUT =&gt; NCLK_NIBBLE_OUT,         -- 1-bit output: Intra-byte DQS strobes/clock to other
                                                  -- control block

      PCLK_NIBBLE_OUT =&gt; PCLK_NIBBLE_OUT,         -- 1-bit output: Intra-byte DQS strobes/clock to other
                                                  -- control block

      RIU_RD_DATA =&gt; RIU_RD_DATA,                 -- 16-bit output: RIU Output Read data to the controller
      RIU_VALID =&gt; RIU_VALID,                     -- 1-bit output: Last data written has been accepted when High
      RX_BIT_CTRL_OUT0 =&gt; RX_BIT_CTRL_OUT0,       -- 40-bit output: Output bus to Bitslice 0
      RX_BIT_CTRL_OUT1 =&gt; RX_BIT_CTRL_OUT1,       -- 40-bit output: Output bus to Bitslice 1
      RX_BIT_CTRL_OUT2 =&gt; RX_BIT_CTRL_OUT2,       -- 40-bit output: Output bus to Bitslice 2
      RX_BIT_CTRL_OUT3 =&gt; RX_BIT_CTRL_OUT3,       -- 40-bit output: Output bus to Bitslice 3
      RX_BIT_CTRL_OUT4 =&gt; RX_BIT_CTRL_OUT4,       -- 40-bit output: Output bus to Bitslice 4
      RX_BIT_CTRL_OUT5 =&gt; RX_BIT_CTRL_OUT5,       -- 40-bit output: Output bus to Bitslice 5
      RX_BIT_CTRL_OUT6 =&gt; RX_BIT_CTRL_OUT6,       -- 40-bit output: Output bus to Bitslice 6
      TX_BIT_CTRL_OUT0 =&gt; TX_BIT_CTRL_OUT0,       -- 40-bit output: Output bus to Bitslice 0
      TX_BIT_CTRL_OUT1 =&gt; TX_BIT_CTRL_OUT1,       -- 40-bit output: Output bus to Bitslice 1
      TX_BIT_CTRL_OUT2 =&gt; TX_BIT_CTRL_OUT2,       -- 40-bit output: Output bus to Bitslice 2
      TX_BIT_CTRL_OUT3 =&gt; TX_BIT_CTRL_OUT3,       -- 40-bit output: Output bus to Bitslice 3
      TX_BIT_CTRL_OUT4 =&gt; TX_BIT_CTRL_OUT4,       -- 40-bit output: Output bus to Bitslice 4
      TX_BIT_CTRL_OUT5 =&gt; TX_BIT_CTRL_OUT5,       -- 40-bit output: Output bus to Bitslice 5
      TX_BIT_CTRL_OUT6 =&gt; TX_BIT_CTRL_OUT6,       -- 40-bit output: Output bus to Bitslice 6
      TX_BIT_CTRL_OUT_TRI =&gt; TX_BIT_CTRL_OUT_TRI, -- 40-bit output: Output bus to 3-state TX_BITSLICE_TRI
      VTC_RDY =&gt; VTC_RDY,                         -- 1-bit output: PHY calibration is complete
      CLK_FROM_EXT =&gt; CLK_FROM_EXT,               -- 1-bit input: Inter-byte clock coming from north or south
                                                  -- BITSLICE_CONTROL

      EN_VTC =&gt; EN_VTC,                           -- 1-bit input: Enables voltage and temperature compensation
                                                  -- when High

      NCLK_NIBBLE_IN =&gt; NCLK_NIBBLE_IN,           -- 1-bit input: Intra-byte DQS strobes from other/clock
                                                  -- control block

      PCLK_NIBBLE_IN =&gt; PCLK_NIBBLE_IN,           -- 1-bit input: Intra-byte DQS strobes/clock from other
                                                  -- control block

      PHY_RDCS0 =&gt; PHY_RDCS0,                     -- 4-bit input: Rank select
      PHY_RDCS1 =&gt; PHY_RDCS1,                     -- 4-bit input: Rank select
      PHY_RDEN =&gt; PHY_RDEN,                       -- 4-bit input: Read burst enable when using a memory
                                                  -- interface

      PHY_WRCS0 =&gt; PHY_WRCS0,                     -- 4-bit input: Rank select
      PHY_WRCS1 =&gt; PHY_WRCS1,                     -- 4-bit input: Rank select
      PLL_CLK =&gt; PLL_CLK,                         -- 1-bit input: PLL clock input
      REFCLK =&gt; REFCLK,                           -- 1-bit input: Frequency reference clock for delay control
      RIU_ADDR =&gt; RIU_ADDR,                       -- 6-bit input: Address input for RIU
      RIU_CLK =&gt; RIU_CLK,                         -- 1-bit input: System clock from fabric for RIU access
      RIU_NIBBLE_SEL =&gt; RIU_NIBBLE_SEL,           -- 1-bit input: Nibble select to enable RIU read/write
      RIU_WR_DATA =&gt; RIU_WR_DATA,                 -- 16-bit input: RIU Input Write data from the controller
      RIU_WR_EN =&gt; RIU_WR_EN,                     -- 1-bit input: Enables write to RIU when High
      RST =&gt; RST,                                 -- 1-bit input: Asynchronous global reset
      RX_BIT_CTRL_IN0 =&gt; RX_BIT_CTRL_IN0,         -- 40-bit input: Input bus from Bitslice 0
      RX_BIT_CTRL_IN1 =&gt; RX_BIT_CTRL_IN1,         -- 40-bit input: Input bus from Bitslice 1
      RX_BIT_CTRL_IN2 =&gt; RX_BIT_CTRL_IN2,         -- 40-bit input: Input bus from Bitslice 2
      RX_BIT_CTRL_IN3 =&gt; RX_BIT_CTRL_IN3,         -- 40-bit input: Input bus from Bitslice 3
      RX_BIT_CTRL_IN4 =&gt; RX_BIT_CTRL_IN4,         -- 40-bit input: Input bus from Bitslice 4
      RX_BIT_CTRL_IN5 =&gt; RX_BIT_CTRL_IN5,         -- 40-bit input: Input bus from Bitslice 5
      RX_BIT_CTRL_IN6 =&gt; RX_BIT_CTRL_IN6,         -- 40-bit input: Input bus from Bitslice 6
      TBYTE_IN =&gt; TBYTE_IN,                       -- 4-bit input: Output enable for 3-state control
      TX_BIT_CTRL_IN0 =&gt; TX_BIT_CTRL_IN0,         -- 40-bit input: Input bus from Bitslice 0
      TX_BIT_CTRL_IN1 =&gt; TX_BIT_CTRL_IN1,         -- 40-bit input: Input bus from Bitslice 1
      TX_BIT_CTRL_IN2 =&gt; TX_BIT_CTRL_IN2,         -- 40-bit input: Input bus from Bitslice 2
      TX_BIT_CTRL_IN3 =&gt; TX_BIT_CTRL_IN3,         -- 40-bit input: Input bus from Bitslice 3
      TX_BIT_CTRL_IN4 =&gt; TX_BIT_CTRL_IN4,         -- 40-bit input: Input bus from Bitslice 4
      TX_BIT_CTRL_IN5 =&gt; TX_BIT_CTRL_IN5,         -- 40-bit input: Input bus from Bitslice 5
      TX_BIT_CTRL_IN6 =&gt; TX_BIT_CTRL_IN6,         -- 40-bit input: Input bus from Bitslice 6
      TX_BIT_CTRL_IN_TRI =&gt; TX_BIT_CTRL_IN_TRI    -- 40-bit input: Input bus from 3-state TX_BITSLICE_TRI
   );

   -- End of BITSLICE_CONTROL_inst instantiation
					</Template>
					<Template label="Register Interface Unit Selection Block (RIU_OR)" treetype="template">
--   RIU_OR    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RIU_OR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RIU_OR: Register Interface Unit Selection Block
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RIU_OR_inst : RIU_OR
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      RIU_RD_DATA =&gt; RIU_RD_DATA,           -- 16-bit output: RIU data bus to the controller
      RIU_RD_VALID =&gt; RIU_RD_VALID,         -- 1-bit output: Combined RIU read valid signal to the controller
      RIU_RD_DATA_LOW =&gt; RIU_RD_DATA_LOW,   -- 16-bit input: RIU data bus from the controller to the lower
                                            -- nibble BITSLICE_CONTROL

      RIU_RD_DATA_UPP =&gt; RIU_RD_DATA_UPP,   -- 16-bit input: RIU data bus from the controller to the upper
                                            -- nibble BITSLICE_CONTROL

      RIU_RD_VALID_LOW =&gt; RIU_RD_VALID_LOW, -- 1-bit input: RIU_VALID of the lower nibble BITSLICE_CONTROL
      RIU_RD_VALID_UPP =&gt; RIU_RD_VALID_UPP  -- 1-bit input: RIU_VALID of the upper nibble BITSLICE_CONTROL
   );

   -- End of RIU_OR_inst instantiation
					</Template>
					<Template label="RX_BITSLICE (RX_BITSLICE)" treetype="template">
-- RX_BITSLICE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RX_BITSLICE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RX_BITSLICE: RX_BITSLICE for input using Native Mode
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RX_BITSLICE_inst : RX_BITSLICE
   generic map (
      CASCADE =&gt; "FALSE",             -- Enables cascading of IDELAY and ODELAY lines
      DATA_TYPE =&gt; "DATA",            -- Defines what the input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                      -- SERIAL)
      DATA_WIDTH =&gt; 8,                -- Defines the width of the serial-to-parallel converter (4-8)
      DELAY_FORMAT =&gt; "TIME",         -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",          -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,               -- Input delay value setting in ps
      DELAY_VALUE_EXT =&gt; 0,           -- Value of the extended input delay value in ps
      FIFO_SYNC_MODE =&gt; "FALSE",      -- Internal write clock and FIFO_RD_CLK are coming from a common source
      IS_CLK_EXT_INVERTED =&gt; '0',     -- Optional inversion for CLK_EXT
      IS_CLK_INVERTED =&gt; '0',         -- Optional inversion for CLK
      IS_RST_DLY_EXT_INVERTED =&gt; '0', -- Optional inversion for RST_DLY_EXT
      IS_RST_DLY_INVERTED =&gt; '0',     -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',         -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,      -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC",         -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
      UPDATE_MODE_EXT =&gt; "ASYNC"      -- Determines when updates to the extended input delay will take effect
                                      -- (ASYNC, MANUAL, SYNC)
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT,         -- 9-bit output: Counter value to device logic
      CNTVALUEOUT_EXT =&gt; CNTVALUEOUT_EXT, -- 9-bit output: Optional extended (cascaded delay) counter value
                                          -- going to the device logic

      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      FIFO_WRCLK_OUT =&gt; FIFO_WRCLK_OUT,   -- 1-bit output: FIFO source synchronous write clock out to the
                                          -- device logic (currently unsupported, do not connect)

      Q =&gt; Q,                             -- 8-bit output: Registered output data from FIFO
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      CE =&gt; CE,                           -- 1-bit input: Clock enable for IDELAY
      CE_EXT =&gt; CE_EXT,                   -- 1-bit input: Optional extended (cascaded delay) clock enable
      CLK =&gt; CLK,                         -- 1-bit input: Clock used to sample LOAD, CE, INC
      CLK_EXT =&gt; CLK_EXT,                 -- 1-bit input: Optional extended (cascaded delay) clock
      CNTVALUEIN =&gt; CNTVALUEIN,           -- 9-bit input: Counter value from device logic
      CNTVALUEIN_EXT =&gt; CNTVALUEIN_EXT,   -- 9-bit input: Optional extended (cascaded delay) counter value from
                                          -- device logic

      DATAIN =&gt; DATAIN,                   -- 1-bit input: Input signal from IBUF
      EN_VTC =&gt; EN_VTC,                   -- 1-bit input: Enable IDELAYCTRL to keep stable delay over VT
      EN_VTC_EXT =&gt; EN_VTC_EXT,           -- 1-bit input: Optional extended (cascaded delay) to keep stable
                                          -- delay over VT

      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: FIFO read enable
      INC =&gt; INC,                         -- 1-bit input: Increment the current delay tap setting
      INC_EXT =&gt; INC_EXT,                 -- 1-bit input: Optional extended (cascaded delay) increments the
                                          -- current delay tap setting

      LOAD =&gt; LOAD,                       -- 1-bit input: Load the CNTVALUEIN tap setting
      LOAD_EXT =&gt; LOAD_EXT,               -- 1-bit input: Optional extended (cascaded delay) load the
                                          -- CNTVALUEIN_EXT tap setting

      RST =&gt; RST,                         -- 1-bit input: Asynchronous assert, synchronous deassert for
                                          -- RX_BITSLICE ISERDES

      RST_DLY =&gt; RST_DLY,                 -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      RST_DLY_EXT =&gt; RST_DLY_EXT,         -- 1-bit input: Optional extended (cascaded delay) reset delay to
                                          -- DELAY_VALUE_EXT

      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN    -- 40-bit input: Input bus from BITSLICE_CONTROL
   );

   -- End of RX_BITSLICE_inst instantiation
					</Template>
					<Template label="RXTX_BITSLICE (RXTX_BITSLICE)" treetype="template">
-- RXTX_BITSLICE : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the body of the design code.  The instance name
--  declaration  : (RXTX_BITSLICE_inst) and/or the port declarations after the
--     code      : "=&gt;" declaration maybe changed to properly reference and
--               : connect this function to the design.  All inputs and outputs
--               : must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--  primitives   : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RXTX_BITSLICE: RXTX_BITSLICE for bidirectional I/O using Native Mode
   --                Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RXTX_BITSLICE_inst : RXTX_BITSLICE
   generic map (
      ENABLE_PRE_EMPHASIS =&gt; "FALSE", -- Enable the pre-emphasis
      FIFO_SYNC_MODE =&gt; "FALSE",      -- Internal write clock and FIFO_RD_CLK are coming from a common source
      INIT =&gt; '1',                    -- Defines initial O value
      IS_RX_CLK_INVERTED =&gt; '0',      -- Optional inversion for RX_CLK
      IS_RX_RST_DLY_INVERTED =&gt; '0',  -- Optional inversion for RX_RST_DLY
      IS_RX_RST_INVERTED =&gt; '0',      -- Optional inversion for RX_RST
      IS_TX_CLK_INVERTED =&gt; '0',      -- Optional inversion for TX_CLK
      IS_TX_RST_DLY_INVERTED =&gt; '0',  -- Optional inversion for TX_RST_DLY
      IS_TX_RST_INVERTED =&gt; '0',      -- Optional inversion for TX_RST
      RX_DATA_TYPE =&gt; "DATA",         -- Defines what the RX input pin is carrying (CLOCK, DATA,
                                      -- DATA_AND_CLOCK, SERIAL)
      RX_DATA_WIDTH =&gt; 8,             -- Defines the width of the serial-to-parallel converter (4-8)
      RX_DELAY_FORMAT =&gt; "TIME",      -- Units of the RX DELAY_VALUE (COUNT, TIME)
      RX_DELAY_TYPE =&gt; "FIXED",       -- Set the type of RX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      RX_DELAY_VALUE =&gt; 0,            -- RX Input delay value setting in ps
      RX_REFCLK_FREQUENCY =&gt; 300.0,   -- Specification of the RX reference clock frequency in MHz
                                      -- (200.0-2667.0)
      RX_UPDATE_MODE =&gt; "ASYNC",      -- Determines when updates to the RX delay will take effect (ASYNC,
                                      -- MANUAL, SYNC)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TBYTE_CTL =&gt; "TBYTE_IN",        -- Select between T and TBYTE_IN inputs
      TX_DATA_WIDTH =&gt; 8,             -- Parallel data input width (4-8)
      TX_DELAY_FORMAT =&gt; "TIME",      -- Units of the TX DELAY_VALUE (COUNT, TIME)
      TX_DELAY_TYPE =&gt; "FIXED",       -- Set the type of TX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      TX_DELAY_VALUE =&gt; 0,            -- TX Input delay value setting in ps
      TX_OUTPUT_PHASE_90 =&gt; "FALSE",  -- Delays the output phase by 90-degrees
      TX_REFCLK_FREQUENCY =&gt; 300.0,   -- Specification of the TX reference clock frequency in MHz
                                      -- (200.0-2667.0)
      TX_UPDATE_MODE =&gt; "ASYNC"       -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
   )
   port map (
      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      FIFO_WRCLK_OUT =&gt; FIFO_WRCLK_OUT,   -- 1-bit output: FIFO source synchronous write clock out to the
                                          -- device logic (currently unsupported, do not connect)

      O =&gt; O,                             -- 1-bit output: Serialized output going to output buffer
      Q =&gt; Q,                             -- 8-bit output: Registered output data from FIFO
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: RX Output bus to BITSLICE_CONTROL
      RX_CNTVALUEOUT =&gt; RX_CNTVALUEOUT,   -- 9-bit output: RX Counter value from device logic
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL for TX
      TX_CNTVALUEOUT =&gt; TX_CNTVALUEOUT,   -- 9-bit output: TX Counter value to device logic
      T_OUT =&gt; T_OUT,                     -- 1-bit output: Byte group 3-state output
      D =&gt; D,                             -- 8-bit input: Data from device logic
      DATAIN =&gt; DATAIN,                   -- 1-bit input: Input signal from IOBUF
      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: FIFO read enable
      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: RX Input bus from BITSLICE_CONTROL
      RX_CE =&gt; RX_CE,                     -- 1-bit input: Clock enable for IDELAY
      RX_CLK =&gt; RX_CLK,                   -- 1-bit input: RX Clock used to sample LOAD, CE, INC
      RX_CNTVALUEIN =&gt; RX_CNTVALUEIN,     -- 9-bit input: RX Counter value from device logic
      RX_EN_VTC =&gt; RX_EN_VTC,             -- 1-bit input: RX Enable to keep stable delay over VT
      RX_INC =&gt; RX_INC,                   -- 1-bit input: RX Increment the current delay tap setting
      RX_LOAD =&gt; RX_LOAD,                 -- 1-bit input: RX Load the CNTVALUEIN tap setting
      RX_RST =&gt; RX_RST,                   -- 1-bit input: RX Asynchronous assert, synchronous deassert for
                                          -- RXTX_BITSLICE ISERDES

      RX_RST_DLY =&gt; RX_RST_DLY,           -- 1-bit input: RX Reset the internal DELAY value to DELAY_VALUE
      T =&gt; T,                             -- 1-bit input: Legacy T byte input from device logic
      TBYTE_IN =&gt; TBYTE_IN,               -- 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN,   -- 40-bit input: TX Input bus from BITSLICE_CONTROL
      TX_CE =&gt; TX_CE,                     -- 1-bit input: Clock enable for ODELAY
      TX_CLK =&gt; TX_CLK,                   -- 1-bit input: TX Clock used to sample LOAD, CE, INC
      TX_CNTVALUEIN =&gt; TX_CNTVALUEIN,     -- 9-bit input: TX Counter value from device logic
      TX_EN_VTC =&gt; TX_EN_VTC,             -- 1-bit input: TX Enable to keep stable delay over VT
      TX_INC =&gt; TX_INC,                   -- 1-bit input: TX Increment the current delay tap setting
      TX_LOAD =&gt; TX_LOAD,                 -- 1-bit input: TX Load the CNTVALUEIN tap setting
      TX_RST =&gt; TX_RST,                   -- 1-bit input: TX Asynchronous assert, synchronous deassert for
                                          -- RXTX_BITSLICE OSERDES

      TX_RST_DLY =&gt; TX_RST_DLY            -- 1-bit input: TX Reset the internal DELAY value to DELAY_VALUE
   );

   -- End of RXTX_BITSLICE_inst instantiation
					</Template>
					<Template label="TX_BITSLICE_TRI (TX_BITSLICE_TRI)" treetype="template">
-- TX_BITSLICE_TRI : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (TX_BITSLICE_TRI_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- TX_BITSLICE_TRI: TX_BITSLICE_TRI for tristate using Native Mode
   --                  Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_TRI_inst : TX_BITSLICE_TRI
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel data input width (4-8)
      DELAY_FORMAT =&gt; "TIME",     -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Output delay value setting
      INIT =&gt; '1',                -- Defines initial O value
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_DLY_INVERTED =&gt; '0', -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      OUTPUT_PHASE_90 =&gt; "FALSE", -- Delays the output phase by 90-degrees
      REFCLK_FREQUENCY =&gt; 300.0,  -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      BIT_CTRL_OUT =&gt; BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      CNTVALUEOUT =&gt; CNTVALUEOUT,   -- 9-bit output: Counter value to device logic
      TRI_OUT =&gt; TRI_OUT,           -- 1-bit output: Output to the TBYTE_IN pins of the bitslices
      BIT_CTRL_IN =&gt; BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      CE =&gt; CE,                     -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                   -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,     -- 9-bit input: Counter value input
      EN_VTC =&gt; EN_VTC,             -- 1-bit input: Enable to keep stable delay over VT
      INC =&gt; INC,                   -- 1-bit input: Increment the current delay tap setting
      LOAD =&gt; LOAD,                 -- 1-bit input: Load the CNTVALUEIN tap setting
      RST =&gt; RST,                   -- 1-bit input: Asynchronous assert, synchronous deassert
      RST_DLY =&gt; RST_DLY            -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
   );

   -- End of TX_BITSLICE_TRI_inst instantiation
					</Template>
					<Template label="TX_BITSLICE (TX_BITSLICE)" treetype="template">
-- TX_BITSLICE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (TX_BITSLICE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- TX_BITSLICE: TX_BITSLICE for output using Native Mode
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_inst : TX_BITSLICE
   generic map (
      DATA_WIDTH =&gt; 8,                -- Parallel data input width (4-8)
      DELAY_FORMAT =&gt; "TIME",         -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",          -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,               -- Output delay value setting
      ENABLE_PRE_EMPHASIS =&gt; "FALSE", -- Enable the pre-emphasis
      INIT =&gt; '1',                    -- Defines initial O value
      IS_CLK_INVERTED =&gt; '0',         -- Optional inversion for CLK
      IS_RST_DLY_INVERTED =&gt; '0',     -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',         -- Optional inversion for RST
      OUTPUT_PHASE_90 =&gt; "FALSE",     -- Delays the output phase by 90-degrees
      REFCLK_FREQUENCY =&gt; 300.0,      -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TBYTE_CTL =&gt; "TBYTE_IN",        -- Select between T and TBYTE_IN inputs
      UPDATE_MODE =&gt; "ASYNC"          -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT,         -- 9-bit output: Counter value to device logic
      O =&gt; O,                             -- 1-bit output: Serialized output going to output buffer
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      T_OUT =&gt; T_OUT,                     -- 1-bit output: Byte group 3-state output
      CE =&gt; CE,                           -- 1-bit input: Clock enable for ODELAY
      CLK =&gt; CLK,                         -- 1-bit input: Clock used to sample LOAD, CE, INC
      CNTVALUEIN =&gt; CNTVALUEIN,           -- 9-bit input: Counter value from device logic
      D =&gt; D,                             -- 8-bit input: Data from device logic
      EN_VTC =&gt; EN_VTC,                   -- 1-bit input: Enable to keep stable delay over VT
      INC =&gt; INC,                         -- 1-bit input: Increment the current delay tap setting
      LOAD =&gt; LOAD,                       -- 1-bit input: Load the CNTVALUEIN tap setting
      RST =&gt; RST,                         -- 1-bit input: Asynchronous assert, synchronous deassert for
                                          -- TX_BITSLICE OSERDES

      RST_DLY =&gt; RST_DLY,                 -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      T =&gt; T,                             -- 1-bit input: Legacy T byte input from device logic
      TBYTE_IN =&gt; TBYTE_IN,               -- 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN    -- 40-bit input: Input bus from BITSLICE_CONTROL
   );

   -- End of TX_BITSLICE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DCI_RESET" treetype="folder">
					<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
--  DCIRESET   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DCIRESET_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DCIRESET: Digitally Controlled Impedance Reset Component
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   DCIRESET_inst : DCIRESET
   port map (
      LOCKED =&gt; LOCKED, -- 1-bit output: LOCK status output
      RST =&gt; RST        -- 1-bit input: Active-High asynchronous reset input
   );

   -- End of DCIRESET_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DELAY" treetype="folder">
					<Template label="IDELAYE3/ODELAYE3 Tap Delay Value Control (IDELAYCTRL)" treetype="template">
-- IDELAYCTRL  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYCTRL: IDELAYE3/ODELAYE3 Tap Delay Value Control
   --             Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL_inst : IDELAYCTRL
   generic map (
      SIM_DEVICE =&gt; "7SERIES"  -- Set the device version (7SERIES, ULTRASCALE)
   )
   port map (
      RDY =&gt; RDY,       -- 1-bit output: Ready output
      REFCLK =&gt; REFCLK, -- 1-bit input: Reference clock input
      RST =&gt; RST        -- 1-bit input: Active high reset input. Asynchronous assert, synchronous deassert to
                        -- REFCLK.

   );

   -- End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE3)" treetype="template">
--  IDELAYE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYE3: Input Fixed or Variable Delay Element
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYE3_inst : IDELAYE3
   generic map (
      CASCADE =&gt; "NONE",          -- Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      DELAY_FORMAT =&gt; "TIME",     -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_SRC =&gt; "IDATAIN",     -- Delay input (DATAIN, IDATAIN)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Input delay value setting
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,  -- IDELAYCTRL clock input frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      CASC_OUT =&gt; CASC_OUT,       -- 1-bit output: Cascade delay output to ODELAY input cascade
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 9-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data output
      CASC_IN =&gt; CASC_IN,         -- 1-bit input: Cascade delay input from slave ODELAY CASCADE_OUT
      CASC_RETURN =&gt; CASC_RETURN, -- 1-bit input: Cascade delay returning from slave ODELAY DATAOUT
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                 -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 9-bit input: Counter value input
      DATAIN =&gt; DATAIN,           -- 1-bit input: Data input from the logic
      EN_VTC =&gt; EN_VTC,           -- 1-bit input: Keep delay constant over VT
      IDATAIN =&gt; IDATAIN,         -- 1-bit input: Data input from the IOBUF
      INC =&gt; INC,                 -- 1-bit input: Increment / Decrement tap delay input
      LOAD =&gt; LOAD,               -- 1-bit input: Load DELAY_VALUE input
      RST =&gt; RST                  -- 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   -- End of IDELAYE3_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE3)" treetype="template">
--  ODELAYE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODELAYE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODELAYE3: Output Fixed or Variable Delay Element
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   ODELAYE3_inst : ODELAYE3
   generic map (
      CASCADE =&gt; "NONE",          -- Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      DELAY_FORMAT =&gt; "TIME",     -- (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Output delay tap setting
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,  -- IDELAYCTRL clock input frequency in MHz (200.0-2667.0).
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      CASC_OUT =&gt; CASC_OUT,       -- 1-bit output: Cascade delay output to IDELAY input cascade
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 9-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data from ODATAIN input port
      CASC_IN =&gt; CASC_IN,         -- 1-bit input: Cascade delay input from slave IDELAY CASCADE_OUT
      CASC_RETURN =&gt; CASC_RETURN, -- 1-bit input: Cascade delay returning from slave IDELAY DATAOUT
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                 -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 9-bit input: Counter value input
      EN_VTC =&gt; EN_VTC,           -- 1-bit input: Keep delay constant over VT
      INC =&gt; INC,                 -- 1-bit input: Increment/Decrement tap delay input
      LOAD =&gt; LOAD,               -- 1-bit input: Load DELAY_VALUE input
      ODATAIN =&gt; ODATAIN,         -- 1-bit input: Data input
      RST =&gt; RST                  -- 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   -- End of ODELAYE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="INPUT_BUFFER" treetype="folder">
					<Template label="Analog Auxiliary SYSMON Input Buffer (IBUF_ANALOG)" treetype="template">
-- IBUF_ANALOG : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUF_ANALOG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_ANALOG: Analog Auxiliary SYSMON Input Buffer
   --              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_ANALOG_inst : IBUF_ANALOG
   port map (
      O =&gt; O, -- 1-bit output: Connect to a VAUXP/VAUXN port of the SYSMONE1
      I =&gt; I  -- 1-bit input: Connect to a top-level design port
   );

   -- End of IBUF_ANALOG_inst instantiation
					</Template>
					<Template label="Differential Input Buffer (IBUFDS)" treetype="template">
--   IBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS: Differential Input Buffer
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_inst : IBUFDS
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer output
      I =&gt; I,   -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB  -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs and Input Buffer Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
-- IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
--            VHDL             : the following instance declaration needs to be placed
--          instance           : in the body of the design code.  The instance name
--         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations after the
--            code             : "=&gt;" declaration maybe changed to properly reference and
--                             : connect this function to the design.  All inputs and outputs
--                             : must be connected.

--           Library           : In addition to adding the instance declaration, a use
--         declaration         : statement for the UNISIM.vcomponents library needs to be
--             for             : added before the entity declaration.  This library
--           Xilinx            : contains the component declarations for all Xilinx
--         primitives          : primitives and points to the models that will be used
--                             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer With Complementary Outputs and Input Buffer Disable
   --                              Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE_inst : IBUFDS_DIFF_OUT_IBUFDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                   -- 1-bit output: Buffer diff_n output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Must be tied to a logic '0'
   );

   -- End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs (IBUFDS_DIFF_OUT)" treetype="template">
-- IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT: Differential Input Buffer With Complementary Outputs
   --                  Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_inst : IBUFDS_DIFF_OUT
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer diff_p output
      OB =&gt; OB, -- 1-bit output: Buffer diff_n output
      I =&gt; I,   -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB  -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
-- IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
--             VHDL              : the following instance declaration needs to be placed
--           instance            : in the body of the design code.  The instance name
--          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations after the
--             code              : "=&gt;" declaration maybe changed to properly reference and
--                               : connect this function to the design.  All inputs and outputs
--                               : must be connected.

--            Library            : In addition to adding the instance declaration, a use
--          declaration          : statement for the UNISIM.vcomponents library needs to be
--              for              : added before the entity declaration.  This library
--            Xilinx             : contains the component declarations for all Xilinx
--          primitives           : primitives and points to the models that will be used
--                               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable
   --                                Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE_inst : IBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                       -- 1-bit output: Buffer diff_n output
      I =&gt; I,                         -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                       -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Must be tied to a logic '0'
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Buffer termination disable, high=disable
   );

   -- End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
-- IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--         VHDL         : the following instance declaration needs to be placed
--       instance       : in the body of the design code.  The instance name
--     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations after the
--         code         : "=&gt;" declaration maybe changed to properly reference and
--                      : connect this function to the design.  All inputs and outputs
--                      : must be connected.

--       Library        : In addition to adding the instance declaration, a use
--     declaration      : statement for the UNISIM.vcomponents library needs to be
--         for          : added before the entity declaration.  This library
--        Xilinx        : contains the component declarations for all Xilinx
--      primitives      : primitives and points to the models that will be used
--                      : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_INTERMDISABLE: Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE_inst : IBUFDS_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                       -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer input disable, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Buffer termination disable, high=disable
   );

   -- End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable (IBUFDS_IBUFDISABLE)" treetype="template">
-- IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--        VHDL        : the following instance declaration needs to be placed
--      instance      : in the body of the design code.  The instance name
--    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations after the
--        code        : "=&gt;" declaration maybe changed to properly reference and
--                    : connect this function to the design.  All inputs and outputs
--                    : must be connected.

--      Library       : In addition to adding the instance declaration, a use
--    declaration     : statement for the UNISIM.vcomponents library needs to be
--        for         : added before the entity declaration.  This library
--       Xilinx       : contains the component declarations for all Xilinx
--     primitives     : primitives and points to the models that will be used
--                    : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_IBUFDISABLE: Differential Input Buffer With Input Buffer Disable
   --                     Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE_inst : IBUFDS_IBUFDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Must be tied to a logic '0'
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Offset Calibration (IBUFDSE3)" treetype="template">
--  IBUFDSE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDSE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDSE3: Differential Input Buffer with Offset Calibration
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDSE3_inst : IBUFDSE3
   generic map (
      DQS_BIAS =&gt; "FALSE",          -- (FALSE, TRUE)
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- 1-bit input: Buffer disable input, high=disable
      OSC =&gt; OSC,                 -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN            -- 2-bit input: Offset cancellation enable
   );

   -- End of IBUFDSE3_inst instantiation
					</Template>
					<Template label="Input Buffer (IBUF)" treetype="template">
--    IBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF: Input Buffer
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_inst : IBUF
   port map (
      O =&gt; O, -- 1-bit output: Buffer output
      I =&gt; I  -- 1-bit input: Buffer input
   );

   -- End of IBUF_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
-- IBUF_INTERMDISABLE : In order to incorporate this function into the design,
--        VHDL        : the following instance declaration needs to be placed
--      instance      : in the body of the design code.  The instance name
--    declaration     : (IBUF_INTERMDISABLE_inst) and/or the port declarations after the
--        code        : "=&gt;" declaration maybe changed to properly reference and
--                    : connect this function to the design.  All inputs and outputs
--                    : must be connected.

--      Library       : In addition to adding the instance declaration, a use
--    declaration     : statement for the UNISIM.vcomponents library needs to be
--        for         : added before the entity declaration.  This library
--       Xilinx       : contains the component declarations for all Xilinx
--     primitives     : primitives and points to the models that will be used
--                    : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_INTERMDISABLE: Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                     Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_INTERMDISABLE_inst : IBUF_INTERMDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Input Termination Disable
   );

   -- End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable (IBUF_IBUFDISABLE)" treetype="template">
-- IBUF_IBUFDISABLE : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_IBUFDISABLE: Input Buffer With Input Buffer Disable
   --                   Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_IBUFDISABLE_inst : IBUF_IBUFDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Buffer disable input, high=disable
   );

   -- End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer with Offset Calibration and VREF Tuning (IBUFE3)" treetype="template">
--   IBUFE3    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFE3: Input Buffer with Offset Calibration and VREF Tuning
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFE3_inst : IBUFE3
   generic map (
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- 1-bit input: Buffer disable input, high=disable
      OSC =&gt; OSC,                 -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,           -- 1-bit input: Offset cancellation enable
      VREF =&gt; VREF                -- 1-bit input: Vref input from HPIO_VREF
   );

   -- End of IBUFE3_inst instantiation
					</Template>
					<Template label="VREF Scan (HPIO_VREF)" treetype="template">
--  HPIO_VREF  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (HPIO_VREF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- HPIO_VREF: VREF Scan
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   HPIO_VREF_inst : HPIO_VREF
   generic map (
      VREF_CNTR =&gt; "OFF"  -- FABRIC_RANGE1, FABRIC_RANGE2, OFF
   )
   port map (
      VREF =&gt; VREF,                         -- 1-bit output: Tuned output (connect to associated IBUFE3
                                            -- component)

      FABRIC_VREF_TUNE =&gt; FABRIC_VREF_TUNE  -- 7-bit input: VREF tuning value
   );

   -- End of HPIO_VREF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="OUTPUT_BUFFER" treetype="folder">
					<Template label="3-State Output Buffer (OBUFT)" treetype="template">
--    OBUFT    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFT: 3-State Output Buffer
   --        Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFT_inst : OBUFT
   port map (
      O =&gt; O, -- 1-bit output: Buffer output (connect directly to top-level port)
      I =&gt; I, -- 1-bit input: Buffer input
      T =&gt; T  -- 1-bit input: 3-state enable input
   );

   -- End of OBUFT_inst instantiation
					</Template>
					<Template label="Differential Output Buffer (OBUFDS)" treetype="template">
--   OBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS: Differential Output Buffer
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_inst : OBUFDS
   port map (
      O =&gt; O,   -- 1-bit output: Diff_p output (connect directly to top-level port)
      OB =&gt; OB, -- 1-bit output: Diff_n output (connect directly to top-level port)
      I =&gt; I    -- 1-bit input: Buffer input
   );

   -- End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential 3-state Output Buffer (OBUFTDS)" treetype="template">
--   OBUFTDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFTDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFTDS: Differential 3-state Output Buffer
   --          Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFTDS_inst : OBUFTDS
   port map (
      O =&gt; O,   -- 1-bit output: Diff_p output (connect directly to top-level port)
      OB =&gt; OB, -- 1-bit output: Diff_n output (connect directly to top-level port)
      I =&gt; I,   -- 1-bit input: Buffer input
      T =&gt; T    -- 1-bit input: 3-state enable input
   );

   -- End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Output Buffer (OBUF)" treetype="template">
--    OBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUF: Output Buffer
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUF_inst : OBUF
   port map (
      O =&gt; O, -- 1-bit output: Buffer output (connect directly to top-level port)
      I =&gt; I  -- 1-bit input: Buffer input
   );

   -- End of OBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer (ISERDESE3)" treetype="template">
--  ISERDESE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ISERDESE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ISERDESE3: Input SERial/DESerializer
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   ISERDESE3_inst : ISERDESE3
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel data width (4,8)
      FIFO_ENABLE =&gt; "FALSE",     -- Enables the use of the FIFO
      FIFO_SYNC_MODE =&gt; "FALSE",  -- Enables the use of internal 2-stage synchronizers on the FIFO
      IS_CLK_B_INVERTED =&gt; '0',   -- Optional inversion for CLK_B
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      INTERNAL_DIVCLK =&gt; INTERNAL_DIVCLK, -- 1-bit output: Internally divided down clock used when FIFO is
                                          -- disabled (do not connect)

      Q =&gt; Q,                             -- 8-bit registered output
      CLK =&gt; CLK,                         -- 1-bit input: High-speed clock
      CLKDIV =&gt; CLKDIV,                   -- 1-bit input: Divided Clock
      CLK_B =&gt; CLK_B,                     -- 1-bit input: Inversion of High-speed clock CLK
      D =&gt; D,                             -- 1-bit input: Serial Data Input
      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: Enables reading the FIFO when asserted
      RST =&gt; RST                          -- 1-bit input: Asynchronous Reset
   );

   -- End of ISERDESE3_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer (OSERDESE3)" treetype="template">
--  OSERDESE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OSERDESE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OSERDESE3: Output SERial/DESerializer
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OSERDESE3_inst : OSERDESE3
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel Data Width (4-8)
      INIT =&gt; '0',                -- Initialization value of the OSERDES flip-flops
      IS_CLKDIV_INVERTED =&gt; '0',  -- Optional inversion for CLKDIV
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      OQ =&gt; OQ,         -- 1-bit output: Serial Output Data
      T_OUT =&gt; T_OUT,   -- 1-bit output: 3-state control output to IOB
      CLK =&gt; CLK,       -- 1-bit input: High-speed clock
      CLKDIV =&gt; CLKDIV, -- 1-bit input: Divided Clock
      D =&gt; D,           -- 8-bit input: Parallel Data Input
      RST =&gt; RST,       -- 1-bit input: Asynchronous Reset
      T =&gt; T            -- 1-bit input: Tristate input from fabric
   );

   -- End of OSERDESE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="WEAK_DRIVER" treetype="folder">
					<Template label="I/O Pulldown (PULLDOWN)" treetype="template">
--  PULLDOWN   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PULLDOWN_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLDOWN: I/O Pulldown
   --           Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   PULLDOWN_inst : PULLDOWN
   port map (
      O =&gt; O  -- 1-bit output: Pulldown output (connect directly to top-level port)
   );

   -- End of PULLDOWN_inst instantiation
					</Template>
					<Template label="I/O Pullup (PULLUP)" treetype="template">
--   PULLUP    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PULLUP_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLUP: I/O Pullup
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   PULLUP_inst : PULLUP
   port map (
      O =&gt; O  -- 1-bit output: Pullup output (connect directly to top-level port)
   );

   -- End of PULLUP_inst instantiation
					</Template>
					<Template label="I/O Weak Keeper (KEEPER)" treetype="template">
--   KEEPER    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (KEEPER_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- KEEPER: I/O Weak Keeper
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   KEEPER_inst : KEEPER
   port map (
      O =&gt; O  -- 1-bit inout: Keeper output (connect directly to top-level port)
   );

   -- End of KEEPER_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="REGISTER" treetype="folder">
				<SubFolder label="DDR" treetype="folder">
					<Template label="Input DDR (IDDRE1)" treetype="template">
--   IDDRE1    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDDRE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDRE1: Dedicated Dual Data Rate (DDR) Input Register
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IDDRE1_inst : IDDRE1
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- IDDRE1 mode (OPPOSITE_EDGE, SAME_EDGE, SAME_EDGE_PIPELINED)
      IS_CB_INVERTED =&gt; '0',           -- Optional inversion for CB
      IS_C_INVERTED =&gt; '0'             -- Optional inversion for C
   )
   port map (
      Q1 =&gt; Q1, -- 1-bit output: Registered parallel output 1
      Q2 =&gt; Q2, -- 1-bit output: Registered parallel output 2
      C =&gt; C,   -- 1-bit input: High-speed clock
      CB =&gt; CB, -- 1-bit input: Inversion of High-speed clock C
      D =&gt; D,   -- 1-bit input: Serial Data Input
      R =&gt; R    -- 1-bit input: Active High Async Reset
   );

   -- End of IDDRE1_inst instantiation
					</Template>
					<Template label="Output DDR (ODDRE1)" treetype="template">
--   ODDRE1    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODDRE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDRE1: Dedicated Dual Data Rate (DDR) Output Register
   --         Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   ODDRE1_inst : ODDRE1
   generic map (
      IS_C_INVERTED =&gt; '0',  -- Optional inversion for C
      IS_D1_INVERTED =&gt; '0', -- Optional inversion for D1
      IS_D2_INVERTED =&gt; '0', -- Optional inversion for D2
      SRVAL =&gt; '0'           -- Initializes the ODDRE1 Flip-Flops to the specified value ('0', '1')
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data output to IOB
      C =&gt; C,   -- 1-bit input: High-speed clock input
      D1 =&gt; D1, -- 1-bit input: Parallel data input 1
      D2 =&gt; D2, -- 1-bit input: Parallel data input 2
      SR =&gt; SR  -- 1-bit input: Active High Async Reset
   );

   -- End of ODDRE1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Transparent Latch with Clock Enable and Asynchronous Clear (LDCE)" treetype="template">
--    LDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LDCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDCE: Transparent Latch with Clock Enable and Asynchronous Clear
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LDCE_inst : LDCE
   generic map (
      INIT =&gt; '0',            -- Initial value of latch, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_G_INVERTED =&gt; '0'    -- Optional inversion for G
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      D =&gt; D,     -- 1-bit input: Data
      G =&gt; G,     -- 1-bit input: Gate
      GE =&gt; GE    -- 1-bit input: Gate enable
   );

   -- End of LDCE_inst instantiation
					</Template>
					<Template label="Transparent Latch with Clock Enable and Asynchronous Preset (LDPE)" treetype="template">
--    LDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LDPE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDPE: Transparent Latch with Clock Enable and Asynchronous Preset
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LDPE_inst : LDPE
   generic map (
      INIT =&gt; '1',            -- Initial value of latch, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_G_INVERTED =&gt; '0',   -- Optional inversion for G
      IS_PRE_INVERTED =&gt; '0'  -- Optional inversion for PRE
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      D =&gt; D,     -- 1-bit input: Data
      G =&gt; G,     -- 1-bit input: Gate
      GE =&gt; GE,   -- 1-bit input: Gate enable
      PRE =&gt; PRE  -- 1-bit input: Asynchronous preset
   );

   -- End of LDPE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="METASTABILITY" treetype="folder">
					<Template label="Metastability Hardened Registers (HARD_SYNC)" treetype="template">
--  HARD_SYNC  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (HARD_SYNC_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- HARD_SYNC: Metastability Hardened Registers
   --            Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   HARD_SYNC_inst : HARD_SYNC
   generic map (
      INIT =&gt; '0',            -- Initial values, '0', '1'
      IS_CLK_INVERTED =&gt; '0', -- Programmable inversion on CLK input
      LATENCY =&gt; 2            -- 2-3
   )
   port map (
      DOUT =&gt; DOUT, -- 1-bit output: Data
      CLK =&gt; CLK,   -- 1-bit input: Clock
      DIN =&gt; DIN    -- 1-bit input: Data
   );

   -- End of HARD_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SDR" treetype="folder">
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Clear (FDCE)" treetype="template">
--    FDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDCE: D Flip-Flop with Clock Enable and Asynchronous Clear
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FDCE_inst : FDCE
   generic map (
      INIT =&gt; '0',            -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_C_INVERTED =&gt; '0',   -- Optional inversion for C
      IS_D_INVERTED =&gt; '0'    -- Optional inversion for D
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      C =&gt; C,     -- 1-bit input: Clock
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      D =&gt; D      -- 1-bit input: Data
   );

   -- End of FDCE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Preset (FDPE)" treetype="template">
--    FDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDPE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDPE: D Flip-Flop with Clock Enable and Asynchronous Preset
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FDPE_inst : FDPE
   generic map (
      INIT =&gt; '1',            -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0',   -- Optional inversion for C
      IS_D_INVERTED =&gt; '0',   -- Optional inversion for D
      IS_PRE_INVERTED =&gt; '0'  -- Optional inversion for PRE
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      C =&gt; C,     -- 1-bit input: Clock
      CE =&gt; CE,   -- 1-bit input: Clock enable
      D =&gt; D,     -- 1-bit input: Data
      PRE =&gt; PRE  -- 1-bit input: Asynchronous preset
   );

   -- End of FDPE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Reset (FDRE)" treetype="template">
--    FDRE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDRE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDRE: D Flip-Flop with Clock Enable and Synchronous Reset
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FDRE_inst : FDRE
   generic map (
      INIT =&gt; '0',          -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0', -- Optional inversion for C
      IS_D_INVERTED =&gt; '0', -- Optional inversion for D
      IS_R_INVERTED =&gt; '0'  -- Optional inversion for R
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data
      C =&gt; C,   -- 1-bit input: Clock
      CE =&gt; CE, -- 1-bit input: Clock enable
      D =&gt; D,   -- 1-bit input: Data
      R =&gt; R    -- 1-bit input: Synchronous reset
   );

   -- End of FDRE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Set (FDSE)" treetype="template">
--    FDSE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDSE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDSE: D Flip-Flop with Clock Enable and Synchronous Set
   --       Kintex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FDSE_inst : FDSE
   generic map (
      INIT =&gt; '1',          -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0', -- Optional inversion for C
      IS_D_INVERTED =&gt; '0', -- Optional inversion for D
      IS_S_INVERTED =&gt; '0'  -- Optional inversion for S
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data
      C =&gt; C,   -- 1-bit input: Clock
      CE =&gt; CE, -- 1-bit input: Clock enable
      D =&gt; D,   -- 1-bit input: Data
      S =&gt; S    -- 1-bit input: Synchronous set
   );

   -- End of FDSE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Kintex UltraScale+" treetype="folder">
			<SubFolder label="ADVANCED" treetype="folder">
				<SubFolder label="GT" treetype="folder">
					<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE4)" treetype="template">
-- IBUFDS_GTE4 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_GTE4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_GTE4: Gigabit Transceiver Buffer
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE4_inst : IBUFDS_GTE4
   generic map (
      REFCLK_EN_TX_PATH =&gt; '0',   -- Refer to Transceiver User Guide
      REFCLK_HROW_CK_SEL =&gt; "00", -- Refer to Transceiver User Guide
      REFCLK_ICNTL_RX =&gt; "00"     -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,         -- 1-bit output: Refer to Transceiver User Guide
      ODIV2 =&gt; ODIV2, -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,     -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,         -- 1-bit input: Refer to Transceiver User Guide
      IB =&gt; IB        -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of IBUFDS_GTE4_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE4_ADV)" treetype="template">
-- OBUFDS_GTE4_ADV : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (OBUFDS_GTE4_ADV_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_GTE4_ADV: Gigabit Transceiver Buffer
   --                  Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE4_ADV_inst : OBUFDS_GTE4_ADV
   generic map (
      REFCLK_EN_TX_PATH =&gt; '1',   -- Refer to Transceiver User Guide
      REFCLK_ICNTL_TX =&gt; "00000"  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,                       -- 1-bit output: Refer to Transceiver User Guide
      OB =&gt; OB,                     -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,                   -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,                       -- 4-bit input: Refer to Transceiver User Guide
      RXRECCLK_SEL =&gt; RXRECCLK_SEL  -- 2-bit input: Refer to Transceiver User Guide
   );

   -- End of OBUFDS_GTE4_ADV_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE4)" treetype="template">
-- OBUFDS_GTE4 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_GTE4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_GTE4: Gigabit Transceiver Buffer
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE4_inst : OBUFDS_GTE4
   generic map (
      REFCLK_EN_TX_PATH =&gt; '1',   -- Refer to Transceiver User Guide
      REFCLK_ICNTL_TX =&gt; "00000"  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,     -- 1-bit output: Refer to Transceiver User Guide
      OB =&gt; OB,   -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB, -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I      -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of OBUFDS_GTE4_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SYSMON" treetype="folder">
					<Template label="SYSMON Simulation File" treetype="template">
-- Must use valid headers on all columns
-- Comments can be added to the stimulus file using '--'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

-- Time stamp data is in nano seconds (ns)
-- Temperature is recorded in C (degrees centigrade)
-- All other channels are recorded as V (Volts)
-- Valid column headers are:
-- TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
-- VUSER0, VUSER1, VUSER2, VUSER3,
-- VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
-- External analog inputs are differential so VP = 0.5 and VN = 0.1 the
-- input on channel VP/VN in 0.5 - 0.1 = 0.4V
					</Template>
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE1)" treetype="template">
--  SYSMONE1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SYSMONE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SYSMONE1: Xilinx Analog-to-Digital Converter and System Monitor
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   SYSMONE1_inst : SYSMONE1
   generic map (
      -- INIT_40 - INIT_44: SYSMON configuration registers
      INIT_40 =&gt; X"0000",
      INIT_41 =&gt; X"0000",
      INIT_42 =&gt; X"0000",
      INIT_43 =&gt; X"0000",
      INIT_44 =&gt; X"0000",
      INIT_45 =&gt; X"0000",               -- Analog Bus Register
      -- INIT_46 - INIT_4F: Sequence Registers
      INIT_46 =&gt; X"0000",
      INIT_47 =&gt; X"0000",
      INIT_48 =&gt; X"0000",
      INIT_49 =&gt; X"0000",
      INIT_4A =&gt; X"0000",
      INIT_4B =&gt; X"0000",
      INIT_4C =&gt; X"0000",
      INIT_4D =&gt; X"0000",
      INIT_4E =&gt; X"0000",
      INIT_4F =&gt; X"0000",
      -- INIT_50 - INIT_5F: Alarm Limit Registers
      INIT_50 =&gt; X"0000",
      INIT_51 =&gt; X"0000",
      INIT_52 =&gt; X"0000",
      INIT_53 =&gt; X"0000",
      INIT_54 =&gt; X"0000",
      INIT_55 =&gt; X"0000",
      INIT_56 =&gt; X"0000",
      INIT_57 =&gt; X"0000",
      INIT_58 =&gt; X"0000",
      INIT_59 =&gt; X"0000",
      INIT_5A =&gt; X"0000",
      INIT_5B =&gt; X"0000",
      INIT_5C =&gt; X"0000",
      INIT_5D =&gt; X"0000",
      INIT_5E =&gt; X"0000",
      INIT_5F =&gt; X"0000",
      -- INIT_60 - INIT_6F: User Supply Alarms
      INIT_60 =&gt; X"0000",
      INIT_61 =&gt; X"0000",
      INIT_62 =&gt; X"0000",
      INIT_63 =&gt; X"0000",
      INIT_64 =&gt; X"0000",
      INIT_65 =&gt; X"0000",
      INIT_66 =&gt; X"0000",
      INIT_67 =&gt; X"0000",
      INIT_68 =&gt; X"0000",
      INIT_69 =&gt; X"0000",
      INIT_6A =&gt; X"0000",
      INIT_6B =&gt; X"0000",
      INIT_6C =&gt; X"0000",
      INIT_6D =&gt; X"0000",
      INIT_6E =&gt; X"0000",
      INIT_6F =&gt; X"0000",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      -- specific pins
      IS_CONVSTCLK_INVERTED =&gt; '0',     -- Optional inversion for CONVSTCLK, 0-1
      IS_DCLK_INVERTED =&gt; '0',          -- Optional inversion for DCLK, 0-1
      -- Simulation attributes: Set for proper simulation behavior
      SIM_MONITOR_FILE =&gt; "design.txt", -- Analog simulation data file name
      -- User Voltage Monitor: SYSMON User voltage monitor
      SYSMON_VUSER0_BANK =&gt; 0,          -- Specify IO Bank for User0
      SYSMON_VUSER0_MONITOR =&gt; "NONE",  -- Specify Voltage for User0
      SYSMON_VUSER1_BANK =&gt; 0,          -- Specify IO Bank for User1
      SYSMON_VUSER1_MONITOR =&gt; "NONE",  -- Specify Voltage for User1
      SYSMON_VUSER2_BANK =&gt; 0,          -- Specify IO Bank for User2
      SYSMON_VUSER2_MONITOR =&gt; "NONE",  -- Specify Voltage for User2
      SYSMON_VUSER3_MONITOR =&gt; "NONE"   -- Specify Voltage for User3
   )
   port map (
      -- ALARMS outputs: ALM, OT
      ALM =&gt; ALM,                   -- 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      OT =&gt; OT,                     -- 1-bit output: Over-Temperature alarm
      -- Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      DO =&gt; DO,                     -- 16-bit output: DRP output data bus
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP data ready
      -- I2C Interface outputs: Ports used with the I2C DRP interface
      I2C_SCLK_TS =&gt; I2C_SCLK_TS,   -- 1-bit output: I2C_SCLK output port
      I2C_SDA_TS =&gt; I2C_SDA_TS,     -- 1-bit output: I2C_SDA_TS output port
      -- STATUS outputs: SYSMON status ports
      BUSY =&gt; BUSY,                 -- 1-bit output: System Monitor busy output
      CHANNEL =&gt; CHANNEL,           -- 6-bit output: Channel selection outputs
      EOC =&gt; EOC,                   -- 1-bit output: End of Conversion
      EOS =&gt; EOS,                   -- 1-bit output: End of Sequence
      JTAGBUSY =&gt; JTAGBUSY,         -- 1-bit output: JTAG DRP transaction in progress output
      JTAGLOCKED =&gt; JTAGLOCKED,     -- 1-bit output: JTAG requested DRP port lock
      JTAGMODIFIED =&gt; JTAGMODIFIED, -- 1-bit output: JTAG Write to the DRP has occurred
      MUXADDR =&gt; MUXADDR,           -- 5-bit output: External MUX channel decode
      -- Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      VAUXN =&gt; VAUXN,               -- 16-bit input: N-side auxiliary analog input
      VAUXP =&gt; VAUXP,               -- 16-bit input: P-side auxiliary analog input
      -- CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      CONVST =&gt; CONVST,             -- 1-bit input: Convert start input
      CONVSTCLK =&gt; CONVSTCLK,       -- 1-bit input: Convert start input
      RESET =&gt; RESET,               -- 1-bit input: Active-High reset
      -- Dedicated Analog Input Pair inputs: VP/VN
      VN =&gt; VN,                     -- 1-bit input: N-side analog input
      VP =&gt; VP,                     -- 1-bit input: P-side analog input
      -- Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      DADDR =&gt; DADDR,               -- 8-bit input: DRP address bus
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable signal
      DI =&gt; DI,                     -- 16-bit input: DRP input data bus
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- I2C Interface inputs: Ports used with the I2C DRP interface
      I2C_SCLK =&gt; I2C_SCLK,         -- 1-bit input: I2C_SCLK input port
      I2C_SDA =&gt; I2C_SDA            -- 1-bit input: I2C_SDA input port
   );

   -- End of SYSMONE1_inst instantiation
					</Template>
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE4)" treetype="template">
--  SYSMONE4   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SYSMONE4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SYSMONE4: Xilinx Analog-to-Digital Converter and System Monitor
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   SYSMONE4_inst : SYSMONE4
   generic map (
      -- INIT_40 - INIT_44: SYSMON configuration registers
      INIT_40 =&gt; X"0000",
      INIT_41 =&gt; X"0000",
      INIT_42 =&gt; X"0000",
      INIT_43 =&gt; X"0000",
      INIT_44 =&gt; X"0000",
      INIT_45 =&gt; X"0000",               -- Analog Bus Register
      -- INIT_46 - INIT_4F: Sequence Registers
      INIT_46 =&gt; X"0000",
      INIT_47 =&gt; X"0000",
      INIT_48 =&gt; X"0000",
      INIT_49 =&gt; X"0000",
      INIT_4A =&gt; X"0000",
      INIT_4B =&gt; X"0000",
      INIT_4C =&gt; X"0000",
      INIT_4D =&gt; X"0000",
      INIT_4E =&gt; X"0000",
      INIT_4F =&gt; X"0000",
      -- INIT_50 - INIT_5F: Alarm Limit Registers
      INIT_50 =&gt; X"0000",
      INIT_51 =&gt; X"0000",
      INIT_52 =&gt; X"0000",
      INIT_53 =&gt; X"0000",
      INIT_54 =&gt; X"0000",
      INIT_55 =&gt; X"0000",
      INIT_56 =&gt; X"0000",
      INIT_57 =&gt; X"0000",
      INIT_58 =&gt; X"0000",
      INIT_59 =&gt; X"0000",
      INIT_5A =&gt; X"0000",
      INIT_5B =&gt; X"0000",
      INIT_5C =&gt; X"0000",
      INIT_5D =&gt; X"0000",
      INIT_5E =&gt; X"0000",
      INIT_5F =&gt; X"0000",
      -- INIT_60 - INIT_6F: User Supply Alarms
      INIT_60 =&gt; X"0000",
      INIT_61 =&gt; X"0000",
      INIT_62 =&gt; X"0000",
      INIT_63 =&gt; X"0000",
      INIT_64 =&gt; X"0000",
      INIT_65 =&gt; X"0000",
      INIT_66 =&gt; X"0000",
      INIT_67 =&gt; X"0000",
      INIT_68 =&gt; X"0000",
      INIT_69 =&gt; X"0000",
      INIT_6A =&gt; X"0000",
      INIT_6B =&gt; X"0000",
      INIT_6C =&gt; X"0000",
      INIT_6D =&gt; X"0000",
      INIT_6E =&gt; X"0000",
      INIT_6F =&gt; X"0000",
      -- Primitive attributes: Primitive Attributes
      COMMON_N_SOURCE =&gt; X"ffff",       -- Sets the auxiliary analog input that is used for the Common-N input.
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      -- specific pins
      IS_CONVSTCLK_INVERTED =&gt; '0',     -- Optional inversion for CONVSTCLK, 0-1
      IS_DCLK_INVERTED =&gt; '0',          -- Optional inversion for DCLK, 0-1
      -- Simulation attributes: Set for proper simulation behavior
      SIM_DEVICE =&gt; "ULTRASCALE_PLUS",  -- Sets the correct target device for simulation functionality.
      SIM_MONITOR_FILE =&gt; "design.txt", -- Analog simulation data file name
      -- User Voltage Monitor: SYSMON User voltage monitor
      SYSMON_VUSER0_BANK =&gt; 0,          -- Specify IO Bank for User0
      SYSMON_VUSER0_MONITOR =&gt; "NONE",  -- Specify Voltage for User0
      SYSMON_VUSER1_BANK =&gt; 0,          -- Specify IO Bank for User1
      SYSMON_VUSER1_MONITOR =&gt; "NONE",  -- Specify Voltage for User1
      SYSMON_VUSER2_BANK =&gt; 0,          -- Specify IO Bank for User2
      SYSMON_VUSER2_MONITOR =&gt; "NONE",  -- Specify Voltage for User2
      SYSMON_VUSER3_MONITOR =&gt; "NONE"   -- Specify Voltage for User3
   )
   port map (
      -- ALARMS outputs: ALM, OT
      ALM =&gt; ALM,                   -- 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      OT =&gt; OT,                     -- 1-bit output: Over-Temperature alarm
      -- Direct Data Out outputs: ADC_DATA
      ADC_DATA =&gt; ADC_DATA,         -- 16-bit output: Direct Data Out
      -- Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      DO =&gt; DO,                     -- 16-bit output: DRP output data bus
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP data ready
      -- I2C Interface outputs: Ports used with the I2C DRP interface
      I2C_SCLK_TS =&gt; I2C_SCLK_TS,   -- 1-bit output: I2C_SCLK output port
      I2C_SDA_TS =&gt; I2C_SDA_TS,     -- 1-bit output: I2C_SDA_TS output port
      SMBALERT_TS =&gt; SMBALERT_TS,   -- 1-bit output: Output control signal for SMBALERT.
      -- STATUS outputs: SYSMON status ports
      BUSY =&gt; BUSY,                 -- 1-bit output: System Monitor busy output
      CHANNEL =&gt; CHANNEL,           -- 6-bit output: Channel selection outputs
      EOC =&gt; EOC,                   -- 1-bit output: End of Conversion
      EOS =&gt; EOS,                   -- 1-bit output: End of Sequence
      JTAGBUSY =&gt; JTAGBUSY,         -- 1-bit output: JTAG DRP transaction in progress output
      JTAGLOCKED =&gt; JTAGLOCKED,     -- 1-bit output: JTAG requested DRP port lock
      JTAGMODIFIED =&gt; JTAGMODIFIED, -- 1-bit output: JTAG Write to the DRP has occurred
      MUXADDR =&gt; MUXADDR,           -- 5-bit output: External MUX channel decode
      -- Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      VAUXN =&gt; VAUXN,               -- 16-bit input: N-side auxiliary analog input
      VAUXP =&gt; VAUXP,               -- 16-bit input: P-side auxiliary analog input
      -- CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      CONVST =&gt; CONVST,             -- 1-bit input: Convert start input
      CONVSTCLK =&gt; CONVSTCLK,       -- 1-bit input: Convert start input
      RESET =&gt; RESET,               -- 1-bit input: Active-High reset
      -- Dedicated Analog Input Pair inputs: VP/VN
      VN =&gt; VN,                     -- 1-bit input: N-side analog input
      VP =&gt; VP,                     -- 1-bit input: P-side analog input
      -- Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      DADDR =&gt; DADDR,               -- 8-bit input: DRP address bus
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable signal
      DI =&gt; DI,                     -- 16-bit input: DRP input data bus
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- I2C Interface inputs: Ports used with the I2C DRP interface
      I2C_SCLK =&gt; I2C_SCLK,         -- 1-bit input: I2C_SCLK input port
      I2C_SDA =&gt; I2C_SDA            -- 1-bit input: I2C_SDA input port
   );

   -- End of SYSMONE4_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="ARITHMETIC" treetype="folder">
				<SubFolder label="DSP" treetype="folder">
					<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E2)" treetype="template">
--   DSP48E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DSP48E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DSP48E2: 48-bit Multi-Functional Arithmetic Block
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   DSP48E2_inst : DSP48E2
   generic map (
      -- Feature Control Attributes: Data Path Selection
      AMULTSEL =&gt; "A",                   -- Selects A input to multiplier (A, AD)
      A_INPUT =&gt; "DIRECT",               -- Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      BMULTSEL =&gt; "B",                   -- Selects B input to multiplier (AD, B)
      B_INPUT =&gt; "DIRECT",               -- Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      PREADDINSEL =&gt; "A",                -- Selects input to pre-adder (A, B)
      RND =&gt; X"000000000000",            -- Rounding Constant
      USE_MULT =&gt; "MULTIPLY",            -- Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
      USE_SIMD =&gt; "ONE48",               -- SIMD selection (FOUR12, ONE48, TWO24)
      USE_WIDEXOR =&gt; "FALSE",            -- Use the Wide XOR function (FALSE, TRUE)
      XORSIMD =&gt; "XOR24_48_96",          -- Mode of operation for the Wide XOR (XOR12, XOR24_48_96)
      -- Pattern Detector Attributes: Pattern Detection Configuration
      AUTORESET_PATDET =&gt; "NO_RESET",    -- NO_RESET, RESET_MATCH, RESET_NOT_MATCH
      AUTORESET_PRIORITY =&gt; "RESET",     -- Priority of AUTORESET vs. CEP (CEP, RESET).
      MASK =&gt; X"3fffffffffff",           -- 48-bit mask value for pattern detect (1=ignore)
      PATTERN =&gt; X"000000000000",        -- 48-bit pattern match for pattern detect
      SEL_MASK =&gt; "MASK",                -- C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
      SEL_PATTERN =&gt; "PATTERN",          -- Select pattern value (C, PATTERN)
      USE_PATTERN_DETECT =&gt; "NO_PATDET", -- Enable pattern detect (NO_PATDET, PATDET)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_ALUMODE_INVERTED =&gt; "0000",     -- Optional inversion for ALUMODE
      IS_CARRYIN_INVERTED =&gt; '0',        -- Optional inversion for CARRYIN
      IS_CLK_INVERTED =&gt; '0',            -- Optional inversion for CLK
      IS_INMODE_INVERTED =&gt; "00000",     -- Optional inversion for INMODE
      IS_OPMODE_INVERTED =&gt; "000000000", -- Optional inversion for OPMODE
      IS_RSTALLCARRYIN_INVERTED =&gt; '0',  -- Optional inversion for RSTALLCARRYIN
      IS_RSTALUMODE_INVERTED =&gt; '0',     -- Optional inversion for RSTALUMODE
      IS_RSTA_INVERTED =&gt; '0',           -- Optional inversion for RSTA
      IS_RSTB_INVERTED =&gt; '0',           -- Optional inversion for RSTB
      IS_RSTCTRL_INVERTED =&gt; '0',        -- Optional inversion for RSTCTRL
      IS_RSTC_INVERTED =&gt; '0',           -- Optional inversion for RSTC
      IS_RSTD_INVERTED =&gt; '0',           -- Optional inversion for RSTD
      IS_RSTINMODE_INVERTED =&gt; '0',      -- Optional inversion for RSTINMODE
      IS_RSTM_INVERTED =&gt; '0',           -- Optional inversion for RSTM
      IS_RSTP_INVERTED =&gt; '0',           -- Optional inversion for RSTP
      -- Register Control Attributes: Pipeline Register Configuration
      ACASCREG =&gt; 1,                     -- Number of pipeline stages between A/ACIN and ACOUT (0-2)
      ADREG =&gt; 1,                        -- Pipeline stages for pre-adder (0-1)
      ALUMODEREG =&gt; 1,                   -- Pipeline stages for ALUMODE (0-1)
      AREG =&gt; 1,                         -- Pipeline stages for A (0-2)
      BCASCREG =&gt; 1,                     -- Number of pipeline stages between B/BCIN and BCOUT (0-2)
      BREG =&gt; 1,                         -- Pipeline stages for B (0-2)
      CARRYINREG =&gt; 1,                   -- Pipeline stages for CARRYIN (0-1)
      CARRYINSELREG =&gt; 1,                -- Pipeline stages for CARRYINSEL (0-1)
      CREG =&gt; 1,                         -- Pipeline stages for C (0-1)
      DREG =&gt; 1,                         -- Pipeline stages for D (0-1)
      INMODEREG =&gt; 1,                    -- Pipeline stages for INMODE (0-1)
      MREG =&gt; 1,                         -- Multiplier pipeline stages (0-1)
      OPMODEREG =&gt; 1,                    -- Pipeline stages for OPMODE (0-1)
      PREG =&gt; 1                          -- Number of pipeline stages for P (0-1)
   )
   port map (
      -- Cascade outputs: Cascade Ports
      ACOUT =&gt; ACOUT,                   -- 30-bit output: A port cascade
      BCOUT =&gt; BCOUT,                   -- 18-bit output: B cascade
      CARRYCASCOUT =&gt; CARRYCASCOUT,     -- 1-bit output: Cascade carry
      MULTSIGNOUT =&gt; MULTSIGNOUT,       -- 1-bit output: Multiplier sign cascade
      PCOUT =&gt; PCOUT,                   -- 48-bit output: Cascade output
      -- Control outputs: Control Inputs/Status Bits
      OVERFLOW =&gt; OVERFLOW,             -- 1-bit output: Overflow in add/acc
      PATTERNBDETECT =&gt; PATTERNBDETECT, -- 1-bit output: Pattern bar detect
      PATTERNDETECT =&gt; PATTERNDETECT,   -- 1-bit output: Pattern detect
      UNDERFLOW =&gt; UNDERFLOW,           -- 1-bit output: Underflow in add/acc
      -- Data outputs: Data Ports
      CARRYOUT =&gt; CARRYOUT,             -- 4-bit output: Carry
      P =&gt; P,                           -- 48-bit output: Primary data
      XOROUT =&gt; XOROUT,                 -- 8-bit output: XOR data
      -- Cascade inputs: Cascade Ports
      ACIN =&gt; ACIN,                     -- 30-bit input: A cascade data
      BCIN =&gt; BCIN,                     -- 18-bit input: B cascade
      CARRYCASCIN =&gt; CARRYCASCIN,       -- 1-bit input: Cascade carry
      MULTSIGNIN =&gt; MULTSIGNIN,         -- 1-bit input: Multiplier sign cascade
      PCIN =&gt; PCIN,                     -- 48-bit input: P cascade
      -- Control inputs: Control Inputs/Status Bits
      ALUMODE =&gt; ALUMODE,               -- 4-bit input: ALU control
      CARRYINSEL =&gt; CARRYINSEL,         -- 3-bit input: Carry select
      CLK =&gt; CLK,                       -- 1-bit input: Clock
      INMODE =&gt; INMODE,                 -- 5-bit input: INMODE control
      OPMODE =&gt; OPMODE,                 -- 9-bit input: Operation mode
      -- Data inputs: Data Ports
      A =&gt; A,                           -- 30-bit input: A data
      B =&gt; B,                           -- 18-bit input: B data
      C =&gt; C,                           -- 48-bit input: C data
      CARRYIN =&gt; CARRYIN,               -- 1-bit input: Carry-in
      D =&gt; D,                           -- 27-bit input: D data
      -- Reset/Clock Enable inputs: Reset/Clock Enable Inputs
      CEA1 =&gt; CEA1,                     -- 1-bit input: Clock enable for 1st stage AREG
      CEA2 =&gt; CEA2,                     -- 1-bit input: Clock enable for 2nd stage AREG
      CEAD =&gt; CEAD,                     -- 1-bit input: Clock enable for ADREG
      CEALUMODE =&gt; CEALUMODE,           -- 1-bit input: Clock enable for ALUMODE
      CEB1 =&gt; CEB1,                     -- 1-bit input: Clock enable for 1st stage BREG
      CEB2 =&gt; CEB2,                     -- 1-bit input: Clock enable for 2nd stage BREG
      CEC =&gt; CEC,                       -- 1-bit input: Clock enable for CREG
      CECARRYIN =&gt; CECARRYIN,           -- 1-bit input: Clock enable for CARRYINREG
      CECTRL =&gt; CECTRL,                 -- 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
      CED =&gt; CED,                       -- 1-bit input: Clock enable for DREG
      CEINMODE =&gt; CEINMODE,             -- 1-bit input: Clock enable for INMODEREG
      CEM =&gt; CEM,                       -- 1-bit input: Clock enable for MREG
      CEP =&gt; CEP,                       -- 1-bit input: Clock enable for PREG
      RSTA =&gt; RSTA,                     -- 1-bit input: Reset for AREG
      RSTALLCARRYIN =&gt; RSTALLCARRYIN,   -- 1-bit input: Reset for CARRYINREG
      RSTALUMODE =&gt; RSTALUMODE,         -- 1-bit input: Reset for ALUMODEREG
      RSTB =&gt; RSTB,                     -- 1-bit input: Reset for BREG
      RSTC =&gt; RSTC,                     -- 1-bit input: Reset for CREG
      RSTCTRL =&gt; RSTCTRL,               -- 1-bit input: Reset for OPMODEREG and CARRYINSELREG
      RSTD =&gt; RSTD,                     -- 1-bit input: Reset for DREG and ADREG
      RSTINMODE =&gt; RSTINMODE,           -- 1-bit input: Reset for INMODEREG
      RSTM =&gt; RSTM,                     -- 1-bit input: Reset for MREG
      RSTP =&gt; RSTP                      -- 1-bit input: Reset for PREG
   );

   -- End of DSP48E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="BLOCKRAM" treetype="folder">
				<SubFolder label="BRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E2)" treetype="template">
--  RAMB18E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB18E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB18E2: 18K-bit Configurable Synchronous Block RAM
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAMB18E2_inst : RAMB18E2
   generic map (
      -- CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      CASCADE_ORDER_A =&gt; "NONE",
      CASCADE_ORDER_B =&gt; "NONE",
      -- CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      CLOCK_DOMAINS =&gt; "INDEPENDENT",
      -- Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0, 1)
      DOA_REG =&gt; 1,
      DOB_REG =&gt; 1,
      -- ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      ENADDRENA =&gt; "FALSE",
      ENADDRENB =&gt; "FALSE",
      -- INITP_00 to INITP_07: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_3F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"00000",
      INIT_B =&gt; X"00000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLKARDCLK_INVERTED =&gt; '0',
      IS_CLKBWRCLK_INVERTED =&gt; '0',
      IS_ENARDEN_INVERTED =&gt; '0',
      IS_ENBWREN_INVERTED =&gt; '0',
      IS_RSTRAMARSTRAM_INVERTED =&gt; '0',
      IS_RSTRAMB_INVERTED =&gt; '0',
      IS_RSTREGARSTREG_INVERTED =&gt; '0',
      IS_RSTREGB_INVERTED =&gt; '0',
      -- RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      RDADDRCHANGEA =&gt; "FALSE",
      RDADDRCHANGEB =&gt; "FALSE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-9
      READ_WIDTH_B =&gt; 0,                                                               -- 0-9
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-9
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-9
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"00000",
      SRVAL_B =&gt; X"00000",
      -- Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      SLEEP_ASYNC =&gt; "FALSE",
      -- WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      WRITE_MODE_A =&gt; "NO_CHANGE",
      WRITE_MODE_B =&gt; "NO_CHANGE" 
   )
   port map (
      -- Cascade Signals outputs: Multi-BRAM cascade signals
      CASDOUTA =&gt; CASDOUTA,               -- 16-bit output: Port A cascade output data
      CASDOUTB =&gt; CASDOUTB,               -- 16-bit output: Port B cascade output data
      CASDOUTPA =&gt; CASDOUTPA,             -- 2-bit output: Port A cascade output parity data
      CASDOUTPB =&gt; CASDOUTPB,             -- 2-bit output: Port B cascade output parity data
      -- Port A Data outputs: Port A data
      DOUTADOUT =&gt; DOUTADOUT,             -- 16-bit output: Port A data/LSB data
      DOUTPADOUTP =&gt; DOUTPADOUTP,         -- 2-bit output: Port A parity/LSB parity
      -- Port B Data outputs: Port B data
      DOUTBDOUT =&gt; DOUTBDOUT,             -- 16-bit output: Port B data/MSB data
      DOUTPBDOUTP =&gt; DOUTPBDOUTP,         -- 2-bit output: Port B parity/MSB parity
      -- Cascade Signals inputs: Multi-BRAM cascade signals
      CASDIMUXA =&gt; CASDIMUXA,             -- 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      CASDIMUXB =&gt; CASDIMUXB,             -- 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      CASDINA =&gt; CASDINA,                 -- 16-bit input: Port A cascade input data
      CASDINB =&gt; CASDINB,                 -- 16-bit input: Port B cascade input data
      CASDINPA =&gt; CASDINPA,               -- 2-bit input: Port A cascade input parity data
      CASDINPB =&gt; CASDINPB,               -- 2-bit input: Port B cascade input parity data
      CASDOMUXA =&gt; CASDOMUXA,             -- 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      CASDOMUXB =&gt; CASDOMUXB,             -- 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      CASDOMUXEN_A =&gt; CASDOMUXEN_A,       -- 1-bit input: Port A unregistered output data enable
      CASDOMUXEN_B =&gt; CASDOMUXEN_B,       -- 1-bit input: Port B unregistered output data enable
      CASOREGIMUXA =&gt; CASOREGIMUXA,       -- 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      CASOREGIMUXB =&gt; CASOREGIMUXB,       -- 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      CASOREGIMUXEN_A =&gt; CASOREGIMUXEN_A, -- 1-bit input: Port A registered output data enable
      CASOREGIMUXEN_B =&gt; CASOREGIMUXEN_B, -- 1-bit input: Port B registered output data enable
      -- Port A Address/Control Signals inputs: Port A address and control signals
      ADDRARDADDR =&gt; ADDRARDADDR,         -- 14-bit input: A/Read port address
      ADDRENA =&gt; ADDRENA,                 -- 1-bit input: Active-High A/Read port address enable
      CLKARDCLK =&gt; CLKARDCLK,             -- 1-bit input: A/Read port clock
      ENARDEN =&gt; ENARDEN,                 -- 1-bit input: Port A enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,         -- 1-bit input: Port A register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM,     -- 1-bit input: Port A set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG,     -- 1-bit input: Port A register set/reset
      WEA =&gt; WEA,                         -- 2-bit input: Port A write enable
      -- Port A Data inputs: Port A data
      DINADIN =&gt; DINADIN,                 -- 16-bit input: Port A data/LSB data
      DINPADINP =&gt; DINPADINP,             -- 2-bit input: Port A parity/LSB parity
      -- Port B Address/Control Signals inputs: Port B address and control signals
      ADDRBWRADDR =&gt; ADDRBWRADDR,         -- 14-bit input: B/Write port address
      ADDRENB =&gt; ADDRENB,                 -- 1-bit input: Active-High B/Write port address enable
      CLKBWRCLK =&gt; CLKBWRCLK,             -- 1-bit input: B/Write port clock
      ENBWREN =&gt; ENBWREN,                 -- 1-bit input: Port B enable/Write enable
      REGCEB =&gt; REGCEB,                   -- 1-bit input: Port B register enable
      RSTRAMB =&gt; RSTRAMB,                 -- 1-bit input: Port B set/reset
      RSTREGB =&gt; RSTREGB,                 -- 1-bit input: Port B register set/reset
      SLEEP =&gt; SLEEP,                     -- 1-bit input: Sleep Mode
      WEBWE =&gt; WEBWE,                     -- 4-bit input: Port B write enable/Write enable
      -- Port B Data inputs: Port B data
      DINBDIN =&gt; DINBDIN,                 -- 16-bit input: Port B data/MSB data
      DINPBDINP =&gt; DINPBDINP              -- 2-bit input: Port B parity/MSB parity
   );

   -- End of RAMB18E2_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E2)" treetype="template">
--  RAMB36E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB36E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB36E2: 36K-bit Configurable Synchronous Block RAM
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAMB36E2_inst : RAMB36E2
   generic map (
      -- CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      CASCADE_ORDER_A =&gt; "NONE",
      CASCADE_ORDER_B =&gt; "NONE",
      -- CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      CLOCK_DOMAINS =&gt; "INDEPENDENT",
      DOB_REG =&gt; 1,
      -- Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0, 1)
      DOA_REG =&gt; 1,
      -- ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      ENADDRENA =&gt; "FALSE",
      ENADDRENB =&gt; "FALSE",
      -- EN_ECC_PIPE: ECC pipeline register, "TRUE"/"FALSE" 
      EN_ECC_PIPE =&gt; "FALSE",
      -- EN_ECC_READ: Enable ECC decoder, "TRUE"/"FALSE" 
      EN_ECC_READ =&gt; "FALSE",
      -- EN_ECC_WRITE: Enable ECC encoder, "TRUE"/"FALSE" 
      EN_ECC_WRITE =&gt; "FALSE",
      -- INITP_00 to INITP_0F: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_7F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"000000000",
      INIT_B =&gt; X"000000000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLKARDCLK_INVERTED =&gt; '0',
      IS_CLKBWRCLK_INVERTED =&gt; '0',
      IS_ENARDEN_INVERTED =&gt; '0',
      IS_ENBWREN_INVERTED =&gt; '0',
      IS_RSTRAMARSTRAM_INVERTED =&gt; '0',
      IS_RSTRAMB_INVERTED =&gt; '0',
      IS_RSTREGARSTREG_INVERTED =&gt; '0',
      IS_RSTREGB_INVERTED =&gt; '0',
      -- RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      RDADDRCHANGEA =&gt; "FALSE",
      RDADDRCHANGEB =&gt; "FALSE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-9
      READ_WIDTH_B =&gt; 0,                                                               -- 0-9
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-9
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-9
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"000000000",
      SRVAL_B =&gt; X"000000000",
      -- Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      SLEEP_ASYNC =&gt; "FALSE",
      -- WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      WRITE_MODE_A =&gt; "NO_CHANGE",
      WRITE_MODE_B =&gt; "NO_CHANGE" 
   )
   port map (
      -- Cascade Signals outputs: Multi-BRAM cascade signals
      CASDOUTA =&gt; CASDOUTA,               -- 32-bit output: Port A cascade output data
      CASDOUTB =&gt; CASDOUTB,               -- 32-bit output: Port B cascade output data
      CASDOUTPA =&gt; CASDOUTPA,             -- 4-bit output: Port A cascade output parity data
      CASDOUTPB =&gt; CASDOUTPB,             -- 4-bit output: Port B cascade output parity data
      CASOUTDBITERR =&gt; CASOUTDBITERR,     -- 1-bit output: DBITERR cascade output
      CASOUTSBITERR =&gt; CASOUTSBITERR,     -- 1-bit output: SBITERR cascade output
      -- ECC Signals outputs: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,                 -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,             -- 8-bit output: Generated error correction parity
      RDADDRECC =&gt; RDADDRECC,             -- 9-bit output: ECC Read Address
      SBITERR =&gt; SBITERR,                 -- 1-bit output: Single bit error status
      -- Port A Data outputs: Port A data
      DOUTADOUT =&gt; DOUTADOUT,             -- 32-bit output: Port A ata/LSB data
      DOUTPADOUTP =&gt; DOUTPADOUTP,         -- 4-bit output: Port A parity/LSB parity
      -- Port B Data outputs: Port B data
      DOUTBDOUT =&gt; DOUTBDOUT,             -- 32-bit output: Port B data/MSB data
      DOUTPBDOUTP =&gt; DOUTPBDOUTP,         -- 4-bit output: Port B parity/MSB parity
      -- Cascade Signals inputs: Multi-BRAM cascade signals
      CASDIMUXA =&gt; CASDIMUXA,             -- 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      CASDIMUXB =&gt; CASDIMUXB,             -- 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      CASDINA =&gt; CASDINA,                 -- 32-bit input: Port A cascade input data
      CASDINB =&gt; CASDINB,                 -- 32-bit input: Port B cascade input data
      CASDINPA =&gt; CASDINPA,               -- 4-bit input: Port A cascade input parity data
      CASDINPB =&gt; CASDINPB,               -- 4-bit input: Port B cascade input parity data
      CASDOMUXA =&gt; CASDOMUXA,             -- 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      CASDOMUXB =&gt; CASDOMUXB,             -- 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      CASDOMUXEN_A =&gt; CASDOMUXEN_A,       -- 1-bit input: Port A unregistered output data enable
      CASDOMUXEN_B =&gt; CASDOMUXEN_B,       -- 1-bit input: Port B unregistered output data enable
      CASINDBITERR =&gt; CASINDBITERR,       -- 1-bit input: DBITERR cascade input
      CASINSBITERR =&gt; CASINSBITERR,       -- 1-bit input: SBITERR cascade input
      CASOREGIMUXA =&gt; CASOREGIMUXA,       -- 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      CASOREGIMUXB =&gt; CASOREGIMUXB,       -- 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      CASOREGIMUXEN_A =&gt; CASOREGIMUXEN_A, -- 1-bit input: Port A registered output data enable
      CASOREGIMUXEN_B =&gt; CASOREGIMUXEN_B, -- 1-bit input: Port B registered output data enable
      -- ECC Signals inputs: Error Correction Circuitry ports
      ECCPIPECE =&gt; ECCPIPECE,             -- 1-bit input: ECC Pipeline Register Enable
      INJECTDBITERR =&gt; INJECTDBITERR,     -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR,
      -- Port A Address/Control Signals inputs: Port A address and control signals
      ADDRARDADDR =&gt; ADDRARDADDR,         -- 15-bit input: A/Read port address
      ADDRENA =&gt; ADDRENA,                 -- 1-bit input: Active-High A/Read port address enable
      CLKARDCLK =&gt; CLKARDCLK,             -- 1-bit input: A/Read port clock
      ENARDEN =&gt; ENARDEN,                 -- 1-bit input: Port A enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,         -- 1-bit input: Port A register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM,     -- 1-bit input: Port A set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG,     -- 1-bit input: Port A register set/reset
      SLEEP =&gt; SLEEP,                     -- 1-bit input: Sleep Mode
      WEA =&gt; WEA,                         -- 4-bit input: Port A write enable
      -- Port A Data inputs: Port A data
      DINADIN =&gt; DINADIN,                 -- 32-bit input: Port A data/LSB data
      DINPADINP =&gt; DINPADINP,             -- 4-bit input: Port A parity/LSB parity
      -- Port B Address/Control Signals inputs: Port B address and control signals
      ADDRBWRADDR =&gt; ADDRBWRADDR,         -- 15-bit input: B/Write port address
      ADDRENB =&gt; ADDRENB,                 -- 1-bit input: Active-High B/Write port address enable
      CLKBWRCLK =&gt; CLKBWRCLK,             -- 1-bit input: B/Write port clock
      ENBWREN =&gt; ENBWREN,                 -- 1-bit input: Port B enable/Write enable
      REGCEB =&gt; REGCEB,                   -- 1-bit input: Port B register enable
      RSTRAMB =&gt; RSTRAMB,                 -- 1-bit input: Port B set/reset
      RSTREGB =&gt; RSTREGB,                 -- 1-bit input: Port B register set/reset
      WEBWE =&gt; WEBWE,                     -- 8-bit input: Port B write enable/Write enable
      -- Port B Data inputs: Port B data
      DINBDIN =&gt; DINBDIN,                 -- 32-bit input: Port B data/MSB data
      DINPBDINP =&gt; DINPBDINP              -- 4-bit input: Port B parity/MSB parity
   );

   -- End of RAMB36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E2)" treetype="template">
--  FIFO18E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO18E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO18E2: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FIFO18E2_inst : FIFO18E2
   generic map (
      CASCADE_ORDER =&gt; "NONE",            -- FIRST, LAST, MIDDLE, NONE, PARALLEL
      CLOCK_DOMAINS =&gt; "INDEPENDENT",     -- COMMON, INDEPENDENT
      FIRST_WORD_FALL_THROUGH =&gt; "FALSE", -- FALSE, TRUE
      INIT =&gt; X"000000000",               -- Initial values on output port
      PROG_EMPTY_THRESH =&gt; 256,           -- Programmable Empty Threshold
      PROG_FULL_THRESH =&gt; 256,            -- Programmable Full Threshold
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_RDCLK_INVERTED =&gt; '0',           -- Optional inversion for RDCLK
      IS_RDEN_INVERTED =&gt; '0',            -- Optional inversion for RDEN
      IS_RSTREG_INVERTED =&gt; '0',          -- Optional inversion for RSTREG
      IS_RST_INVERTED =&gt; '0',             -- Optional inversion for RST
      IS_WRCLK_INVERTED =&gt; '0',           -- Optional inversion for WRCLK
      IS_WREN_INVERTED =&gt; '0',            -- Optional inversion for WREN
      RDCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      READ_WIDTH =&gt; 4,                    -- 18-9
      REGISTER_MODE =&gt; "UNREGISTERED",    -- DO_PIPELINED, REGISTERED, UNREGISTERED
      RSTREG_PRIORITY =&gt; "RSTREG",        -- REGCE, RSTREG
      SLEEP_ASYNC =&gt; "FALSE",             -- FALSE, TRUE
      SRVAL =&gt; X"000000000",              -- SET/reset value of the FIFO outputs
      WRCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      WRITE_WIDTH =&gt; 4                    -- 18-9
   )
   port map (
      -- Cascade Signals outputs: Multi-FIFO cascade signals
      CASDOUT =&gt; CASDOUT,             -- 32-bit output: Data cascade output bus
      CASDOUTP =&gt; CASDOUTP,           -- 4-bit output: Parity data cascade output bus
      CASNXTEMPTY =&gt; CASNXTEMPTY,     -- 1-bit output: Cascade next empty
      CASPRVRDEN =&gt; CASPRVRDEN,       -- 1-bit output: Cascade previous read enable
      -- Read Data outputs: Read output data
      DOUT =&gt; DOUT,                   -- 32-bit output: FIFO data output bus
      DOUTP =&gt; DOUTP,                 -- 4-bit output: FIFO parity output bus.
      -- Status outputs: Flags and other FIFO status outputs
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty
      FULL =&gt; FULL,                   -- 1-bit output: Full
      PROGEMPTY =&gt; PROGEMPTY,         -- 1-bit output: Programmable empty
      PROGFULL =&gt; PROGFULL,           -- 1-bit output: Programmable full
      RDCOUNT =&gt; RDCOUNT,             -- 13-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      RDRSTBUSY =&gt; RDRSTBUSY,         -- 1-bit output: Reset busy (sync to RDCLK)
      WRCOUNT =&gt; WRCOUNT,             -- 13-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write Error
      WRRSTBUSY =&gt; WRRSTBUSY,         -- 1-bit output: Reset busy (sync to WRCLK)
      -- Cascade Signals inputs: Multi-FIFO cascade signals
      CASDIN =&gt; CASDIN,               -- 32-bit input: Data cascade input bus
      CASDINP =&gt; CASDINP,             -- 4-bit input: Parity data cascade input bus
      CASDOMUX =&gt; CASDOMUX,           -- 1-bit input: Cascade MUX select
      CASDOMUXEN =&gt; CASDOMUXEN,       -- 1-bit input: Enable for cascade MUX select
      CASNXTRDEN =&gt; CASNXTRDEN,       -- 1-bit input: Cascade next read enable
      CASOREGIMUX =&gt; CASOREGIMUX,     -- 1-bit input: Cascade output MUX select
      CASOREGIMUXEN =&gt; CASOREGIMUXEN, -- 1-bit input: Cascade output MUX select enable
      CASPRVEMPTY =&gt; CASPRVEMPTY,     -- 1-bit input: Cascade previous empty
      -- Read Control Signals inputs: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Output register clock enable
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register reset
      SLEEP =&gt; SLEEP,                 -- 1-bit input: Sleep Mode
      -- Write Control Signals inputs: Write clock and enable input signals
      RST =&gt; RST,                     -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Write clock
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data inputs: Write input data
      DIN =&gt; DIN,                     -- 32-bit input: FIFO data input bus
      DINP =&gt; DINP                    -- 4-bit input: FIFO parity input bus
   );

   -- End of FIFO18E2_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E2)" treetype="template">
--  FIFO36E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO36E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO36E2: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FIFO36E2_inst : FIFO36E2
   generic map (
      CASCADE_ORDER =&gt; "NONE",            -- FIRST, LAST, MIDDLE, NONE, PARALLEL
      CLOCK_DOMAINS =&gt; "INDEPENDENT",     -- COMMON, INDEPENDENT
      EN_ECC_PIPE =&gt; "FALSE",             -- ECC pipeline register, (FALSE, TRUE)
      EN_ECC_READ =&gt; "FALSE",             -- Enable ECC decoder, (FALSE, TRUE)
      EN_ECC_WRITE =&gt; "FALSE",            -- Enable ECC encoder, (FALSE, TRUE)
      FIRST_WORD_FALL_THROUGH =&gt; "FALSE", -- FALSE, TRUE
      INIT =&gt; X"000000000000000000",      -- Initial values on output port
      PROG_EMPTY_THRESH =&gt; 256,           -- Programmable Empty Threshold
      PROG_FULL_THRESH =&gt; 256,            -- Programmable Full Threshold
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_RDCLK_INVERTED =&gt; '0',           -- Optional inversion for RDCLK
      IS_RDEN_INVERTED =&gt; '0',            -- Optional inversion for RDEN
      IS_RSTREG_INVERTED =&gt; '0',          -- Optional inversion for RSTREG
      IS_RST_INVERTED =&gt; '0',             -- Optional inversion for RST
      IS_WRCLK_INVERTED =&gt; '0',           -- Optional inversion for WRCLK
      IS_WREN_INVERTED =&gt; '0',            -- Optional inversion for WREN
      RDCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      READ_WIDTH =&gt; 4,                    -- 18-9
      REGISTER_MODE =&gt; "UNREGISTERED",    -- DO_PIPELINED, REGISTERED, UNREGISTERED
      RSTREG_PRIORITY =&gt; "RSTREG",        -- REGCE, RSTREG
      SLEEP_ASYNC =&gt; "FALSE",             -- FALSE, TRUE
      SRVAL =&gt; X"000000000000000000",     -- SET/reset value of the FIFO outputs
      WRCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      WRITE_WIDTH =&gt; 4                    -- 18-9
   )
   port map (
      -- Cascade Signals outputs: Multi-FIFO cascade signals
      CASDOUT =&gt; CASDOUT,             -- 64-bit output: Data cascade output bus
      CASDOUTP =&gt; CASDOUTP,           -- 8-bit output: Parity data cascade output bus
      CASNXTEMPTY =&gt; CASNXTEMPTY,     -- 1-bit output: Cascade next empty
      CASPRVRDEN =&gt; CASPRVRDEN,       -- 1-bit output: Cascade previous read enable
      -- ECC Signals outputs: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Read Data outputs: Read output data
      DOUT =&gt; DOUT,                   -- 64-bit output: FIFO data output bus
      DOUTP =&gt; DOUTP,                 -- 8-bit output: FIFO parity output bus.
      -- Status outputs: Flags and other FIFO status outputs
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty
      FULL =&gt; FULL,                   -- 1-bit output: Full
      PROGEMPTY =&gt; PROGEMPTY,         -- 1-bit output: Programmable empty
      PROGFULL =&gt; PROGFULL,           -- 1-bit output: Programmable full
      RDCOUNT =&gt; RDCOUNT,             -- 14-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      RDRSTBUSY =&gt; RDRSTBUSY,         -- 1-bit output: Reset busy (sync to RDCLK)
      WRCOUNT =&gt; WRCOUNT,             -- 14-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write Error
      WRRSTBUSY =&gt; WRRSTBUSY,         -- 1-bit output: Reset busy (sync to WRCLK)
      -- Cascade Signals inputs: Multi-FIFO cascade signals
      CASDIN =&gt; CASDIN,               -- 64-bit input: Data cascade input bus
      CASDINP =&gt; CASDINP,             -- 8-bit input: Parity data cascade input bus
      CASDOMUX =&gt; CASDOMUX,           -- 1-bit input: Cascade MUX select input
      CASDOMUXEN =&gt; CASDOMUXEN,       -- 1-bit input: Enable for cascade MUX select
      CASNXTRDEN =&gt; CASNXTRDEN,       -- 1-bit input: Cascade next read enable
      CASOREGIMUX =&gt; CASOREGIMUX,     -- 1-bit input: Cascade output MUX select
      CASOREGIMUXEN =&gt; CASOREGIMUXEN, -- 1-bit input: Cascade output MUX select enable
      CASPRVEMPTY =&gt; CASPRVEMPTY,     -- 1-bit input: Cascade previous empty
      -- ECC Signals inputs: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR, -- 1-bit input: Inject a single bit error
      -- Read Control Signals inputs: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Output register clock enable
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register reset
      SLEEP =&gt; SLEEP,                 -- 1-bit input: Sleep Mode
      -- Write Control Signals inputs: Write clock and enable input signals
      RST =&gt; RST,                     -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Write clock
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data inputs: Write input data
      DIN =&gt; DIN,                     -- 64-bit input: FIFO data input bus
      DINP =&gt; DINP                    -- 8-bit input: FIFO parity input bus
   );

   -- End of FIFO36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="URAM" treetype="folder">
					<Template label="288K-bit High-Density Base Memory Building Block (URAM288_BASE)" treetype="template">
-- URAM288_BASE : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (URAM288_BASE_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- URAM288_BASE: 288K-bit High-Density Base Memory Building Block
   --               Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   URAM288_BASE_inst : URAM288_BASE
   generic map (
      AUTO_SLEEP_LATENCY =&gt; 8,            -- Latency requirement to enter sleep mode
      AVG_CONS_INACTIVE_CYCLES =&gt; 10,     -- Average concecutive inactive cycles when is SLEEP mode for power
                                          -- estimation
      BWE_MODE_A =&gt; "PARITY_INTERLEAVED", -- Port A Byte write control
      BWE_MODE_B =&gt; "PARITY_INTERLEAVED", -- Port B Byte write control
      EN_AUTO_SLEEP_MODE =&gt; "FALSE",      -- Enable to automatically enter sleep mode
      EN_ECC_RD_A =&gt; "FALSE",             -- Port A ECC encoder
      EN_ECC_RD_B =&gt; "FALSE",             -- Port B ECC encoder
      EN_ECC_WR_A =&gt; "FALSE",             -- Port A ECC decoder
      EN_ECC_WR_B =&gt; "FALSE",             -- Port B ECC decoder
      IREG_PRE_A =&gt; "FALSE",              -- Optional Port A input pipeline registers
      IREG_PRE_B =&gt; "FALSE",              -- Optional Port B input pipeline registers
      IS_CLK_INVERTED =&gt; '0',             -- Optional inverter for CLK
      IS_EN_A_INVERTED =&gt; '0',            -- Optional inverter for Port A enable
      IS_EN_B_INVERTED =&gt; '0',            -- Optional inverter for Port B enable
      IS_RDB_WR_A_INVERTED =&gt; '0',        -- Optional inverter for Port A read/write select
      IS_RDB_WR_B_INVERTED =&gt; '0',        -- Optional inverter for Port B read/write select
      IS_RST_A_INVERTED =&gt; '0',           -- Optional inverter for Port A reset
      IS_RST_B_INVERTED =&gt; '0',           -- Optional inverter for Port B reset
      MATRIX_ID =&gt; "NONE",
      NUM_UNIQUE_SELF_ADDR_A =&gt; 1,
      NUM_UNIQUE_SELF_ADDR_B =&gt; 1,
      NUM_URAM_IN_MATRIX =&gt; 1,
      OREG_A =&gt; "FALSE",                  -- Optional Port A output pipeline registers
      OREG_B =&gt; "FALSE",                  -- Optional Port B output pipeline registers
      OREG_ECC_A =&gt; "FALSE",              -- Port A ECC decoder output
      OREG_ECC_B =&gt; "FALSE",              -- Port B output ECC decoder
      RST_MODE_A =&gt; "SYNC",               -- Port A reset mode
      RST_MODE_B =&gt; "SYNC",               -- Port B reset mode
      USE_EXT_CE_A =&gt; "FALSE",            -- Enable Port A external CE inputs for output registers
      USE_EXT_CE_B =&gt; "FALSE"             -- Enable Port B external CE inputs for output registers
   )
   port map (
      DBITERR_A =&gt; DBITERR_A,               -- 1-bit output: Port A double-bit error flag status
      DBITERR_B =&gt; DBITERR_B,               -- 1-bit output: Port B double-bit error flag status
      DOUT_A =&gt; DOUT_A,                     -- 72-bit output: Port A read data output
      DOUT_B =&gt; DOUT_B,                     -- 72-bit output: Port B read data output
      SBITERR_A =&gt; SBITERR_A,               -- 1-bit output: Port A single-bit error flag status
      SBITERR_B =&gt; SBITERR_B,               -- 1-bit output: Port B single-bit error flag status
      ADDR_A =&gt; ADDR_A,                     -- 23-bit input: Port A address
      ADDR_B =&gt; ADDR_B,                     -- 23-bit input: Port B address
      BWE_A =&gt; BWE_A,                       -- 9-bit input: Port A Byte-write enable
      BWE_B =&gt; BWE_B,                       -- 9-bit input: Port B Byte-write enable
      CLK =&gt; CLK,                           -- 1-bit input: Clock source
      DIN_A =&gt; DIN_A,                       -- 72-bit input: Port A write data input
      DIN_B =&gt; DIN_B,                       -- 72-bit input: Port B write data input
      EN_A =&gt; EN_A,                         -- 1-bit input: Port A enable
      EN_B =&gt; EN_B,                         -- 1-bit input: Port B enable
      INJECT_DBITERR_A =&gt; INJECT_DBITERR_A, -- 1-bit input: Port A double-bit error injection
      INJECT_DBITERR_B =&gt; INJECT_DBITERR_B, -- 1-bit input: Port B double-bit error injection
      INJECT_SBITERR_A =&gt; INJECT_SBITERR_A, -- 1-bit input: Port A single-bit error injection
      INJECT_SBITERR_B =&gt; INJECT_SBITERR_B, -- 1-bit input: Port B single-bit error injection
      OREG_CE_A =&gt; OREG_CE_A,               -- 1-bit input: Port A output register clock enable
      OREG_CE_B =&gt; OREG_CE_B,               -- 1-bit input: Port B output register clock enable
      OREG_ECC_CE_A =&gt; OREG_ECC_CE_A,       -- 1-bit input: Port A ECC decoder output register clock enable
      OREG_ECC_CE_B =&gt; OREG_ECC_CE_B,       -- 1-bit input: Port B ECC decoder output register clock enable
      RDB_WR_A =&gt; RDB_WR_A,                 -- 1-bit input: Port A read/write select
      RDB_WR_B =&gt; RDB_WR_B,                 -- 1-bit input: Port B read/write select
      RST_A =&gt; RST_A,                       -- 1-bit input: Port A asynchronous or synchronous reset for output
                                            -- registers

      RST_B =&gt; RST_B,                       -- 1-bit input: Port B asynchronous or synchronous reset for output
                                            -- registers

      SLEEP =&gt; SLEEP                        -- 1-bit input: Dynamic power gating control
   );

   -- End of URAM288_BASE_inst instantiation
					</Template>
					<Template label="288K-bit High-Density Memory Building Block (URAM288)" treetype="template">
--   URAM288   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (URAM288_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- URAM288: 288K-bit High-Density Memory Building Block
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   URAM288_inst : URAM288
   generic map (
      AUTO_SLEEP_LATENCY =&gt; 8,            -- Latency requirement to enter sleep mode
      AVG_CONS_INACTIVE_CYCLES =&gt; 10,     -- Average concecutive inactive cycles when is SLEEP mode for power
                                          -- estimation
      BWE_MODE_A =&gt; "PARITY_INTERLEAVED", -- Port A Byte write control
      BWE_MODE_B =&gt; "PARITY_INTERLEAVED", -- Port B Byte write control
      CASCADE_ORDER_A =&gt; "NONE",          -- Port A position in cascade chain
      CASCADE_ORDER_B =&gt; "NONE",          -- Port B position in cascade chain
      EN_AUTO_SLEEP_MODE =&gt; "FALSE",      -- Enable to automatically enter sleep mode
      EN_ECC_RD_A =&gt; "FALSE",             -- Port A ECC encoder
      EN_ECC_RD_B =&gt; "FALSE",             -- Port B ECC encoder
      EN_ECC_WR_A =&gt; "FALSE",             -- Port A ECC decoder
      EN_ECC_WR_B =&gt; "FALSE",             -- Port B ECC decoder
      IREG_PRE_A =&gt; "FALSE",              -- Optional Port A input pipeline registers
      IREG_PRE_B =&gt; "FALSE",              -- Optional Port B input pipeline registers
      IS_CLK_INVERTED =&gt; '0',             -- Optional inverter for CLK
      IS_EN_A_INVERTED =&gt; '0',            -- Optional inverter for Port A enable
      IS_EN_B_INVERTED =&gt; '0',            -- Optional inverter for Port B enable
      IS_RDB_WR_A_INVERTED =&gt; '0',        -- Optional inverter for Port A read/write select
      IS_RDB_WR_B_INVERTED =&gt; '0',        -- Optional inverter for Port B read/write select
      IS_RST_A_INVERTED =&gt; '0',           -- Optional inverter for Port A reset
      IS_RST_B_INVERTED =&gt; '0',           -- Optional inverter for Port B reset
      MATRIX_ID =&gt; "NONE",                -- Custom label to set a matrix ID name used by the power reporting
                                          -- tools to tag all of the UltraRAM blocks that belong to a cascade
                                          -- chain or matrix.
      NUM_UNIQUE_SELF_ADDR_A =&gt; 1,        -- The number of unique SELF_ADDR_A UltraRAM blocks in a cascade
                                          -- chain or matrix.
      NUM_UNIQUE_SELF_ADDR_B =&gt; 1,        -- The number of unique SELF_ADDR_B UltraRAM blocks in a cascade
                                          -- chain or matrix.
      NUM_URAM_IN_MATRIX =&gt; 1,            -- Defines the cascade/matrix size (the number of UltraRAMs in a
                                          -- matrix).
      OREG_A =&gt; "FALSE",                  -- Optional Port A output pipeline registers
      OREG_B =&gt; "FALSE",                  -- Optional Port B output pipeline registers
      OREG_ECC_A =&gt; "FALSE",              -- Port A ECC decoder output
      OREG_ECC_B =&gt; "FALSE",              -- Port B output ECC decoder
      REG_CAS_A =&gt; "FALSE",               -- Optional Port A cascade register
      REG_CAS_B =&gt; "FALSE",               -- Optional Port B cascade register
      RST_MODE_A =&gt; "SYNC",               -- Port A reset mode
      RST_MODE_B =&gt; "SYNC",               -- Port B reset mode
      SELF_ADDR_A =&gt; X"000",              -- Port A self-address value
      SELF_ADDR_B =&gt; X"000",              -- Port B self-address value
      SELF_MASK_A =&gt; X"7ff",              -- Port A self-address mask
      SELF_MASK_B =&gt; X"7ff",              -- Port B self-address mask
      USE_EXT_CE_A =&gt; "FALSE",            -- Enable Port A external CE inputs for output registers
      USE_EXT_CE_B =&gt; "FALSE"             -- Enable Port B external CE inputs for output registers
   )
   port map (
      CAS_OUT_ADDR_A =&gt; CAS_OUT_ADDR_A,         -- 23-bit output: Port A cascade output address
      CAS_OUT_ADDR_B =&gt; CAS_OUT_ADDR_B,         -- 23-bit output: Port B cascade output address
      CAS_OUT_BWE_A =&gt; CAS_OUT_BWE_A,           -- 9-bit output: Port A cascade Byte-write enable output
      CAS_OUT_BWE_B =&gt; CAS_OUT_BWE_B,           -- 9-bit output: Port B cascade Byte-write enable output
      CAS_OUT_DBITERR_A =&gt; CAS_OUT_DBITERR_A,   -- 1-bit output: Port A cascade double-bit error flag output
      CAS_OUT_DBITERR_B =&gt; CAS_OUT_DBITERR_B,   -- 1-bit output: Port B cascade double-bit error flag output
      CAS_OUT_DIN_A =&gt; CAS_OUT_DIN_A,           -- 72-bit output: Port A cascade output write mode data
      CAS_OUT_DIN_B =&gt; CAS_OUT_DIN_B,           -- 72-bit output: Port B cascade output write mode data
      CAS_OUT_DOUT_A =&gt; CAS_OUT_DOUT_A,         -- 72-bit output: Port A cascade output read mode data
      CAS_OUT_DOUT_B =&gt; CAS_OUT_DOUT_B,         -- 72-bit output: Port B cascade output read mode data
      CAS_OUT_EN_A =&gt; CAS_OUT_EN_A,             -- 1-bit output: Port A cascade output enable
      CAS_OUT_EN_B =&gt; CAS_OUT_EN_B,             -- 1-bit output: Port B cascade output enable
      CAS_OUT_RDACCESS_A =&gt; CAS_OUT_RDACCESS_A, -- 1-bit output: Port A cascade read status output
      CAS_OUT_RDACCESS_B =&gt; CAS_OUT_RDACCESS_B, -- 1-bit output: Port B cascade read status output
      CAS_OUT_RDB_WR_A =&gt; CAS_OUT_RDB_WR_A,     -- 1-bit output: Port A cascade read/write select output
      CAS_OUT_RDB_WR_B =&gt; CAS_OUT_RDB_WR_B,     -- 1-bit output: Port B cascade read/write select output
      CAS_OUT_SBITERR_A =&gt; CAS_OUT_SBITERR_A,   -- 1-bit output: Port A cascade single-bit error flag output
      CAS_OUT_SBITERR_B =&gt; CAS_OUT_SBITERR_B,   -- 1-bit output: Port B cascade single-bit error flag output
      DBITERR_A =&gt; DBITERR_A,                   -- 1-bit output: Port A double-bit error flag status
      DBITERR_B =&gt; DBITERR_B,                   -- 1-bit output: Port B double-bit error flag status
      DOUT_A =&gt; DOUT_A,                         -- 72-bit output: Port A read data output
      DOUT_B =&gt; DOUT_B,                         -- 72-bit output: Port B read data output
      RDACCESS_A =&gt; RDACCESS_A,                 -- 1-bit output: Port A read status
      RDACCESS_B =&gt; RDACCESS_B,                 -- 1-bit output: Port B read status
      SBITERR_A =&gt; SBITERR_A,                   -- 1-bit output: Port A single-bit error flag status
      SBITERR_B =&gt; SBITERR_B,                   -- 1-bit output: Port B single-bit error flag status
      ADDR_A =&gt; ADDR_A,                         -- 23-bit input: Port A address
      ADDR_B =&gt; ADDR_B,                         -- 23-bit input: Port B address
      BWE_A =&gt; BWE_A,                           -- 9-bit input: Port A Byte-write enable
      BWE_B =&gt; BWE_B,                           -- 9-bit input: Port B Byte-write enable
      CAS_IN_ADDR_A =&gt; CAS_IN_ADDR_A,           -- 23-bit input: Port A cascade input address
      CAS_IN_ADDR_B =&gt; CAS_IN_ADDR_B,           -- 23-bit input: Port B cascade input address
      CAS_IN_BWE_A =&gt; CAS_IN_BWE_A,             -- 9-bit input: Port A cascade Byte-write enable input
      CAS_IN_BWE_B =&gt; CAS_IN_BWE_B,             -- 9-bit input: Port B cascade Byte-write enable input
      CAS_IN_DBITERR_A =&gt; CAS_IN_DBITERR_A,     -- 1-bit input: Port A cascade double-bit error flag input
      CAS_IN_DBITERR_B =&gt; CAS_IN_DBITERR_B,     -- 1-bit input: Port B cascade double-bit error flag input
      CAS_IN_DIN_A =&gt; CAS_IN_DIN_A,             -- 72-bit input: Port A cascade input write mode data
      CAS_IN_DIN_B =&gt; CAS_IN_DIN_B,             -- 72-bit input: Port B cascade input write mode data
      CAS_IN_DOUT_A =&gt; CAS_IN_DOUT_A,           -- 72-bit input: Port A cascade input read mode data
      CAS_IN_DOUT_B =&gt; CAS_IN_DOUT_B,           -- 72-bit input: Port B cascade input read mode data
      CAS_IN_EN_A =&gt; CAS_IN_EN_A,               -- 1-bit input: Port A cascade enable input
      CAS_IN_EN_B =&gt; CAS_IN_EN_B,               -- 1-bit input: Port B cascade enable input
      CAS_IN_RDACCESS_A =&gt; CAS_IN_RDACCESS_A,   -- 1-bit input: Port A cascade read status input
      CAS_IN_RDACCESS_B =&gt; CAS_IN_RDACCESS_B,   -- 1-bit input: Port B cascade read status input
      CAS_IN_RDB_WR_A =&gt; CAS_IN_RDB_WR_A,       -- 1-bit input: Port A cascade read/write select input
      CAS_IN_RDB_WR_B =&gt; CAS_IN_RDB_WR_B,       -- 1-bit input: Port A cascade read/write select input
      CAS_IN_SBITERR_A =&gt; CAS_IN_SBITERR_A,     -- 1-bit input: Port A cascade single-bit error flag input
      CAS_IN_SBITERR_B =&gt; CAS_IN_SBITERR_B,     -- 1-bit input: Port B cascade single-bit error flag input
      CLK =&gt; CLK,                               -- 1-bit input: Clock source
      DIN_A =&gt; DIN_A,                           -- 72-bit input: Port A write data input
      DIN_B =&gt; DIN_B,                           -- 72-bit input: Port B write data input
      EN_A =&gt; EN_A,                             -- 1-bit input: Port A enable
      EN_B =&gt; EN_B,                             -- 1-bit input: Port B enable
      INJECT_DBITERR_A =&gt; INJECT_DBITERR_A,     -- 1-bit input: Port A double-bit error injection
      INJECT_DBITERR_B =&gt; INJECT_DBITERR_B,     -- 1-bit input: Port B double-bit error injection
      INJECT_SBITERR_A =&gt; INJECT_SBITERR_A,     -- 1-bit input: Port A single-bit error injection
      INJECT_SBITERR_B =&gt; INJECT_SBITERR_B,     -- 1-bit input: Port B single-bit error injection
      OREG_CE_A =&gt; OREG_CE_A,                   -- 1-bit input: Port A output register clock enable
      OREG_CE_B =&gt; OREG_CE_B,                   -- 1-bit input: Port B output register clock enable
      OREG_ECC_CE_A =&gt; OREG_ECC_CE_A,           -- 1-bit input: Port A ECC decoder output register clock enable
      OREG_ECC_CE_B =&gt; OREG_ECC_CE_B,           -- 1-bit input: Port B ECC decoder output register clock enable
      RDB_WR_A =&gt; RDB_WR_A,                     -- 1-bit input: Port A read/write select
      RDB_WR_B =&gt; RDB_WR_B,                     -- 1-bit input: Port B read/write select
      RST_A =&gt; RST_A,                           -- 1-bit input: Port A asynchronous or synchronous reset for
                                                -- output registers

      RST_B =&gt; RST_B,                           -- 1-bit input: Port B asynchronous or synchronous reset for
                                                -- output registers

      SLEEP =&gt; SLEEP                            -- 1-bit input: Dynamic power gating control
   );

   -- End of URAM288_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLB" treetype="folder">
				<SubFolder label="CARRY" treetype="folder">
					<Template label="Fast Carry Logic with Look Ahead (CARRY8)" treetype="template">
--   CARRY8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CARRY8_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CARRY8: Fast Carry Logic with Look Ahead
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   CARRY8_inst : CARRY8
   generic map (
      CARRY_TYPE =&gt; "SINGLE_CY8"  -- 8-bit or dual 4-bit carry (DUAL_CY4, SINGLE_CY8)
   )
   port map (
      CO =&gt; CO,         -- 8-bit output: Carry-out
      O =&gt; O,           -- 8-bit output: Carry chain XOR data out
      CI =&gt; CI,         -- 1-bit input: Lower Carry-In
      CI_TOP =&gt; CI_TOP, -- 1-bit input: Upper Carry-In
      DI =&gt; DI,         -- 8-bit input: Carry-MUX data in
      S =&gt; S            -- 8-bit input: Carry-mux select
   );

   -- End of CARRY8_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Two input AND gate implemented in place of a CLB Latch (AND2B1L)" treetype="template">
--   AND2B1L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (AND2B1L_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- AND2B1L: Two input AND gate implemented in place of a CLB Latch
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   AND2B1L_inst : AND2B1L
   generic map (
      IS_SRI_INVERTED =&gt; '0'  -- Optional inversion for SRI
   )
   port map (
      O =&gt; O,     -- 1-bit output: AND gate output
      DI =&gt; DI,   -- 1-bit input: Data input connected to LUT logic
      SRI =&gt; SRI  -- 1-bit input: External CLB data
   );

   -- End of AND2B1L_inst instantiation
					</Template>
					<Template label="Two input OR gate implemented in place of a CLB Latch (OR2L)" treetype="template">
--    OR2L     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OR2L_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OR2L: Two input OR gate implemented in place of a CLB Latch
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OR2L_inst : OR2L
   generic map (
      IS_SRI_INVERTED =&gt; '0'  -- Optional inversion for SRI
   )
   port map (
      O =&gt; O,     -- 1-bit output: OR gate output
      DI =&gt; DI,   -- 1-bit input: Data input connected to LUT logic
      SRI =&gt; SRI  -- 1-bit input: External CLB data
   );

   -- End of OR2L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUT" treetype="folder">
					<Template label="1-Bit Look-Up Table (LUT1)" treetype="template">
--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-Bit Look-Up Table
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; X"0"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0  -- 1-bit input: LUT
   );

   -- End of LUT1_inst instantiation
					</Template>
					<Template label="2-Bit Look-Up Table (LUT2)" treetype="template">
--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-Bit Look-Up Table
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1  -- 1-bit input: LUT
   );

   -- End of LUT2_inst instantiation
					</Template>
					<Template label="3-Bit Look-Up Table (LUT3)" treetype="template">
--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-Bit Look-Up Table
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2  -- 1-bit input: LUT
   );

   -- End of LUT3_inst instantiation
					</Template>
					<Template label="4-Bit Look-Up Table (LUT4)" treetype="template">
--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-Bit Look-Up Table
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3  -- 1-bit input: LUT
   );

   -- End of LUT4_inst instantiation
					</Template>
					<Template label="5-Bit Look-Up Table (LUT5)" treetype="template">
--    LUT5     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT5_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5: 5-Bit Look-Up Table
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_inst : LUT5
   generic map (
      INIT =&gt; X"00000000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3, -- 1-bit input: LUT
      I4 =&gt; I4  -- 1-bit input: LUT
   );

   -- End of LUT5_inst instantiation
					</Template>
					<Template label="5-input Dynamically Reconfigurable Look-Up Table (LUT) (CFGLUT5)" treetype="template">
--   CFGLUT5   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CFGLUT5_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CFGLUT5: 5-input Dynamically Reconfigurable Look-Up Table (LUT)
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   CFGLUT5_inst : CFGLUT5
   generic map (
      INIT =&gt; X"00000000",    -- Initial logic function
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      CDO =&gt; CDO, -- 1-bit output: Reconfiguration cascade
      O5 =&gt; O5,   -- 1-bit output: 4-LUT
      O6 =&gt; O6,   -- 1-bit output: 5-LUT
      CDI =&gt; CDI, -- 1-bit input: Reconfiguration data
      CE =&gt; CE,   -- 1-bit input: Reconfiguration enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      -- LUT Inputs inputs: Logic inputs
      I0 =&gt; I0,
      I1 =&gt; I1,
      I2 =&gt; I2,
      I3 =&gt; I3,
      I4 =&gt; I4 
   );

   -- End of CFGLUT5_inst instantiation
					</Template>
					<Template label="6-Bit Look-Up Table (LUT6)" treetype="template">
--    LUT6     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT6_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6: 6-Bit Look-Up Table
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_inst : LUT6
   generic map (
      INIT =&gt; X"0000000000000000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3, -- 1-bit input: LUT
      I4 =&gt; I4, -- 1-bit input: LUT
      I5 =&gt; I5  -- 1-bit input: LUT
   );

   -- End of LUT6_inst instantiation
					</Template>
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
-- The INIT constant for the FPGA LUT primitive is what gives the LUT its
-- logical value. By default this value is zero thus driving the output to a
-- zero regardless of the input values (acting as a ground) however in most
-- cases an new INIT value must be determined in order to specify the logic
-- function for the LUT primitive.  There are a few methods in which the LUT
-- value can be determined and two of those methods will be discussed here.
--
-- The Truth Table Method
-- ----------------------
--
--  A common method to determine the desired INIT value for a LUT is using a
-- truth table.  To do so, simply create a binary truth table of all possible
-- inputs, specify the desired logic value of the output and then create the
-- INIT string from those output values.  An example is shown below:
--
-- Example of determining an XOR INIT equation for a LUT4:
--
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | 0 |\
--     |  0  0  0  1 | 1 | \ = 0110 = 6 -----------+
--     |  0  0  1  0 | 1 | /                       |
--     |  0  0  1  1 | 0 |/                        |
--     |-------------|---|                         |
--     |  0  1  0  0 | 1 |\                        |
--     |  0  1  0  1 | 0 | \ = 1001 = 9            |
--     |  0  1  1  0 | 0 | /                       |
--     |  0  1  1  1 | 1 |/                        |
--     |-------------|---|               INIT = 6996
--     |  1  0  0  0 | 1 |\                     |
--     |  1  0  0  1 | 0 | \ = 0110 = 9         |
--     |  1  0  1  0 | 0 | /                    |
--     |  1  0  1  1 | 1 |/                     |
--     |-------------|---|                      |
--     |  1  1  0  0 | 0 |\                     |
--     |  1  1  0  1 | 1 | \ = 1001 = 6---------+
--     |  1  1  1  0 | 1 | /
--     |  1  1  1  1 | 0 |/
--     -------------------
--
-- Example of determining a 3-input AND gate:
--
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | 0 |\
--     |  0  0  1 | 0 | \ = 0000 = 0 -----------+
--     |  0  1  0 | 0 | /                       |
--     |  0  1  1 | 0 |/                        |
--     |----------|---|                 INIT = 80
--     |  1  0  0 | 0 |\                       |
--     |  1  0  1 | 0 | \ = 1000 = 8-----------+
--     |  1  1  0 | 0 | /
--     |  1  1  1 | 1 |/
--     ----------------
--
-- The Equation Method
-- -------------------
--
-- Another method to determine the LUT value is to define constants for each
-- input to the LUT that correspond to their listed truth value and use those to
-- build the logic equation you are after.  This method is easier to understand
-- once you have grasped the concept and more self-documenting that the above
-- method however does require the code to first specify the appropriate
-- constants.  See the example below.
--
-- Example of specifying the equation (A and B) or (C and D) for a LUT4:
--
   -- The following constants are defined to allow for
   --   equation-based INIT specification.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";


   -- LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; (I3 and I2) or (I1 and I0))
   port map (
      O =&gt; O_LUT,   -- LUT general output
      I0 =&gt; A, -- LUT input
      I1 =&gt; B, -- LUT input
      I2 =&gt; C, -- LUT input
      I3 =&gt; D  -- LUT input
   );
   -- End of LUT4_inst instantiation

-- With the constants specifying all possible cases for the truth table, a
-- VHDL equation can be written to determine the end INIT value.

						</Template>
						<SubFolder label="INIT Constants" treetype="folder">
							<Template label="LUT1" treetype="template">
   -- The following constant is defined to allow for
   --   equation-based INIT specification for a LUT1.
   constant I0 : BIT_VECTOR(1 downto 0) := "10";
							</Template>
							<Template label="LUT2" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT2.
   constant I0 : BIT_VECTOR(3 downto 0) := X"A";
   constant I1 : BIT_VECTOR(3 downto 0) := X"C";
							</Template>
							<Template label="LUT3" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT3.
   constant I0 : BIT_VECTOR(7 downto 0) := X"AA";
   constant I1 : BIT_VECTOR(7 downto 0) := X"CC";
   constant I2 : BIT_VECTOR(7 downto 0) := X"F0";
							</Template>
							<Template label="LUT4" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT4.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";
							</Template>
							<Template label="LUT5" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT5.
   constant I0 : BIT_VECTOR(31 downto 0) := X"AAAAAAAA";
   constant I1 : BIT_VECTOR(31 downto 0) := X"CCCCCCCC";
   constant I2 : BIT_VECTOR(31 downto 0) := X"F0F0F0F0";
   constant I3 : BIT_VECTOR(31 downto 0) := X"FF00FF00";
   constant I4 : BIT_VECTOR(31 downto 0) := X"FFFF0000";
							</Template>
							<Template label="LUT6" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT6.
   constant I0 : BIT_VECTOR(63 downto 0) := X"AAAAAAAAAAAAAAAA";
   constant I1 : BIT_VECTOR(63 downto 0) := X"CCCCCCCCCCCCCCCC";
   constant I2 : BIT_VECTOR(63 downto 0) := X"F0F0F0F0F0F0F0F0";
   constant I3 : BIT_VECTOR(63 downto 0) := X"FF00FF00FF00FF00";
   constant I4 : BIT_VECTOR(63 downto 0) := X"FFFF0000FFFF0000";
   constant I5 : BIT_VECTOR(63 downto 0) := X"FFFFFFFF00000000";
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
--  Truth Table to determine INIT value for a LUT1
--      ________
--     | I0 | O |
--     |--------|
--     |  0 | ? |\
--     |  1 | ? |/ = 2'b??
--     ----------
							</Template>
							<Template label="LUT2" treetype="template">
--  Truth Table to determine INIT value for a LUT2
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
--     |  0  1  0 | ? | /
--     |  0  1  1 | ? |/
--      ---------- ---
							</Template>
							<Template label="LUT3" treetype="template">
--  Truth Table to determine INIT value for a LUT3
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
--     |  0  1  0 | ? | /                                |
--     |  0  1  1 | ? |/                                 |
--     |----------|---|                       INIT = 8'h??
--     |  1  0  0 | ? |\                                |
--     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
--     |  1  1  0 | ? | /
--     |  1  1  1 | ? |/
--     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
--  Truth Table to determine INIT value for a LUT4
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | ? |\
--     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
--     |  0  0  1  0 | ? | /                                 |
--     |  0  0  1  1 | ? |/                                  |
--     |-------------|---|                                   |
--     |  0  1  0  0 | ? |\                                  |
--     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
--     |  0  1  1  0 | ? | /                                 |
--     |  0  1  1  1 | ? |/                                  |
--     |-------------|---|                     INIT = 16'h????
--     |  1  0  0  0 | ? |\                               |
--     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  0 | ? | /                              |
--     |  1  0  1  1 | ? |/                               |
--     |-------------|---|                                |
--     |  1  1  0  0 | ? |\                               |
--     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  0 | ? | /
--     |  1  1  1  1 | ? |/
--     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
--  Truth Table to determine INIT value for a LUT5
--      ____________________
--     | I4 I3 I2 I1 I0 | O |
--     |--------------------|
--     |  0  0  0  0  0 | ? |\
--     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  0  1  0  0 | ? |\                                      |
--     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  0  0  0 | ? |\                                      |
--     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  0 | ? | /                                     |
--     |  0  1  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  1  0  0 | ? |\                                      |
--     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1 | ? |/                                      |
--     ----------------------                     INIT = 32'h????????
--     |  1  0  0  0  0 | ? |\                               |
--     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  0  1  0 | ? | /                              |
--     |  1  0  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  0  1  0  0 | ? |\                               |
--     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  1  0 | ? | /                              |
--     |  1  0  1  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  0  0  0 | ? |\                               |
--     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  1  0  1  0 | ? | /                              |
--     |  1  1  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  1  0  0 | ? |\                               |
--     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1 | ? |/
--     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
--  Truth Table to determine INIT value for a LUT6
--      _______________________
--     | I5 I4 I3 I2 I1 I0 | O |
--     |-----------------------|
--     |  0  0  0  0  0  0 | ? |\
--     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  0  1  0  0 | ? |\                                      |
--     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  0  1  1  0 | ? | /                                     |
--     |  0  0  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  0  0  0 | ? |\                                      |
--     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  0  1  0 | ? | /                                     |
--     |  0  0  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  1  0  0 | ? |\                                      |
--     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1  1 | ? |/                                      |
--     -------------------------                                       |
--     |  0  1  0  0  0  0 | ? |\                                      |
--     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  0  1  0 | ? | /                                     |
--     |  0  1  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  0  1  0  0 | ? |\                                      |
--     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  1  0 | ? | /                                     |
--     |  0  1  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  0  0  0 | ? |\                                      |
--     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  0  1  0 | ? | /                                     |
--     |  0  1  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  1  0  0 | ? |\                                      |
--     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1  1 | ? |/                                      |
--     ------------------------              INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     -----------------------
							</Template>
							<Template label="LUT6_2" treetype="template">
--  Truth Table to determine INIT value for a LUT6_2
--      _____________________________
--     | I5 I4 I3 I2 I1 I0 | O6 | O5 |
--     |-----------------------------|
--     |  0  0  0  0  0  0 |    ?    |\
--     |  0  0  0  0  0  1 |    ?    | \ = 4'b???? = 4'h? -------------+
--     |  0  0  0  0  1  0 |    ?    | /                               |
--     |  0  0  0  0  1  1 |	?    |/				       |
--     |-------------------|---------|                                 |
--     |  0  0  0  1  0  0 |	?    |\                                |
--     |  0  0  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  0  0  1  1  0 |	?    | /                               |
--     |  0  0  0  1  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  0  1  0  0  0 |	?    |\                                |
--     |  0  0  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  0  1  0  1  0 |	?    | /                               |
--     |  0  0  1  0  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  0  1  1  0  0 |	?    |\                                |
--     |  0  0  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  0  1  1  1  0 |	?    | /                               |
--     |  0  0  1  1  1  1 |	?    |/                                |
--     -------------------------------                                 |
--     |  0  1  0  0  0  0 |	?    |\                                |
--     |  0  1  0  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  0  0  1  0 |	?    | /                               |
--     |  0  1  0  0  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  1  0  1  0  0 |	?    |\                                |
--     |  0  1  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  0  1  1  0 |	?    | /                               |
--     |  0  1  0  1  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  1  1  0  0  0 |	?    |\                                |
--     |  0  1  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  1  0  1  0 |	?    | /                               |
--     |  0  1  1  0  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  1  1  1  0  0 |	?    |\                                |
--     |  0  1  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  1  1  1  0 |	?    | /                               |
--     |  0  1  1  1  1  1 |	?    |/                                |
--     ------------------------------        INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT6_2" treetype="template">

--   LUT6_2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_2: 6-input  2 output Look-Up Table
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_2_inst : LUT6_2
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      O6 =&gt; O6,  -- 6/5-LUT output (1-bit)
      O5 =&gt; O5,  -- 5-LUT output (1-bit)
      I0 =&gt; I0,   -- LUT input (1-bit)
      I1 =&gt; I1,   -- LUT input (1-bit)
      I2 =&gt; I2,   -- LUT input (1-bit)
      I3 =&gt; I3,   -- LUT input (1-bit)
      I4 =&gt; I4,   -- LUT input (1-bit)
      I5 =&gt; I5    -- LUT input (1-bit)
   );

   -- End of LUT6_2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUTRAM" treetype="folder">
					<Template label="64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM) (RAM64X8SW)" treetype="template">
--  RAM64X8SW  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAM64X8SW_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X8SW: 64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM)
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X8SW_inst : RAM64X8SW
   generic map (
      INIT_A =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 7
      INIT_B =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 6
      INIT_C =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 5
      INIT_D =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 4
      INIT_E =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 3
      INIT_F =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 2
      INIT_G =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 1
      INIT_H =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 0
      IS_WCLK_INVERTED =&gt; '0'        -- Optional inversion for WCLK
   )
   port map (
      O =&gt; O,       -- 8-bit data output
      A =&gt; A,       -- 6-bit address input
      D =&gt; D,       -- 1-bit input: Write data input
      WCLK =&gt; WCLK, -- 1-bit input: Write clock input
      WE =&gt; WE,     -- 1-bit input: Write enable input
      WSEL =&gt; WSEL  -- 3-bit write select
   );

   -- End of RAM64X8SW_inst instantiation
					</Template>
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 x 1 negedge write (RAM32X1D_1)" treetype="template">

-- RAM32X1D_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_1_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D_1: 32 x 1 negative edge write, asynchronous read
   --             dual-port distributed RAM
   --             Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1_inst : RAM32X1D_1
   generic map (
      INIT =&gt; X"00000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );

   -- End of RAM32X1D_1_inst instantiation
						</Template>
						<Template label="32 x 1 posedge write (RAM32X1D)" treetype="template">

--   RAM32X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D: 32 x 1 positive edge write, asynchronous read
   --              dual-port distributed RAM
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_inst : RAM32X1D
   generic map (
      INIT =&gt; X"00000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );

   -- End of RAM32X1D_inst instantiation

						</Template>
						<Template label="64 x 1 posedge write (RAM64X1D)" treetype="template">

--   RAM64X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1D: 64 x 1 positive edge write, asynchronous read
   --           dual-port distributed RAM
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1D_inst : RAM64X1D
   generic map (
      INIT =&gt; X"0000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      A5 =&gt; A5,       -- R/W address[5] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      DPRA5 =&gt; DPRA5, -- Read-only address[5] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );

   -- End of RAM64X1D_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">

--  RAM128X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read
   --            dual-port distributed LUT RAM
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1D_inst : RAM128X1D
   generic map (
      INIT =&gt; X"00000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read/Write port 1-bit ouput
      SPO =&gt; SPO,     -- Read port 1-bit output
      A =&gt; A,         -- Read/Write port 7-bit address input
      D =&gt; D,         -- RAM data input
      DPRA =&gt; DPRA,   -- Read port 7-bit address input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1D_inst instantiation

						</Template>
						<Template label="256 X 1 posedge write (RAM256X1D)" treetype="template">

--  RAM256X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM256X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM256X1D: 256-deep by 1-wide positive edge write, asynchronous read
   --            dual-port distributed LUT RAM
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM256X1D_inst : RAM256X1D
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read/Write port 1-bit ouput
      SPO =&gt; SPO,     -- Read port 1-bit output
      A =&gt; A,         -- Read/Write port 8-bit address input
      D =&gt; D,         -- RAM data input
      DPRA =&gt; DPRA,   -- Read port 8-bit address input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM256X1D_inst instantiation


						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">

--   RAM32M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M: 32-deep by 8-wide Multi Port LUT RAM
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM32M_inst : RAM32M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",    -- Initial contents of D port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read/Write port D 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 5-bit address input
      DIA =&gt; DIA, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M_inst instantiation


--   RAM32M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M: 32-deep by 8-wide Multi Port LUT RAM
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM32M_inst : RAM32M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",    -- Initial contents of D port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read/Write port D 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 5-bit address input
      DIA =&gt; DIA, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M_inst instantiation
						</Template>
						<Template label="32 X 16 (RAM32M16)" treetype="template">
--   RAM32M16  : In order to incorporate this function into the design,
--     VHDL    : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M16_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M16: 32-deep by 16-wide Multi Port LUT RAM
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4
 RAM32M16_inst : RAM32M16
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",   -- Initial contents of D port
      INIT_E =&gt; X"0000000000000000",   -- Initial contents of E port
      INIT_F =&gt; X"0000000000000000",   -- Initial contents of F port
      INIT_G =&gt; X"0000000000000000",   -- Initial contents of G port
      INIT_H =&gt; X"0000000000000000",   -- Initial contents of H port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read port D 2-bit output
      DOE =&gt; DOE, -- Read port E 2-bit output
      DOF =&gt; DOF, -- Read port F 2-bit output
      DOG =&gt; DOG, -- Read port G 2-bit output
      DOH =&gt; DOH, -- Read/write port H 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read port D 5-bit address input
      ADDRE =&gt; ADDRE,   -- Read port E 5-bit address input
      ADDRF =&gt; ADDRF,   -- Read port F 5-bit address input
      ADDRG =&gt; ADDRG,   -- Read port G 5-bit address input
      ADDRH =&gt; ADDRH,   -- Read/write port H 5-bit address input
      DIA =&gt; DIA,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRA
      DIB =&gt; DIB,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRB
      DIC =&gt; DIC,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRC
      DID =&gt; DID,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRD
      DIE =&gt; DIE,       -- RAM 2-bit data write input addressed by ADDRE,
                        -- read addressed by ADDRE
      DIF =&gt; DIF,       -- RAM 2-bit data write input addressed by ADDRF,
                        -- read addressed by ADDRF
      DIG =&gt; DIG,       -- RAM 2-bit data write input addressed by ADDRG,
                        -- read addressed by ADDRG
      DIH =&gt; DIH,       -- RAM 2-bit data write input addressed by ADDRH,
                        -- read addressed by ADDRH
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M16_inst instantiation
						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">

--   RAM64M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64M: 64-deep by 4-wide Multi Port LUT RAM
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM64M_inst : RAM64M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",    -- Initial contents of D port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 1-bit output
      DOB =&gt; DOB, -- Read port B 1-bit output
      DOC =&gt; DOC, -- Read port C 1-bit output
      DOD =&gt; DOD, -- Read/Write port D 1-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 6-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 6-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 6-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 6-bit address input
      DIA =&gt; DIA, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM64M_inst instantiation

						</Template>
						<Template label="64 X 8 (RAM64M8)" treetype="template">
--   RAM64M8  : In order to incorporate this function into the design,
--     VHDL    : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64M8_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64M8: 64-deep by 8-wide Multi Port LUT RAM
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4
 RAM64M8_inst : RAM64M8
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",   -- Initial contents of D port
      INIT_E =&gt; X"0000000000000000",   -- Initial contents of E port
      INIT_F =&gt; X"0000000000000000",   -- Initial contents of F port
      INIT_G =&gt; X"0000000000000000",   -- Initial contents of G port
      INIT_H =&gt; X"0000000000000000",   -- Initial contents of H port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 1-bit output
      DOB =&gt; DOB, -- Read port B 1-bit output
      DOC =&gt; DOC, -- Read port C 1-bit output
      DOD =&gt; DOD, -- Read port D 1-bit output
      DOE =&gt; DOE, -- Read port E 1-bit output
      DOF =&gt; DOF, -- Read port F 1-bit output
      DOG =&gt; DOG, -- Read port G 1-bit output
      DOH =&gt; DOH, -- Read/write port H 1-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 6-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 6-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 6-bit address input
      ADDRD =&gt; ADDRD,   -- Read port D 6-bit address input
      ADDRE =&gt; ADDRE,   -- Read port E 6-bit address input
      ADDRF =&gt; ADDRF,   -- Read port F 6-bit address input
      ADDRG =&gt; ADDRG,   -- Read port G 6-bit address input
      ADDRH =&gt; ADDRH,   -- Read/write port H 6-bit address input
      DIA =&gt; DIA,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRA
      DIB =&gt; DIB,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRB
      DIC =&gt; DIC,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRC
      DID =&gt; DID,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRD
      DIE =&gt; DIE,       -- RAM 1-bit data write input addressed by ADDRE,
                        -- read addressed by ADDRE
      DIF =&gt; DIF,       -- RAM 1-bit data write input addressed by ADDRF,
                        -- read addressed by ADDRF
      DIG =&gt; DIG,       -- RAM 1-bit data write input addressed by ADDRG,
                        -- read addressed by ADDRG
      DIH =&gt; DIH,       -- RAM 1-bit data write input addressed by ADDRH,
                        -- read addressed by ADDRH
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64M8_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">

--  RAM32X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1S_inst : RAM32X1S
   generic map (
      INIT =&gt; X"00000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,       -- RAM output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D =&gt; D,       -- RAM data input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X1S_inst instantiation
						</Template>
						<SubFolder label="64 Deep (6-bit address)" treetype="folder">
							<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">

--  RAM64X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port distributed RAM
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1S_inst : RAM64X1S
   generic map (
      INIT =&gt; X"0000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,        -- 1-bit data output
      A0 =&gt; A0,      -- Address[0] input bit
      A1 =&gt; A1,      -- Address[1] input bit
      A2 =&gt; A2,      -- Address[2] input bit
      A3 =&gt; A3,      -- Address[3] input bit
      A4 =&gt; A4,      -- Address[4] input bit
      A5 =&gt; A5,      -- Address[5] input bit
      D =&gt; D,        -- 1-bit data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="128 Deep (7-bit address)" treetype="folder">
							<Template label="128 x 1 negedge write (RAM128X1S_1)" treetype="template">

--RAM128X1S_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S_1: 128-deep x 1 negative edge write, asynchronous read
   --              single-port distributed RAM
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation
							</Template>
							<Template label="128 x 1 posedge write (RAM128X1S)" treetype="template">

--  RAM128X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S: 128-deep x 1 positive edge write, asynchronous read
   --            single-port distributed RAM
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation

							</Template>
						</SubFolder>
						<SubFolder label="256 Deep (8-bit address)" treetype="folder">
							<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">

--  RAM256X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM256X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read
   --            single-port distributed LUT RAM
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM256X1S_inst : RAM256X1S
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,  -- Read/Write port 1-bit ouput
      A =&gt; A,  -- Read/Write port 8-bit address input
      D =&gt; D,  -- RAM data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE -- Write enable input
   );

   -- End of RAM256X1S_inst instantiation

							</Template>
						</SubFolder>
						<SubFolder label="512 Deep (9-bit address)" treetype="folder">
							<Template label="512 X 1 posedge write (RAM512X1S)" treetype="template">

--  RAM512X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM512X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM512X1S: 512-deep by 1-wide positive edge write, asynchronous read
   --            single-port distributed LUT RAM
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM512X1S_inst : RAM512X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,  -- Read/Write port 1-bit ouput
      A =&gt; A,  -- Read/Write port 9-bit address input
      D =&gt; D,  -- RAM data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE -- Write enable input
   );

   -- End of RAM512X1S_inst instantiation

							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="MUXF" treetype="folder">
					<Template label="CLB MUX to connect two LUT6's Together (MUXF7)" treetype="template">
--    MUXF7    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF7_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7: CLB MUX to connect two LUT6's Together
   --        Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_inst : MUXF7
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to LUT6 output
      I1 =&gt; I1, -- 1-bit input: Connect to LUT6 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF7_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF7's Together (MUXF8)" treetype="template">
--    MUXF8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF8_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8: CLB MUX to connect two MUXF7's Together
   --        Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_inst : MUXF8
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to MUXF7 output
      I1 =&gt; I1, -- 1-bit input: Connect to MUXF7 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF8_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF8's Together (MUXF9)" treetype="template">
--    MUXF9    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF9_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF9: CLB MUX to connect two MUXF8's Together
   --        Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MUXF9_inst : MUXF9
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to MUXF8 output
      I1 =&gt; I1, -- 1-bit input: Connect to MUXF8 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF9_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="16-Bit Shift Register Look-Up Table (LUT) (SRL16E)" treetype="template">
--   SRL16E    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SRL16E_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRL16E: 16-Bit Shift Register Look-Up Table (LUT)
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   SRL16E_inst : SRL16E
   generic map (
      INIT =&gt; X"0000",        -- Initial contents of shift register
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: SRL Data
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      D =&gt; D,     -- 1-bit input: SRL Data
      -- Depth Selection inputs: A0-A3 select SRL depth
      A0 =&gt; A0,
      A1 =&gt; A1,
      A2 =&gt; A2,
      A3 =&gt; A3 
   );

   -- End of SRL16E_inst instantiation
					</Template>
					<Template label="32-Bit Shift Register Look-Up Table (LUT) (SRLC32E)" treetype="template">
--   SRLC32E   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SRLC32E_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRLC32E: 32-Bit Shift Register Look-Up Table (LUT)
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   SRLC32E_inst : SRLC32E
   generic map (
      INIT =&gt; X"00000000",    -- Initial contents of shift register
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: SRL Data
      Q31 =&gt; Q31, -- 1-bit output: SRL Cascade Data
      A =&gt; A,     -- 5-bit input: Selects SRL depth
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      D =&gt; D      -- 1-bit input: SRL Data
   );

   -- End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLOCK" treetype="folder">
				<SubFolder label="BUFFER" treetype="folder">
					<Template label="A high-fanout buffer for low-skew distribution of the PS Clock signals (BUFG_PS)" treetype="template">
--   BUFG_PS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_PS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_PS: A high-fanout buffer for low-skew distribution of the PS Clock signals
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_PS_inst : BUFG_PS
   port map (
      O =&gt; O, -- 1-bit output: Clock buffer output
      I =&gt; I  -- 1-bit input: Clock buffer input
   );

   -- End of BUFG_PS_inst instantiation
					</Template>
					<Template label="Clock Buffer Driven by Gigabit Transceiver (BUFG_GT)" treetype="template">
--   BUFG_GT   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_GT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_GT: Clock Buffer Driven by Gigabit Transceiver
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_GT_inst : BUFG_GT
   port map (
      O =&gt; O,             -- 1-bit output: Buffer
      CE =&gt; CE,           -- 1-bit input: Buffer enable
      CEMASK =&gt; CEMASK,   -- 1-bit input: CE Mask
      CLR =&gt; CLR,         -- 1-bit input: Asynchronous clear
      CLRMASK =&gt; CLRMASK, -- 1-bit input: CLR Mask
      DIV =&gt; DIV,         -- 3-bit input: Dynamic divide Value
      I =&gt; I              -- 1-bit input: Buffer
   );

   -- End of BUFG_GT_inst instantiation
					</Template>
					<Template label="General Clock Buffer (BUFG)" treetype="template">
--    BUFG     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG: General Clock Buffer
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_inst : BUFG
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFG_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
--   BUFGCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE: General Clock Buffer with Clock Enable
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_inst : BUFGCE
   generic map (
      CE_TYPE =&gt; "SYNC",     -- ASYNC, SYNC
      IS_CE_INVERTED =&gt; '0', -- Programmable inversion on CE
      IS_I_INVERTED =&gt; '0'   -- Programmable inversion on I
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer
      CE =&gt; CE, -- 1-bit input: Buffer enable
      I =&gt; I    -- 1-bit input: Buffer
   );

   -- End of BUFGCE_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Divide (BUFGCE_DIV)" treetype="template">
-- BUFGCE_DIV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_DIV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_DIV: General Clock Buffer with Divide Function
   --             Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_DIV_inst : BUFGCE_DIV
   generic map (
      BUFGCE_DIVIDE =&gt; 1,     -- 1-8
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CE_INVERTED =&gt; '0',  -- Optional inversion for CE
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_I_INVERTED =&gt; '0'    -- Optional inversion for I
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer
      CE =&gt; CE,   -- 1-bit input: Buffer enable
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      I =&gt; I      -- 1-bit input: Buffer
   );

   -- End of BUFGCE_DIV_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
--  BUFGCE_1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_1: General Clock Buffer with Clock Enable and Output State 1
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_1_inst : BUFGCE_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock buffer active-High enable
      I =&gt; I    -- 1-bit input: Clock input
   );

   -- End of BUFGCE_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="CLOCK_SYNC" treetype="folder">
					<Template label="Synchronizer for BUFG_GT Control Signals (BUFG_GT_SYNC)" treetype="template">
-- BUFG_GT_SYNC : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFG_GT_SYNC_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_GT_SYNC: Synchronizer for BUFG_GT Control Signals
   --               Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_GT_SYNC_inst : BUFG_GT_SYNC
   port map (
      CESYNC =&gt; CESYNC,   -- 1-bit output: Synchronized CE
      CLRSYNC =&gt; CLRSYNC, -- 1-bit output: Synchronized CLR
      CE =&gt; CE,           -- 1-bit input: Asynchronous enable
      CLK =&gt; CLK,         -- 1-bit input: Clock
      CLR =&gt; CLR          -- 1-bit input: Asynchronous clear
   );

   -- End of BUFG_GT_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUX" treetype="folder">
					<Template label="2-to-1 General Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
-- BUFGMUX_CTRL : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_CTRL: 2-to-1 General Clock MUX Buffer
   --               Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL_inst : BUFGMUX_CTRL
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="General Clock Control Buffer (BUFGCTRL)" treetype="template">
--  BUFGCTRL   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCTRL: General Clock Control Buffer
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCTRL_inst : BUFGCTRL
   generic map (
      INIT_OUT =&gt; 0,              -- Initial value of BUFGCTRL output, 0-1
      PRESELECT_I0 =&gt; FALSE,      -- BUFGCTRL output uses I0 input, FALSE, TRUE
      PRESELECT_I1 =&gt; FALSE,      -- BUFGCTRL output uses I1 input, FALSE, TRUE
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CE0_INVERTED =&gt; '0',     -- Optional inversion for CE0
      IS_CE1_INVERTED =&gt; '0',     -- Optional inversion for CE1
      IS_I0_INVERTED =&gt; '0',      -- Optional inversion for I0
      IS_I1_INVERTED =&gt; '0',      -- Optional inversion for I1
      IS_IGNORE0_INVERTED =&gt; '0', -- Optional inversion for IGNORE0
      IS_IGNORE1_INVERTED =&gt; '0', -- Optional inversion for IGNORE1
      IS_S0_INVERTED =&gt; '0',      -- Optional inversion for S0
      IS_S1_INVERTED =&gt; '0'       -- Optional inversion for S1
   )
   port map (
      O =&gt; O,             -- 1-bit output: Clock output
      CE0 =&gt; CE0,         -- 1-bit input: Clock enable input for I0
      CE1 =&gt; CE1,         -- 1-bit input: Clock enable input for I1
      I0 =&gt; I0,           -- 1-bit input: Primary clock
      I1 =&gt; I1,           -- 1-bit input: Secondary clock
      IGNORE0 =&gt; IGNORE0, -- 1-bit input: Clock ignore input for I0
      IGNORE1 =&gt; IGNORE1, -- 1-bit input: Clock ignore input for I1
      S0 =&gt; S0,           -- 1-bit input: Clock select for I0
      S1 =&gt; S1            -- 1-bit input: Clock select for I1
   );

   -- End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer (BUFGMUX)" treetype="template">
--   BUFGMUX   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX: General Clock Mux Buffer
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_inst : BUFGMUX
   generic map (
      CLK_SEL_TYPE =&gt; "SYNC"  -- ASYNC, SYNC
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
--  BUFGMUX_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_1: General Clock Mux Buffer with Output State 1
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1_inst : BUFGMUX_1
   generic map (
      CLK_SEL_TYPE =&gt; "SYNC"  -- ASYNC, SYNC
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME3_ADV)" treetype="template">
-- MMCME3_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME3_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME3_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   --             Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MMCME3_ADV_inst : MMCME3_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",        -- Jitter programming (HIGH, LOW, OPTIMIZED)
      CLKFBOUT_MULT_F =&gt; 5.0,          -- Multiply value for all CLKOUT (2.000-64.000)
      CLKFBOUT_PHASE =&gt; 0.0,           -- Phase offset in degrees of CLKFB (-360.000-360.000)
      -- CLKIN_PERIOD: Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      CLKOUT0_DIVIDE_F =&gt; 1.0,         -- Divide amount for CLKOUT0 (1.000-128.000)
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      -- CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_CASCADE =&gt; "FALSE",
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      COMPENSATION =&gt; "AUTO",          -- AUTO, BUF_IN, EXTERNAL, INTERNAL, ZHOLD
      DIVCLK_DIVIDE =&gt; 1,              -- Master division value (1-106)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0',      -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',       -- Optional inversion for CLKIN1
      IS_CLKIN2_INVERTED =&gt; '0',       -- Optional inversion for CLKIN2
      IS_CLKINSEL_INVERTED =&gt; '0',     -- Optional inversion for CLKINSEL
      IS_PSEN_INVERTED =&gt; '0',         -- Optional inversion for PSEN
      IS_PSINCDEC_INVERTED =&gt; '0',     -- Optional inversion for PSINCDEC
      IS_PWRDWN_INVERTED =&gt; '0',       -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',          -- Optional inversion for RST
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; "FALSE",         -- Delays DONE until MMCM is locked (FALSE, TRUE)
      -- Spread Spectrum: Spread Spectrum Attributes
      SS_EN =&gt; "FALSE",                -- Enables spread spectrum (FALSE, TRUE)
      SS_MODE =&gt; "CENTER_HIGH",        -- CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      SS_MOD_PERIOD =&gt; 10000,          -- Spread spectrum modulation period (ns) (4000-40000)
      -- USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      CLKFBOUT_USE_FINE_PS =&gt; "FALSE",
      CLKOUT0_USE_FINE_PS =&gt; "FALSE",
      CLKOUT1_USE_FINE_PS =&gt; "FALSE",
      CLKOUT2_USE_FINE_PS =&gt; "FALSE",
      CLKOUT3_USE_FINE_PS =&gt; "FALSE",
      CLKOUT4_USE_FINE_PS =&gt; "FALSE",
      CLKOUT5_USE_FINE_PS =&gt; "FALSE",
      CLKOUT6_USE_FINE_PS =&gt; "FALSE" 
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,           -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,         -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,           -- 1-bit output: Primary clock
      CLKOUT1B =&gt; CLKOUT1B,         -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,           -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,         -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,           -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,         -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,           -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,           -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,           -- 1-bit output: CLKOUT6
      -- DRP Ports outputs: Dynamic reconfiguration ports
      DO =&gt; DO,                     -- 16-bit output: DRP data
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP ready
      -- Dynamic Phase Shift Ports outputs: Ports used for dynamic phase shifting of the outputs
      PSDONE =&gt; PSDONE,             -- 1-bit output: Phase shift done
      -- Feedback outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,         -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB,       -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports outputs: MMCM status ports
      CDDCDONE =&gt; CDDCDONE,         -- 1-bit output: Clock dynamic divide done
      CLKFBSTOPPED =&gt; CLKFBSTOPPED, -- 1-bit output: Feedback clock stopped
      CLKINSTOPPED =&gt; CLKINSTOPPED, -- 1-bit output: Input clock stopped
      LOCKED =&gt; LOCKED,             -- 1-bit output: LOCK
      CDDCREQ =&gt; CDDCREQ,           -- 1-bit input: Request to dynamic divide clock
      -- Clock Inputs inputs: Clock inputs
      CLKIN1 =&gt; CLKIN1,             -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,             -- 1-bit input: Secondary clock
      -- Control Ports inputs: MMCM control ports
      CLKINSEL =&gt; CLKINSEL,         -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,             -- 1-bit input: Power-down
      RST =&gt; RST,                   -- 1-bit input: Reset
      -- DRP Ports inputs: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable
      DI =&gt; DI,                     -- 16-bit input: DRP data
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- Dynamic Phase Shift Ports inputs: Ports used for dynamic phase shifting of the outputs
      PSCLK =&gt; PSCLK,               -- 1-bit input: Phase shift clock
      PSEN =&gt; PSEN,                 -- 1-bit input: Phase shift enable
      PSINCDEC =&gt; PSINCDEC,         -- 1-bit input: Phase shift increment/decrement
      -- Feedback inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN            -- 1-bit input: Feedback clock
   );

   -- End of MMCME3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME4_ADV)" treetype="template">
-- MMCME4_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME4_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME4_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   --             Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MMCME4_ADV_inst : MMCME4_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",        -- Jitter programming
      CLKFBOUT_MULT_F =&gt; 5.0,          -- Multiply value for all CLKOUT
      CLKFBOUT_PHASE =&gt; 0.0,           -- Phase offset in degrees of CLKFB
      CLKFBOUT_USE_FINE_PS =&gt; "FALSE", -- Fine phase shift enable (TRUE/FALSE)
      CLKIN1_PERIOD =&gt; 0.0,            -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN2_PERIOD =&gt; 0.0,            -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE_F =&gt; 1.0,         -- Divide amount for CLKOUT0
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT0
      CLKOUT0_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT0
      CLKOUT0_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT1_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT1_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT1_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT2_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT2_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT2_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT3_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT3_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT3_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT4_CASCADE =&gt; "FALSE",      -- Divide amount for CLKOUT (1-128)
      CLKOUT4_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT4_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT4_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT5_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT5_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT5_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT6_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT6_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT6_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      COMPENSATION =&gt; "AUTO",          -- Clock input compensation
      DIVCLK_DIVIDE =&gt; 1,              -- Master division value
      IS_CLKFBIN_INVERTED =&gt; '0',      -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',       -- Optional inversion for CLKIN1
      IS_CLKIN2_INVERTED =&gt; '0',       -- Optional inversion for CLKIN2
      IS_CLKINSEL_INVERTED =&gt; '0',     -- Optional inversion for CLKINSEL
      IS_PSEN_INVERTED =&gt; '0',         -- Optional inversion for PSEN
      IS_PSINCDEC_INVERTED =&gt; '0',     -- Optional inversion for PSINCDEC
      IS_PWRDWN_INVERTED =&gt; '0',       -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',          -- Optional inversion for RST
      REF_JITTER1 =&gt; 0.0,              -- Reference input jitter in UI (0.000-0.999).
      REF_JITTER2 =&gt; 0.0,              -- Reference input jitter in UI (0.000-0.999).
      SS_EN =&gt; "FALSE",                -- Enables spread spectrum
      SS_MODE =&gt; "CENTER_HIGH",        -- Spread spectrum frequency deviation and the spread type
      SS_MOD_PERIOD =&gt; 10000,          -- Spread spectrum modulation period (ns)
      STARTUP_WAIT =&gt; "FALSE"          -- Delays DONE until MMCM is locked
   )
   port map (
      CDDCDONE =&gt; CDDCDONE,         -- 1-bit output: Clock dynamic divide done
      CLKFBOUT =&gt; CLKFBOUT,         -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB,       -- 1-bit output: Inverted CLKFBOUT
      CLKFBSTOPPED =&gt; CLKFBSTOPPED, -- 1-bit output: Feedback clock stopped
      CLKINSTOPPED =&gt; CLKINSTOPPED, -- 1-bit output: Input clock stopped
      CLKOUT0 =&gt; CLKOUT0,           -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,         -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,           -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,         -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,           -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,         -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,           -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,         -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,           -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,           -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,           -- 1-bit output: CLKOUT6
      DO =&gt; DO,                     -- 16-bit output: DRP data output
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP ready
      LOCKED =&gt; LOCKED,             -- 1-bit output: LOCK
      PSDONE =&gt; PSDONE,             -- 1-bit output: Phase shift done
      CDDCREQ =&gt; CDDCREQ,           -- 1-bit input: Request to dynamic divide clock
      CLKFBIN =&gt; CLKFBIN,           -- 1-bit input: Feedback clock
      CLKIN1 =&gt; CLKIN1,             -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,             -- 1-bit input: Secondary clock
      CLKINSEL =&gt; CLKINSEL,         -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable
      DI =&gt; DI,                     -- 16-bit input: DRP data input
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      PSCLK =&gt; PSCLK,               -- 1-bit input: Phase shift clock
      PSEN =&gt; PSEN,                 -- 1-bit input: Phase shift enable
      PSINCDEC =&gt; PSINCDEC,         -- 1-bit input: Phase shift increment/decrement
      PWRDWN =&gt; PWRDWN,             -- 1-bit input: Power-down
      RST =&gt; RST                    -- 1-bit input: Reset
   );

   -- End of MMCME4_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE3_ADV)" treetype="template">
--  PLLE3_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE3_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE3_ADV: Advanced Phase-Locked Loop (PLL)
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PLLE3_ADV_inst : PLLE3_ADV
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT, (1-19)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB, (-360.000-360.000)
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0 (1-128)
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0 (0.001-0.999)
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0 (-360.000-360.000)
      -- CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1 (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1 (0.001-0.999)
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1 (-360.000-360.000)
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      COMPENSATION =&gt; "AUTO",     -- AUTO, BUF_IN, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value, (1-15)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      -- DRP Ports outputs: Dynamic reconfiguration ports
      DO =&gt; DO,                   -- 16-bit output: DRP data
      DRDY =&gt; DRDY,               -- 1-bit output: DRP ready
      -- Feedback Clocks outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      -- Control Ports inputs: PLL control ports
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST,                 -- 1-bit input: Reset
      -- DRP Ports inputs: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,             -- 7-bit input: DRP address
      DCLK =&gt; DCLK,               -- 1-bit input: DRP clock
      DEN =&gt; DEN,                 -- 1-bit input: DRP enable
      DI =&gt; DI,                   -- 16-bit input: DRP data
      DWE =&gt; DWE,                 -- 1-bit input: DRP write enable
      -- Feedback Clocks inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN          -- 1-bit input: Feedback clock
   );

   -- End of PLLE3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE4_ADV)" treetype="template">
--  PLLE4_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE4_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE4_ADV: Advanced Phase-Locked Loop (PLL)
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PLLE4_ADV_inst : PLLE4_ADV
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY
      COMPENSATION =&gt; "AUTO",     -- Clock input compensation
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked
   )
   port map (
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      DO =&gt; DO,                   -- 16-bit output: DRP data output
      DRDY =&gt; DRDY,               -- 1-bit output: DRP ready
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKFBIN =&gt; CLKFBIN,         -- 1-bit input: Feedback clock
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      DADDR =&gt; DADDR,             -- 7-bit input: DRP address
      DCLK =&gt; DCLK,               -- 1-bit input: DRP clock
      DEN =&gt; DEN,                 -- 1-bit input: DRP enable
      DI =&gt; DI,                   -- 16-bit input: DRP data input
      DWE =&gt; DWE,                 -- 1-bit input: DRP write enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST                  -- 1-bit input: Reset
   );

   -- End of PLLE4_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE4_BASE)" treetype="template">
-- PLLE4_BASE  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE4_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE4_BASE: Advanced Phase-Locked Loop (PLL)
   --             Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PLLE4_BASE_inst : PLLE4_BASE
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked
   )
   port map (
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKFBIN =&gt; CLKFBIN,         -- 1-bit input: Feedback clock
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST                  -- 1-bit input: Reset
   );

   -- End of PLLE4_BASE_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME3_BASE)" treetype="template">
-- MMCME3_BASE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME3_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME3_BASE: Base Mixed Mode Clock Manager (MMCM)
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MMCME3_BASE_inst : MMCME3_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",   -- Jitter programming (HIGH, LOW, OPTIMIZED)
      CLKFBOUT_MULT_F =&gt; 5.0,     -- Multiply value for all CLKOUT (2.000-64.000)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB (-360.000-360.000)
      CLKIN1_PERIOD =&gt; 0.0,       -- Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE_F =&gt; 1.0,    -- Divide amount for CLKOUT0 (1.000-128.000)
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      -- CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT4_CASCADE =&gt; "FALSE", -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value (1-106)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',  -- Optional inversion for CLKIN1
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER1 =&gt; 0.0,         -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,     -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,   -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,     -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,   -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,     -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,   -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,     -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,   -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,     -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,     -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,     -- 1-bit output: CLKOUT6
      -- Feedback outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,   -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB, -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports outputs: MMCM status ports
      LOCKED =&gt; LOCKED,       -- 1-bit output: LOCK
      -- Clock Inputs inputs: Clock input
      CLKIN1 =&gt; CLKIN1,       -- 1-bit input: Clock
      -- Control Ports inputs: MMCM control ports
      PWRDWN =&gt; PWRDWN,       -- 1-bit input: Power-down
      RST =&gt; RST,             -- 1-bit input: Reset
      -- Feedback inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN      -- 1-bit input: Feedback clock
   );

   -- End of MMCME3_BASE_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME4_BASE)" treetype="template">
-- MMCME4_BASE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME4_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME4_BASE: Base Mixed Mode Clock Manager (MMCM)
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MMCME4_BASE_inst : MMCME4_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",   -- Jitter programming
      CLKFBOUT_MULT_F =&gt; 5.0,     -- Multiply value for all CLKOUT
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB
      CLKIN1_PERIOD =&gt; 0.0,       -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE_F =&gt; 1.0,    -- Divide amount for CLKOUT0
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT2_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT2_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT3_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT3_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT4_CASCADE =&gt; "FALSE", -- Divide amount for CLKOUT (1-128)
      CLKOUT4_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT4_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT5_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT5_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT6_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT6_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',  -- Optional inversion for CLKIN1
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER1 =&gt; 0.0,         -- Reference input jitter in UI (0.000-0.999).
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until MMCM is locked
   )
   port map (
      CLKFBOUT =&gt; CLKFBOUT,   -- 1-bit output: Feedback clock pin to the MMCM
      CLKFBOUTB =&gt; CLKFBOUTB, -- 1-bit output: Inverted CLKFBOUT
      CLKOUT0 =&gt; CLKOUT0,     -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,   -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,     -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,   -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,     -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,   -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,     -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,   -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,     -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,     -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,     -- 1-bit output: CLKOUT6
      LOCKED =&gt; LOCKED,       -- 1-bit output: LOCK
      CLKFBIN =&gt; CLKFBIN,     -- 1-bit input: Feedback clock pin to the MMCM
      CLKIN1 =&gt; CLKIN1,       -- 1-bit input: Primary clock
      PWRDWN =&gt; PWRDWN,       -- 1-bit input: Power-down
      RST =&gt; RST              -- 1-bit input: Reset
   );

   -- End of MMCME4_BASE_inst instantiation
					</Template>
					<Template label="Base Phase-Locked Loop (PLL) (PLLE3_BASE)" treetype="template">
-- PLLE3_BASE  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE3_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE3_BASE: Base Phase-Locked Loop (PLL)
   --             Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PLLE3_BASE_inst : PLLE3_BASE
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT, (1-19)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB, (-360.000-360.000)
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0 (1-128)
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0 (0.001-0.999)
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0 (-360.000-360.000)
      -- CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1 (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1 (0.001-0.999)
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1 (-360.000-360.000)
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value, (1-15)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      -- Feedback Clocks outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      -- Control Ports inputs: PLL control ports
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST,                 -- 1-bit input: Reset
      -- Feedback Clocks inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN          -- 1-bit input: Feedback clock
   );

   -- End of PLLE3_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CONFIGURATION" treetype="folder">
				<SubFolder label="BSCAN" treetype="folder">
					<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
--   BSCANE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BSCANE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BSCANE2: Boundary-Scan User Instruction
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BSCANE2_inst : BSCANE2
   generic map (
      JTAG_CHAIN =&gt; 1  -- Value for USER command
   )
   port map (
      CAPTURE =&gt; CAPTURE, -- 1-bit output: CAPTURE output from TAP controller.
      DRCK =&gt; DRCK,       -- 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                          -- SHIFT are asserted.

      RESET =&gt; RESET,     -- 1-bit output: Reset output for TAP controller.
      RUNTEST =&gt; RUNTEST, -- 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      SEL =&gt; SEL,         -- 1-bit output: USER instruction active output.
      SHIFT =&gt; SHIFT,     -- 1-bit output: SHIFT output from TAP controller.
      TCK =&gt; TCK,         -- 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      TDI =&gt; TDI,         -- 1-bit output: Test Data Input (TDI) output from TAP controller.
      TMS =&gt; TMS,         -- 1-bit output: Test Mode Select output. Fabric connection to TAP.
      UPDATE =&gt; UPDATE,   -- 1-bit output: UPDATE output from TAP controller
      TDO =&gt; TDO          -- 1-bit input: Test Data Output (TDO) input for USER function.
   );

   -- End of BSCANE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DNA" treetype="folder">
					<Template label="Device DNA Access Port (DNA_PORTE2)" treetype="template">
-- DNA_PORTE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DNA_PORTE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DNA_PORTE2: Device DNA Access Port
   --             Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   DNA_PORTE2_inst : DNA_PORTE2
   generic map (
      SIM_DNA_VALUE =&gt; X"000000000000000000000000"  -- Specifies a sample 96-bit DNA value for simulation
   )
   port map (
      DOUT =&gt; DOUT,   -- 1-bit output: DNA output data
      CLK =&gt; CLK,     -- 1-bit input: Clock input
      DIN =&gt; DIN,     -- 1-bit input: User data input pin
      READ =&gt; READ,   -- 1-bit input: Active-High load DNA, active-Low read input
      SHIFT =&gt; SHIFT  -- 1-bit input: Active-High shift enable input
   );

   -- End of DNA_PORTE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="EFUSE" treetype="folder">
					<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
--  EFUSE_USR  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (EFUSE_USR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EFUSE_USR: 32-bit non-volatile design ID
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   EFUSE_USR_inst : EFUSE_USR
   generic map (
      SIM_EFUSE_VALUE =&gt; X"00000000"  -- Value of the 32-bit non-volatile value used in simulation
   )
   port map (
      EFUSEUSR =&gt; EFUSEUSR  -- 32-bit output: User eFUSE register value output
   );

   -- End of EFUSE_USR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="ICAP" treetype="folder">
					<Template label="Internal Configuration Access Port (ICAPE3)" treetype="template">
--   ICAPE3    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ICAPE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ICAPE3: Internal Configuration Access Port
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   ICAPE3_inst : ICAPE3
   generic map (
      DEVICE_ID =&gt; X"03628093",      -- Specifies the pre-programmed Device ID value to be used for simulation
                                     -- purposes.
      ICAP_AUTO_SWITCH =&gt; "DISABLE", -- Enable switch ICAP using sync word
      SIM_CFG_FILE_NAME =&gt; "NONE"    -- Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                     -- model
   )
   port map (
      AVAIL =&gt; AVAIL,     -- 1-bit output: Availability status of ICAP
      O =&gt; O,             -- 32-bit output: Configuration data output bus
      PRDONE =&gt; PRDONE,   -- 1-bit output: Indicates completion of Partial Reconfiguration
      PRERROR =&gt; PRERROR, -- 1-bit output: Indicates Error during Partial Reconfiguration
      CLK =&gt; CLK,         -- 1-bit input: Clock input
      CSIB =&gt; CSIB,       -- 1-bit input: Active-Low ICAP enable
      I =&gt; I,             -- 32-bit input: Configuration data input bus
      RDWRB =&gt; RDWRB      -- 1-bit input: Read/Write Select input
   );

   -- End of ICAPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MASTER_JTAG" treetype="folder">
					<Template label="JTAG Port Access (MASTER_JTAG)" treetype="template">
-- MASTER_JTAG : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MASTER_JTAG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MASTER_JTAG: JTAG Port Access
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MASTER_JTAG_inst : MASTER_JTAG
   port map (
      TDO =&gt; TDO, -- 1-bit output: JTAG TDO output pin
      TCK =&gt; TCK, -- 1-bit input: JTAG TCK input pin
      TDI =&gt; TDI, -- 1-bit input: JTAG TDI input pin
      TMS =&gt; TMS  -- 1-bit input: JTAG TMS input pin
   );

   -- End of MASTER_JTAG_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="STARTUP" treetype="folder">
					<Template label="STARTUP Block (STARTUPE3)" treetype="template">
--  STARTUPE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (STARTUPE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- STARTUPE3: STARTUP Block
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   STARTUPE3_inst : STARTUPE3
   generic map (
      PROG_USR =&gt; "FALSE",  -- Activate program event security feature. Requires encrypted bitstreams.
      SIM_CCLK_FREQ =&gt; 0.0  -- Set the Configuration Clock Frequency (ns) for simulation
   )
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration main clock output
      CFGMCLK =&gt; CFGMCLK,     -- 1-bit output: Configuration internal oscillator clock output
      DI =&gt; DI,               -- 4-bit output: Allow receiving on the D input pin
      EOS =&gt; EOS,             -- 1-bit output: Active-High output signal indicating the End Of Startup
      PREQ =&gt; PREQ,           -- 1-bit output: PROGRAM request to fabric output
      DO =&gt; DO,               -- 4-bit input: Allows control of the D pin output
      DTS =&gt; DTS,             -- 4-bit input: Allows tristate of the D pin
      FCSBO =&gt; FCSBO,         -- 1-bit input: Controls the FCS_B pin for flash access
      FCSBTS =&gt; FCSBTS,       -- 1-bit input: Tristate the FCS_B pin
      GSR =&gt; GSR,             -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port)
      GTS =&gt; GTS,             -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      KEYCLEARB =&gt; KEYCLEARB, -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      PACK =&gt; PACK,           -- 1-bit input: PROGRAM acknowledge input
      USRCCLKO =&gt; USRCCLKO,   -- 1-bit input: User CCLK input
      USRCCLKTS =&gt; USRCCLKTS, -- 1-bit input: User CCLK 3-state enable input
      USRDONEO =&gt; USRDONEO,   -- 1-bit input: User DONE pin output control
      USRDONETS =&gt; USRDONETS  -- 1-bit input: User DONE 3-state enable output
   );

   -- End of STARTUPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="USR_ACCESS" treetype="folder">
					<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
-- USR_ACCESSE2 : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (USR_ACCESSE2_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- USR_ACCESSE2: Configuration Data Access
   --               Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2_inst : USR_ACCESSE2
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration Clock
      DATA =&gt; DATA,           -- 32-bit output: Configuration Data reflecting the contents of the AXSS register
      DATAVALID =&gt; DATAVALID  -- 1-bit output: Active High Data Valid
   );

   -- End of USR_ACCESSE2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="BIDIR_BUFFER" treetype="folder">
					<Template label="Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable (IOBUF_INTERMDISABLE)" treetype="template">
-- IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
--        VHDL         : the following instance declaration needs to be placed
--      instance       : in the body of the design code.  The instance name
--     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations after the
--        code         : "=&gt;" declaration maybe changed to properly reference and
--                     : connect this function to the design.  All inputs and outputs
--                     : must be connected.

--       Library       : In addition to adding the instance declaration, a use
--     declaration     : statement for the UNISIM.vcomponents library needs to be
--         for         : added before the entity declaration.  This library
--       Xilinx        : contains the component declarations for all Xilinx
--     primitives      : primitives and points to the models that will be used
--                     : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_INTERMDISABLE: Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable
   --                      Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_INTERMDISABLE_inst : IOBUF_INTERMDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T                          -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Bidirectional I/O Buffer with Offset Calibration and VREF Tuning (IOBUFE3)" treetype="template">
--   IOBUFE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFE3: Bidirectional I/O Buffer with Offset Calibration and VREF Tuning
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFE3_inst : IOBUFE3
   generic map (
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Buffer inout (connect directly to top-level port)
      OSC =&gt; OSC,                       -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,                 -- 1-bit input: Offset cancellation enable
      T =&gt; T,                           -- 1-bit input: 3-state enable input
      VREF =&gt; VREF                      -- 1-bit input: Vref input from HPIO_VREF
   );

   -- End of IOBUFE3_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
-- IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
--              VHDL              : the following instance declaration needs to be placed
--            instance            : in the body of the design code.  The instance name
--          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations after the
--              code              : "=&gt;" declaration maybe changed to properly reference and
--                                : connect this function to the design.  All inputs and outputs
--                                : must be connected.

--            Library             : In addition to adding the instance declaration, a use
--          declaration           : statement for the UNISIM.vcomponents library needs to be
--              for               : added before the entity declaration.  This library
--             Xilinx             : contains the component declarations for all Xilinx
--           primitives           : primitives and points to the models that will be used
--                                : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable
   --                                 Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst : IOBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                       -- 1-bit output: Buffer diff_n output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Must be tied to a logic '0'
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                     -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,                       -- 1-bit input: 3-state master enable input
      TS =&gt; TS                        -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
-- IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
--          VHDL          : the following instance declaration needs to be placed
--        instance        : in the body of the design code.  The instance name
--      declaration       : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations after the
--          code          : "=&gt;" declaration maybe changed to properly reference and
--                        : connect this function to the design.  All inputs and outputs
--                        : must be connected.

--        Library         : In addition to adding the instance declaration, a use
--      declaration       : statement for the UNISIM.vcomponents library needs to be
--          for           : added before the entity declaration.  This library
--         Xilinx         : contains the component declarations for all Xilinx
--       primitives       : primitives and points to the models that will be used
--                        : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_DCIEN: Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable
   --                         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_DCIEN_inst : IOBUFDS_DIFF_OUT_DCIEN
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                         -- 1-bit output: Buffer diff_n output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Must be tied to a logic '0'
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,                         -- 1-bit input: 3-state master enable input
      TS =&gt; TS                          -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input (IOBUFDS_INTERMDISABLE)" treetype="template">
-- IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--         VHDL          : the following instance declaration needs to be placed
--       instance        : in the body of the design code.  The instance name
--      declaration      : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations after the
--         code          : "=&gt;" declaration maybe changed to properly reference and
--                       : connect this function to the design.  All inputs and outputs
--                       : must be connected.

--        Library        : In addition to adding the instance declaration, a use
--      declaration      : statement for the UNISIM.vcomponents library needs to be
--          for          : added before the entity declaration.  This library
--        Xilinx         : contains the component declarations for all Xilinx
--      primitives       : primitives and points to the models that will be used
--                       : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_INTERMDISABLE: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input
   --                        Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_INTERMDISABLE_inst : IOBUFDS_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                     -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T                          -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DCIEN)" treetype="template">
-- IOBUFDS_DCIEN : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the body of the design code.  The instance name
--  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations after the
--     code      : "=&gt;" declaration maybe changed to properly reference and
--               : connect this function to the design.  All inputs and outputs
--               : must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--  primitives   : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DCIEN: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DCIEN_inst : IOBUFDS_DCIEN
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional I/O Buffer with Offset Calibration (IOBUFDSE3)" treetype="template">
--  IOBUFDSE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFDSE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDSE3: Differential Bidirectional I/O Buffer with Offset Calibration
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDSE3_inst : IOBUFDSE3
   generic map (
      DQS_BIAS =&gt; "FALSE",          -- (FALSE, TRUE)
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      OSC =&gt; OSC,                       -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,                 -- 2-bit input: Offset cancellation enable
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDSE3_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer (IOBUFDS)" treetype="template">
--   IOBUFDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS: Differential Input/Output Buffer
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_inst : IOBUFDS
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer output
      I =&gt; I,     -- 1-bit input: Buffer input
      IO =&gt; IO,   -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T      -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer (IOBUFDS_DIFF_OUT)" treetype="template">
-- IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT: Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer
   --                   Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_inst : IOBUFDS_DIFF_OUT
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,   -- 1-bit output: Buffer diff_n output
      I =&gt; I,     -- 1-bit input: Buffer input
      IO =&gt; IO,   -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,   -- 1-bit input: 3-state master enable input
      TS =&gt; TS    -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Input/Output Buffer DCI Enable (IOBUF_DCIEN)" treetype="template">
-- IOBUF_DCIEN : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUF_DCIEN_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_DCIEN: Input/Output Buffer DCI Enable
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_DCIEN_inst : IOBUF_DCIEN
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Input/Output Buffer (IOBUF)" treetype="template">
--    IOBUF    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF: Input/Output Buffer
   --        Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_inst : IOBUF
   port map (
      O =&gt; O,   -- 1-bit output: Buffer output
      I =&gt; I,   -- 1-bit input: Buffer input
      IO =&gt; IO, -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T    -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="BITSLICE" treetype="folder">
					<Template label="BITSLICE_CONTROL (BITSLICE_CONTROL)" treetype="template">
-- BITSLICE_CONTROL : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (BITSLICE_CONTROL_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BITSLICE_CONTROL: BITSLICE_CONTROL for control using Native Mode
   --                   Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BITSLICE_CONTROL_inst : BITSLICE_CONTROL
   generic map (
      DIV_MODE =&gt; "DIV2",               -- Controller DIV2/DIV4 mode (DIV2, DIV4)
      EN_CLK_TO_EXT_NORTH =&gt; "DISABLE", -- Enable clock forwarding to north
      EN_CLK_TO_EXT_SOUTH =&gt; "DISABLE", -- Enable clock forwarding to south
      EN_DYN_ODLY_MODE =&gt; "FALSE",      -- Enable dynamic output delay mode
      EN_OTHER_NCLK =&gt; "FALSE",         -- Select the NCLK from the other BITSLICE_CONTROL in the nibble
                                        -- (FALSE, TRUE)
      EN_OTHER_PCLK =&gt; "FALSE",         -- Select the PCLK from the other BITSLICE_CONTROL in the nibble
                                        -- (FALSE, TRUE)
      IDLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for input delays
      INV_RXCLK =&gt; "FALSE",             -- Invert clock path from IOB to upper RX bitslice
      ODLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for output delays
      QDLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for clock delays
      READ_IDLE_COUNT =&gt; X"00",         -- Gap count between read bursts for ODT control counter (0-3f)
      REFCLK_SRC =&gt; "PLLCLK",           -- Select the input clock for the delay control (PLLCLK, REFCLK)
      ROUNDING_FACTOR =&gt; 16,            -- Rounding factor in BISC spec (128-8)
      RXGATE_EXTEND =&gt; "FALSE",         -- Reserved for use by MIG Memory Controller. Do Not Change.
      RX_CLK_PHASE_N =&gt; "SHIFT_0",      -- Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                        -- SHIFT_90)
      RX_CLK_PHASE_P =&gt; "SHIFT_0",      -- Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                        -- SHIFT_90)
      RX_GATING =&gt; "DISABLE",           -- ENABLE/DISABLE read DQS gating
      SELF_CALIBRATE =&gt; "ENABLE",       -- Enable BISC of nibble controlled by BITSLICE_CONTROL
      SERIAL_MODE =&gt; "FALSE",           -- Put BITSLICE read paths into serial mode (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE",       -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                        -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TX_GATING =&gt; "DISABLE"            -- ENABLE/DISABLE clock gating in WClkgen
   )
   port map (
      CLK_TO_EXT_NORTH =&gt; CLK_TO_EXT_NORTH,       -- 1-bit output: Inter-byte clock going to north
                                                  -- BITSLICE_CONTROL

      CLK_TO_EXT_SOUTH =&gt; CLK_TO_EXT_SOUTH,       -- 1-bit output: Inter-byte clock going to south
                                                  -- BITSLICE_CONTROL

      DLY_RDY =&gt; DLY_RDY,                         -- 1-bit output: Fixed delay calibration complete
      DYN_DCI =&gt; DYN_DCI,                         -- 7-bit output: Direct control of IOB DCI when using a
                                                  -- memory interface

      NCLK_NIBBLE_OUT =&gt; NCLK_NIBBLE_OUT,         -- 1-bit output: Intra-byte DQS strobes/clock to other
                                                  -- control block

      PCLK_NIBBLE_OUT =&gt; PCLK_NIBBLE_OUT,         -- 1-bit output: Intra-byte DQS strobes/clock to other
                                                  -- control block

      RIU_RD_DATA =&gt; RIU_RD_DATA,                 -- 16-bit output: RIU Output Read data to the controller
      RIU_VALID =&gt; RIU_VALID,                     -- 1-bit output: Last data written has been accepted when High
      RX_BIT_CTRL_OUT0 =&gt; RX_BIT_CTRL_OUT0,       -- 40-bit output: Output bus to Bitslice 0
      RX_BIT_CTRL_OUT1 =&gt; RX_BIT_CTRL_OUT1,       -- 40-bit output: Output bus to Bitslice 1
      RX_BIT_CTRL_OUT2 =&gt; RX_BIT_CTRL_OUT2,       -- 40-bit output: Output bus to Bitslice 2
      RX_BIT_CTRL_OUT3 =&gt; RX_BIT_CTRL_OUT3,       -- 40-bit output: Output bus to Bitslice 3
      RX_BIT_CTRL_OUT4 =&gt; RX_BIT_CTRL_OUT4,       -- 40-bit output: Output bus to Bitslice 4
      RX_BIT_CTRL_OUT5 =&gt; RX_BIT_CTRL_OUT5,       -- 40-bit output: Output bus to Bitslice 5
      RX_BIT_CTRL_OUT6 =&gt; RX_BIT_CTRL_OUT6,       -- 40-bit output: Output bus to Bitslice 6
      TX_BIT_CTRL_OUT0 =&gt; TX_BIT_CTRL_OUT0,       -- 40-bit output: Output bus to Bitslice 0
      TX_BIT_CTRL_OUT1 =&gt; TX_BIT_CTRL_OUT1,       -- 40-bit output: Output bus to Bitslice 1
      TX_BIT_CTRL_OUT2 =&gt; TX_BIT_CTRL_OUT2,       -- 40-bit output: Output bus to Bitslice 2
      TX_BIT_CTRL_OUT3 =&gt; TX_BIT_CTRL_OUT3,       -- 40-bit output: Output bus to Bitslice 3
      TX_BIT_CTRL_OUT4 =&gt; TX_BIT_CTRL_OUT4,       -- 40-bit output: Output bus to Bitslice 4
      TX_BIT_CTRL_OUT5 =&gt; TX_BIT_CTRL_OUT5,       -- 40-bit output: Output bus to Bitslice 5
      TX_BIT_CTRL_OUT6 =&gt; TX_BIT_CTRL_OUT6,       -- 40-bit output: Output bus to Bitslice 6
      TX_BIT_CTRL_OUT_TRI =&gt; TX_BIT_CTRL_OUT_TRI, -- 40-bit output: Output bus to 3-state TX_BITSLICE_TRI
      VTC_RDY =&gt; VTC_RDY,                         -- 1-bit output: PHY calibration is complete
      CLK_FROM_EXT =&gt; CLK_FROM_EXT,               -- 1-bit input: Inter-byte clock coming from north or south
                                                  -- BITSLICE_CONTROL

      EN_VTC =&gt; EN_VTC,                           -- 1-bit input: Enables voltage and temperature compensation
                                                  -- when High

      NCLK_NIBBLE_IN =&gt; NCLK_NIBBLE_IN,           -- 1-bit input: Intra-byte DQS strobes from other/clock
                                                  -- control block

      PCLK_NIBBLE_IN =&gt; PCLK_NIBBLE_IN,           -- 1-bit input: Intra-byte DQS strobes/clock from other
                                                  -- control block

      PHY_RDCS0 =&gt; PHY_RDCS0,                     -- 4-bit input: Rank select
      PHY_RDCS1 =&gt; PHY_RDCS1,                     -- 4-bit input: Rank select
      PHY_RDEN =&gt; PHY_RDEN,                       -- 4-bit input: Read burst enable when using a memory
                                                  -- interface

      PHY_WRCS0 =&gt; PHY_WRCS0,                     -- 4-bit input: Rank select
      PHY_WRCS1 =&gt; PHY_WRCS1,                     -- 4-bit input: Rank select
      PLL_CLK =&gt; PLL_CLK,                         -- 1-bit input: PLL clock input
      REFCLK =&gt; REFCLK,                           -- 1-bit input: Frequency reference clock for delay control
      RIU_ADDR =&gt; RIU_ADDR,                       -- 6-bit input: Address input for RIU
      RIU_CLK =&gt; RIU_CLK,                         -- 1-bit input: System clock from fabric for RIU access
      RIU_NIBBLE_SEL =&gt; RIU_NIBBLE_SEL,           -- 1-bit input: Nibble select to enable RIU read/write
      RIU_WR_DATA =&gt; RIU_WR_DATA,                 -- 16-bit input: RIU Input Write data from the controller
      RIU_WR_EN =&gt; RIU_WR_EN,                     -- 1-bit input: Enables write to RIU when High
      RST =&gt; RST,                                 -- 1-bit input: Asynchronous global reset
      RX_BIT_CTRL_IN0 =&gt; RX_BIT_CTRL_IN0,         -- 40-bit input: Input bus from Bitslice 0
      RX_BIT_CTRL_IN1 =&gt; RX_BIT_CTRL_IN1,         -- 40-bit input: Input bus from Bitslice 1
      RX_BIT_CTRL_IN2 =&gt; RX_BIT_CTRL_IN2,         -- 40-bit input: Input bus from Bitslice 2
      RX_BIT_CTRL_IN3 =&gt; RX_BIT_CTRL_IN3,         -- 40-bit input: Input bus from Bitslice 3
      RX_BIT_CTRL_IN4 =&gt; RX_BIT_CTRL_IN4,         -- 40-bit input: Input bus from Bitslice 4
      RX_BIT_CTRL_IN5 =&gt; RX_BIT_CTRL_IN5,         -- 40-bit input: Input bus from Bitslice 5
      RX_BIT_CTRL_IN6 =&gt; RX_BIT_CTRL_IN6,         -- 40-bit input: Input bus from Bitslice 6
      TBYTE_IN =&gt; TBYTE_IN,                       -- 4-bit input: Output enable for 3-state control
      TX_BIT_CTRL_IN0 =&gt; TX_BIT_CTRL_IN0,         -- 40-bit input: Input bus from Bitslice 0
      TX_BIT_CTRL_IN1 =&gt; TX_BIT_CTRL_IN1,         -- 40-bit input: Input bus from Bitslice 1
      TX_BIT_CTRL_IN2 =&gt; TX_BIT_CTRL_IN2,         -- 40-bit input: Input bus from Bitslice 2
      TX_BIT_CTRL_IN3 =&gt; TX_BIT_CTRL_IN3,         -- 40-bit input: Input bus from Bitslice 3
      TX_BIT_CTRL_IN4 =&gt; TX_BIT_CTRL_IN4,         -- 40-bit input: Input bus from Bitslice 4
      TX_BIT_CTRL_IN5 =&gt; TX_BIT_CTRL_IN5,         -- 40-bit input: Input bus from Bitslice 5
      TX_BIT_CTRL_IN6 =&gt; TX_BIT_CTRL_IN6,         -- 40-bit input: Input bus from Bitslice 6
      TX_BIT_CTRL_IN_TRI =&gt; TX_BIT_CTRL_IN_TRI    -- 40-bit input: Input bus from 3-state TX_BITSLICE_TRI
   );

   -- End of BITSLICE_CONTROL_inst instantiation
					</Template>
					<Template label="Register Interface Unit Selection Block (RIU_OR)" treetype="template">
--   RIU_OR    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RIU_OR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RIU_OR: Register Interface Unit Selection Block
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RIU_OR_inst : RIU_OR
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      RIU_RD_DATA =&gt; RIU_RD_DATA,           -- 16-bit output: RIU data bus to the controller
      RIU_RD_VALID =&gt; RIU_RD_VALID,         -- 1-bit output: Combined RIU read valid signal to the controller
      RIU_RD_DATA_LOW =&gt; RIU_RD_DATA_LOW,   -- 16-bit input: RIU data bus from the controller to the lower
                                            -- nibble BITSLICE_CONTROL

      RIU_RD_DATA_UPP =&gt; RIU_RD_DATA_UPP,   -- 16-bit input: RIU data bus from the controller to the upper
                                            -- nibble BITSLICE_CONTROL

      RIU_RD_VALID_LOW =&gt; RIU_RD_VALID_LOW, -- 1-bit input: RIU_VALID of the lower nibble BITSLICE_CONTROL
      RIU_RD_VALID_UPP =&gt; RIU_RD_VALID_UPP  -- 1-bit input: RIU_VALID of the upper nibble BITSLICE_CONTROL
   );

   -- End of RIU_OR_inst instantiation
					</Template>
					<Template label="RX_BITSLICE (RX_BITSLICE)" treetype="template">
-- RX_BITSLICE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RX_BITSLICE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RX_BITSLICE: RX_BITSLICE for input using Native Mode
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RX_BITSLICE_inst : RX_BITSLICE
   generic map (
      CASCADE =&gt; "FALSE",             -- Enables cascading of IDELAY and ODELAY lines
      DATA_TYPE =&gt; "DATA",            -- Defines what the input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                      -- SERIAL)
      DATA_WIDTH =&gt; 8,                -- Defines the width of the serial-to-parallel converter (4-8)
      DELAY_FORMAT =&gt; "TIME",         -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",          -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,               -- Input delay value setting in ps
      DELAY_VALUE_EXT =&gt; 0,           -- Value of the extended input delay value in ps
      FIFO_SYNC_MODE =&gt; "FALSE",      -- Internal write clock and FIFO_RD_CLK are coming from a common source
      IS_CLK_EXT_INVERTED =&gt; '0',     -- Optional inversion for CLK_EXT
      IS_CLK_INVERTED =&gt; '0',         -- Optional inversion for CLK
      IS_RST_DLY_EXT_INVERTED =&gt; '0', -- Optional inversion for RST_DLY_EXT
      IS_RST_DLY_INVERTED =&gt; '0',     -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',         -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,      -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC",         -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
      UPDATE_MODE_EXT =&gt; "ASYNC"      -- Determines when updates to the extended input delay will take effect
                                      -- (ASYNC, MANUAL, SYNC)
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT,         -- 9-bit output: Counter value to device logic
      CNTVALUEOUT_EXT =&gt; CNTVALUEOUT_EXT, -- 9-bit output: Optional extended (cascaded delay) counter value
                                          -- going to the device logic

      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      FIFO_WRCLK_OUT =&gt; FIFO_WRCLK_OUT,   -- 1-bit output: FIFO source synchronous write clock out to the
                                          -- device logic (currently unsupported, do not connect)

      Q =&gt; Q,                             -- 8-bit output: Registered output data from FIFO
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      CE =&gt; CE,                           -- 1-bit input: Clock enable for IDELAY
      CE_EXT =&gt; CE_EXT,                   -- 1-bit input: Optional extended (cascaded delay) clock enable
      CLK =&gt; CLK,                         -- 1-bit input: Clock used to sample LOAD, CE, INC
      CLK_EXT =&gt; CLK_EXT,                 -- 1-bit input: Optional extended (cascaded delay) clock
      CNTVALUEIN =&gt; CNTVALUEIN,           -- 9-bit input: Counter value from device logic
      CNTVALUEIN_EXT =&gt; CNTVALUEIN_EXT,   -- 9-bit input: Optional extended (cascaded delay) counter value from
                                          -- device logic

      DATAIN =&gt; DATAIN,                   -- 1-bit input: Input signal from IBUF
      EN_VTC =&gt; EN_VTC,                   -- 1-bit input: Enable IDELAYCTRL to keep stable delay over VT
      EN_VTC_EXT =&gt; EN_VTC_EXT,           -- 1-bit input: Optional extended (cascaded delay) to keep stable
                                          -- delay over VT

      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: FIFO read enable
      INC =&gt; INC,                         -- 1-bit input: Increment the current delay tap setting
      INC_EXT =&gt; INC_EXT,                 -- 1-bit input: Optional extended (cascaded delay) increments the
                                          -- current delay tap setting

      LOAD =&gt; LOAD,                       -- 1-bit input: Load the CNTVALUEIN tap setting
      LOAD_EXT =&gt; LOAD_EXT,               -- 1-bit input: Optional extended (cascaded delay) load the
                                          -- CNTVALUEIN_EXT tap setting

      RST =&gt; RST,                         -- 1-bit input: Asynchronous assert, synchronous deassert for
                                          -- RX_BITSLICE ISERDES

      RST_DLY =&gt; RST_DLY,                 -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      RST_DLY_EXT =&gt; RST_DLY_EXT,         -- 1-bit input: Optional extended (cascaded delay) reset delay to
                                          -- DELAY_VALUE_EXT

      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN    -- 40-bit input: Input bus from BITSLICE_CONTROL
   );

   -- End of RX_BITSLICE_inst instantiation
					</Template>
					<Template label="RXTX_BITSLICE (RXTX_BITSLICE)" treetype="template">
-- RXTX_BITSLICE : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the body of the design code.  The instance name
--  declaration  : (RXTX_BITSLICE_inst) and/or the port declarations after the
--     code      : "=&gt;" declaration maybe changed to properly reference and
--               : connect this function to the design.  All inputs and outputs
--               : must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--  primitives   : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RXTX_BITSLICE: RXTX_BITSLICE for bidirectional I/O using Native Mode
   --                Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RXTX_BITSLICE_inst : RXTX_BITSLICE
   generic map (
      ENABLE_PRE_EMPHASIS =&gt; "FALSE", -- Enable the pre-emphasis
      FIFO_SYNC_MODE =&gt; "FALSE",      -- Internal write clock and FIFO_RD_CLK are coming from a common source
      INIT =&gt; '1',                    -- Defines initial O value
      IS_RX_CLK_INVERTED =&gt; '0',      -- Optional inversion for RX_CLK
      IS_RX_RST_DLY_INVERTED =&gt; '0',  -- Optional inversion for RX_RST_DLY
      IS_RX_RST_INVERTED =&gt; '0',      -- Optional inversion for RX_RST
      IS_TX_CLK_INVERTED =&gt; '0',      -- Optional inversion for TX_CLK
      IS_TX_RST_DLY_INVERTED =&gt; '0',  -- Optional inversion for TX_RST_DLY
      IS_TX_RST_INVERTED =&gt; '0',      -- Optional inversion for TX_RST
      RX_DATA_TYPE =&gt; "DATA",         -- Defines what the RX input pin is carrying (CLOCK, DATA,
                                      -- DATA_AND_CLOCK, SERIAL)
      RX_DATA_WIDTH =&gt; 8,             -- Defines the width of the serial-to-parallel converter (4-8)
      RX_DELAY_FORMAT =&gt; "TIME",      -- Units of the RX DELAY_VALUE (COUNT, TIME)
      RX_DELAY_TYPE =&gt; "FIXED",       -- Set the type of RX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      RX_DELAY_VALUE =&gt; 0,            -- RX Input delay value setting in ps
      RX_REFCLK_FREQUENCY =&gt; 300.0,   -- Specification of the RX reference clock frequency in MHz
                                      -- (200.0-2667.0)
      RX_UPDATE_MODE =&gt; "ASYNC",      -- Determines when updates to the RX delay will take effect (ASYNC,
                                      -- MANUAL, SYNC)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TBYTE_CTL =&gt; "TBYTE_IN",        -- Select between T and TBYTE_IN inputs
      TX_DATA_WIDTH =&gt; 8,             -- Parallel data input width (4-8)
      TX_DELAY_FORMAT =&gt; "TIME",      -- Units of the TX DELAY_VALUE (COUNT, TIME)
      TX_DELAY_TYPE =&gt; "FIXED",       -- Set the type of TX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      TX_DELAY_VALUE =&gt; 0,            -- TX Input delay value setting in ps
      TX_OUTPUT_PHASE_90 =&gt; "FALSE",  -- Delays the output phase by 90-degrees
      TX_REFCLK_FREQUENCY =&gt; 300.0,   -- Specification of the TX reference clock frequency in MHz
                                      -- (200.0-2667.0)
      TX_UPDATE_MODE =&gt; "ASYNC"       -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
   )
   port map (
      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      FIFO_WRCLK_OUT =&gt; FIFO_WRCLK_OUT,   -- 1-bit output: FIFO source synchronous write clock out to the
                                          -- device logic (currently unsupported, do not connect)

      O =&gt; O,                             -- 1-bit output: Serialized output going to output buffer
      Q =&gt; Q,                             -- 8-bit output: Registered output data from FIFO
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: RX Output bus to BITSLICE_CONTROL
      RX_CNTVALUEOUT =&gt; RX_CNTVALUEOUT,   -- 9-bit output: RX Counter value from device logic
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL for TX
      TX_CNTVALUEOUT =&gt; TX_CNTVALUEOUT,   -- 9-bit output: TX Counter value to device logic
      T_OUT =&gt; T_OUT,                     -- 1-bit output: Byte group 3-state output
      D =&gt; D,                             -- 8-bit input: Data from device logic
      DATAIN =&gt; DATAIN,                   -- 1-bit input: Input signal from IOBUF
      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: FIFO read enable
      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: RX Input bus from BITSLICE_CONTROL
      RX_CE =&gt; RX_CE,                     -- 1-bit input: Clock enable for IDELAY
      RX_CLK =&gt; RX_CLK,                   -- 1-bit input: RX Clock used to sample LOAD, CE, INC
      RX_CNTVALUEIN =&gt; RX_CNTVALUEIN,     -- 9-bit input: RX Counter value from device logic
      RX_EN_VTC =&gt; RX_EN_VTC,             -- 1-bit input: RX Enable to keep stable delay over VT
      RX_INC =&gt; RX_INC,                   -- 1-bit input: RX Increment the current delay tap setting
      RX_LOAD =&gt; RX_LOAD,                 -- 1-bit input: RX Load the CNTVALUEIN tap setting
      RX_RST =&gt; RX_RST,                   -- 1-bit input: RX Asynchronous assert, synchronous deassert for
                                          -- RXTX_BITSLICE ISERDES

      RX_RST_DLY =&gt; RX_RST_DLY,           -- 1-bit input: RX Reset the internal DELAY value to DELAY_VALUE
      T =&gt; T,                             -- 1-bit input: Legacy T byte input from device logic
      TBYTE_IN =&gt; TBYTE_IN,               -- 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN,   -- 40-bit input: TX Input bus from BITSLICE_CONTROL
      TX_CE =&gt; TX_CE,                     -- 1-bit input: Clock enable for ODELAY
      TX_CLK =&gt; TX_CLK,                   -- 1-bit input: TX Clock used to sample LOAD, CE, INC
      TX_CNTVALUEIN =&gt; TX_CNTVALUEIN,     -- 9-bit input: TX Counter value from device logic
      TX_EN_VTC =&gt; TX_EN_VTC,             -- 1-bit input: TX Enable to keep stable delay over VT
      TX_INC =&gt; TX_INC,                   -- 1-bit input: TX Increment the current delay tap setting
      TX_LOAD =&gt; TX_LOAD,                 -- 1-bit input: TX Load the CNTVALUEIN tap setting
      TX_RST =&gt; TX_RST,                   -- 1-bit input: TX Asynchronous assert, synchronous deassert for
                                          -- RXTX_BITSLICE OSERDES

      TX_RST_DLY =&gt; TX_RST_DLY            -- 1-bit input: TX Reset the internal DELAY value to DELAY_VALUE
   );

   -- End of RXTX_BITSLICE_inst instantiation
					</Template>
					<Template label="TX_BITSLICE_TRI (TX_BITSLICE_TRI)" treetype="template">
-- TX_BITSLICE_TRI : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (TX_BITSLICE_TRI_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- TX_BITSLICE_TRI: TX_BITSLICE_TRI for tristate using Native Mode
   --                  Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_TRI_inst : TX_BITSLICE_TRI
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel data input width (4-8)
      DELAY_FORMAT =&gt; "TIME",     -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Output delay value setting
      INIT =&gt; '1',                -- Defines initial O value
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_DLY_INVERTED =&gt; '0', -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      OUTPUT_PHASE_90 =&gt; "FALSE", -- Delays the output phase by 90-degrees
      REFCLK_FREQUENCY =&gt; 300.0,  -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      BIT_CTRL_OUT =&gt; BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      CNTVALUEOUT =&gt; CNTVALUEOUT,   -- 9-bit output: Counter value to device logic
      TRI_OUT =&gt; TRI_OUT,           -- 1-bit output: Output to the TBYTE_IN pins of the bitslices
      BIT_CTRL_IN =&gt; BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      CE =&gt; CE,                     -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                   -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,     -- 9-bit input: Counter value input
      EN_VTC =&gt; EN_VTC,             -- 1-bit input: Enable to keep stable delay over VT
      INC =&gt; INC,                   -- 1-bit input: Increment the current delay tap setting
      LOAD =&gt; LOAD,                 -- 1-bit input: Load the CNTVALUEIN tap setting
      RST =&gt; RST,                   -- 1-bit input: Asynchronous assert, synchronous deassert
      RST_DLY =&gt; RST_DLY            -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
   );

   -- End of TX_BITSLICE_TRI_inst instantiation
					</Template>
					<Template label="TX_BITSLICE (TX_BITSLICE)" treetype="template">
-- TX_BITSLICE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (TX_BITSLICE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- TX_BITSLICE: TX_BITSLICE for output using Native Mode
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_inst : TX_BITSLICE
   generic map (
      DATA_WIDTH =&gt; 8,                -- Parallel data input width (4-8)
      DELAY_FORMAT =&gt; "TIME",         -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",          -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,               -- Output delay value setting
      ENABLE_PRE_EMPHASIS =&gt; "FALSE", -- Enable the pre-emphasis
      INIT =&gt; '1',                    -- Defines initial O value
      IS_CLK_INVERTED =&gt; '0',         -- Optional inversion for CLK
      IS_RST_DLY_INVERTED =&gt; '0',     -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',         -- Optional inversion for RST
      OUTPUT_PHASE_90 =&gt; "FALSE",     -- Delays the output phase by 90-degrees
      REFCLK_FREQUENCY =&gt; 300.0,      -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TBYTE_CTL =&gt; "TBYTE_IN",        -- Select between T and TBYTE_IN inputs
      UPDATE_MODE =&gt; "ASYNC"          -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT,         -- 9-bit output: Counter value to device logic
      O =&gt; O,                             -- 1-bit output: Serialized output going to output buffer
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      T_OUT =&gt; T_OUT,                     -- 1-bit output: Byte group 3-state output
      CE =&gt; CE,                           -- 1-bit input: Clock enable for ODELAY
      CLK =&gt; CLK,                         -- 1-bit input: Clock used to sample LOAD, CE, INC
      CNTVALUEIN =&gt; CNTVALUEIN,           -- 9-bit input: Counter value from device logic
      D =&gt; D,                             -- 8-bit input: Data from device logic
      EN_VTC =&gt; EN_VTC,                   -- 1-bit input: Enable to keep stable delay over VT
      INC =&gt; INC,                         -- 1-bit input: Increment the current delay tap setting
      LOAD =&gt; LOAD,                       -- 1-bit input: Load the CNTVALUEIN tap setting
      RST =&gt; RST,                         -- 1-bit input: Asynchronous assert, synchronous deassert for
                                          -- TX_BITSLICE OSERDES

      RST_DLY =&gt; RST_DLY,                 -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      T =&gt; T,                             -- 1-bit input: Legacy T byte input from device logic
      TBYTE_IN =&gt; TBYTE_IN,               -- 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN    -- 40-bit input: Input bus from BITSLICE_CONTROL
   );

   -- End of TX_BITSLICE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DCI_RESET" treetype="folder">
					<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
--  DCIRESET   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DCIRESET_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DCIRESET: Digitally Controlled Impedance Reset Component
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   DCIRESET_inst : DCIRESET
   port map (
      LOCKED =&gt; LOCKED, -- 1-bit output: LOCK status output
      RST =&gt; RST        -- 1-bit input: Active-High asynchronous reset input
   );

   -- End of DCIRESET_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DELAY" treetype="folder">
					<Template label="IDELAYE3/ODELAYE3 Tap Delay Value Control (IDELAYCTRL)" treetype="template">
-- IDELAYCTRL  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYCTRL: IDELAYE3/ODELAYE3 Tap Delay Value Control
   --             Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL_inst : IDELAYCTRL
   generic map (
      SIM_DEVICE =&gt; "7SERIES"  -- Set the device version (7SERIES, ULTRASCALE)
   )
   port map (
      RDY =&gt; RDY,       -- 1-bit output: Ready output
      REFCLK =&gt; REFCLK, -- 1-bit input: Reference clock input
      RST =&gt; RST        -- 1-bit input: Active high reset input. Asynchronous assert, synchronous deassert to
                        -- REFCLK.

   );

   -- End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE3)" treetype="template">
--  IDELAYE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYE3: Input Fixed or Variable Delay Element
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYE3_inst : IDELAYE3
   generic map (
      CASCADE =&gt; "NONE",          -- Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      DELAY_FORMAT =&gt; "TIME",     -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_SRC =&gt; "IDATAIN",     -- Delay input (DATAIN, IDATAIN)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Input delay value setting
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,  -- IDELAYCTRL clock input frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      CASC_OUT =&gt; CASC_OUT,       -- 1-bit output: Cascade delay output to ODELAY input cascade
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 9-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data output
      CASC_IN =&gt; CASC_IN,         -- 1-bit input: Cascade delay input from slave ODELAY CASCADE_OUT
      CASC_RETURN =&gt; CASC_RETURN, -- 1-bit input: Cascade delay returning from slave ODELAY DATAOUT
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                 -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 9-bit input: Counter value input
      DATAIN =&gt; DATAIN,           -- 1-bit input: Data input from the logic
      EN_VTC =&gt; EN_VTC,           -- 1-bit input: Keep delay constant over VT
      IDATAIN =&gt; IDATAIN,         -- 1-bit input: Data input from the IOBUF
      INC =&gt; INC,                 -- 1-bit input: Increment / Decrement tap delay input
      LOAD =&gt; LOAD,               -- 1-bit input: Load DELAY_VALUE input
      RST =&gt; RST                  -- 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   -- End of IDELAYE3_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE3)" treetype="template">
--  ODELAYE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODELAYE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODELAYE3: Output Fixed or Variable Delay Element
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   ODELAYE3_inst : ODELAYE3
   generic map (
      CASCADE =&gt; "NONE",          -- Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      DELAY_FORMAT =&gt; "TIME",     -- (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Output delay tap setting
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,  -- IDELAYCTRL clock input frequency in MHz (200.0-2667.0).
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      CASC_OUT =&gt; CASC_OUT,       -- 1-bit output: Cascade delay output to IDELAY input cascade
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 9-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data from ODATAIN input port
      CASC_IN =&gt; CASC_IN,         -- 1-bit input: Cascade delay input from slave IDELAY CASCADE_OUT
      CASC_RETURN =&gt; CASC_RETURN, -- 1-bit input: Cascade delay returning from slave IDELAY DATAOUT
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                 -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 9-bit input: Counter value input
      EN_VTC =&gt; EN_VTC,           -- 1-bit input: Keep delay constant over VT
      INC =&gt; INC,                 -- 1-bit input: Increment/Decrement tap delay input
      LOAD =&gt; LOAD,               -- 1-bit input: Load DELAY_VALUE input
      ODATAIN =&gt; ODATAIN,         -- 1-bit input: Data input
      RST =&gt; RST                  -- 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   -- End of ODELAYE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="INPUT_BUFFER" treetype="folder">
					<Template label="Analog Auxiliary SYSMON Input Buffer (IBUF_ANALOG)" treetype="template">
-- IBUF_ANALOG : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUF_ANALOG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_ANALOG: Analog Auxiliary SYSMON Input Buffer
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_ANALOG_inst : IBUF_ANALOG
   port map (
      O =&gt; O, -- 1-bit output: Connect to a VAUXP/VAUXN port of the SYSMONE1
      I =&gt; I  -- 1-bit input: Connect to a top-level design port
   );

   -- End of IBUF_ANALOG_inst instantiation
					</Template>
					<Template label="Differential Input Buffer (IBUFDS)" treetype="template">
--   IBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS: Differential Input Buffer
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_inst : IBUFDS
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer output
      I =&gt; I,   -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB  -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs and Input Buffer Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
-- IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
--            VHDL             : the following instance declaration needs to be placed
--          instance           : in the body of the design code.  The instance name
--         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations after the
--            code             : "=&gt;" declaration maybe changed to properly reference and
--                             : connect this function to the design.  All inputs and outputs
--                             : must be connected.

--           Library           : In addition to adding the instance declaration, a use
--         declaration         : statement for the UNISIM.vcomponents library needs to be
--             for             : added before the entity declaration.  This library
--           Xilinx            : contains the component declarations for all Xilinx
--         primitives          : primitives and points to the models that will be used
--                             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer With Complementary Outputs and Input Buffer Disable
   --                              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE_inst : IBUFDS_DIFF_OUT_IBUFDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                   -- 1-bit output: Buffer diff_n output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Must be tied to a logic '0'
   );

   -- End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs (IBUFDS_DIFF_OUT)" treetype="template">
-- IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT: Differential Input Buffer With Complementary Outputs
   --                  Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_inst : IBUFDS_DIFF_OUT
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer diff_p output
      OB =&gt; OB, -- 1-bit output: Buffer diff_n output
      I =&gt; I,   -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB  -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
-- IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
--             VHDL              : the following instance declaration needs to be placed
--           instance            : in the body of the design code.  The instance name
--          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations after the
--             code              : "=&gt;" declaration maybe changed to properly reference and
--                               : connect this function to the design.  All inputs and outputs
--                               : must be connected.

--            Library            : In addition to adding the instance declaration, a use
--          declaration          : statement for the UNISIM.vcomponents library needs to be
--              for              : added before the entity declaration.  This library
--            Xilinx             : contains the component declarations for all Xilinx
--          primitives           : primitives and points to the models that will be used
--                               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable
   --                                Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE_inst : IBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                       -- 1-bit output: Buffer diff_n output
      I =&gt; I,                         -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                       -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Must be tied to a logic '0'
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Buffer termination disable, high=disable
   );

   -- End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
-- IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--         VHDL         : the following instance declaration needs to be placed
--       instance       : in the body of the design code.  The instance name
--     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations after the
--         code         : "=&gt;" declaration maybe changed to properly reference and
--                      : connect this function to the design.  All inputs and outputs
--                      : must be connected.

--       Library        : In addition to adding the instance declaration, a use
--     declaration      : statement for the UNISIM.vcomponents library needs to be
--         for          : added before the entity declaration.  This library
--        Xilinx        : contains the component declarations for all Xilinx
--      primitives      : primitives and points to the models that will be used
--                      : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_INTERMDISABLE: Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE_inst : IBUFDS_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                       -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer input disable, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Buffer termination disable, high=disable
   );

   -- End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable (IBUFDS_IBUFDISABLE)" treetype="template">
-- IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--        VHDL        : the following instance declaration needs to be placed
--      instance      : in the body of the design code.  The instance name
--    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations after the
--        code        : "=&gt;" declaration maybe changed to properly reference and
--                    : connect this function to the design.  All inputs and outputs
--                    : must be connected.

--      Library       : In addition to adding the instance declaration, a use
--    declaration     : statement for the UNISIM.vcomponents library needs to be
--        for         : added before the entity declaration.  This library
--       Xilinx       : contains the component declarations for all Xilinx
--     primitives     : primitives and points to the models that will be used
--                    : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_IBUFDISABLE: Differential Input Buffer With Input Buffer Disable
   --                     Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE_inst : IBUFDS_IBUFDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Must be tied to a logic '0'
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with MIPI support (IBUFDS_DPHY)" treetype="template">
-- IBUFDS_DPHY : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_DPHY_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DPHY: Differential Input Buffer with MIPI support
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DPHY_inst : IBUFDS_DPHY
   generic map (
      DIFF_TERM =&gt; TRUE,       -- Differential termination
      IOSTANDARD =&gt; "DEFAULT"  -- I/O standard
   )
   port map (
      HSRX_O =&gt; HSRX_O,             -- 1-bit output: HS RX output
      LPRX_O_N =&gt; LPRX_O_N,         -- 1-bit output: LP RX output (Slave)
      LPRX_O_P =&gt; LPRX_O_P,         -- 1-bit output: LP RX output (Master)
      HSRX_DISABLE =&gt; HSRX_DISABLE, -- 1-bit input: Disable control for HS mode
      I =&gt; I,                       -- 1-bit input: Data input0 PAD
      IB =&gt; IB,                     -- 1-bit input: Data input1 PAD
      LPRX_DISABLE =&gt; LPRX_DISABLE  -- 1-bit input: Disable control for LP mode
   );

   -- End of IBUFDS_DPHY_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Offset Calibration (IBUFDSE3)" treetype="template">
--  IBUFDSE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDSE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDSE3: Differential Input Buffer with Offset Calibration
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDSE3_inst : IBUFDSE3
   generic map (
      DQS_BIAS =&gt; "FALSE",          -- (FALSE, TRUE)
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- 1-bit input: Buffer disable input, high=disable
      OSC =&gt; OSC,                 -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN            -- 2-bit input: Offset cancellation enable
   );

   -- End of IBUFDSE3_inst instantiation
					</Template>
					<Template label="Input Buffer (IBUF)" treetype="template">
--    IBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF: Input Buffer
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_inst : IBUF
   port map (
      O =&gt; O, -- 1-bit output: Buffer output
      I =&gt; I  -- 1-bit input: Buffer input
   );

   -- End of IBUF_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
-- IBUF_INTERMDISABLE : In order to incorporate this function into the design,
--        VHDL        : the following instance declaration needs to be placed
--      instance      : in the body of the design code.  The instance name
--    declaration     : (IBUF_INTERMDISABLE_inst) and/or the port declarations after the
--        code        : "=&gt;" declaration maybe changed to properly reference and
--                    : connect this function to the design.  All inputs and outputs
--                    : must be connected.

--      Library       : In addition to adding the instance declaration, a use
--    declaration     : statement for the UNISIM.vcomponents library needs to be
--        for         : added before the entity declaration.  This library
--       Xilinx       : contains the component declarations for all Xilinx
--     primitives     : primitives and points to the models that will be used
--                    : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_INTERMDISABLE: Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                     Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_INTERMDISABLE_inst : IBUF_INTERMDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Input Termination Disable
   );

   -- End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable (IBUF_IBUFDISABLE)" treetype="template">
-- IBUF_IBUFDISABLE : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_IBUFDISABLE: Input Buffer With Input Buffer Disable
   --                   Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_IBUFDISABLE_inst : IBUF_IBUFDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Buffer disable input, high=disable
   );

   -- End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer with Offset Calibration and VREF Tuning (IBUFE3)" treetype="template">
--   IBUFE3    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFE3: Input Buffer with Offset Calibration and VREF Tuning
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFE3_inst : IBUFE3
   generic map (
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- 1-bit input: Buffer disable input, high=disable
      OSC =&gt; OSC,                 -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,           -- 1-bit input: Offset cancellation enable
      VREF =&gt; VREF                -- 1-bit input: Vref input from HPIO_VREF
   );

   -- End of IBUFE3_inst instantiation
					</Template>
					<Template label="VREF Scan (HPIO_VREF)" treetype="template">
--  HPIO_VREF  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (HPIO_VREF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- HPIO_VREF: VREF Scan
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   HPIO_VREF_inst : HPIO_VREF
   generic map (
      VREF_CNTR =&gt; "OFF"  -- FABRIC_RANGE1, FABRIC_RANGE2, OFF
   )
   port map (
      VREF =&gt; VREF,                         -- 1-bit output: Tuned output (connect to associated IBUFE3
                                            -- component)

      FABRIC_VREF_TUNE =&gt; FABRIC_VREF_TUNE  -- 7-bit input: VREF tuning value
   );

   -- End of HPIO_VREF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="OUTPUT_BUFFER" treetype="folder">
					<Template label="3-State Output Buffer (OBUFT)" treetype="template">
--    OBUFT    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFT: 3-State Output Buffer
   --        Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFT_inst : OBUFT
   port map (
      O =&gt; O, -- 1-bit output: Buffer output (connect directly to top-level port)
      I =&gt; I, -- 1-bit input: Buffer input
      T =&gt; T  -- 1-bit input: 3-state enable input
   );

   -- End of OBUFT_inst instantiation
					</Template>
					<Template label="Differential Output Buffer (OBUFDS)" treetype="template">
--   OBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS: Differential Output Buffer
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_inst : OBUFDS
   port map (
      O =&gt; O,   -- 1-bit output: Diff_p output (connect directly to top-level port)
      OB =&gt; OB, -- 1-bit output: Diff_n output (connect directly to top-level port)
      I =&gt; I    -- 1-bit input: Buffer input
   );

   -- End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential Output Buffer with MIPI support (OBUFDS_DPHY)" treetype="template">
-- OBUFDS_DPHY : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_DPHY_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_DPHY: Differential Output Buffer with MIPI support
   --              Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_DPHY_inst : OBUFDS_DPHY
   generic map (
      IOSTANDARD =&gt; "DEFAULT"  -- I/O standard
   )
   port map (
      O =&gt; O,               -- 1-bit output: Diff_P Data output
      OB =&gt; OB,             -- 1-bit output: Diff_N Data output
      HSTX_I =&gt; HSTX_I,     -- 1-bit input: Data input (HS TX)
      HSTX_T =&gt; HSTX_T,     -- 1-bit input: Tristate Control input (HS TX)
      LPTX_I_N =&gt; LPTX_I_N, -- 1-bit input: Data input (LP TX) (Master-N)
      LPTX_I_P =&gt; LPTX_I_P, -- 1-bit input: Data input (LP TX) (Master-P)
      LPTX_T =&gt; LPTX_T      -- 1-bit input: Tristate Control input (LP TX)
   );

   -- End of OBUFDS_DPHY_inst instantiation
					</Template>
					<Template label="Differential 3-state Output Buffer (OBUFTDS)" treetype="template">
--   OBUFTDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFTDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFTDS: Differential 3-state Output Buffer
   --          Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFTDS_inst : OBUFTDS
   port map (
      O =&gt; O,   -- 1-bit output: Diff_p output (connect directly to top-level port)
      OB =&gt; OB, -- 1-bit output: Diff_n output (connect directly to top-level port)
      I =&gt; I,   -- 1-bit input: Buffer input
      T =&gt; T    -- 1-bit input: 3-state enable input
   );

   -- End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Output Buffer (OBUF)" treetype="template">
--    OBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUF: Output Buffer
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUF_inst : OBUF
   port map (
      O =&gt; O, -- 1-bit output: Buffer output (connect directly to top-level port)
      I =&gt; I  -- 1-bit input: Buffer input
   );

   -- End of OBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer (ISERDESE3)" treetype="template">
--  ISERDESE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ISERDESE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ISERDESE3: Input SERial/DESerializer
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   ISERDESE3_inst : ISERDESE3
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel data width (4,8)
      FIFO_ENABLE =&gt; "FALSE",     -- Enables the use of the FIFO
      FIFO_SYNC_MODE =&gt; "FALSE",  -- Enables the use of internal 2-stage synchronizers on the FIFO
      IS_CLK_B_INVERTED =&gt; '0',   -- Optional inversion for CLK_B
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      INTERNAL_DIVCLK =&gt; INTERNAL_DIVCLK, -- 1-bit output: Internally divided down clock used when FIFO is
                                          -- disabled (do not connect)

      Q =&gt; Q,                             -- 8-bit registered output
      CLK =&gt; CLK,                         -- 1-bit input: High-speed clock
      CLKDIV =&gt; CLKDIV,                   -- 1-bit input: Divided Clock
      CLK_B =&gt; CLK_B,                     -- 1-bit input: Inversion of High-speed clock CLK
      D =&gt; D,                             -- 1-bit input: Serial Data Input
      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: Enables reading the FIFO when asserted
      RST =&gt; RST                          -- 1-bit input: Asynchronous Reset
   );

   -- End of ISERDESE3_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer (OSERDESE3)" treetype="template">
--  OSERDESE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OSERDESE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OSERDESE3: Output SERial/DESerializer
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OSERDESE3_inst : OSERDESE3
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel Data Width (4-8)
      INIT =&gt; '0',                -- Initialization value of the OSERDES flip-flops
      IS_CLKDIV_INVERTED =&gt; '0',  -- Optional inversion for CLKDIV
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      OQ =&gt; OQ,         -- 1-bit output: Serial Output Data
      T_OUT =&gt; T_OUT,   -- 1-bit output: 3-state control output to IOB
      CLK =&gt; CLK,       -- 1-bit input: High-speed clock
      CLKDIV =&gt; CLKDIV, -- 1-bit input: Divided Clock
      D =&gt; D,           -- 8-bit input: Parallel Data Input
      RST =&gt; RST,       -- 1-bit input: Asynchronous Reset
      T =&gt; T            -- 1-bit input: Tristate input from fabric
   );

   -- End of OSERDESE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="WEAK_DRIVER" treetype="folder">
					<Template label="I/O Pulldown (PULLDOWN)" treetype="template">
--  PULLDOWN   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PULLDOWN_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLDOWN: I/O Pulldown
   --           Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PULLDOWN_inst : PULLDOWN
   port map (
      O =&gt; O  -- 1-bit output: Pulldown output (connect directly to top-level port)
   );

   -- End of PULLDOWN_inst instantiation
					</Template>
					<Template label="I/O Pullup (PULLUP)" treetype="template">
--   PULLUP    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PULLUP_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLUP: I/O Pullup
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PULLUP_inst : PULLUP
   port map (
      O =&gt; O  -- 1-bit output: Pullup output (connect directly to top-level port)
   );

   -- End of PULLUP_inst instantiation
					</Template>
					<Template label="I/O Weak Keeper (KEEPER)" treetype="template">
--   KEEPER    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (KEEPER_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- KEEPER: I/O Weak Keeper
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   KEEPER_inst : KEEPER
   port map (
      O =&gt; O  -- 1-bit inout: Keeper output (connect directly to top-level port)
   );

   -- End of KEEPER_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="REGISTER" treetype="folder">
				<SubFolder label="DDR" treetype="folder">
					<Template label="Input DDR (IDDRE1)" treetype="template">
--   IDDRE1    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDDRE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDRE1: Dedicated Dual Data Rate (DDR) Input Register
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IDDRE1_inst : IDDRE1
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- IDDRE1 mode (OPPOSITE_EDGE, SAME_EDGE, SAME_EDGE_PIPELINED)
      IS_CB_INVERTED =&gt; '0',           -- Optional inversion for CB
      IS_C_INVERTED =&gt; '0'             -- Optional inversion for C
   )
   port map (
      Q1 =&gt; Q1, -- 1-bit output: Registered parallel output 1
      Q2 =&gt; Q2, -- 1-bit output: Registered parallel output 2
      C =&gt; C,   -- 1-bit input: High-speed clock
      CB =&gt; CB, -- 1-bit input: Inversion of High-speed clock C
      D =&gt; D,   -- 1-bit input: Serial Data Input
      R =&gt; R    -- 1-bit input: Active High Async Reset
   );

   -- End of IDDRE1_inst instantiation
					</Template>
					<Template label="Output DDR (ODDRE1)" treetype="template">
--   ODDRE1    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODDRE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDRE1: Dedicated Dual Data Rate (DDR) Output Register
   --         Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   ODDRE1_inst : ODDRE1
   generic map (
      IS_C_INVERTED =&gt; '0',  -- Optional inversion for C
      IS_D1_INVERTED =&gt; '0', -- Optional inversion for D1
      IS_D2_INVERTED =&gt; '0', -- Optional inversion for D2
      SRVAL =&gt; '0'           -- Initializes the ODDRE1 Flip-Flops to the specified value ('0', '1')
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data output to IOB
      C =&gt; C,   -- 1-bit input: High-speed clock input
      D1 =&gt; D1, -- 1-bit input: Parallel data input 1
      D2 =&gt; D2, -- 1-bit input: Parallel data input 2
      SR =&gt; SR  -- 1-bit input: Active High Async Reset
   );

   -- End of ODDRE1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Transparent Latch with Clock Enable and Asynchronous Clear (LDCE)" treetype="template">
--    LDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LDCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDCE: Transparent Latch with Clock Enable and Asynchronous Clear
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LDCE_inst : LDCE
   generic map (
      INIT =&gt; '0',            -- Initial value of latch, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_G_INVERTED =&gt; '0'    -- Optional inversion for G
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      D =&gt; D,     -- 1-bit input: Data
      G =&gt; G,     -- 1-bit input: Gate
      GE =&gt; GE    -- 1-bit input: Gate enable
   );

   -- End of LDCE_inst instantiation
					</Template>
					<Template label="Transparent Latch with Clock Enable and Asynchronous Preset (LDPE)" treetype="template">
--    LDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LDPE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDPE: Transparent Latch with Clock Enable and Asynchronous Preset
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LDPE_inst : LDPE
   generic map (
      INIT =&gt; '1',            -- Initial value of latch, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_G_INVERTED =&gt; '0',   -- Optional inversion for G
      IS_PRE_INVERTED =&gt; '0'  -- Optional inversion for PRE
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      D =&gt; D,     -- 1-bit input: Data
      G =&gt; G,     -- 1-bit input: Gate
      GE =&gt; GE,   -- 1-bit input: Gate enable
      PRE =&gt; PRE  -- 1-bit input: Asynchronous preset
   );

   -- End of LDPE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="METASTABILITY" treetype="folder">
					<Template label="Metastability Hardened Registers (HARD_SYNC)" treetype="template">
--  HARD_SYNC  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (HARD_SYNC_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- HARD_SYNC: Metastability Hardened Registers
   --            Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   HARD_SYNC_inst : HARD_SYNC
   generic map (
      INIT =&gt; '0',            -- Initial values, '0', '1'
      IS_CLK_INVERTED =&gt; '0', -- Programmable inversion on CLK input
      LATENCY =&gt; 2            -- 2-3
   )
   port map (
      DOUT =&gt; DOUT, -- 1-bit output: Data
      CLK =&gt; CLK,   -- 1-bit input: Clock
      DIN =&gt; DIN    -- 1-bit input: Data
   );

   -- End of HARD_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SDR" treetype="folder">
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Clear (FDCE)" treetype="template">
--    FDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDCE: D Flip-Flop with Clock Enable and Asynchronous Clear
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FDCE_inst : FDCE
   generic map (
      INIT =&gt; '0',            -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_C_INVERTED =&gt; '0',   -- Optional inversion for C
      IS_D_INVERTED =&gt; '0'    -- Optional inversion for D
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      C =&gt; C,     -- 1-bit input: Clock
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      D =&gt; D      -- 1-bit input: Data
   );

   -- End of FDCE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Preset (FDPE)" treetype="template">
--    FDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDPE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDPE: D Flip-Flop with Clock Enable and Asynchronous Preset
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FDPE_inst : FDPE
   generic map (
      INIT =&gt; '1',            -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0',   -- Optional inversion for C
      IS_D_INVERTED =&gt; '0',   -- Optional inversion for D
      IS_PRE_INVERTED =&gt; '0'  -- Optional inversion for PRE
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      C =&gt; C,     -- 1-bit input: Clock
      CE =&gt; CE,   -- 1-bit input: Clock enable
      D =&gt; D,     -- 1-bit input: Data
      PRE =&gt; PRE  -- 1-bit input: Asynchronous preset
   );

   -- End of FDPE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Reset (FDRE)" treetype="template">
--    FDRE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDRE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDRE: D Flip-Flop with Clock Enable and Synchronous Reset
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FDRE_inst : FDRE
   generic map (
      INIT =&gt; '0',          -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0', -- Optional inversion for C
      IS_D_INVERTED =&gt; '0', -- Optional inversion for D
      IS_R_INVERTED =&gt; '0'  -- Optional inversion for R
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data
      C =&gt; C,   -- 1-bit input: Clock
      CE =&gt; CE, -- 1-bit input: Clock enable
      D =&gt; D,   -- 1-bit input: Data
      R =&gt; R    -- 1-bit input: Synchronous reset
   );

   -- End of FDRE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Set (FDSE)" treetype="template">
--    FDSE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDSE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDSE: D Flip-Flop with Clock Enable and Synchronous Set
   --       Kintex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FDSE_inst : FDSE
   generic map (
      INIT =&gt; '1',          -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0', -- Optional inversion for C
      IS_D_INVERTED =&gt; '0', -- Optional inversion for D
      IS_S_INVERTED =&gt; '0'  -- Optional inversion for S
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data
      C =&gt; C,   -- 1-bit input: Clock
      CE =&gt; CE, -- 1-bit input: Clock enable
      D =&gt; D,   -- 1-bit input: Data
      S =&gt; S    -- 1-bit input: Synchronous set
   );

   -- End of FDSE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Kintex-7" treetype="folder">
			<SubFolder label="Advanced" treetype="folder">
				<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE2)" treetype="template">
-- IBUFDS_GTE2 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_GTE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_GTE2: Gigabit Transceiver Buffer
   --              Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE2_inst : IBUFDS_GTE2
   generic map (
      CLKCM_CFG =&gt; TRUE,    -- Refer to Transceiver User Guide
      CLKRCV_TRST =&gt; TRUE,  -- Refer to Transceiver User Guide
      CLKSWING_CFG =&gt; '11'  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,         -- 1-bit output: Refer to Transceiver User Guide
      ODIV2 =&gt; ODIV2, -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,     -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,         -- 1-bit input: Refer to Transceiver User Guide
      IB =&gt; IB        -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of IBUFDS_GTE2_inst instantiation
				</Template>
				<Template label="XADC Simulation File" treetype="template">
-- Must use valid headers on all columns
-- Comments can be added to the stimulus file using '--'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

-- Time stamp data is in nano seconds (ns)
-- Temperature is recorded in C (degrees centigrade)
-- All other channels are recorded as V (Volts)
-- Valid column headers are:
-- TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
-- VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
-- External analog inputs are differential so VP = 0.5 and VN = 0.1 the
-- input on channel VP/VN in 0.5 - 0.1 = 0.4V

				</Template>
				<Template label="Xilinx Analog-to-Digital Converter (XADC)" treetype="template">
--    XADC     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (XADC_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- XADC: Dual 12-Bit 1MSPS Analog-to-Digital Converter
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   XADC_inst : XADC
   generic map (
      -- INIT_40 - INIT_42: XADC configuration registers
      INIT_40 =&gt; X"0000",
      INIT_41 =&gt; X"0000",
      INIT_42 =&gt; X"0800",
      -- INIT_48 - INIT_4F: Sequence Registers
      INIT_48 =&gt; X"0000",
      INIT_49 =&gt; X"0000",
      INIT_4A =&gt; X"0000",
      INIT_4B =&gt; X"0000",
      INIT_4C =&gt; X"0000",
      INIT_4D =&gt; X"0000",
      INIT_4F =&gt; X"0000",
      INIT_4E =&gt; X"0000",                 -- Sequence register 6
      -- INIT_50 - INIT_58, INIT5C: Alarm Limit Registers
      INIT_50 =&gt; X"0000",
      INIT_51 =&gt; X"0000",
      INIT_52 =&gt; X"0000",
      INIT_53 =&gt; X"0000",
      INIT_54 =&gt; X"0000",
      INIT_55 =&gt; X"0000",
      INIT_56 =&gt; X"0000",
      INIT_57 =&gt; X"0000",
      INIT_58 =&gt; X"0000",
      INIT_5C =&gt; X"0000",
      -- Simulation attributes: Set for proper simulation behavior
      SIM_DEVICE =&gt; "7SERIES",            -- Select target device (values)
      SIM_MONITOR_FILE =&gt; "design.txt"  -- Analog simulation data file name
   )
   port map (
      -- ALARMS: 8-bit (each) output: ALM, OT
      ALM =&gt; ALM,                   -- 8-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      OT =&gt; OT,                     -- 1-bit output: Over-Temperature alarm
      -- Dynamic Reconfiguration Port (DRP): 16-bit (each) output: Dynamic Reconfiguration Ports
      DO =&gt; DO,                     -- 16-bit output: DRP output data bus
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP data ready
      -- STATUS: 1-bit (each) output: XADC status ports
      BUSY =&gt; BUSY,                 -- 1-bit output: ADC busy output
      CHANNEL =&gt; CHANNEL,           -- 5-bit output: Channel selection outputs
      EOC =&gt; EOC,                   -- 1-bit output: End of Conversion
      EOS =&gt; EOS,                   -- 1-bit output: End of Sequence
      JTAGBUSY =&gt; JTAGBUSY,         -- 1-bit output: JTAG DRP transaction in progress output
      JTAGLOCKED =&gt; JTAGLOCKED,     -- 1-bit output: JTAG requested DRP port lock
      JTAGMODIFIED =&gt; JTAGMODIFIED, -- 1-bit output: JTAG Write to the DRP has occurred
      MUXADDR =&gt; MUXADDR,           -- 5-bit output: External MUX channel decode
      -- Auxiliary Analog-Input Pairs: 16-bit (each) input: VAUXP[15:0], VAUXN[15:0]
      VAUXN =&gt; VAUXN,               -- 16-bit input: N-side auxiliary analog input
      VAUXP =&gt; VAUXP,               -- 16-bit input: P-side auxiliary analog input
      -- CONTROL and CLOCK: 1-bit (each) input: Reset, conversion start and clock inputs
      CONVST =&gt; CONVST,             -- 1-bit input: Convert start input
      CONVSTCLK =&gt; CONVSTCLK,       -- 1-bit input: Convert start input
      RESET =&gt; RESET,               -- 1-bit input: Active-high reset
      -- Dedicated Analog Input Pair: 1-bit (each) input: VP/VN
      VN =&gt; VN,                     -- 1-bit input: N-side analog input
      VP =&gt; VP,                     -- 1-bit input: P-side analog input
      -- Dynamic Reconfiguration Port (DRP): 7-bit (each) input: Dynamic Reconfiguration Ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address bus
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable signal
      DI =&gt; DI,                     -- 16-bit input: DRP input data bus
      DWE =&gt; DWE                    -- 1-bit input: DRP write enable
   );

   -- End of XADC_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Arithmetic Functions" treetype="folder">
				<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E1)" treetype="template">
--   DSP48E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DSP48E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DSP48E1: 48-bit Multi-Functional Arithmetic Block
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   DSP48E1_inst : DSP48E1
   generic map (
      -- Feature Control Attributes: Data Path Selection
      A_INPUT =&gt; "DIRECT",               -- Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      B_INPUT =&gt; "DIRECT",               -- Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      USE_DPORT =&gt; FALSE,                -- Select D port usage (TRUE or FALSE)
      USE_MULT =&gt; "MULTIPLY",            -- Select multiplier usage ("MULTIPLY", "DYNAMIC", or "NONE")
      USE_SIMD =&gt; "ONE48",               -- SIMD selection ("ONE48", "TWO24", "FOUR12")
      -- Pattern Detector Attributes: Pattern Detection Configuration
      AUTORESET_PATDET =&gt; "NO_RESET",    -- "NO_RESET", "RESET_MATCH", "RESET_NOT_MATCH" 
      MASK =&gt; X"3fffffffffff",           -- 48-bit mask value for pattern detect (1=ignore)
      PATTERN =&gt; X"000000000000",        -- 48-bit pattern match for pattern detect
      SEL_MASK =&gt; "MASK",                -- "C", "MASK", "ROUNDING_MODE1", "ROUNDING_MODE2" 
      SEL_PATTERN =&gt; "PATTERN",          -- Select pattern value ("PATTERN" or "C")
      USE_PATTERN_DETECT =&gt; "NO_PATDET", -- Enable pattern detect ("PATDET" or "NO_PATDET")
      -- Register Control Attributes: Pipeline Register Configuration
      ACASCREG =&gt; 1,                     -- Number of pipeline stages between A/ACIN and ACOUT (0, 1 or 2)
      ADREG =&gt; 1,                        -- Number of pipeline stages for pre-adder (0 or 1)
      ALUMODEREG =&gt; 1,                   -- Number of pipeline stages for ALUMODE (0 or 1)
      AREG =&gt; 1,                         -- Number of pipeline stages for A (0, 1 or 2)
      BCASCREG =&gt; 1,                     -- Number of pipeline stages between B/BCIN and BCOUT (0, 1 or 2)
      BREG =&gt; 1,                         -- Number of pipeline stages for B (0, 1 or 2)
      CARRYINREG =&gt; 1,                   -- Number of pipeline stages for CARRYIN (0 or 1)
      CARRYINSELREG =&gt; 1,                -- Number of pipeline stages for CARRYINSEL (0 or 1)
      CREG =&gt; 1,                         -- Number of pipeline stages for C (0 or 1)
      DREG =&gt; 1,                         -- Number of pipeline stages for D (0 or 1)
      INMODEREG =&gt; 1,                    -- Number of pipeline stages for INMODE (0 or 1)
      MREG =&gt; 1,                         -- Number of multiplier pipeline stages (0 or 1)
      OPMODEREG =&gt; 1,                    -- Number of pipeline stages for OPMODE (0 or 1)
      PREG =&gt; 1                          -- Number of pipeline stages for P (0 or 1)
   )
   port map (
      -- Cascade: 30-bit (each) output: Cascade Ports
      ACOUT =&gt; ACOUT,                   -- 30-bit output: A port cascade output
      BCOUT =&gt; BCOUT,                   -- 18-bit output: B port cascade output
      CARRYCASCOUT =&gt; CARRYCASCOUT,     -- 1-bit output: Cascade carry output
      MULTSIGNOUT =&gt; MULTSIGNOUT,       -- 1-bit output: Multiplier sign cascade output
      PCOUT =&gt; PCOUT,                   -- 48-bit output: Cascade output
      -- Control: 1-bit (each) output: Control Inputs/Status Bits
      OVERFLOW =&gt; OVERFLOW,             -- 1-bit output: Overflow in add/acc output
      PATTERNBDETECT =&gt; PATTERNBDETECT, -- 1-bit output: Pattern bar detect output
      PATTERNDETECT =&gt; PATTERNDETECT,   -- 1-bit output: Pattern detect output
      UNDERFLOW =&gt; UNDERFLOW,           -- 1-bit output: Underflow in add/acc output
      -- Data: 4-bit (each) output: Data Ports
      CARRYOUT =&gt; CARRYOUT,             -- 4-bit output: Carry output
      P =&gt; P,                           -- 48-bit output: Primary data output
      -- Cascade: 30-bit (each) input: Cascade Ports
      ACIN =&gt; ACIN,                     -- 30-bit input: A cascade data input
      BCIN =&gt; BCIN,                     -- 18-bit input: B cascade input
      CARRYCASCIN =&gt; CARRYCASCIN,       -- 1-bit input: Cascade carry input
      MULTSIGNIN =&gt; MULTSIGNIN,         -- 1-bit input: Multiplier sign input
      PCIN =&gt; PCIN,                     -- 48-bit input: P cascade input
      -- Control: 4-bit (each) input: Control Inputs/Status Bits
      ALUMODE =&gt; ALUMODE,               -- 4-bit input: ALU control input
      CARRYINSEL =&gt; CARRYINSEL,         -- 3-bit input: Carry select input
      CLK =&gt; CLK,                       -- 1-bit input: Clock input
      INMODE =&gt; INMODE,                 -- 5-bit input: INMODE control input
      OPMODE =&gt; OPMODE,                 -- 7-bit input: Operation mode input
      -- Data: 30-bit (each) input: Data Ports
      A =&gt; A,                           -- 30-bit input: A data input
      B =&gt; B,                           -- 18-bit input: B data input
      C =&gt; C,                           -- 48-bit input: C data input
      CARRYIN =&gt; CARRYIN,               -- 1-bit input: Carry input signal
      D =&gt; D,                           -- 25-bit input: D data input
      -- Reset/Clock Enable: 1-bit (each) input: Reset/Clock Enable Inputs
      CEA1 =&gt; CEA1,                     -- 1-bit input: Clock enable input for 1st stage AREG
      CEA2 =&gt; CEA2,                     -- 1-bit input: Clock enable input for 2nd stage AREG
      CEAD =&gt; CEAD,                     -- 1-bit input: Clock enable input for ADREG
      CEALUMODE =&gt; CEALUMODE,           -- 1-bit input: Clock enable input for ALUMODE
      CEB1 =&gt; CEB1,                     -- 1-bit input: Clock enable input for 1st stage BREG
      CEB2 =&gt; CEB2,                     -- 1-bit input: Clock enable input for 2nd stage BREG
      CEC =&gt; CEC,                       -- 1-bit input: Clock enable input for CREG
      CECARRYIN =&gt; CECARRYIN,           -- 1-bit input: Clock enable input for CARRYINREG
      CECTRL =&gt; CECTRL,                 -- 1-bit input: Clock enable input for OPMODEREG and CARRYINSELREG
      CED =&gt; CED,                       -- 1-bit input: Clock enable input for DREG
      CEINMODE =&gt; CEINMODE,             -- 1-bit input: Clock enable input for INMODEREG
      CEM =&gt; CEM,                       -- 1-bit input: Clock enable input for MREG
      CEP =&gt; CEP,                       -- 1-bit input: Clock enable input for PREG
      RSTA =&gt; RSTA,                     -- 1-bit input: Reset input for AREG
      RSTALLCARRYIN =&gt; RSTALLCARRYIN,   -- 1-bit input: Reset input for CARRYINREG
      RSTALUMODE =&gt; RSTALUMODE,         -- 1-bit input: Reset input for ALUMODEREG
      RSTB =&gt; RSTB,                     -- 1-bit input: Reset input for BREG
      RSTC =&gt; RSTC,                     -- 1-bit input: Reset input for CREG
      RSTCTRL =&gt; RSTCTRL,               -- 1-bit input: Reset input for OPMODEREG and CARRYINSELREG
      RSTD =&gt; RSTD,                     -- 1-bit input: Reset input for DREG and ADREG
      RSTINMODE =&gt; RSTINMODE,           -- 1-bit input: Reset input for INMODEREG
      RSTM =&gt; RSTM,                     -- 1-bit input: Reset input for MREG
      RSTP =&gt; RSTP                      -- 1-bit input: Reset input for PREG
   );

   -- End of DSP48E1_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Clock Components" treetype="folder">
				<SubFolder label="Clock Buffers" treetype="folder">
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
--  BUFGCE_1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_1: Global Clock Buffer with Clock Enable and Output State 1
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_1_inst : BUFGCE_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock enable input for I0
      I =&gt; I    -- 1-bit input: Primary clock
   );

   -- End of BUFGCE_1_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
--   BUFGCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE: Global Clock Buffer with Clock Enable
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_inst : BUFGCE
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock enable input for I0
      I =&gt; I    -- 1-bit input: Primary clock
   );

   -- End of BUFGCE_inst instantiation
					</Template>
					<Template label="Global Clock Simple Buffer (BUFG)" treetype="template">
--    BUFG     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG: Global Clock Simple Buffer
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_inst : BUFG
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFG_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer (BUFH)" treetype="template">
--    BUFH     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFH_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFH: HROW Clock Buffer for a Single Clocking Region
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFH_inst : BUFH
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFH_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer with Clock Enable (BUFHCE)" treetype="template">
--   BUFHCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFHCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFHCE: HROW Clock Buffer for a Single Clocking Region with Clock Enable
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFHCE_inst : BUFHCE
   generic map (
      CE_TYPE =&gt; "SYNC", -- "SYNC" (glitchless switching) or "ASYNC" (immediate switch)
      INIT_OUT =&gt; 0      -- Initial output value (0-1)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Active high enable
      I =&gt; I    -- 1-bit input: Clock input
   );

   -- End of BUFHCE_inst instantiation
					</Template>
					<Template label="I/O Clock Buffer (BUFIO)" treetype="template">
--    BUFIO    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFIO_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFIO: Local Clock Buffer for I/O
   --        Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFIO_inst : BUFIO
   port map (
      O =&gt; O, -- 1-bit output: Clock output (connect to I/O clock loads).
      I =&gt; I  -- 1-bit input: Clock input (connect to an IBUF or BUFMR).
   );

   -- End of BUFIO_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer (BUFMR)" treetype="template">
--    BUFMR    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFMR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFMR: Multi-Region Clock Buffer
   --        Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFMR_inst : BUFMR
   port map (
      O =&gt; O, -- 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      I =&gt; I  -- 1-bit input: Clock input (Connect to IBUF)
   );

   -- End of BUFMR_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer with Clock Enable (BUFMRCE)" treetype="template">
--   BUFMRCE   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFMRCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFMRCE: Multi-Region Clock Buffer with Clock Enable
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFMRCE_inst : BUFMRCE
   generic map (
      CE_TYPE =&gt; "SYNC", -- SYNC, ASYNC
      INIT_OUT =&gt; 0      -- Initial output and stopped polarity, (0-1)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      CE =&gt; CE, -- 1-bit input: Active high buffer enable
      I =&gt; I    -- 1-bit input: Clock input (Connect to IBUF)
   );

   -- End of BUFMRCE_inst instantiation
					</Template>
					<Template label="Regional Clock Buffer (BUFR)" treetype="template">
--    BUFR     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFR: Regional Clock Buffer for I/O and Logic Resources within a Clock Region
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFR_inst : BUFR
   generic map (
      BUFR_DIVIDE =&gt; "BYPASS",   -- Values: "BYPASS, 1, 2, 3, 4, 5, 6, 7, 8" 
      SIM_DEVICE =&gt; "7SERIES"  -- Must be set to "7SERIES" 
   )
   port map (
      O =&gt; O,     -- 1-bit output: Clock output port
      CE =&gt; CE,   -- 1-bit input: Active high, clock enable (Divided modes only)
      CLR =&gt; CLR, -- 1-bit input: Active high, asynchronous clear (Divided modes only)
      I =&gt; I      -- 1-bit input: Clock buffer input driven by an IBUF, MMCM or local interconnect
   );

   -- End of BUFR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Clock MUXes" treetype="folder">
					<Template label="2-to-1 Global Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
-- BUFGMUX_CTRL : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_CTRL: 2-to-1 Global Clock MUX Buffer
   --               Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL_inst : BUFGMUX_CTRL
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="Global Clock Control Buffer (BUFGCTRL)" treetype="template">
--  BUFGCTRL   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCTRL: Global Clock Control Buffer
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCTRL_inst : BUFGCTRL
   generic map (
      INIT_OUT =&gt; 0,         -- Initial value of BUFGCTRL output ($VALUES;)
      PRESELECT_I0 =&gt; FALSE, -- BUFGCTRL output uses I0 input ($VALUES;)
      PRESELECT_I1 =&gt; FALSE  -- BUFGCTRL output uses I1 input ($VALUES;)
   )
   port map (
      O =&gt; O,             -- 1-bit output: Clock output
      CE0 =&gt; CE0,         -- 1-bit input: Clock enable input for I0
      CE1 =&gt; CE1,         -- 1-bit input: Clock enable input for I1
      I0 =&gt; I0,           -- 1-bit input: Primary clock
      I1 =&gt; I1,           -- 1-bit input: Secondary clock
      IGNORE0 =&gt; IGNORE0, -- 1-bit input: Clock ignore input for I0
      IGNORE1 =&gt; IGNORE1, -- 1-bit input: Clock ignore input for I1
      S0 =&gt; S0,           -- 1-bit input: Clock select for I0
      S1 =&gt; S1            -- 1-bit input: Clock select for I1
   );

   -- End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer (BUFGMUX)" treetype="template">
--   BUFGMUX   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX: Global Clock Mux Buffer
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_inst : BUFGMUX
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
--  BUFGMUX_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_1: Global Clock Mux Buffer with Output State 1
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1_inst : BUFGMUX_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MMCM / PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCME2_ADV)" treetype="template">
-- MMCME2_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME2_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME2_ADV: Advanced Mixed Mode Clock Manager
   --             Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   MMCME2_ADV_inst : MMCME2_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",      -- Jitter programming (OPTIMIZED, HIGH, LOW)
      CLKFBOUT_MULT_F =&gt; 5.0,        -- Multiply value for all CLKOUT (2.000-64.000).
      CLKFBOUT_PHASE =&gt; 0.0,         -- Phase offset in degrees of CLKFB (-360.000-360.000).
      -- CLKIN_PERIOD: Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      -- CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT0_DIVIDE_F =&gt; 1.0,       -- Divide amount for CLKOUT0 (1.000-128.000).
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.01-0.99).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      CLKOUT4_CASCADE =&gt; FALSE,      -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      COMPENSATION =&gt; "ZHOLD",       -- ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,            -- Master division value (1-106)
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; FALSE,         -- Delays DONE until MMCM is locked (FALSE, TRUE)
      -- Spread Spectrum: Spread Spectrum Attributes
      SS_EN =&gt; "FALSE",              -- Enables spread spectrum (FALSE, TRUE)
      SS_MODE =&gt; "CENTER_HIGH",      -- CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      SS_MOD_PERIOD =&gt; 10000,        -- Spread spectrum modulation period (ns) (VALUES)
      -- USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      CLKFBOUT_USE_FINE_PS =&gt; FALSE,
      CLKOUT0_USE_FINE_PS =&gt; FALSE,
      CLKOUT1_USE_FINE_PS =&gt; FALSE,
      CLKOUT2_USE_FINE_PS =&gt; FALSE,
      CLKOUT3_USE_FINE_PS =&gt; FALSE,
      CLKOUT4_USE_FINE_PS =&gt; FALSE,
      CLKOUT5_USE_FINE_PS =&gt; FALSE,
      CLKOUT6_USE_FINE_PS =&gt; FALSE 
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,           -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,         -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,           -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,         -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,           -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,         -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,           -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,         -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,           -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,           -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,           -- 1-bit output: CLKOUT6
      -- DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      DO =&gt; DO,                     -- 16-bit output: DRP data
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP ready
      -- Dynamic Phase Shift Ports: 1-bit (each) output: Ports used for dynamic phase shifting of the outputs
      PSDONE =&gt; PSDONE,             -- 1-bit output: Phase shift done
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,         -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB,       -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports: 1-bit (each) output: MMCM status ports
      CLKFBSTOPPED =&gt; CLKFBSTOPPED, -- 1-bit output: Feedback clock stopped
      CLKINSTOPPED =&gt; CLKINSTOPPED, -- 1-bit output: Input clock stopped
      LOCKED =&gt; LOCKED,             -- 1-bit output: LOCK
      -- Clock Inputs: 1-bit (each) input: Clock inputs
      CLKIN1 =&gt; CLKIN1,             -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,             -- 1-bit input: Secondary clock
      -- Control Ports: 1-bit (each) input: MMCM control ports
      CLKINSEL =&gt; CLKINSEL,         -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,             -- 1-bit input: Power-down
      RST =&gt; RST,                   -- 1-bit input: Reset
      -- DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable
      DI =&gt; DI,                     -- 16-bit input: DRP data
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- Dynamic Phase Shift Ports: 1-bit (each) input: Ports used for dynamic phase shifting of the outputs
      PSCLK =&gt; PSCLK,               -- 1-bit input: Phase shift clock
      PSEN =&gt; PSEN,                 -- 1-bit input: Phase shift enable
      PSINCDEC =&gt; PSINCDEC,         -- 1-bit input: Phase shift increment/decrement
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN            -- 1-bit input: Feedback clock
   );

   -- End of MMCME2_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase Locked Loop (PLLE2_ADV)" treetype="template">
--  PLLE2_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE2_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE2_ADV: Advanced Phase Locked Loop (PLL)
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   PLLE2_ADV_inst : PLLE2_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",  -- OPTIMIZED, HIGH, LOW
      CLKFBOUT_MULT =&gt; 5,        -- Multiply value for all CLKOUT, (2-64)
      CLKFBOUT_PHASE =&gt; 0.0,     -- Phase offset in degrees of CLKFB, (-360.000-360.000).
      -- CLKIN_PERIOD: Input clock period in nS to ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      -- CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT0_DIVIDE =&gt; 1,
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      -- CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      COMPENSATION =&gt; "ZHOLD",   -- ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,        -- Master division value (1-56)
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; "FALSE"    -- Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,   -- 1-bit output: CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,   -- 1-bit output: CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,   -- 1-bit output: CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,   -- 1-bit output: CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,   -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,   -- 1-bit output: CLKOUT5
      -- DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      DO =&gt; DO,             -- 16-bit output: DRP data
      DRDY =&gt; DRDY,         -- 1-bit output: DRP ready
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT, -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,     -- 1-bit output: LOCK
      -- Clock Inputs: 1-bit (each) input: Clock inputs
      CLKIN1 =&gt; CLKIN1,     -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,     -- 1-bit input: Secondary clock
      -- Control Ports: 1-bit (each) input: PLL control ports
      CLKINSEL =&gt; CLKINSEL, -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,     -- 1-bit input: Power-down
      RST =&gt; RST,           -- 1-bit input: Reset
      -- DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,       -- 7-bit input: DRP address
      DCLK =&gt; DCLK,         -- 1-bit input: DRP clock
      DEN =&gt; DEN,           -- 1-bit input: DRP enable
      DI =&gt; DI,             -- 16-bit input: DRP data
      DWE =&gt; DWE,           -- 1-bit input: DRP write enable
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN    -- 1-bit input: Feedback clock
   );

   -- End of PLLE2_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCME2_BASE)" treetype="template">
-- MMCME2_BASE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME2_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME2_BASE: Base Mixed Mode Clock Manager
   --              Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   MMCME2_BASE_inst : MMCME2_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",  -- Jitter programming (OPTIMIZED, HIGH, LOW)
      CLKFBOUT_MULT_F =&gt; 5.0,    -- Multiply value for all CLKOUT (2.000-64.000).
      CLKFBOUT_PHASE =&gt; 0.0,     -- Phase offset in degrees of CLKFB (-360.000-360.000).
      CLKIN1_PERIOD =&gt; 0.0,      -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT0_DIVIDE_F =&gt; 1.0,   -- Divide amount for CLKOUT0 (1.000-128.000).
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.01-0.99).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      CLKOUT4_CASCADE =&gt; FALSE,  -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      DIVCLK_DIVIDE =&gt; 1,        -- Master division value (1-106)
      REF_JITTER1 =&gt; 0.0,        -- Reference input jitter in UI (0.000-0.999).
      STARTUP_WAIT =&gt; FALSE      -- Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,     -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,   -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,     -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,   -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,     -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,   -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,     -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,   -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,     -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,     -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,     -- 1-bit output: CLKOUT6
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,   -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB, -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports: 1-bit (each) output: MMCM status ports
      LOCKED =&gt; LOCKED,       -- 1-bit output: LOCK
      -- Clock Inputs: 1-bit (each) input: Clock input
      CLKIN1 =&gt; CLKIN1,       -- 1-bit input: Clock
      -- Control Ports: 1-bit (each) input: MMCM control ports
      PWRDWN =&gt; PWRDWN,       -- 1-bit input: Power-down
      RST =&gt; RST,             -- 1-bit input: Reset
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN      -- 1-bit input: Feedback clock
   );

   -- End of MMCME2_BASE_inst instantiation
					</Template>
					<Template label="Base Phase Locked Loop (PLLE2_BASE)" treetype="template">
-- PLLE2_BASE  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE2_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE2_BASE: Base Phase Locked Loop (PLL)
   --             Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   PLLE2_BASE_inst : PLLE2_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",  -- OPTIMIZED, HIGH, LOW
      CLKFBOUT_MULT =&gt; 5,        -- Multiply value for all CLKOUT, (2-64)
      CLKFBOUT_PHASE =&gt; 0.0,     -- Phase offset in degrees of CLKFB, (-360.000-360.000).
      CLKIN1_PERIOD =&gt; 0.0,      -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT0_DIVIDE =&gt; 1,
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      -- CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      DIVCLK_DIVIDE =&gt; 1,        -- Master division value, (1-56)
      REF_JITTER1 =&gt; 0.0,        -- Reference input jitter in UI, (0.000-0.999).
      STARTUP_WAIT =&gt; "FALSE"    -- Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,   -- 1-bit output: CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,   -- 1-bit output: CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,   -- 1-bit output: CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,   -- 1-bit output: CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,   -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,   -- 1-bit output: CLKOUT5
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT, -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,     -- 1-bit output: LOCK
      CLKIN1 =&gt; CLKIN1,     -- 1-bit input: Input clock
      -- Control Ports: 1-bit (each) input: PLL control ports
      PWRDWN =&gt; PWRDWN,     -- 1-bit input: Power-down
      RST =&gt; RST,           -- 1-bit input: Reset
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN    -- 1-bit input: Feedback clock
   );

   -- End of PLLE2_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Config/BSCAN Components" treetype="folder">
				<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
--  EFUSE_USR  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (EFUSE_USR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EFUSE_USR: 32-bit non-volatile design ID
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   EFUSE_USR_inst : EFUSE_USR
   generic map (
      SIM_EFUSE_VALUE =&gt; X"00000000"  -- Value of the 32-bit non-volatile value used in simulation
   )
   port map (
      EFUSEUSR =&gt; EFUSEUSR  -- 32-bit output: User eFUSE register value output
   );

   -- End of EFUSE_USR_inst instantiation
				</Template>
				<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
--   BSCANE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BSCANE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BSCANE2: Boundary-Scan User Instruction
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   BSCANE2_inst : BSCANE2
   generic map (
      JTAG_CHAIN =&gt; 1  -- Value for USER command.
   )
   port map (
      CAPTURE =&gt; CAPTURE, -- 1-bit output: CAPTURE output from TAP controller.
      DRCK =&gt; DRCK,       -- 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                          -- SHIFT are asserted.

      RESET =&gt; RESET,     -- 1-bit output: Reset output for TAP controller.
      RUNTEST =&gt; RUNTEST, -- 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      SEL =&gt; SEL,         -- 1-bit output: USER instruction active output.
      SHIFT =&gt; SHIFT,     -- 1-bit output: SHIFT output from TAP controller.
      TCK =&gt; TCK,         -- 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      TDI =&gt; TDI,         -- 1-bit output: Test Data Input (TDI) output from TAP controller.
      TMS =&gt; TMS,         -- 1-bit output: Test Mode Select output. Fabric connection to TAP.
      UPDATE =&gt; UPDATE,   -- 1-bit output: UPDATE output from TAP controller
      TDO =&gt; TDO          -- 1-bit input: Test Data Output (TDO) input for USER function.
   );

   -- End of BSCANE2_inst instantiation
				</Template>
				<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
-- USR_ACCESSE2 : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (USR_ACCESSE2_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- USR_ACCESSE2: Configuration Data Access
   --               Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2_inst : USR_ACCESSE2
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration Clock output
      DATA =&gt; DATA,           -- 32-bit output: Configuration Data output
      DATAVALID =&gt; DATAVALID  -- 1-bit output: Active high data valid output
   );

   -- End of USR_ACCESSE2_inst instantiation
				</Template>
				<Template label="Configuration Frame Error Correction (FRAME_ECCE2)" treetype="template">
-- FRAME_ECCE2 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FRAME_ECCE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FRAME_ECCE2: Configuration Frame Error Correction
   --              Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   FRAME_ECCE2_inst : FRAME_ECCE2
   generic map (
      FARSRC =&gt; "EFAR",                -- Determines if the output of FAR[25:0] configuration register points
                                       -- to the FAR or EFAR. Sets configuration option register bit CTL0[7].
      FRAME_RBT_IN_FILENAME =&gt; "None"  -- This file is output by the ICAP_E2 model and it contains Frame Data
                                       -- information for the Raw Bitstream (RBT) file. The FRAME_ECCE2 model
                                       -- will parse this file, calculate ECC and output any error conditions.
   )
   port map (
      CRCERROR =&gt; CRCERROR,             -- 1-bit output: Output indicating a CRC error.
      ECCERROR =&gt; ECCERROR,             -- 1-bit output: Output indicating an ECC error.
      ECCERRORSINGLE =&gt; ECCERRORSINGLE, -- 1-bit output: Output Indicating single-bit Frame ECC error detected.
      FAR =&gt; FAR,                       -- 26-bit output: Frame Address Register Value output.
      SYNBIT =&gt; SYNBIT,                 -- 5-bit output: Output bit address of error.
      SYNDROME =&gt; SYNDROME,             -- 13-bit output: Output location of erroneous bit.
      SYNDROMEVALID =&gt; SYNDROMEVALID,   -- 1-bit output: Frame ECC output indicating the SYNDROME output is
                                        -- valid.

      SYNWORD =&gt; SYNWORD                -- 7-bit output: Word output in the frame where an ECC error has been
                                        -- detected.

   );

   -- End of FRAME_ECCE2_inst instantiation
				</Template>
				<Template label="Device DNA Access Port (DNA_PORT)" treetype="template">
--  DNA_PORT   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DNA_PORT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DNA_PORT: Device DNA Access Port
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   DNA_PORT_inst : DNA_PORT
   generic map (
      SIM_DNA_VALUE =&gt; X"000000000000000"  -- Specifies a sample 57-bit DNA value for simulation
   )
   port map (
      DOUT =&gt; DOUT,   -- 1-bit output: DNA output data.
      CLK =&gt; CLK,     -- 1-bit input: Clock input.
      DIN =&gt; DIN,     -- 1-bit input: User data input pin.
      READ =&gt; READ,   -- 1-bit input: Active high load DNA, active low read input.
      SHIFT =&gt; SHIFT  -- 1-bit input: Active high shift enable input.
   );

   -- End of DNA_PORT_inst instantiation
				</Template>
				<Template label="Internal Configuration Access Port (ICAPE2)" treetype="template">
--   ICAPE2    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ICAPE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ICAPE2: Internal Configuration Access Port
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   ICAPE2_inst : ICAPE2
   generic map (
      DEVICE_ID =&gt; X"3651093",     -- Specifies the pre-programmed Device ID value to be used for simulation
                                   -- purposes.
      ICAP_WIDTH =&gt; "X32",         -- Specifies the input and output data width.
      SIM_CFG_FILE_NAME =&gt; "None"  -- Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                   -- model.
   )
   port map (
      O =&gt; O,         -- 32-bit output: Configuration data output bus
      CLK =&gt; CLK,     -- 1-bit input: Clock Input
      CSIB =&gt; CSIB,   -- 1-bit input: Active-Low ICAP Enable
      I =&gt; I,         -- 32-bit input: Configuration data input bus
      RDWRB =&gt; RDWRB  -- 1-bit input: Read/Write Select input
   );

   -- End of ICAPE2_inst instantiation
				</Template>
				<Template label="Register Capture (CAPTUREE2)" treetype="template">
--  CAPTUREE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CAPTUREE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CAPTUREE2: Register Capture
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   CAPTUREE2_inst : CAPTUREE2
   generic map (
      ONESHOT =&gt; "TRUE"  -- Specifies the procedure for performing single readback per CAP trigger.
   )
   port map (
      CAP =&gt; CAP, -- 1-bit input: Capture Input
      CLK =&gt; CLK  -- 1-bit input: Clock Input
   );

   -- End of CAPTUREE2_inst instantiation
				</Template>
				<Template label="STARTUP Block (STARTUPE2)" treetype="template">
--  STARTUPE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (STARTUPE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- STARTUPE2: STARTUP Block
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   STARTUPE2_inst : STARTUPE2
   generic map (
      PROG_USR =&gt; "FALSE",  -- Activate program event security feature. Requires encrypted bitstreams.
      SIM_CCLK_FREQ =&gt; 0.0  -- Set the Configuration Clock Frequency(ns) for simulation.
   )
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration main clock output
      CFGMCLK =&gt; CFGMCLK,     -- 1-bit output: Configuration internal oscillator clock output
      EOS =&gt; EOS,             -- 1-bit output: Active high output signal indicating the End Of Startup.
      PREQ =&gt; PREQ,           -- 1-bit output: PROGRAM request to fabric output
      CLK =&gt; CLK,             -- 1-bit input: User start-up clock input
      GSR =&gt; GSR,             -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port name)
      GTS =&gt; GTS,             -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      KEYCLEARB =&gt; KEYCLEARB, -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      PACK =&gt; PACK,           -- 1-bit input: PROGRAM acknowledge input
      USRCCLKO =&gt; USRCCLKO,   -- 1-bit input: User CCLK input
      USRCCLKTS =&gt; USRCCLKTS, -- 1-bit input: User CCLK 3-state enable input
      USRDONEO =&gt; USRDONEO,   -- 1-bit input: User DONE pin output control
      USRDONETS =&gt; USRDONETS  -- 1-bit input: User DONE 3-state enable output
   );

   -- End of STARTUPE2_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="I/O Components" treetype="folder">
				<SubFolder label="Bi-directional Buffers" treetype="folder">
					<Template label="Differential Buffer (IOBUFDS)" treetype="template">

--   IOBUFDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUFDS_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS: Differential Bi-directional Buffer
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_inst : IOBUFDS
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; TRUE, -- Low Power = TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      SLEW =&gt; "SLOW")       -- Specify the output slew rate
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ input and DCI disable(IOBUFDS_DCIEN)" treetype="template">

--IOBUFDS_DCIEN : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUFDS_DCIEN_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DCIEN: Differential Bi-directional Buffer with Digital Controlled Impedance (DCI)
   --                and Input path enable/disable
   --                May only be placed in High Performance (HP) Banks
   --                Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DCIEN_inst : IOBUFDS_DCIEN
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, HIGH Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      SLEW =&gt; "SLOW",   -- Specify the output slew rate
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable
      T =&gt; T      -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_DCIEN_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ input and input termination disable (IOBUFDS_INTERMDISABLE)" treetype="template">

--IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--    VHDL              : the following instance declaration needs to be placed
--  instance            : in the architecture body of the design code.  The
-- declaration          : instance name (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations
--    code              : after the "=&gt;" assignment maybe changed to properly
--                      : connect this function to the design. All inputs must be
--                      : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_INTERMDISABLE: Differential Bi-directional Buffer with Input Termination
   --                        and Input path enable/disable
   --                        May only be placed in High Range (HR) Banks
   --                        Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_INTERMDISABLE_inst : IOBUFDS_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, HIGH Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      SLEW =&gt; "SLOW",   -- Specify the output slew rate
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input termination disable input
      T =&gt; T      -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output, input and DCI disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">

--IOBUFDS_DIFF_OUT_DCIEN: In order to incorporate this function into the design,
--    VHDL           : the following instance declaration needs to be placed
--  instance         : in the architecture body of the design code.  The
-- declaration       : instance name (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations
--    code           : after the "=&gt;" assignment maybe changed to properly
--                   : connect this function to the design. All inputs must be
--                   : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_DCIEN: Differential Bi-directional Buffer with Differential Output,
   --                         Digital Controlled Impedance (DCI)and Input path enable/disable
   --                         May only be placed in High Performance (HP) Banks
   --                         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_DCIEN_inst : IOBUFDS_DIFF_OUT_DCIEN
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function, "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer p-side output
      OB =&gt; OB,   -- Buffer n-side output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFTERMDISABLE =&gt; IBUFTERMDISABLE, -- input disable input, low=disable
      TM =&gt; TM,   -- 3-state enable input, high=input, low=output
      TS =&gt; TS    -- 3-state enable input, high=output, low=input
   );
  
   -- End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation

					</Template>
					<Template label="Differential Buffer with Differential Output (IOBUFDS_DIFF_OUT)" treetype="template">

--IOBUFDS_DIFF_OUT   : In order to incorporate this function into the design,
--    VHDL           : the following instance declaration needs to be placed
--  instance         : in the architecture body of the design code.  The
-- declaration       : instance name (IOBUFDS_DIFF_OUT_inst) and/or the port declarations
--    code           : after the "=&gt;" assignment maybe changed to properly
--                   : connect this function to the design. All inputs must be
--                   : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT: Differential Bi-directional Buffer with Diffirential Output
   --                   Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_inst : IOBUFDS_DIFF_OUT
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; TRUE, -- Low Power - TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25") -- Specify the I/O standard
   port map (
      O =&gt; O,     -- Buffer p-side output
      OB =&gt; OB,   -- Buffer n-side output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      TM =&gt; TM,   -- 3-state enable input, high=input, low=output
      TS =&gt; TS    -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_DIFF_OUT_inst instantiation

					</Template>
					<Template label="Differential Global Clock Buffer w/ Differential Output, INTERM and IBUF disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">

--IOBUFDS_DIFF_OUT_INTERMDISABLE: In order to incorporate this function into the design,
--         VHDL                 : the following instance declaration needs to be placed
--       instance               : in the architecture body of the design code.  The
--      declaration             : instance name (IOBUFDS_DIFF_OUT_INTRMDISABLE_inst) and/or the port declarations
--         code                 : after the "=&gt;" assignment maybe changed to properly
--                              : connect this function to the design. All inputs must be
--                              : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_INTERMDISABLE:  Differential Global Clock Buffer with Differential Output
   --                                  Input Termination and Input Path Disable
   --                                  May only be placed in High Range (HR) Banks
   --                                  Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst : IOBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function, "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer p-side output
      OB =&gt; OB,   -- Buffer n-side output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- input disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input termination disable input 
      TM =&gt; TM,   -- 3-state enable input, high=input, low=output
      TS =&gt; TS    -- 3-state enable input, high=output, low=input
   );
  
   -- End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation

					</Template>
					<Template label="Single-ended Buffer (IOBUF)" treetype="template">

--    IOBUF    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUF_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF: Single-ended Bi-directional Buffer
   --        Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUF_inst : IOBUF
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Buffer inout port (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input, high=input, low=output 
   );
  
   -- End of IOBUF_inst instantiation


					</Template>
					<Template label="Single-ended Buffer w/input and DCI disable (IOBUF_DCIEN)" treetype="template">

-- IOBUF_DCIEN : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUF_DCIEN_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_DCIEN: Single-ended Bi-directional Buffer with Digital Controlled Impedance (DCI)
   --              and Input path enable/disable
   --              May only be placed in High Performance (HP) Banks
   --              Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUF_DCIEN_inst : IOBUF_DCIEN
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      IBUF_LOW_PWR =&gt; "TRUE",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Buffer inout port (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable 
      T =&gt; T      -- 3-state enable input, high=input, low=output 
   );
  
   -- End of IOBUF_DCIEN_inst instantiation

					</Template>
					<Template label="Single-ended Buffer w/ input and INTERM disable (IOBUF_INTERMDISABLE)" treetype="template">

-- IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
--       VHDL          : the following instance declaration needs to be placed
--     instance        : in the architecture body of the design code.  The
--   declaration       : instance name (IOBUF_INTERMDISABLE_inst) and/or the port declarations
--       code          : after the "=&gt;" assignment maybe changed to properly
--                     : connect this function to the design. All inputs must be
--                     : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_INTERMDISABLE: Single-ended Bi-directional Buffer with Input Termination
   --                      and Input path enable/disable
   --                      May only be placed in High Range (HR) Banks
   --                      Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUF_INTERMDISABLE_inst : IOBUF_INTERMDISABLE
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT", -- Specify the I/O standard
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - "TRUE", High Performance = "FALSE" 
      USE_IBUFDISABLE =&gt; "TRUE", -- Use IBUFDISABLE function "TRUE" or "FALSE" 
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Buffer inout port (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input termination disable input
      T =&gt; T      -- 3-state enable input, high=input, low=output 
   );
  
   -- End of IOBUF_DCIEN_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="DDR Registers" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
--    IDDR_2CLK  : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The
--   declaration : instance name (IDDR_2CLK_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design.  All inputs must be 
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   --            Set, Reset and Clock Enable.
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK_inst : IDDR_2CLK 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit primary clock input
      CB =&gt; CB, -- 1-bit secondary clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_2CLK_inst instantiation

					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
--      IDDR     : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The 
--   declaration : instance name (IDDR_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design. All inputs must be
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR: Double Data Rate Input Register with Set, Reset
   --       and Clock Enable. 
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_inst : IDDR 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_inst instantiation

					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
--      ODDR       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (ODDR_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs  
--                 : and outputs must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDR: Output Double Data Rate Output Register with Set, Reset
   --       and Clock Enable. 
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   ODDR_inst : ODDR
   generic map(
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE" or "SAME_EDGE" 
      INIT =&gt; '0',   -- Initial value for Q port ('1' or '0')
      SRTYPE =&gt; "SYNC") -- Reset Type ("ASYNC" or "SYNC")
   port map (
      Q =&gt; Q,   -- 1-bit DDR output
      C =&gt; C,    -- 1-bit clock input
      CE =&gt; CE,  -- 1-bit clock enable input
      D1 =&gt; D1,  -- 1-bit data input (positive edge)
      D2 =&gt; D2,  -- 1-bit data input (negative edge)
      R =&gt; R,    -- 1-bit reset input
      S =&gt; S     -- 1-bit set input
   );
  
   -- End of ODDR_inst instantiation


					</Template>
				</SubFolder>
				<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
--  DCIRESET   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DCIRESET_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DCIRESET: Digitally Controlled Impedance Reset Component
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   DCIRESET_inst : DCIRESET
   port map (
      LOCKED =&gt; LOCKED, -- 1-bit output: LOCK status output
      RST =&gt; RST        -- 1-bit input: Active-high asynchronous reset input
   );

   -- End of DCIRESET_inst instantiation
				</Template>
				<SubFolder label="FIFOs" treetype="folder">
					<Template label="Input FIFO (IN_FIFO)" treetype="template">
--   IN_FIFO   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IN_FIFO_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IN_FIFO: Input First-In, First-Out (FIFO)
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IN_FIFO_inst : IN_FIFO
   generic map (
      ALMOST_EMPTY_VALUE =&gt; 1,          -- Almost empty offset (1-2)
      ALMOST_FULL_VALUE =&gt; 1,           -- Almost full offset (1-2)
      ARRAY_MODE =&gt; "ARRAY_MODE_4_X_8", -- ARRAY_MODE_4_X_8, ARRAY_MODE_4_X_4
      SYNCHRONOUS_MODE =&gt; "FALSE"       -- Clock synchronous (FALSE)
   )
   port map (
      -- FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY, -- 1-bit output: Almost empty
      ALMOSTFULL =&gt; ALMOSTFULL,   -- 1-bit output: Almost full
      EMPTY =&gt; EMPTY,             -- 1-bit output: Empty
      FULL =&gt; FULL,               -- 1-bit output: Full
      -- Q0-Q9: 8-bit (each) output: FIFO Outputs
      Q0 =&gt; Q0,                   -- 8-bit output: Channel 0
      Q1 =&gt; Q1,                   -- 8-bit output: Channel 1
      Q2 =&gt; Q2,                   -- 8-bit output: Channel 2
      Q3 =&gt; Q3,                   -- 8-bit output: Channel 3
      Q4 =&gt; Q4,                   -- 8-bit output: Channel 4
      Q5 =&gt; Q5,                   -- 8-bit output: Channel 5
      Q6 =&gt; Q6,                   -- 8-bit output: Channel 6
      Q7 =&gt; Q7,                   -- 8-bit output: Channel 7
      Q8 =&gt; Q8,                   -- 8-bit output: Channel 8
      Q9 =&gt; Q9,                   -- 8-bit output: Channel 9
      -- D0-D9: 4-bit (each) input: FIFO inputs
      D0 =&gt; D0,                   -- 4-bit input: Channel 0
      D1 =&gt; D1,                   -- 4-bit input: Channel 1
      D2 =&gt; D2,                   -- 4-bit input: Channel 2
      D3 =&gt; D3,                   -- 4-bit input: Channel 3
      D4 =&gt; D4,                   -- 4-bit input: Channel 4
      D5 =&gt; D5,                   -- 8-bit input: Channel 5
      D6 =&gt; D6,                   -- 8-bit input: Channel 6
      D7 =&gt; D7,                   -- 4-bit input: Channel 7
      D8 =&gt; D8,                   -- 4-bit input: Channel 8
      D9 =&gt; D9,                   -- 4-bit input: Channel 9
      -- FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      RDCLK =&gt; RDCLK,             -- 1-bit input: Read clock
      RDEN =&gt; RDEN,               -- 1-bit input: Read enable
      RESET =&gt; RESET,             -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,             -- 1-bit input: Write clock
      WREN =&gt; WREN                -- 1-bit input: Write enable
   );

   -- End of IN_FIFO_inst instantiation
					</Template>
					<Template label="Output FIFO (OUT_FIFO)" treetype="template">
--  OUT_FIFO   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OUT_FIFO_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OUT_FIFO: Output First-In, First-Out (FIFO) Buffer
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   OUT_FIFO_inst : OUT_FIFO
   generic map (
      ALMOST_EMPTY_VALUE =&gt; 1,          -- Almost empty offset (1-2)
      ALMOST_FULL_VALUE =&gt; 1,           -- Almost full offset (1-2)
      ARRAY_MODE =&gt; "ARRAY_MODE_8_X_4", -- ARRAY_MODE_8_X_4, ARRAY_MODE_4_X_4
      OUTPUT_DISABLE =&gt; "FALSE",        -- Disable output (FALSE, TRUE)
      SYNCHRONOUS_MODE =&gt; "FALSE"       -- Must always be set to false.
   )
   port map (
      -- FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY, -- 1-bit output: Almost empty flag
      ALMOSTFULL =&gt; ALMOSTFULL,   -- 1-bit output: Almost full flag
      EMPTY =&gt; EMPTY,             -- 1-bit output: Empty flag
      FULL =&gt; FULL,               -- 1-bit output: Full flag
      -- Q0-Q9: 4-bit (each) output: FIFO Outputs
      Q0 =&gt; Q0,                   -- 4-bit output: Channel 0 output bus
      Q1 =&gt; Q1,                   -- 4-bit output: Channel 1 output bus
      Q2 =&gt; Q2,                   -- 4-bit output: Channel 2 output bus
      Q3 =&gt; Q3,                   -- 4-bit output: Channel 3 output bus
      Q4 =&gt; Q4,                   -- 4-bit output: Channel 4 output bus
      Q5 =&gt; Q5,                   -- 8-bit output: Channel 5 output bus
      Q6 =&gt; Q6,                   -- 8-bit output: Channel 6 output bus
      Q7 =&gt; Q7,                   -- 4-bit output: Channel 7 output bus
      Q8 =&gt; Q8,                   -- 4-bit output: Channel 8 output bus
      Q9 =&gt; Q9,                   -- 4-bit output: Channel 9 output bus
      -- D0-D9: 8-bit (each) input: FIFO inputs
      D0 =&gt; D0,                   -- 8-bit input: Channel 0 input bus
      D1 =&gt; D1,                   -- 8-bit input: Channel 1 input bus
      D2 =&gt; D2,                   -- 8-bit input: Channel 2 input bus
      D3 =&gt; D3,                   -- 8-bit input: Channel 3 input bus
      D4 =&gt; D4,                   -- 8-bit input: Channel 4 input bus
      D5 =&gt; D5,                   -- 8-bit input: Channel 5 input bus
      D6 =&gt; D6,                   -- 8-bit input: Channel 6 input bus
      D7 =&gt; D7,                   -- 8-bit input: Channel 7 input bus
      D8 =&gt; D8,                   -- 8-bit input: Channel 8 input bus
      D9 =&gt; D9,                   -- 8-bit input: Channel 9 input bus
      -- FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      RDCLK =&gt; RDCLK,             -- 1-bit input: Read clock
      RDEN =&gt; RDEN,               -- 1-bit input: Read enable
      RESET =&gt; RESET,             -- 1-bit input: Active high reset
      WRCLK =&gt; WRCLK,             -- 1-bit input: Write clock
      WREN =&gt; WREN                -- 1-bit input: Write enable
   );

   -- End of OUT_FIFO_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Input Buffers" treetype="folder">
					<Template label="Differential Buffer (IBUFDS)" treetype="template">

--   IBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IBUFDS_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS: Differential Input Buffer
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_inst : IBUFDS
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination 
      IBUF_LOW_PWR =&gt; TRUE, -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT")
   port map (
      O =&gt; O,  -- Buffer output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB -- Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ Disable (IBUFDS_IBUFDISABLE)" treetype="template">

--IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IBUFDS_IBUFDISABLE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_IBUFDISABLE: Differential Input Buffer w/ Disable
   --                     Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE_inst : IBUFDS_IBUFDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,  -- Buffer output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, low=disable
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Differential Buffer with Differential Output (IBUFDS_DIFF_OUT)" treetype="template">

--IBUFDS_DIFF_OUT: In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : instance name (IBUFDS_DIFF_OUT_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT: Differential Input Buffer with Differential Output
   --                  Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_inst : IBUFDS_DIFF_OUT
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination 
      IBUF_LOW_PWR =&gt; TRUE, -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT") -- Specify the input I/O standard
   port map (
      O =&gt; O,     -- Buffer diff_p output
      OB =&gt; OB,   -- Buffer diff_n output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB -- Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_DIFF_OUT_inst instantiation


					</Template>
					<Template label="Differential Buffer with Differential Output w/Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">

--IBUFDS_DIFF_OUT_IBUFDISABLE: In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : instance name (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer with Differential Output w/ Disable
   --                              Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE_inst : IBUFDS_DIFF_OUT_IBUFDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power "TRUE" vs. performance "FALSE" setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer diff_p output
      OB =&gt; OB,   -- Buffer diff_n output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, low=disable
   );

   -- End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Differential Buffer with Differential Output w/Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">

--IBUFDS_DIFF_OUT_INTERMDISABLE: In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : instance name (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Differential Output w/ Disable
   --                                Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE_inst : IBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power "TRUE" vs. performance "FALSE" setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer diff_p output
      OB =&gt; OB,   -- Buffer diff_n output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- Buffer disable input, low=disable
      INTERMDISABLE =&gt; INTERMDISABLE -- Input termination disable
   );

   -- End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">

--IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IBUFDS_INTERMDISABLE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_INTERMDISABLE: Differential Input Buffer with Input Termination Disable
   --                       May only be placed in High Range (HR) Banks
   --                       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE_inst : IBUFDS_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,  -- Buffer output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- Buffer disable input, low=disable
      INTERMDISABLE =&gt; INTERMDISABLE -- Input termination disable
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Single-ended Buffer (IBUF)" treetype="template">

--      IBUF       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (IBUF_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs must be
--                 : connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF: Single-ended Input Buffer
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IBUF_inst : IBUF
   generic map (
      IBUF_LOW_PWR =&gt; TRUE, -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT")
   port map (
      O =&gt; O,     -- Buffer output
      I =&gt; I      -- Buffer input (connect directly to top-level port)
   );
  
   -- End of IBUF_inst instantiation

					</Template>
					<Template label="Single-ended Buffer w/ Disable (IBUF_IBUFDISABLE)" treetype="template">

--IBUF_IBUFDISABLE : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (IBUF_IBUFDISABLE_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs must be
--                 : connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_IBUFDISABLE: Single-ended Input Buffer with Disable
   --                   Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IBUF_IBUFDISABLE_inst : IBUF_IBUFDISABLE
   generic map (
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer output
      I =&gt; I,     -- Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, low=disable
   );
  
   -- End of IBUF_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Single-ended Buffer w/ Termination Disable (IBUF_INTERMDISABLE)" treetype="template">

--IBUF_INTERMDISABLE : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (IBUF_INTERMDISABLE_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs must be
--                 : connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_INTERMDISABLE: Single-ended Input Buffer with Termination Input Disable
   --                     May only be placed in High Range (HR) Banks
   --                     Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IBUF_INTERMDISABLE_inst : IBUF_INTERMDISABLE
   generic map (
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer output
      I =&gt; I,     -- Buffer input (connect directly to top-level port)
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input Termination Disable
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, low=disable
   );
  
   -- End of IBUF_INTERMDISABLE_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="I/O Delay Components" treetype="folder">
					<Template label="Delay Calibration (IDELAYCTRL)" treetype="template">
-- IDELAYCTRL  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  Put the following attribute before the 'begin' statement
--  Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

attribute IODELAY_GROUP : STRING;
attribute IODELAY_GROUP of &lt;label_name&gt;: label is "&lt;iodelay_group_name&gt;";

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYCTRL: IDELAYE2/ODELAYE2 Tap Delay Value Control
   --             Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL_inst : IDELAYCTRL
   port map (
      RDY =&gt; RDY,       -- 1-bit output: Ready output
      REFCLK =&gt; REFCLK, -- 1-bit input: Reference clock input
      RST =&gt; RST        -- 1-bit input: Active high reset input
   );

   -- End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE2)" treetype="template">
--  IDELAYE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  Put the following attribute before the 'begin' statement
--  Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

attribute IODELAY_GROUP : STRING;
attribute IODELAY_GROUP of &lt;label_name&gt;: label is "&lt;iodelay_group_name&gt;";

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYE2: Input Fixed or Variable Delay Element
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYE2_inst : IDELAYE2
   generic map (
      CINVCTRL_SEL =&gt; "FALSE",          -- Enable dynamic clock inversion (FALSE, TRUE)
      DELAY_SRC =&gt; "IDATAIN",           -- Delay input (IDATAIN, DATAIN)
      HIGH_PERFORMANCE_MODE =&gt; "FALSE", -- Reduced jitter ("TRUE"), Reduced power ("FALSE")
      IDELAY_TYPE =&gt; "FIXED",           -- FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      IDELAY_VALUE =&gt; 0,                -- Input delay tap setting (0-31)
      PIPE_SEL =&gt; "FALSE",              -- Select pipelined mode, FALSE, TRUE
      REFCLK_FREQUENCY =&gt; 200.0,        -- IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      SIGNAL_PATTERN =&gt; "DATA"          -- DATA, CLOCK input signal
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 5-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data output
      C =&gt; C,                     -- 1-bit input: Clock input
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CINVCTRL =&gt; CINVCTRL,       -- 1-bit input: Dynamic clock inversion input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 5-bit input: Counter value input
      DATAIN =&gt; DATAIN,           -- 1-bit input: Internal delay data input
      IDATAIN =&gt; IDATAIN,         -- 1-bit input: Data input from the I/O
      INC =&gt; INC,                 -- 1-bit input: Increment / Decrement tap delay input
      LD =&gt; LD,                   -- 1-bit input: Load IDELAY_VALUE input
      LDPIPEEN =&gt; LDPIPEEN,       -- 1-bit input: Enable PIPELINE register to load data input
      REGRST =&gt; REGRST            -- 1-bit input: Active-high reset tap-delay input
   );

   -- End of IDELAYE2_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE2)" treetype="template">
--  ODELAYE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODELAYE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  Put the following attribute before the 'begin' statement
--  Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

attribute IODELAY_GROUP : STRING;
attribute IODELAY_GROUP of &lt;label_name&gt;: label is "&lt;iodelay_group_name&gt;";

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODELAYE2: Output Fixed or Variable Delay Element
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   ODELAYE2_inst : ODELAYE2
   generic map (
      CINVCTRL_SEL =&gt; "FALSE",          -- Enable dynamic clock inversion (FALSE, TRUE)
      DELAY_SRC =&gt; "ODATAIN",           -- Delay input (ODATAIN, CLKIN)
      HIGH_PERFORMANCE_MODE =&gt; "FALSE", -- Reduced jitter ("TRUE"), Reduced power ("FALSE")
      ODELAY_TYPE =&gt; "FIXED",           -- FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      ODELAY_VALUE =&gt; 0,                -- Output delay tap setting (0-31)
      PIPE_SEL =&gt; "FALSE",              -- Select pipelined mode, FALSE, TRUE
      REFCLK_FREQUENCY =&gt; 200.0,        -- IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      SIGNAL_PATTERN =&gt; "DATA"          -- DATA, CLOCK input signal
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 5-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data/clock output
      C =&gt; C,                     -- 1-bit input: Clock input
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CINVCTRL =&gt; CINVCTRL,       -- 1-bit input: Dynamic clock inversion input
      CLKIN =&gt; CLKIN,             -- 1-bit input: Clock delay input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 5-bit input: Counter value input
      INC =&gt; INC,                 -- 1-bit input: Increment / Decrement tap delay input
      LD =&gt; LD,                   -- 1-bit input: Loads ODELAY_VALUE tap delay in VARIABLE mode, in VAR_LOAD or
                                  -- VAR_LOAD_PIPE mode, loads the value of CNTVALUEIN

      LDPIPEEN =&gt; LDPIPEEN,       -- 1-bit input: Enables the pipeline register to load data
      ODATAIN =&gt; ODATAIN,         -- 1-bit input: Output delay data input
      REGRST =&gt; REGRST            -- 1-bit input: Active-high reset tap-delay input
   );

   -- End of ODELAYE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="I/O SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer with Bitslip (ISERDESE2)" treetype="template">
--  ISERDESE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ISERDESE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ISERDESE2: Input SERial/DESerializer with Bitslip
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   ISERDESE2_inst : ISERDESE2
   generic map (
      DATA_RATE =&gt; "DDR",           -- DDR, SDR
      DATA_WIDTH =&gt; 4,              -- Parallel data width (2-8,10,14)
      DYN_CLKDIV_INV_EN =&gt; "FALSE", -- Enable DYNCLKDIVINVSEL inversion (FALSE, TRUE)
      DYN_CLK_INV_EN =&gt; "FALSE",    -- Enable DYNCLKINVSEL inversion (FALSE, TRUE)
      -- INIT_Q1 - INIT_Q4: Initial value on the Q outputs (0/1)
      INIT_Q1 =&gt; '0',
      INIT_Q2 =&gt; '0',
      INIT_Q3 =&gt; '0',
      INIT_Q4 =&gt; '0',
      INTERFACE_TYPE =&gt; "MEMORY",   -- MEMORY, MEMORY_DDR3, MEMORY_QDR, NETWORKING, OVERSAMPLE
      IOBDELAY =&gt; "NONE",           -- NONE, BOTH, IBUF, IFD
      NUM_CE =&gt; 2,                  -- Number of clock enables (1,2)
      OFB_USED =&gt; "FALSE",          -- Select OFB path (FALSE, TRUE)
      SERDES_MODE =&gt; "MASTER",      -- MASTER, SLAVE
      -- SRVAL_Q1 - SRVAL_Q4: Q output values when SR is used (0/1)
      SRVAL_Q1 =&gt; '0',
      SRVAL_Q2 =&gt; '0',
      SRVAL_Q3 =&gt; '0',
      SRVAL_Q4 =&gt; '0' 
   )
   port map (
      O =&gt; O,                       -- 1-bit output: Combinatorial output
      -- Q1 - Q8: 1-bit (each) output: Registered data outputs
      Q1 =&gt; Q1,
      Q2 =&gt; Q2,
      Q3 =&gt; Q3,
      Q4 =&gt; Q4,
      Q5 =&gt; Q5,
      Q6 =&gt; Q6,
      Q7 =&gt; Q7,
      Q8 =&gt; Q8,
      -- SHIFTOUT1, SHIFTOUT2: 1-bit (each) output: Data width expansion output ports
      SHIFTOUT1 =&gt; SHIFTOUT1,
      SHIFTOUT2 =&gt; SHIFTOUT2,
      BITSLIP =&gt; BITSLIP,           -- 1-bit input: The BITSLIP pin performs a Bitslip operation synchronous to
                                    -- CLKDIV when asserted (active High). Subsequently, the data seen on the
                                    -- Q1 to Q8 output ports will shift, as in a barrel-shifter operation, one
                                    -- position every time Bitslip is invoked (DDR operation is different from
                                    -- SDR).

      -- CE1, CE2: 1-bit (each) input: Data register clock enable inputs
      CE1 =&gt; CE1,
      CE2 =&gt; CE2,
      CLKDIVP =&gt; CLKDIVP,           -- 1-bit input: TBD
      -- Clocks: 1-bit (each) input: ISERDESE2 clock input ports
      CLK =&gt; CLK,                   -- 1-bit input: High-speed clock
      CLKB =&gt; CLKB,                 -- 1-bit input: High-speed secondary clock
      CLKDIV =&gt; CLKDIV,             -- 1-bit input: Divided clock
      OCLK =&gt; OCLK,                 -- 1-bit input: High speed output clock used when INTERFACE_TYPE="MEMORY" 
      -- Dynamic Clock Inversions: 1-bit (each) input: Dynamic clock inversion pins to switch clock polarity
      DYNCLKDIVSEL =&gt; DYNCLKDIVSEL, -- 1-bit input: Dynamic CLKDIV inversion
      DYNCLKSEL =&gt; DYNCLKSEL,       -- 1-bit input: Dynamic CLK/CLKB inversion
      -- Input Data: 1-bit (each) input: ISERDESE2 data input ports
      D =&gt; D,                       -- 1-bit input: Data input
      DDLY =&gt; DDLY,                 -- 1-bit input: Serial data from IDELAYE2
      OFB =&gt; OFB,                   -- 1-bit input: Data feedback from OSERDESE2
      OCLKB =&gt; OCLKB,               -- 1-bit input: High speed negative edge output clock
      RST =&gt; RST,                   -- 1-bit input: Active high asynchronous reset
      -- SHIFTIN1, SHIFTIN2: 1-bit (each) input: Data width expansion input ports
      SHIFTIN1 =&gt; SHIFTIN1,
      SHIFTIN2 =&gt; SHIFTIN2 
   );

   -- End of ISERDESE2_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer with bitslip (OSERDESE2)" treetype="template">
--  OSERDESE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OSERDESE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OSERDESE2: Output SERial/DESerializer with bitslip
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   OSERDESE2_inst : OSERDESE2
   generic map (
      DATA_RATE_OQ =&gt; "DDR",   -- DDR, SDR
      DATA_RATE_TQ =&gt; "DDR",   -- DDR, BUF, SDR
      DATA_WIDTH =&gt; 4,         -- Parallel data width (2-8,10,14)
      INIT_OQ =&gt; '0',          -- Initial value of OQ output (1'b0,1'b1)
      INIT_TQ =&gt; '0',          -- Initial value of TQ output (1'b0,1'b1)
      SERDES_MODE =&gt; "MASTER", -- MASTER, SLAVE
      SRVAL_OQ =&gt; '0',         -- OQ output value when SR is used (1'b0,1'b1)
      SRVAL_TQ =&gt; '0',         -- TQ output value when SR is used (1'b0,1'b1)
      TBYTE_CTL =&gt; "FALSE",    -- Enable tristate byte operation (FALSE, TRUE)
      TBYTE_SRC =&gt; "FALSE",    -- Tristate byte source (FALSE, TRUE)
      TRISTATE_WIDTH =&gt; 4      -- 3-state converter width (1,4)
   )
   port map (
      OFB =&gt; OFB,             -- 1-bit output: Feedback path for data
      OQ =&gt; OQ,               -- 1-bit output: Data path output
      -- SHIFTOUT1 / SHIFTOUT2: 1-bit (each) output: Data output expansion (1-bit each)
      SHIFTOUT1 =&gt; SHIFTOUT1,
      SHIFTOUT2 =&gt; SHIFTOUT2,
      TBYTEOUT =&gt; TBYTEOUT,   -- 1-bit output: Byte group tristate
      TFB =&gt; TFB,             -- 1-bit output: 3-state control
      TQ =&gt; TQ,               -- 1-bit output: 3-state control
      CLK =&gt; CLK,             -- 1-bit input: High speed clock
      CLKDIV =&gt; CLKDIV,       -- 1-bit input: Divided clock
      -- D1 - D8: 1-bit (each) input: Parallel data inputs (1-bit each)
      D1 =&gt; D1,
      D2 =&gt; D2,
      D3 =&gt; D3,
      D4 =&gt; D4,
      D5 =&gt; D5,
      D6 =&gt; D6,
      D7 =&gt; D7,
      D8 =&gt; D8,
      OCE =&gt; OCE,             -- 1-bit input: Output data clock enable
      RST =&gt; RST,             -- 1-bit input: Reset
      -- SHIFTIN1 / SHIFTIN2: 1-bit (each) input: Data input expansion (1-bit each)
      SHIFTIN1 =&gt; SHIFTIN1,
      SHIFTIN2 =&gt; SHIFTIN2,
      -- T1 - T4: 1-bit (each) input: Parallel 3-state inputs
      T1 =&gt; T1,
      T2 =&gt; T2,
      T3 =&gt; T3,
      T4 =&gt; T4,
      TBYTEIN =&gt; TBYTEIN,     -- 1-bit input: Byte group tristate
      TCE =&gt; TCE              -- 1-bit input: 3-state clock enable
   );

   -- End of OSERDESE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Output" treetype="folder">
					<Template label="Differential Buffer (OBUFDS)" treetype="template">

--   OBUFDS     : In order to incorporate this function into the design,
--    VHDL      : the following instance declaration needs to be placed
--  instance    : in the architecture body of the design code.  The
-- declaration  : instance name (OBUFDS_inst) and/or the port declarations
--    code      : after the "=&gt;" assignment maybe changed to properly
--              : connect this function to the design. All inputs must be
--              : connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--   Xilinx     : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS: Differential Output Buffer
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUFDS_inst : OBUFDS
   generic map (
      IOSTANDARD =&gt; "DEFAULT", -- Specify the output I/O standard
      SLEW =&gt; "SLOW")          -- Specify the output slew rate
   port map (
      O =&gt; O,     -- Diff_p output (connect directly to top-level port)
      OB =&gt; OB,   -- Diff_n output (connect directly to top-level port)
      I =&gt; I      -- Buffer input 
   );
  
   -- End of OBUFDS_inst instantiation

					</Template>
					<Template label="Differential 3-state Buffer (OBUFTDS)" treetype="template">

--   OBUFTDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (OBUFTDS_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFTDS: Differential 3-state Output Buffer
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUFTDS_inst : OBUFTDS
   generic map (
      IOSTANDARD =&gt; "DEFAULT")
   port map (
      O =&gt; O,     -- Diff_p output (connect directly to top-level port)
      OB =&gt; OB,   -- Diff_n output (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input
   );
  
   -- End of OBUFTDS_inst instantiation

					</Template>
					<Template label="Single-ended Buffer (OBUF)" treetype="template">

--    OBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (OBUF_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUF: Single-ended Output Buffer
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUF_inst : OBUF
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output (connect directly to top-level port)
      I =&gt; I      -- Buffer input 
   );
  
   -- End of OBUF_inst instantiation

					</Template>
					<Template label="Single-ended 3-state Buffer (OBUFT)" treetype="template">

--    OBUFT    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (OBUFT_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFT: Single-ended 3-state Output Buffer
   --        Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUFT_inst : OBUFT
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input 
   );
  
   -- End of OBUFT_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Weak drivers" treetype="folder">
					<Template label="KEEPER" treetype="template">

--   KEEPER    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (KEEPER_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design.  

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- KEEPER: I/O Buffer Weak Keeper
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   KEEPER_inst : KEEPER
   port map (
      O =&gt; O     -- Keeper output (connect directly to top-level port)
   );
  
   -- End of KEEPER_inst instantiation


					</Template>
					<Template label="PULLDOWN" treetype="template">

--  PULLDOWN   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (PULLDOWN_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design.  

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLDOWN: I/O Buffer Weak Pull-down
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   PULLDOWN_inst : PULLDOWN
   port map (
      O =&gt; O     -- Pulldown output (connect directly to top-level port)
   );
  
   -- End of PULLDOWN_inst instantiation

					</Template>
					<Template label="PULLUP" treetype="template">

--   PULLUP    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (PULLUP_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLUP: I/O Buffer Weak Pull-up
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   PULLUP_inst : PULLUP
   port map (
      O =&gt; O     -- Pullup output (connect directly to top-level port)
   );
  
   -- End of PULLUP_inst instantiation

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="RAM/ROM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E1)" treetype="template">
--  RAMB18E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB18E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB18E1: 18K-bit Configurable Synchronous Block RAM
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAMB18E1_inst : RAMB18E1
   generic map (
      -- Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      RDADDR_COLLISION_HWCONFIG =&gt; "DELAYED_WRITE",
      -- Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0 or 1)
      DOA_REG =&gt; 0,
      DOB_REG =&gt; 0,
      -- INITP_00 to INITP_07: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_3F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"00000",
      INIT_B =&gt; X"00000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- RAM Mode: "SDP" or "TDP" 
      RAM_MODE =&gt; "TDP",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-72
      READ_WIDTH_B =&gt; 0,                                                               -- 0-18
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-18
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-72
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"00000",
      SRVAL_B =&gt; X"00000",
      -- Simulation Device: Must be set to "7SERIES" for simulation behavior
      SIM_DEVICE =&gt; "7SERIES",
      -- WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      WRITE_MODE_A =&gt; "WRITE_FIRST",
      WRITE_MODE_B =&gt; "WRITE_FIRST" 
   )
   port map (
      -- Port A Data: 16-bit (each) output: Port A data
      DOADO =&gt; DOADO,                 -- 16-bit output: A port data/LSB data
      DOPADOP =&gt; DOPADOP,             -- 2-bit output: A port parity/LSB parity
      -- Port B Data: 16-bit (each) output: Port B data
      DOBDO =&gt; DOBDO,                 -- 16-bit output: B port data/MSB data
      DOPBDOP =&gt; DOPBDOP,             -- 2-bit output: B port parity/MSB parity
      -- Port A Address/Control Signals: 14-bit (each) input: Port A address and control signals (read port
      -- when RAM_MODE="SDP")
      ADDRARDADDR =&gt; ADDRARDADDR,     -- 14-bit input: A port address/Read address
      CLKARDCLK =&gt; CLKARDCLK,         -- 1-bit input: A port clock/Read clock
      ENARDEN =&gt; ENARDEN,             -- 1-bit input: A port enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,     -- 1-bit input: A port register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM, -- 1-bit input: A port set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG, -- 1-bit input: A port register set/reset
      WEA =&gt; WEA,                     -- 2-bit input: A port write enable
      -- Port A Data: 16-bit (each) input: Port A data
      DIADI =&gt; DIADI,                 -- 16-bit input: A port data/LSB data
      DIPADIP =&gt; DIPADIP,             -- 2-bit input: A port parity/LSB parity
      -- Port B Address/Control Signals: 14-bit (each) input: Port B address and control signals (write port
      -- when RAM_MODE="SDP")
      ADDRBWRADDR =&gt; ADDRBWRADDR,     -- 14-bit input: B port address/Write address
      CLKBWRCLK =&gt; CLKBWRCLK,         -- 1-bit input: B port clock/Write clock
      ENBWREN =&gt; ENBWREN,             -- 1-bit input: B port enable/Write enable
      REGCEB =&gt; REGCEB,               -- 1-bit input: B port register enable
      RSTRAMB =&gt; RSTRAMB,             -- 1-bit input: B port set/reset
      RSTREGB =&gt; RSTREGB,             -- 1-bit input: B port register set/reset
      WEBWE =&gt; WEBWE,                 -- 4-bit input: B port write enable/Write enable
      -- Port B Data: 16-bit (each) input: Port B data
      DIBDI =&gt; DIBDI,                 -- 16-bit input: B port data/MSB data
      DIPBDIP =&gt; DIPBDIP              -- 2-bit input: B port parity/MSB parity
   );

   -- End of RAMB18E1_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E1)" treetype="template">
--  RAMB36E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB36E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB36E1: 36K-bit Configurable Synchronous Block RAM
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAMB36E1_inst : RAMB36E1
   generic map (
      -- Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      RDADDR_COLLISION_HWCONFIG =&gt; "DELAYED_WRITE",
      -- Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0 or 1)
      DOA_REG =&gt; 0,
      DOB_REG =&gt; 0,
      EN_ECC_READ =&gt; FALSE,                                                            -- Enable ECC decoder,
                                                                                       -- FALSE, TRUE
      EN_ECC_WRITE =&gt; FALSE,                                                           -- Enable ECC encoder,
                                                                                       -- FALSE, TRUE
      -- INITP_00 to INITP_0F: Initial contents of the parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_7F: Initial contents of the data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"000000000",
      INIT_B =&gt; X"000000000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- RAM Mode: "SDP" or "TDP" 
      RAM_MODE =&gt; "TDP",
      -- RAM_EXTENSION_A, RAM_EXTENSION_B: Selects cascade mode ("UPPER", "LOWER", or "NONE")
      RAM_EXTENSION_A =&gt; "NONE",
      RAM_EXTENSION_B =&gt; "NONE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-72
      READ_WIDTH_B =&gt; 0,                                                               -- 0-36
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-36
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-72
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"000000000",
      SRVAL_B =&gt; X"000000000",
      -- Simulation Device: Must be set to "7SERIES" for simulation behavior
      SIM_DEVICE =&gt; "7SERIES",
      -- WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      WRITE_MODE_A =&gt; "WRITE_FIRST",
      WRITE_MODE_B =&gt; "WRITE_FIRST" 
   )
   port map (
      -- Cascade Signals: 1-bit (each) output: BRAM cascade ports (to create 64kx1)
      CASCADEOUTA =&gt; CASCADEOUTA,     -- 1-bit output: A port cascade
      CASCADEOUTB =&gt; CASCADEOUTB,     -- 1-bit output: B port cascade
      -- ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      RDADDRECC =&gt; RDADDRECC,         -- 9-bit output: ECC read address
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Port A Data: 32-bit (each) output: Port A data
      DOADO =&gt; DOADO,                 -- 32-bit output: A port data/LSB data
      DOPADOP =&gt; DOPADOP,             -- 4-bit output: A port parity/LSB parity
      -- Port B Data: 32-bit (each) output: Port B data
      DOBDO =&gt; DOBDO,                 -- 32-bit output: B port data/MSB data
      DOPBDOP =&gt; DOPBDOP,             -- 4-bit output: B port parity/MSB parity
      -- Cascade Signals: 1-bit (each) input: BRAM cascade ports (to create 64kx1)
      CASCADEINA =&gt; CASCADEINA,       -- 1-bit input: A port cascade
      CASCADEINB =&gt; CASCADEINB,       -- 1-bit input: B port cascade
      -- ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR, -- 1-bit input: Inject a single bit error
      -- Port A Address/Control Signals: 16-bit (each) input: Port A address and control signals (read port
      -- when RAM_MODE="SDP")
      ADDRARDADDR =&gt; ADDRARDADDR,     -- 16-bit input: A port address/Read address
      CLKARDCLK =&gt; CLKARDCLK,         -- 1-bit input: A port clock/Read clock
      ENARDEN =&gt; ENARDEN,             -- 1-bit input: A port enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,     -- 1-bit input: A port register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM, -- 1-bit input: A port set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG, -- 1-bit input: A port register set/reset
      WEA =&gt; WEA,                     -- 4-bit input: A port write enable
      -- Port A Data: 32-bit (each) input: Port A data
      DIADI =&gt; DIADI,                 -- 32-bit input: A port data/LSB data
      DIPADIP =&gt; DIPADIP,             -- 4-bit input: A port parity/LSB parity
      -- Port B Address/Control Signals: 16-bit (each) input: Port B address and control signals (write port
      -- when RAM_MODE="SDP")
      ADDRBWRADDR =&gt; ADDRBWRADDR,     -- 16-bit input: B port address/Write address
      CLKBWRCLK =&gt; CLKBWRCLK,         -- 1-bit input: B port clock/Write clock
      ENBWREN =&gt; ENBWREN,             -- 1-bit input: B port enable/Write enable
      REGCEB =&gt; REGCEB,               -- 1-bit input: B port register enable
      RSTRAMB =&gt; RSTRAMB,             -- 1-bit input: B port set/reset
      RSTREGB =&gt; RSTREGB,             -- 1-bit input: B port register set/reset
      WEBWE =&gt; WEBWE,                 -- 8-bit input: B port write enable/Write enable
      -- Port B Data: 32-bit (each) input: Port B data
      DIBDI =&gt; DIBDI,                 -- 32-bit input: B port data/MSB data
      DIPBDIP =&gt; DIPBDIP              -- 4-bit input: B port parity/MSB parity
   );

   -- End of RAMB36E1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Distributed RAM" treetype="folder">
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 x 1 negedge write (RAM32X1D_1)" treetype="template">

-- RAM32X1D_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_1_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D_1: 32 x 1 negative edge write, asynchronous read 
   --             dual-port distributed RAM (Mapped to SliceM LUT6)
   --             Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1_inst : RAM32X1D_1
   generic map (
      INIT =&gt; X"00000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_1_inst instantiation

						</Template>
						<Template label="32 x 1 posedge write (RAM32X1D)" treetype="template">

--   RAM32X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D: 32 x 1 positive edge write, asynchronous read 
   --              dual-port distributed RAM (Mapped to SliceM LUT6)
   --              Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_inst : RAM32X1D
   generic map (
      INIT =&gt; X"00000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_inst instantiation

						</Template>
						<Template label="64 x 1 negedge write (RAM64X1D_1)" treetype="template">

-- RAM64X1D_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1D: 64 x 1 negative edge write, asynchronous read 
   --           dual-port distributed RAM (Mapped to SliceM LUT6)
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1D_1_inst : RAM64X1D_1
   generic map (
      INIT =&gt; X"0000000000000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      A5 =&gt; A5,       -- R/W address[5] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      DPRA5 =&gt; DPRA5, -- Read-only address[5] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM64X1D_1_inst instantiation

						</Template>
						<Template label="64 x 1 posedge write (RAM64X1D)" treetype="template">

--   RAM64X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1D: 64 x 1 positive edge write, asynchronous read 
   --           dual-port distributed RAM (Mapped to SliceM LUT6)
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1D_inst : RAM64X1D
   generic map (
      INIT =&gt; X"0000000000000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      A5 =&gt; A5,       -- R/W address[5] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      DPRA5 =&gt; DPRA5, -- Read-only address[5] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM64X1D_inst instantiation

						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">

--  RAM128X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read 
   --            dual-port distributed LUT RAM (Mapped to two SliceM LUT6s)
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1D_inst : RAM128X1D
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      DPO =&gt; DPO,     -- Read/Write port 1-bit ouput
      SPO =&gt; SPO,     -- Read port 1-bit output
      A =&gt; A,         -- Read/Write port 7-bit address input
      D =&gt; D,         -- RAM data input
      DPRA =&gt; DPRA,   -- Read port 7-bit address input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1D_inst instantiation

						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">

--   RAM32M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M: 32-deep by 8-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s)
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32M_inst : RAM32M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000")   -- Initial contents of D port
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read/Write port D 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 5-bit address input
      DIA =&gt; DIA, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M_inst instantiation

						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">

--   RAM64M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64M: 64-deep by 4-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s) 
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64M_inst : RAM64M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000")   -- Initial contents of D port
   port map (
      DOA =&gt; DOA, -- Read port A 1-bit output
      DOB =&gt; DOB, -- Read port B 1-bit output
      DOC =&gt; DOC, -- Read port C 1-bit output
      DOD =&gt; DOD, -- Read/Write port D 1-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 6-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 6-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 6-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 6-bit address input
      DIA =&gt; DIA, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM64M_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<SubFolder label="32 Deep (5-bit address)" treetype="folder">
							<Template label="32 x 1 negedge write (RAM32X1S_1)" treetype="template">

-- RAM32X1S_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1S_1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1S_1: 32 x 1 negedge write distributed (LUT) RAM (Mapped to SliceM LUT6)
   --             Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1S_1_inst : RAM32X1S_1
   generic map (
      INIT =&gt; X"00000000")
   port map (
      O =&gt; O,       -- RAM output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D =&gt; D,       -- RAM data input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X1S_1_inst instantiation
							</Template>
							<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">

--  RAM32X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM (Mapped to SliceM LUT6)
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1S_inst : RAM32X1S
   generic map (
      INIT =&gt; X"00000000")
   port map (
      O =&gt; O,       -- RAM output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D =&gt; D,       -- RAM data input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X1S_inst instantiation
							</Template>
							<Template label="32 x 2 posedge write (RAM32X2S)" treetype="template">

--  RAM32X2S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM16X2S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X2S: 32 x 2 posedge write distributed (LUT) RAM (Mapped to SliceM LUT6)
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X2S_inst : RAM32X2S
   generic map (
      INIT_00 =&gt; X"00000000", --  INIT for bit 0 of RAM
      INIT_01 =&gt; X"00000000") --  INIT for bit 1 of RAM
   port map (
      O0 =&gt; O0,     -- RAM data[0] output
      O1 =&gt; O1,     -- RAM data[1] output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D0 =&gt; D0,     -- RAM data[0] input
      D1 =&gt; D1,     -- RAM data[1] input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X2S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="64 Deep (6-bit address)" treetype="folder">
							<Template label="64 X 1 negedge write (RAM64X1S_1)" treetype="template">

--  RAM64X1S_1 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1S_1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1S_1: 64 x 1 negative edge write, asynchronous read single-port distributed RAM (Mapped to SliceM LUT6)
   --             Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1S_1_inst : RAM64X1S_1
   generic map (
      INIT =&gt; X"0000000000000000")
   port map (
      O =&gt; O,        -- 1-bit data output
      A0 =&gt; A0,      -- Address[0] input bit
      A1 =&gt; A1,      -- Address[1] input bit
      A2 =&gt; A2,      -- Address[2] input bit
      A3 =&gt; A3,      -- Address[3] input bit
      A4 =&gt; A4,      -- Address[4] input bit
      A5 =&gt; A5,      -- Address[5] input bit
      D =&gt; D,        -- 1-bit data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64X1S_1_inst instantiation

							</Template>
							<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">

--  RAM64X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port distributed RAM (Mapped to SliceM LUT6)
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1S_inst : RAM64X1S
   generic map (
      INIT =&gt; X"0000000000000000")
   port map (
      O =&gt; O,        -- 1-bit data output
      A0 =&gt; A0,      -- Address[0] input bit
      A1 =&gt; A1,      -- Address[1] input bit
      A2 =&gt; A2,      -- Address[2] input bit
      A3 =&gt; A3,      -- Address[3] input bit
      A4 =&gt; A4,      -- Address[4] input bit
      A5 =&gt; A5,      -- Address[5] input bit
      D =&gt; D,        -- 1-bit data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="128 Deep (7-bit address)" treetype="folder">
							<Template label="128 x 1 negedge write (RAM128X1S_1)" treetype="template">

--RAM128X1S_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S_1: 128-deep x 1 negative edge write, asynchronous read 
   --              single-port distributed RAM (Mapped to SliceM LUT6)
   --              Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation

							</Template>
							<Template label="128 x 1 posedge write (RAM128X1S)" treetype="template">

--  RAM128X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S: 128-deep x 1 positive edge write, asynchronous read 
   --            single-port distributed RAM (Mapped to SliceM LUT6)
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation

							</Template>
						</SubFolder>
						<SubFolder label="256 Deep (8-bit address)" treetype="folder">
							<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">

--  RAM256X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM256X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read 
   --            single-port distributed LUT RAM (Mapped to four SliceM LUT6s)
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM256X1S_inst : RAM256X1S
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      O =&gt; O,  -- Read/Write port 1-bit ouput
      A =&gt; A,  -- Read/Write port 8-bit address input
      D =&gt; D,  -- RAM data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE -- Write enable input
   );

   -- End of RAM256X1S_inst instantiation

							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Distributed ROM" treetype="folder">
					<Template label="32 X 1 (ROM32X1)" treetype="template">

--   ROM32X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM32X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM32X1: 32 x 1 Asynchronous Distributed (LUT) ROM
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM32X1_inst : ROM32X1
   generic map (
      INIT =&gt; X"00000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4  -- ROM address[4]
   );
   -- End of ROM32X1_inst instantiation
					</Template>
					<Template label="64 X 1 (ROM64X1)" treetype="template">

--   ROM64X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM64X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM64X1: 64 x 1 Asynchronous Distributed (LUT) ROM
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM64X1_inst : ROM64X1
   generic map (
      INIT =&gt; X"0000000000000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4, -- ROM address[4]
      A5 =&gt; A5  -- ROM address[5]
   );

   -- End of ROM64X1_inst instantiation
					</Template>
					<Template label="128 X 1 (ROM128X1)" treetype="template">

--  ROM128X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM128X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM128X1: 128 x 1 Asynchronous Distributed (LUT) ROM
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM128X1_inst : ROM128X1
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4, -- ROM address[4]
      A5 =&gt; A5, -- ROM address[5]
      A6 =&gt; A6  -- ROM address[6]
   );

   -- End of ROM128X1_inst instantiation
					</Template>
					<Template label="256 X 1 (ROM256X1)" treetype="template">

--   ROM256X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM256X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM256X1: 256 x 1 Asynchronous Distributed (LUT) ROM
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM256X1_inst : ROM256X1
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4, -- ROM address[4]
      A5 =&gt; A5, -- ROM address[5]
      A6 =&gt; A6,  -- ROM address[6]
      A7 =&gt; A7  -- ROM address[7]
   );

   -- End of ROM256X1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E1)" treetype="template">
--  FIFO18E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO18E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO18E1: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   FIFO18E1_inst : FIFO18E1
   generic map (
      ALMOST_EMPTY_OFFSET =&gt; X"0080",   -- Sets the almost empty threshold
      ALMOST_FULL_OFFSET =&gt; X"0080",    -- Sets almost full threshold
      DATA_WIDTH =&gt; 4,                  -- Sets data width to 4-36
      DO_REG =&gt; 1,                      -- Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      EN_SYN =&gt; FALSE,                  -- Specifies FIFO as dual-clock (FALSE) or Synchronous (TRUE)
      FIFO_MODE =&gt; "FIFO18",            -- Sets mode to FIFO18 or FIFO18_36
      FIRST_WORD_FALL_THROUGH =&gt; FALSE, -- Sets the FIFO FWFT to FALSE, TRUE
      INIT =&gt; X"000000000",             -- Initial values on output port
      SIM_DEVICE =&gt; "7SERIES",          -- Must be set to "7SERIES" for simulation behavior
      SRVAL =&gt; X"000000000"             -- Set/Reset value for output port
   )
   port map (
      -- Read Data: 32-bit (each) output: Read output data
      DO =&gt; DO,                   -- 32-bit output: Data output
      DOP =&gt; DOP,                 -- 4-bit output: Parity data output
      -- Status: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY, -- 1-bit output: Almost empty flag
      ALMOSTFULL =&gt; ALMOSTFULL,   -- 1-bit output: Almost full flag
      EMPTY =&gt; EMPTY,             -- 1-bit output: Empty flag
      FULL =&gt; FULL,               -- 1-bit output: Full flag
      RDCOUNT =&gt; RDCOUNT,         -- 12-bit output: Read count
      RDERR =&gt; RDERR,             -- 1-bit output: Read error
      WRCOUNT =&gt; WRCOUNT,         -- 12-bit output: Write count
      WRERR =&gt; WRERR,             -- 1-bit output: Write error
      -- Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,             -- 1-bit input: Read clock
      RDEN =&gt; RDEN,               -- 1-bit input: Read enable
      REGCE =&gt; REGCE,             -- 1-bit input: Clock enable
      RST =&gt; RST,                 -- 1-bit input: Asynchronous Reset
      RSTREG =&gt; RSTREG,           -- 1-bit input: Output register set/reset
      -- Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      WRCLK =&gt; WRCLK,             -- 1-bit input: Write clock
      WREN =&gt; WREN,               -- 1-bit input: Write enable
      -- Write Data: 32-bit (each) input: Write input data
      DI =&gt; DI,                   -- 32-bit input: Data input
      DIP =&gt; DIP                  -- 4-bit input: Parity input
   );

   -- End of FIFO18E1_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E1)" treetype="template">
--  FIFO36E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO36E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO36E1: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   FIFO36E1_inst : FIFO36E1
   generic map (
      ALMOST_EMPTY_OFFSET =&gt; X"0080",   -- Sets the almost empty threshold
      ALMOST_FULL_OFFSET =&gt; X"0080",    -- Sets almost full threshold
      DATA_WIDTH =&gt; 4,                  -- Sets data width to 4-72
      DO_REG =&gt; 1,                      -- Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      EN_ECC_READ =&gt; FALSE,             -- Enable ECC decoder, FALSE, TRUE
      EN_ECC_WRITE =&gt; FALSE,            -- Enable ECC encoder, FALSE, TRUE
      EN_SYN =&gt; FALSE,                  -- Specifies FIFO as Asynchronous (FALSE) or Synchronous (TRUE)
      FIFO_MODE =&gt; "FIFO36",            -- Sets mode to "FIFO36" or "FIFO36_72" 
      FIRST_WORD_FALL_THROUGH =&gt; FALSE, -- Sets the FIFO FWFT to FALSE, TRUE
      INIT =&gt; X"000000000000000000",    -- Initial values on output port
      SIM_DEVICE =&gt; "7SERIES",          -- Must be set to "7SERIES" for simulation behavior
      SRVAL =&gt; X"000000000000000000"    -- Set/Reset value for output port
   )
   port map (
      -- ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Read Data: 64-bit (each) output: Read output data
      DO =&gt; DO,                       -- 64-bit output: Data output
      DOP =&gt; DOP,                     -- 8-bit output: Parity data output
      -- Status: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY,     -- 1-bit output: Almost empty flag
      ALMOSTFULL =&gt; ALMOSTFULL,       -- 1-bit output: Almost full flag
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty flag
      FULL =&gt; FULL,                   -- 1-bit output: Full flag
      RDCOUNT =&gt; RDCOUNT,             -- 13-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      WRCOUNT =&gt; WRCOUNT,             -- 13-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write error
      -- ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error input
      INJECTSBITERR =&gt; INJECTSBITERR,
      -- Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Clock enable
      RST =&gt; RST,                     -- 1-bit input: Reset
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register set/reset
      -- Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Rising edge write clock.
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data: 64-bit (each) input: Write input data
      DI =&gt; DI,                       -- 64-bit input: Data input
      DIP =&gt; DIP                      -- 8-bit input: Parity input
   );

   -- End of FIFO36E1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Registers &amp; Latches" treetype="folder">
				<SubFolder label="Double Data Rate" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
--    IDDR_2CLK  : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The
--   declaration : instance name (IDDR_2CLK_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design.  All inputs must be 
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   --            Set, Reset and Clock Enable.
   --            Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK_inst : IDDR_2CLK 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit primary clock input
      CB =&gt; CB, -- 1-bit secondary clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_2CLK_inst instantiation

					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
--      IDDR     : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The 
--   declaration : instance name (IDDR_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design. All inputs must be
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR: Double Data Rate Input Register with Set, Reset
   --       and Clock Enable. 
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_inst : IDDR 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_inst instantiation

					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
--      ODDR       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (ODDR_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs  
--                 : and outputs must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDR: Output Double Data Rate Output Register with Set, Reset
   --       and Clock Enable. 
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   ODDR_inst : ODDR
   generic map(
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE" or "SAME_EDGE" 
      INIT =&gt; '0',   -- Initial value for Q port ('1' or '0')
      SRTYPE =&gt; "SYNC") -- Reset Type ("ASYNC" or "SYNC")
   port map (
      Q =&gt; Q,   -- 1-bit DDR output
      C =&gt; C,    -- 1-bit clock input
      CE =&gt; CE,  -- 1-bit clock enable input
      D1 =&gt; D1,  -- 1-bit data input (positive edge)
      D2 =&gt; D2,  -- 1-bit data input (negative edge)
      R =&gt; R,    -- 1-bit reset input
      S =&gt; S     -- 1-bit set input
   );
  
   -- End of ODDR_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Single Data Rate" treetype="folder">
					<Template label="Posedge D-FF /w Async Clear, and CE (FDCE)" treetype="template">

--    FDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDCE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and
   --       Clock Enable (posedge clk).  
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDCE_inst : FDCE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      CLR =&gt; CLR,  -- Asynchronous clear input
      D =&gt; D       -- Data input
   );
  
   -- End of FDCE_inst instantiation
					</Template>
					<Template label="Posedge D-FF /w Async Preset, and CE (FDPE)" treetype="template">

--    FDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDPE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDPE: Single Data Rate D Flip-Flop with Asynchronous Preset and
   --       Clock Enable (posedge clk).  
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDPE_inst : FDPE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      PRE =&gt; PRE,  -- Asynchronous preset input
      D =&gt; D       -- Data input
   );
  
   -- End of FDPE_inst instantiation
					</Template>
					<Template label="Posedge D-FF /w Sync Reset, and CE (FDRE)" treetype="template">

--    FDRE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDRE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
   --       Clock Enable (posedge clk).  
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDRE_inst : FDRE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      R =&gt; R,      -- Synchronous reset input
      D =&gt; D       -- Data input
   );
  
   -- End of FDRE_inst instantiation

					</Template>
					<Template label="Posedge D-FF /w Sync Set, and CE (FDSE)" treetype="template">

--    FDSE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDSE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDSE: Single Data Rate D Flip-Flop with Synchronous Set and
   --       Clock Enable (posedge clk).  
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDSE_inst : FDSE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      S =&gt; S,      -- Synchronous Set input
      D =&gt; D       -- Data input
   );
  
   -- End of FDSE_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Transparent Latch" treetype="folder">
					<Template label="Latch with Async Reset and Gate Enable (LDCE)" treetype="template">

--    LDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LDCE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDCE: Transparent latch with Asynchronous Reset and
   --        Gate Enable.
   --        Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LDCE_inst : LDCE
   generic map (
      INIT =&gt; '0') -- Initial value of latch ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      CLR =&gt; CLR,  -- Asynchronous clear/reset input
      D =&gt; D,      -- Data input
      G =&gt; G,      -- Gate input
      GE =&gt; GE     -- Gate enable input
   );

   -- End of LDCE_inst instantiation

					</Template>
					<Template label="Latch with Async Set and Gate Enable (LDPE)" treetype="template">

--    LDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LDPE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDPE:  Transparent latch with Asynchronous Set and
   --        Gate Enable.
   --        Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LDPE_inst : LDPE
   generic map (
      INIT =&gt; '0') -- Initial value of latch ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      CLR =&gt; CLR,  -- Asynchronous preset/set input
      D =&gt; D,      -- Data input
      G =&gt; G,      -- Gate input
      GE =&gt; GE     -- Gate enable input
   );

   -- End of LDPE_inst instantiation

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Slice/CLB Primitives" treetype="folder">
				<Template label="Carry (CARRY4)" treetype="template">
--    CARRY4       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (CARRY4_inst) and/or the port declarations after the
--      code       : "=&gt;" assignment maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and 
--                 : outputs of this primitive must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CARRY4: Fast Carry Logic Component
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   CARRY4_inst : CARRY4
   port map (
      CO =&gt; CO,         -- 4-bit carry out
      O =&gt; O,           -- 4-bit carry chain XOR data out
      CI =&gt; CI,         -- 1-bit carry cascade input
      CYINIT =&gt; CYINIT, -- 1-bit carry initialization
      DI =&gt; DI,         -- 4-bit carry-MUX data in
      S =&gt; S            -- 4-bit carry-MUX select input
   );

   -- End of CARRY4_inst instantiation

				</Template>
				<SubFolder label="LUTs" treetype="folder">
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
-- The INIT constant for the FPGA LUT primitive is what gives the LUT its 
-- logical value. By default this value is zero thus driving the output to a  
-- zero regardless of the input values (acting as a ground) however in most 
-- cases an new INIT value must be determined in order to specify the logic 
-- function for the LUT primitive.  There are a few methods in which the LUT 
-- value can be determined and two of those methods will be discussed here.
--
-- The Truth Table Method
-- ----------------------
--
--  A common method to determine the desired INIT value for a LUT is using a 
-- truth table.  To do so, simply create a binary truth table of all possible 
-- inputs, specify the desired logic value of the output and then create the 
-- INIT string from those output values.  An example is shown below:
--
-- Example of determining an XOR INIT equation for a LUT4:
--
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | 0 |\
--     |  0  0  0  1 | 1 | \ = 0110 = 6 -----------+
--     |  0  0  1  0 | 1 | /                       |
--     |  0  0  1  1 | 0 |/                        |
--     |-------------|---|                         |
--     |  0  1  0  0 | 1 |\                        |
--     |  0  1  0  1 | 0 | \ = 1001 = 9            |
--     |  0  1  1  0 | 0 | /                       |
--     |  0  1  1  1 | 1 |/                        |                     
--     |-------------|---|               INIT = 6996
--     |  1  0  0  0 | 1 |\                     |
--     |  1  0  0  1 | 0 | \ = 0110 = 9         |
--     |  1  0  1  0 | 0 | /                    |
--     |  1  0  1  1 | 1 |/                     |
--     |-------------|---|                      |
--     |  1  1  0  0 | 0 |\                     |
--     |  1  1  0  1 | 1 | \ = 1001 = 6---------+
--     |  1  1  1  0 | 1 | /
--     |  1  1  1  1 | 0 |/
--     -------------------
--
-- Example of determining a 3-input AND gate:
--
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | 0 |\
--     |  0  0  1 | 0 | \ = 0000 = 0 -----------+
--     |  0  1  0 | 0 | /                       |
--     |  0  1  1 | 0 |/                        |
--     |----------|---|                 INIT = 80 
--     |  1  0  0 | 0 |\                       |
--     |  1  0  1 | 0 | \ = 1000 = 8-----------+
--     |  1  1  0 | 0 | / 
--     |  1  1  1 | 1 |/                      
--     ----------------
--
-- The Equation Method
-- -------------------
--
-- Another method to determine the LUT value is to define constants for each 
-- input to the LUT that correspond to their listed truth value and use those to
-- build the logic equation you are after.  This method is easier to understand 
-- once you have grasped the concept and more self-documenting that the above 
-- method however does require the code to first specify the appropriate 
-- constants.  See the example below.
--
-- Example of specifying the equation (A and B) or (C and D) for a LUT4:
--
   -- The following constants are defined to allow for
   --   equation-based INIT specification.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00"; 


   -- LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; (I3 and I2) or (I1 and I0))
   port map (
      O =&gt; O_LUT,   -- LUT general output
      I0 =&gt; A, -- LUT input
      I1 =&gt; B, -- LUT input
      I2 =&gt; C, -- LUT input
      I3 =&gt; D  -- LUT input
   );
   -- End of LUT4_inst instantiation

-- With the constants specifying all possible cases for the truth table, a 
-- VHDL equation can be written to determine the end INIT value.

						</Template>
						<SubFolder label="INIT Constants" treetype="folder">
							<Template label="LUT1" treetype="template">
   -- The following constant is defined to allow for
   --   equation-based INIT specification for a LUT1.
   constant I0 : BIT_VECTOR(1 downto 0) := "10";
   -- The following constant is defined to allow for
   --   equation-based INIT specification for a LUT1.
   constant I0 : BIT_VECTOR(1 downto 0) := "10";
							</Template>
							<Template label="LUT2" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT2.
   constant I0 : BIT_VECTOR(3 downto 0) := X"A";
   constant I1 : BIT_VECTOR(3 downto 0) := X"C";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT2.
   constant I0 : BIT_VECTOR(3 downto 0) := X"A";
   constant I1 : BIT_VECTOR(3 downto 0) := X"C";
							</Template>
							<Template label="LUT3" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT3.
   constant I0 : BIT_VECTOR(7 downto 0) := X"AA";
   constant I1 : BIT_VECTOR(7 downto 0) := X"CC";
   constant I2 : BIT_VECTOR(7 downto 0) := X"F0";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT3.
   constant I0 : BIT_VECTOR(7 downto 0) := X"AA";
   constant I1 : BIT_VECTOR(7 downto 0) := X"CC";
   constant I2 : BIT_VECTOR(7 downto 0) := X"F0";
							</Template>
							<Template label="LUT4" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT4.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT4.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";
							</Template>
							<Template label="LUT5" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT5.
   constant I0 : BIT_VECTOR(31 downto 0) := X"AAAAAAAA";
   constant I1 : BIT_VECTOR(31 downto 0) := X"CCCCCCCC";
   constant I2 : BIT_VECTOR(31 downto 0) := X"F0F0F0F0";
   constant I3 : BIT_VECTOR(31 downto 0) := X"FF00FF00";
   constant I4 : BIT_VECTOR(31 downto 0) := X"FFFF0000";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT5.
   constant I0 : BIT_VECTOR(31 downto 0) := X"AAAAAAAA";
   constant I1 : BIT_VECTOR(31 downto 0) := X"CCCCCCCC";
   constant I2 : BIT_VECTOR(31 downto 0) := X"F0F0F0F0";
   constant I3 : BIT_VECTOR(31 downto 0) := X"FF00FF00";
   constant I4 : BIT_VECTOR(31 downto 0) := X"FFFF0000";
							</Template>
							<Template label="LUT6" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT6.
   constant I0 : BIT_VECTOR(63 downto 0) := X"AAAAAAAAAAAAAAAA";
   constant I1 : BIT_VECTOR(63 downto 0) := X"CCCCCCCCCCCCCCCC";
   constant I2 : BIT_VECTOR(63 downto 0) := X"F0F0F0F0F0F0F0F0";
   constant I3 : BIT_VECTOR(63 downto 0) := X"FF00FF00FF00FF00";
   constant I4 : BIT_VECTOR(63 downto 0) := X"FFFF0000FFFF0000";
   constant I5 : BIT_VECTOR(63 downto 0) := X"FFFFFFFF00000000";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT6.
   constant I0 : BIT_VECTOR(63 downto 0) := X"AAAAAAAAAAAAAAAA";
   constant I1 : BIT_VECTOR(63 downto 0) := X"CCCCCCCCCCCCCCCC";
   constant I2 : BIT_VECTOR(63 downto 0) := X"F0F0F0F0F0F0F0F0";
   constant I3 : BIT_VECTOR(63 downto 0) := X"FF00FF00FF00FF00";
   constant I4 : BIT_VECTOR(63 downto 0) := X"FFFF0000FFFF0000";
   constant I5 : BIT_VECTOR(63 downto 0) := X"FFFFFFFF00000000";
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
--  Truth Table to determine INIT value for a LUT1
--      ________
--     | I0 | O |
--     |--------|
--     |  0 | ? |\
--     |  1 | ? |/ = 2'b??
--     ----------
--  Truth Table to determine INIT value for a LUT1
--      ________
--     | I0 | O |
--     |--------|
--     |  0 | ? |\
--     |  1 | ? |/ = 2'b??
--     ----------
							</Template>
							<Template label="LUT2" treetype="template">
--  Truth Table to determine INIT value for a LUT2
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
--     |  0  1  0 | ? | /
--     |  0  1  1 | ? |/ 
--      ---------- --- 
--  Truth Table to determine INIT value for a LUT2
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
--     |  0  1  0 | ? | /
--     |  0  1  1 | ? |/ 
--      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
--  Truth Table to determine INIT value for a LUT3
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
--     |  0  1  0 | ? | /                                |
--     |  0  1  1 | ? |/                                 |
--     |----------|---|                       INIT = 8'h?? 
--     |  1  0  0 | ? |\                                |
--     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
--     |  1  1  0 | ? | / 
--     |  1  1  1 | ? |/                      
--     ----------------
--  Truth Table to determine INIT value for a LUT3
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
--     |  0  1  0 | ? | /                                |
--     |  0  1  1 | ? |/                                 |
--     |----------|---|                       INIT = 8'h?? 
--     |  1  0  0 | ? |\                                |
--     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
--     |  1  1  0 | ? | / 
--     |  1  1  1 | ? |/                      
--     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
--  Truth Table to determine INIT value for a LUT4
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | ? |\
--     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
--     |  0  0  1  0 | ? | /                                 |
--     |  0  0  1  1 | ? |/                                  |
--     |-------------|---|                                   |
--     |  0  1  0  0 | ? |\                                  |
--     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
--     |  0  1  1  0 | ? | /                                 |
--     |  0  1  1  1 | ? |/                                  |                     
--     |-------------|---|                     INIT = 16'h????
--     |  1  0  0  0 | ? |\                               |
--     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  0 | ? | /                              |
--     |  1  0  1  1 | ? |/                               |
--     |-------------|---|                                |
--     |  1  1  0  0 | ? |\                               |
--     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  0 | ? | /
--     |  1  1  1  1 | ? |/
--     -------------------
--  Truth Table to determine INIT value for a LUT4
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | ? |\
--     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
--     |  0  0  1  0 | ? | /                                 |
--     |  0  0  1  1 | ? |/                                  |
--     |-------------|---|                                   |
--     |  0  1  0  0 | ? |\                                  |
--     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
--     |  0  1  1  0 | ? | /                                 |
--     |  0  1  1  1 | ? |/                                  |                     
--     |-------------|---|                     INIT = 16'h????
--     |  1  0  0  0 | ? |\                               |
--     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  0 | ? | /                              |
--     |  1  0  1  1 | ? |/                               |
--     |-------------|---|                                |
--     |  1  1  0  0 | ? |\                               |
--     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  0 | ? | /
--     |  1  1  1  1 | ? |/
--     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
--  Truth Table to determine INIT value for a LUT5
--      ____________________
--     | I4 I3 I2 I1 I0 | O |
--     |--------------------|
--     |  0  0  0  0  0 | ? |\
--     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  0  1  0  0 | ? |\                                      |
--     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1 | ? |/                                      |                     
--     |----------------|---|                                       |
--     |  0  1  0  0  0 | ? |\                                      |
--     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  0 | ? | /                                     |
--     |  0  1  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  1  0  0 | ? |\                                      |
--     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1 | ? |/                                      |
--     ----------------------                     INIT = 32'h????????
--     |  1  0  0  0  0 | ? |\                               |
--     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  0  1  0 | ? | /                              |
--     |  1  0  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  0  1  0  0 | ? |\                               |
--     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  1  0 | ? | /                              |
--     |  1  0  1  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  0  0  0 | ? |\                               |
--     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  1  0  1  0 | ? | /                              |
--     |  1  1  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  1  0  0 | ? |\                               |
--     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1 | ? |/
--     ----------------------
--  Truth Table to determine INIT value for a LUT5
--      ____________________
--     | I4 I3 I2 I1 I0 | O |
--     |--------------------|
--     |  0  0  0  0  0 | ? |\
--     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  0  1  0  0 | ? |\                                      |
--     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1 | ? |/                                      |                     
--     |----------------|---|                                       |
--     |  0  1  0  0  0 | ? |\                                      |
--     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  0 | ? | /                                     |
--     |  0  1  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  1  0  0 | ? |\                                      |
--     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1 | ? |/                                      |
--     ----------------------                     INIT = 32'h????????
--     |  1  0  0  0  0 | ? |\                               |
--     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  0  1  0 | ? | /                              |
--     |  1  0  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  0  1  0  0 | ? |\                               |
--     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  1  0 | ? | /                              |
--     |  1  0  1  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  0  0  0 | ? |\                               |
--     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  1  0  1  0 | ? | /                              |
--     |  1  1  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  1  0  0 | ? |\                               |
--     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1 | ? |/
--     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
--  Truth Table to determine INIT value for a LUT6
--      _______________________
--     | I5 I4 I3 I2 I1 I0 | O |
--     |-----------------------|
--     |  0  0  0  0  0  0 | ? |\
--     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  0  1  0  0 | ? |\                                      |
--     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  0  1  1  0 | ? | /                                     |
--     |  0  0  0  1  1  1 | ? |/                                      |                     
--     |-------------------|---|                                       |
--     |  0  0  1  0  0  0 | ? |\                                      |
--     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  0  1  0 | ? | /                                     |
--     |  0  0  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  1  0  0 | ? |\                                      |
--     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1  1 | ? |/                                      |
--     -------------------------                                       |
--     |  0  1  0  0  0  0 | ? |\                                      |
--     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  0  1  0 | ? | /                                     |
--     |  0  1  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  0  1  0  0 | ? |\                                      |
--     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  1  0 | ? | /                                     |
--     |  0  1  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  0  0  0 | ? |\                                      |
--     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  0  1  0 | ? | /                                     |
--     |  0  1  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  1  0  0 | ? |\                                      |
--     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1  1 | ? |/                                      |
--     ------------------------              INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     ------------------------




--  Truth Table to determine INIT value for a LUT6
--      _______________________
--     | I5 I4 I3 I2 I1 I0 | O |
--     |-----------------------|
--     |  0  0  0  0  0  0 | ? |\
--     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  0  1  0  0 | ? |\                                      |
--     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  0  1  1  0 | ? | /                                     |
--     |  0  0  0  1  1  1 | ? |/                                      |                     
--     |-------------------|---|                                       |
--     |  0  0  1  0  0  0 | ? |\                                      |
--     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  0  1  0 | ? | /                                     |
--     |  0  0  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  1  0  0 | ? |\                                      |
--     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1  1 | ? |/                                      |
--     -------------------------                                       |
--     |  0  1  0  0  0  0 | ? |\                                      |
--     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  0  1  0 | ? | /                                     |
--     |  0  1  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  0  1  0  0 | ? |\                                      |
--     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  1  0 | ? | /                                     |
--     |  0  1  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  0  0  0 | ? |\                                      |
--     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  0  1  0 | ? | /                                     |
--     |  0  1  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  1  0  0 | ? |\                                      |
--     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1  1 | ? |/                                      |
--     ------------------------              INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT1" treetype="template">

--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; "00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_inst instantiation


--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-input Look-Up Table with general output
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; "00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_inst instantiation

					</Template>
					<Template label="LUT1_D" treetype="template">

--   LUT1_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_D: 1-input Look-Up Table with general and local outputs
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_D_inst : LUT1_D
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_D_inst instantiation

--     -------------------
--
-- Example of determining a 3-input AND gate:
--
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | 0 |\
--     |  0  0  1 | 0 | \ = 0000 = 0 -----------+
--     |  0  1  0 | 0 | /                       |
--     |  0  1  1 | 0 |/                        |
--     |----------|---|                 INIT = 80 
--     |  1  0  0 | 0 |\                       |
--     |  1  0  1 | 0 | \ = 1000 = 8-----------+
--     |  1  1  0 | 0 | / 
--     |  1  1  1 | 1 |/                      
--     ----------------
--
-- The Equation Method
-- -------------------
--
-- Another method to determine the LUT value is to define constants for each 
-- input to the LUT that correspond to their listed truth value and use those to
-- build the logic equation you are after.  This method is easier to understand 
-- once you have grasped the concept and more self-documenting that the above 
-- method however does require the code to first specify the appropriate 
-- constants.  See the example below.
--
-- Example of specifying the equation (A and B) or (C and D) for a LUT4:
--
   -- The following constants are defined to allow for
   --   equation-based INIT specification.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00"; 


   -- LUT4: 4-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; (I3 and I2) or (I1 and I0))
   port map (
      O =&gt; O_LUT,   -- LUT general output
      I0 =&gt; A, -- LUT input
      I1 =&gt; B, -- LUT input
      I2 =&gt; C, -- LUT input
      I3 =&gt; D  -- LUT input
   );
   -- End of LUT4_inst instantiation

-- With the constants specifying all possible cases for the truth table, a 
-- VHDL equation can be written to determine the end INIT value.


--   LUT1_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_D: 1-input Look-Up Table with general and local outputs
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_D_inst : LUT1_D
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_D_inst instantiation

					</Template>
					<Template label="LUT1_L" treetype="template">

--   LUT1_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_L: 1-input Look-Up Table with local output
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_L_inst : LUT1_L
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_L_inst instantiation


--   LUT1_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_L: 1-input Look-Up Table with local output
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_L_inst : LUT1_L
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_L_inst instantiation

					</Template>
					<Template label="LUT2" treetype="template">

--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_inst instantiation


--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-input Look-Up Table with general output
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_inst instantiation

					</Template>
					<Template label="LUT2_D" treetype="template">

--   LUT2_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_D: 2-input Look-Up Table with general and local outputs
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_D_inst : LUT2_D
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_D_inst instantiation


--   LUT2_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_D: 2-input Look-Up Table with general and local outputs
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_D_inst : LUT2_D
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_D_inst instantiation

					</Template>
					<Template label="LUT2_L" treetype="template">

--   LUT2_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_L: 2-input Look-Up Table with local output
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_L_inst : LUT2_L
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_L_inst instantiation


--   LUT2_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_L: 2-input Look-Up Table with local output
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_L_inst : LUT2_L
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_L_inst instantiation

					</Template>
					<Template label="LUT3" treetype="template">

--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2  -- LUT input
   );

   -- End of LUT3_inst instantiation


--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-input Look-Up Table with general output (Mapped to a LUT6)
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2  -- LUT input
   );

   -- End of LUT3_inst instantiation

					</Template>
					<Template label="LUT3_D" treetype="template">

--   LUT3_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_D: 3-input Look-Up Table with general and local outputs
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_D_inst : LUT3_D
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,  -- LUT local output
      O =&gt; O,    -- LUT general output
      I0 =&gt; I0,  -- LUT input
      I1 =&gt; I1,  -- LUT input
      I2 =&gt; I2   -- LUT input
   );

   -- End of LUT3_D_inst instantiation


--   LUT3_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_D: 3-input Look-Up Table with general and local outputs
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_D_inst : LUT3_D
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,  -- LUT local output
      O =&gt; O,    -- LUT general output
      I0 =&gt; I0,  -- LUT input
      I1 =&gt; I1,  -- LUT input
      I2 =&gt; I2   -- LUT input
   );

   -- End of LUT3_D_inst instantiation

					</Template>
					<Template label="LUT3_L" treetype="template">

--   LUT3_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_L: 3-input Look-Up Table with local output
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_L_inst : LUT3_L
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,   -- LUT local output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2    -- LUT input
   );

   -- End of LUT3_L_inst instantiation


--   LUT3_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_L: 3-input Look-Up Table with local output
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_L_inst : LUT3_L
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,   -- LUT local output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2    -- LUT input
   );

   -- End of LUT3_L_inst instantiation

					</Template>
					<Template label="LUT4" treetype="template">

--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_inst instantiation


--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-input Look-Up Table with general output
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_inst instantiation

					</Template>
					<Template label="LUT4_D" treetype="template">

--   LUT4_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_D: 4-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_D_inst : LUT4_D
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_D_inst instantiation


--   LUT4_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_D: 4-input Look-Up Table with general and local outputs
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_D_inst : LUT4_D
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_D_inst instantiation
					</Template>
					<Template label="LUT4_L" treetype="template">

--   LUT4_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_L: 4-input Look-Up Table with local output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_L_inst : LUT4_L
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_L_inst instantiation


--   LUT4_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_L: 4-input Look-Up Table with local output
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_L_inst : LUT4_L
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_L_inst instantiation

					</Template>
					<Template label="LUT5" treetype="template">

--    LUT5     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT5_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5: 5-input Look-Up Table with general output (Mapped to SliceM LUT6)
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_inst : LUT5
   generic map (
      INIT =&gt; X"00000000") -- Specify LUT Contents
   port map (
      O =&gt; O,  -- LUT general output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2,   -- LUT input
      I3 =&gt; I3,   -- LUT input
      I4 =&gt; I4    -- LUT input 
   );

   -- End of LUT5_inst instantiation

					</Template>
					<Template label="LUT5_D" treetype="template">

--   LUT5_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT5_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5_D: 5-input Look-Up Table with general and local outputs (Mapped to SliceM LUT6)
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_D_inst : LUT5_D
   generic map (
      INIT =&gt; X"00000000") -- Specify LUT contents
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4  -- LUT input
   );

   -- End of LUT5_D_inst instantiation

					</Template>
					<Template label="LUT5_L" treetype="template">

--   LUT5_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT5_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5_L: 5-input Look-Up Table with local output (Mapped to SliceM LUT6)
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_L_inst : LUT5_L
   generic map (
      INIT =&gt; X"00000000") -- Specify LUT Contents
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4  -- LUT input
   );

   -- End of LUT5_L_inst instantiation

					</Template>
					<Template label="LUT6" treetype="template">

--    LUT6     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6: 6-input Look-Up Table with general output
   --       Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_inst : LUT6
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      O =&gt; O,  -- LUT general output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2,   -- LUT input
      I3 =&gt; I3,   -- LUT input
      I4 =&gt; I4,   -- LUT input
      I5 =&gt; I5    -- LUT input 
   );

   -- End of LUT6_inst instantiation

					</Template>
					<Template label="LUT6_D" treetype="template">

--   LUT6_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_D: 6-input Look-Up Table with general and local outputs
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_D_inst : LUT6_D
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT contents
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4, -- LUT input
      I5 =&gt; I5 -- LUT input
   );

   -- End of LUT6_D_inst instantiation
					</Template>
					<Template label="LUT6_L" treetype="template">

--   LUT6_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_L: 6-input Look-Up Table with local output
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_L_inst : LUT6_L
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4, -- LUT input
      I5 =&gt; I5  -- LUT input
   );

   -- End of LUT6_L_inst instantiation

					</Template>
					<Template label="LUT6_2" treetype="template">

--   LUT6_2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_2: 6-input  2 output Look-Up Table
   --         Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_2_inst : LUT6_2
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      O6 =&gt; O6,  -- 6/5-LUT output (1-bit)
      O5 =&gt; O5,  -- 5-LUT output (1-bit)
      I0 =&gt; I0,   -- LUT input (1-bit)
      I1 =&gt; I1,   -- LUT input (1-bit)
      I2 =&gt; I2,   -- LUT input (1-bit)
      I3 =&gt; I3,   -- LUT input (1-bit)
      I4 =&gt; I4,   -- LUT input (1-bit)
      I5 =&gt; I5    -- LUT input (1-bit)
   );

   -- End of LUT6_2_inst instantiation

					</Template>
					<Template label="Reconfigurable LUT (CFGLUT5)" treetype="template">
--     CFGLUT5     : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (CFGLUT5_inst) and/or the port declarations after the
--      code       : "=&gt;" assignment maybe changed to properly reference and
--                 : connect this function to the design.  All inputs
--                 : and outputs must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CFGLUT5: Reconfigurable 5-input LUT (Mapped to SliceM LUT6) 
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   CFGLUT5_inst : CFGLUT5
   generic map (
      INT =&gt; X"00000000")
   port map (
      CDO =&gt; CDO, -- Reconfiguration cascade output
      O5 =&gt; O5,   -- 4-LUT output
      O6 =&gt; O6,   -- 5-LUT output
      CDI =&gt; CDI, -- Reconfiguration data input
      CE =&gt; CE,   -- Reconfiguration enable input
      CLK =&gt; CLK, -- Clock input
      I0 =&gt; I0,   -- Logic data input
      I1 =&gt; I1,   -- Logic data input
      I2 =&gt; I2,   -- Logic data input
      I3 =&gt; I3,   -- Logic data input
      I4 =&gt; I4    -- Logic data input
   );

   -- End of CFGLUT5_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUXFx" treetype="folder">
					<Template label="MUXF7" treetype="template">

--    MUXF7    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF7_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7: CLB MUX to tie two LUT6's together with general output
   --        Kintex-7 
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_inst : MUXF7
   port map (
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to LUT6 O6 pin)
      I1 =&gt; I1,  -- Input (tie to LUT6 O6 pin)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF7_inst instantiation

					</Template>
					<Template label="MUXF7_D" treetype="template">

--   MUXF7_D   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF7_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7_D: CLB MUX to tie two LUT6's together with general and local outputs
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_D_inst : MUXF7_D
   port map (
      LO =&gt; LO,  -- Ouptut of MUX to local routing
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to LUT6 O6 pin)
      I1 =&gt; I1,  -- Input (tie to LUT6 O6 pin)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF7_D_inst instantiation

					</Template>
					<Template label="MUXF7_L" treetype="template">

--   MUXF7_L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF7_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7_L: CLB MUX to tie two LUT6's together with local output
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_L_inst : MUXF7_L
   port map (
      LO =&gt; LO,  -- Output of MUX to local routing
      I0 =&gt; I0,  -- Input (tie to LUT6 O6 pin)
      I1 =&gt; I1,  -- Input (tie to LUT6 O6 pin)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF7_L_inst instantiation

					</Template>
					<Template label="MUXF8" treetype="template">

--    MUXF8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF8_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8: CLB MUX to tie two MUXF7's together with general output
   --        Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_inst : MUXF8
   port map (
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to MUXF7 L/LO out)
      I1 =&gt; I1,  -- Input (tie to MUXF7 L/LO out)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF8_inst instantiation

					</Template>
					<Template label="MUXF8_D" treetype="template">

--   MUXF8_D   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF8_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8_D: CLB MUX to tie two MUXF7's together with general and local outputs
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_D_inst : MUXF8_D
   port map (
      LO =&gt; LO,  -- Ouptut of MUX to local routing
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to MUXF7 L/LO out)
      I1 =&gt; I1,  -- Input (tie to MUXF7 L/LO out)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF8_D_inst instantiation

					</Template>
					<Template label="MUXF8_L" treetype="template">

--   MUXF8_L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF8_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8_L: CLB MUX to tie two MUXF7's together with local output
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_L_inst : MUXF8_L
   port map (
      LO =&gt; LO,  -- Output of MUX to local routing
      I0 =&gt; I0,  -- Input (tie to MUXF7 L/LO out)
      I1 =&gt; I1,  -- Input (tie to MUXF7 L/LO out)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF8_L_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Shift Register LUT" treetype="folder">
					<Template label="16-bit /w CE posedge SR (SRL16E)" treetype="template">

--   SRL16E    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (SRL16E_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRL16E: 16-bit shift register LUT with clock enable operating on posedge of clock (Mapped to SliceM LUT6)
   --        Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   SRL16E_inst : SRL16E
   generic map (
      INIT =&gt; X"0000")
   port map (
      Q =&gt; Q,       -- SRL data output
      A0 =&gt; A0,     -- Select[0] input
      A1 =&gt; A1,     -- Select[1] input
      A2 =&gt; A2,     -- Select[2] input
      A3 =&gt; A3,     -- Select[3] input
      CE =&gt; CE,     -- Clock enable input
      CLK =&gt; CLK,   -- Clock input
      D =&gt; D        -- SRL data input
   );

   -- End of SRL16E_inst instantiation

					</Template>
					<Template label="32-bit /w CE posedge SR (SRLC32E)" treetype="template">

--   SRLC32E   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (SRLC32E_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRLC32E: 32-bit variable length shift register LUT
   --          with clock enable (Mapped to a SliceM LUT6)
   --          Kintex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   SRLC32E_inst : SRLC32E
   generic map (
      INIT =&gt; X"00000000")
   port map (
      Q =&gt; Q,        -- SRL data output
      Q31 =&gt; Q31,    -- SRL cascade output pin
      A =&gt; A,        -- 5-bit shift depth select input
      CE =&gt; CE,      -- Clock enable input
      CLK =&gt; CLK,    -- Clock input
      D =&gt; D         -- SRL data input
   );

   -- End of SRLC32E_inst instantiation

					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Virtex UltraScale" treetype="folder">
			<SubFolder label="ADVANCED" treetype="folder">
				<SubFolder label="GT" treetype="folder">
					<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE3)" treetype="template">
-- IBUFDS_GTE3 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_GTE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_GTE3: Gigabit Transceiver Buffer
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE3_inst : IBUFDS_GTE3
   generic map (
      REFCLK_EN_TX_PATH =&gt; '0',   -- Refer to Transceiver User Guide
      REFCLK_HROW_CK_SEL =&gt; "00", -- Refer to Transceiver User Guide
      REFCLK_ICNTL_RX =&gt; "00"     -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,         -- 1-bit output: Refer to Transceiver User Guide
      ODIV2 =&gt; ODIV2, -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,     -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,         -- 1-bit input: Refer to Transceiver User Guide
      IB =&gt; IB        -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of IBUFDS_GTE3_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE3_ADV)" treetype="template">
-- OBUFDS_GTE3_ADV : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (OBUFDS_GTE3_ADV_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_GTE3_ADV: Gigabit Transceiver Buffer
   --                  Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE3_ADV_inst : OBUFDS_GTE3_ADV
   generic map (
      REFCLK_EN_TX_PATH =&gt; '1',   -- Refer to Transceiver User Guide
      REFCLK_ICNTL_TX =&gt; "00000"  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,                       -- 1-bit output: Refer to Transceiver User Guide
      OB =&gt; OB,                     -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,                   -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,                       -- 4-bit input: Refer to Transceiver User Guide
      RXRECCLK_SEL =&gt; RXRECCLK_SEL  -- 2-bit input: Refer to Transceiver User Guide
   );

   -- End of OBUFDS_GTE3_ADV_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE3)" treetype="template">
-- OBUFDS_GTE3 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_GTE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_GTE3: Gigabit Transceiver Buffer
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE3_inst : OBUFDS_GTE3
   generic map (
      REFCLK_EN_TX_PATH =&gt; '1',   -- Refer to Transceiver User Guide
      REFCLK_ICNTL_TX =&gt; "00000"  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,     -- 1-bit output: Refer to Transceiver User Guide
      OB =&gt; OB,   -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB, -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I      -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of OBUFDS_GTE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SYSMON" treetype="folder">
					<Template label="SYSMON Simulation File" treetype="template">
-- Must use valid headers on all columns
-- Comments can be added to the stimulus file using '--'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

-- Time stamp data is in nano seconds (ns)
-- Temperature is recorded in C (degrees centigrade)
-- All other channels are recorded as V (Volts)
-- Valid column headers are:
-- TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
-- VUSER0, VUSER1, VUSER2, VUSER3,
-- VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
-- External analog inputs are differential so VP = 0.5 and VN = 0.1 the
-- input on channel VP/VN in 0.5 - 0.1 = 0.4V
					</Template>
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE1)" treetype="template">
--  SYSMONE1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SYSMONE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SYSMONE1: Xilinx Analog-to-Digital Converter and System Monitor
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   SYSMONE1_inst : SYSMONE1
   generic map (
      -- INIT_40 - INIT_44: SYSMON configuration registers
      INIT_40 =&gt; X"0000",
      INIT_41 =&gt; X"0000",
      INIT_42 =&gt; X"0000",
      INIT_43 =&gt; X"0000",
      INIT_44 =&gt; X"0000",
      INIT_45 =&gt; X"0000",               -- Analog Bus Register
      -- INIT_46 - INIT_4F: Sequence Registers
      INIT_46 =&gt; X"0000",
      INIT_47 =&gt; X"0000",
      INIT_48 =&gt; X"0000",
      INIT_49 =&gt; X"0000",
      INIT_4A =&gt; X"0000",
      INIT_4B =&gt; X"0000",
      INIT_4C =&gt; X"0000",
      INIT_4D =&gt; X"0000",
      INIT_4E =&gt; X"0000",
      INIT_4F =&gt; X"0000",
      -- INIT_50 - INIT_5F: Alarm Limit Registers
      INIT_50 =&gt; X"0000",
      INIT_51 =&gt; X"0000",
      INIT_52 =&gt; X"0000",
      INIT_53 =&gt; X"0000",
      INIT_54 =&gt; X"0000",
      INIT_55 =&gt; X"0000",
      INIT_56 =&gt; X"0000",
      INIT_57 =&gt; X"0000",
      INIT_58 =&gt; X"0000",
      INIT_59 =&gt; X"0000",
      INIT_5A =&gt; X"0000",
      INIT_5B =&gt; X"0000",
      INIT_5C =&gt; X"0000",
      INIT_5D =&gt; X"0000",
      INIT_5E =&gt; X"0000",
      INIT_5F =&gt; X"0000",
      -- INIT_60 - INIT_6F: User Supply Alarms
      INIT_60 =&gt; X"0000",
      INIT_61 =&gt; X"0000",
      INIT_62 =&gt; X"0000",
      INIT_63 =&gt; X"0000",
      INIT_64 =&gt; X"0000",
      INIT_65 =&gt; X"0000",
      INIT_66 =&gt; X"0000",
      INIT_67 =&gt; X"0000",
      INIT_68 =&gt; X"0000",
      INIT_69 =&gt; X"0000",
      INIT_6A =&gt; X"0000",
      INIT_6B =&gt; X"0000",
      INIT_6C =&gt; X"0000",
      INIT_6D =&gt; X"0000",
      INIT_6E =&gt; X"0000",
      INIT_6F =&gt; X"0000",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      -- specific pins
      IS_CONVSTCLK_INVERTED =&gt; '0',     -- Optional inversion for CONVSTCLK, 0-1
      IS_DCLK_INVERTED =&gt; '0',          -- Optional inversion for DCLK, 0-1
      -- Simulation attributes: Set for proper simulation behavior
      SIM_MONITOR_FILE =&gt; "design.txt", -- Analog simulation data file name
      -- User Voltage Monitor: SYSMON User voltage monitor
      SYSMON_VUSER0_BANK =&gt; 0,          -- Specify IO Bank for User0
      SYSMON_VUSER0_MONITOR =&gt; "NONE",  -- Specify Voltage for User0
      SYSMON_VUSER1_BANK =&gt; 0,          -- Specify IO Bank for User1
      SYSMON_VUSER1_MONITOR =&gt; "NONE",  -- Specify Voltage for User1
      SYSMON_VUSER2_BANK =&gt; 0,          -- Specify IO Bank for User2
      SYSMON_VUSER2_MONITOR =&gt; "NONE",  -- Specify Voltage for User2
      SYSMON_VUSER3_MONITOR =&gt; "NONE"   -- Specify Voltage for User3
   )
   port map (
      -- ALARMS outputs: ALM, OT
      ALM =&gt; ALM,                   -- 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      OT =&gt; OT,                     -- 1-bit output: Over-Temperature alarm
      -- Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      DO =&gt; DO,                     -- 16-bit output: DRP output data bus
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP data ready
      -- I2C Interface outputs: Ports used with the I2C DRP interface
      I2C_SCLK_TS =&gt; I2C_SCLK_TS,   -- 1-bit output: I2C_SCLK output port
      I2C_SDA_TS =&gt; I2C_SDA_TS,     -- 1-bit output: I2C_SDA_TS output port
      -- STATUS outputs: SYSMON status ports
      BUSY =&gt; BUSY,                 -- 1-bit output: System Monitor busy output
      CHANNEL =&gt; CHANNEL,           -- 6-bit output: Channel selection outputs
      EOC =&gt; EOC,                   -- 1-bit output: End of Conversion
      EOS =&gt; EOS,                   -- 1-bit output: End of Sequence
      JTAGBUSY =&gt; JTAGBUSY,         -- 1-bit output: JTAG DRP transaction in progress output
      JTAGLOCKED =&gt; JTAGLOCKED,     -- 1-bit output: JTAG requested DRP port lock
      JTAGMODIFIED =&gt; JTAGMODIFIED, -- 1-bit output: JTAG Write to the DRP has occurred
      MUXADDR =&gt; MUXADDR,           -- 5-bit output: External MUX channel decode
      -- Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      VAUXN =&gt; VAUXN,               -- 16-bit input: N-side auxiliary analog input
      VAUXP =&gt; VAUXP,               -- 16-bit input: P-side auxiliary analog input
      -- CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      CONVST =&gt; CONVST,             -- 1-bit input: Convert start input
      CONVSTCLK =&gt; CONVSTCLK,       -- 1-bit input: Convert start input
      RESET =&gt; RESET,               -- 1-bit input: Active-High reset
      -- Dedicated Analog Input Pair inputs: VP/VN
      VN =&gt; VN,                     -- 1-bit input: N-side analog input
      VP =&gt; VP,                     -- 1-bit input: P-side analog input
      -- Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      DADDR =&gt; DADDR,               -- 8-bit input: DRP address bus
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable signal
      DI =&gt; DI,                     -- 16-bit input: DRP input data bus
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- I2C Interface inputs: Ports used with the I2C DRP interface
      I2C_SCLK =&gt; I2C_SCLK,         -- 1-bit input: I2C_SCLK input port
      I2C_SDA =&gt; I2C_SDA            -- 1-bit input: I2C_SDA input port
   );

   -- End of SYSMONE1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="ARITHMETIC" treetype="folder">
				<SubFolder label="DSP" treetype="folder">
					<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E2)" treetype="template">
--   DSP48E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DSP48E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DSP48E2: 48-bit Multi-Functional Arithmetic Block
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   DSP48E2_inst : DSP48E2
   generic map (
      -- Feature Control Attributes: Data Path Selection
      AMULTSEL =&gt; "A",                   -- Selects A input to multiplier (A, AD)
      A_INPUT =&gt; "DIRECT",               -- Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      BMULTSEL =&gt; "B",                   -- Selects B input to multiplier (AD, B)
      B_INPUT =&gt; "DIRECT",               -- Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      PREADDINSEL =&gt; "A",                -- Selects input to pre-adder (A, B)
      RND =&gt; X"000000000000",            -- Rounding Constant
      USE_MULT =&gt; "MULTIPLY",            -- Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
      USE_SIMD =&gt; "ONE48",               -- SIMD selection (FOUR12, ONE48, TWO24)
      USE_WIDEXOR =&gt; "FALSE",            -- Use the Wide XOR function (FALSE, TRUE)
      XORSIMD =&gt; "XOR24_48_96",          -- Mode of operation for the Wide XOR (XOR12, XOR24_48_96)
      -- Pattern Detector Attributes: Pattern Detection Configuration
      AUTORESET_PATDET =&gt; "NO_RESET",    -- NO_RESET, RESET_MATCH, RESET_NOT_MATCH
      AUTORESET_PRIORITY =&gt; "RESET",     -- Priority of AUTORESET vs. CEP (CEP, RESET).
      MASK =&gt; X"3fffffffffff",           -- 48-bit mask value for pattern detect (1=ignore)
      PATTERN =&gt; X"000000000000",        -- 48-bit pattern match for pattern detect
      SEL_MASK =&gt; "MASK",                -- C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
      SEL_PATTERN =&gt; "PATTERN",          -- Select pattern value (C, PATTERN)
      USE_PATTERN_DETECT =&gt; "NO_PATDET", -- Enable pattern detect (NO_PATDET, PATDET)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_ALUMODE_INVERTED =&gt; "0000",     -- Optional inversion for ALUMODE
      IS_CARRYIN_INVERTED =&gt; '0',        -- Optional inversion for CARRYIN
      IS_CLK_INVERTED =&gt; '0',            -- Optional inversion for CLK
      IS_INMODE_INVERTED =&gt; "00000",     -- Optional inversion for INMODE
      IS_OPMODE_INVERTED =&gt; "000000000", -- Optional inversion for OPMODE
      IS_RSTALLCARRYIN_INVERTED =&gt; '0',  -- Optional inversion for RSTALLCARRYIN
      IS_RSTALUMODE_INVERTED =&gt; '0',     -- Optional inversion for RSTALUMODE
      IS_RSTA_INVERTED =&gt; '0',           -- Optional inversion for RSTA
      IS_RSTB_INVERTED =&gt; '0',           -- Optional inversion for RSTB
      IS_RSTCTRL_INVERTED =&gt; '0',        -- Optional inversion for RSTCTRL
      IS_RSTC_INVERTED =&gt; '0',           -- Optional inversion for RSTC
      IS_RSTD_INVERTED =&gt; '0',           -- Optional inversion for RSTD
      IS_RSTINMODE_INVERTED =&gt; '0',      -- Optional inversion for RSTINMODE
      IS_RSTM_INVERTED =&gt; '0',           -- Optional inversion for RSTM
      IS_RSTP_INVERTED =&gt; '0',           -- Optional inversion for RSTP
      -- Register Control Attributes: Pipeline Register Configuration
      ACASCREG =&gt; 1,                     -- Number of pipeline stages between A/ACIN and ACOUT (0-2)
      ADREG =&gt; 1,                        -- Pipeline stages for pre-adder (0-1)
      ALUMODEREG =&gt; 1,                   -- Pipeline stages for ALUMODE (0-1)
      AREG =&gt; 1,                         -- Pipeline stages for A (0-2)
      BCASCREG =&gt; 1,                     -- Number of pipeline stages between B/BCIN and BCOUT (0-2)
      BREG =&gt; 1,                         -- Pipeline stages for B (0-2)
      CARRYINREG =&gt; 1,                   -- Pipeline stages for CARRYIN (0-1)
      CARRYINSELREG =&gt; 1,                -- Pipeline stages for CARRYINSEL (0-1)
      CREG =&gt; 1,                         -- Pipeline stages for C (0-1)
      DREG =&gt; 1,                         -- Pipeline stages for D (0-1)
      INMODEREG =&gt; 1,                    -- Pipeline stages for INMODE (0-1)
      MREG =&gt; 1,                         -- Multiplier pipeline stages (0-1)
      OPMODEREG =&gt; 1,                    -- Pipeline stages for OPMODE (0-1)
      PREG =&gt; 1                          -- Number of pipeline stages for P (0-1)
   )
   port map (
      -- Cascade outputs: Cascade Ports
      ACOUT =&gt; ACOUT,                   -- 30-bit output: A port cascade
      BCOUT =&gt; BCOUT,                   -- 18-bit output: B cascade
      CARRYCASCOUT =&gt; CARRYCASCOUT,     -- 1-bit output: Cascade carry
      MULTSIGNOUT =&gt; MULTSIGNOUT,       -- 1-bit output: Multiplier sign cascade
      PCOUT =&gt; PCOUT,                   -- 48-bit output: Cascade output
      -- Control outputs: Control Inputs/Status Bits
      OVERFLOW =&gt; OVERFLOW,             -- 1-bit output: Overflow in add/acc
      PATTERNBDETECT =&gt; PATTERNBDETECT, -- 1-bit output: Pattern bar detect
      PATTERNDETECT =&gt; PATTERNDETECT,   -- 1-bit output: Pattern detect
      UNDERFLOW =&gt; UNDERFLOW,           -- 1-bit output: Underflow in add/acc
      -- Data outputs: Data Ports
      CARRYOUT =&gt; CARRYOUT,             -- 4-bit output: Carry
      P =&gt; P,                           -- 48-bit output: Primary data
      XOROUT =&gt; XOROUT,                 -- 8-bit output: XOR data
      -- Cascade inputs: Cascade Ports
      ACIN =&gt; ACIN,                     -- 30-bit input: A cascade data
      BCIN =&gt; BCIN,                     -- 18-bit input: B cascade
      CARRYCASCIN =&gt; CARRYCASCIN,       -- 1-bit input: Cascade carry
      MULTSIGNIN =&gt; MULTSIGNIN,         -- 1-bit input: Multiplier sign cascade
      PCIN =&gt; PCIN,                     -- 48-bit input: P cascade
      -- Control inputs: Control Inputs/Status Bits
      ALUMODE =&gt; ALUMODE,               -- 4-bit input: ALU control
      CARRYINSEL =&gt; CARRYINSEL,         -- 3-bit input: Carry select
      CLK =&gt; CLK,                       -- 1-bit input: Clock
      INMODE =&gt; INMODE,                 -- 5-bit input: INMODE control
      OPMODE =&gt; OPMODE,                 -- 9-bit input: Operation mode
      -- Data inputs: Data Ports
      A =&gt; A,                           -- 30-bit input: A data
      B =&gt; B,                           -- 18-bit input: B data
      C =&gt; C,                           -- 48-bit input: C data
      CARRYIN =&gt; CARRYIN,               -- 1-bit input: Carry-in
      D =&gt; D,                           -- 27-bit input: D data
      -- Reset/Clock Enable inputs: Reset/Clock Enable Inputs
      CEA1 =&gt; CEA1,                     -- 1-bit input: Clock enable for 1st stage AREG
      CEA2 =&gt; CEA2,                     -- 1-bit input: Clock enable for 2nd stage AREG
      CEAD =&gt; CEAD,                     -- 1-bit input: Clock enable for ADREG
      CEALUMODE =&gt; CEALUMODE,           -- 1-bit input: Clock enable for ALUMODE
      CEB1 =&gt; CEB1,                     -- 1-bit input: Clock enable for 1st stage BREG
      CEB2 =&gt; CEB2,                     -- 1-bit input: Clock enable for 2nd stage BREG
      CEC =&gt; CEC,                       -- 1-bit input: Clock enable for CREG
      CECARRYIN =&gt; CECARRYIN,           -- 1-bit input: Clock enable for CARRYINREG
      CECTRL =&gt; CECTRL,                 -- 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
      CED =&gt; CED,                       -- 1-bit input: Clock enable for DREG
      CEINMODE =&gt; CEINMODE,             -- 1-bit input: Clock enable for INMODEREG
      CEM =&gt; CEM,                       -- 1-bit input: Clock enable for MREG
      CEP =&gt; CEP,                       -- 1-bit input: Clock enable for PREG
      RSTA =&gt; RSTA,                     -- 1-bit input: Reset for AREG
      RSTALLCARRYIN =&gt; RSTALLCARRYIN,   -- 1-bit input: Reset for CARRYINREG
      RSTALUMODE =&gt; RSTALUMODE,         -- 1-bit input: Reset for ALUMODEREG
      RSTB =&gt; RSTB,                     -- 1-bit input: Reset for BREG
      RSTC =&gt; RSTC,                     -- 1-bit input: Reset for CREG
      RSTCTRL =&gt; RSTCTRL,               -- 1-bit input: Reset for OPMODEREG and CARRYINSELREG
      RSTD =&gt; RSTD,                     -- 1-bit input: Reset for DREG and ADREG
      RSTINMODE =&gt; RSTINMODE,           -- 1-bit input: Reset for INMODEREG
      RSTM =&gt; RSTM,                     -- 1-bit input: Reset for MREG
      RSTP =&gt; RSTP                      -- 1-bit input: Reset for PREG
   );

   -- End of DSP48E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="BLOCKRAM" treetype="folder">
				<SubFolder label="BRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E2)" treetype="template">
--  RAMB18E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB18E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB18E2: 18K-bit Configurable Synchronous Block RAM
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAMB18E2_inst : RAMB18E2
   generic map (
      -- CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      CASCADE_ORDER_A =&gt; "NONE",
      CASCADE_ORDER_B =&gt; "NONE",
      -- CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      CLOCK_DOMAINS =&gt; "INDEPENDENT",
      -- Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0, 1)
      DOA_REG =&gt; 1,
      DOB_REG =&gt; 1,
      -- ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      ENADDRENA =&gt; "FALSE",
      ENADDRENB =&gt; "FALSE",
      -- INITP_00 to INITP_07: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_3F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"00000",
      INIT_B =&gt; X"00000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLKARDCLK_INVERTED =&gt; '0',
      IS_CLKBWRCLK_INVERTED =&gt; '0',
      IS_ENARDEN_INVERTED =&gt; '0',
      IS_ENBWREN_INVERTED =&gt; '0',
      IS_RSTRAMARSTRAM_INVERTED =&gt; '0',
      IS_RSTRAMB_INVERTED =&gt; '0',
      IS_RSTREGARSTREG_INVERTED =&gt; '0',
      IS_RSTREGB_INVERTED =&gt; '0',
      -- RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      RDADDRCHANGEA =&gt; "FALSE",
      RDADDRCHANGEB =&gt; "FALSE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-9
      READ_WIDTH_B =&gt; 0,                                                               -- 0-9
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-9
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-9
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"00000",
      SRVAL_B =&gt; X"00000",
      -- Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      SLEEP_ASYNC =&gt; "FALSE",
      -- WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      WRITE_MODE_A =&gt; "NO_CHANGE",
      WRITE_MODE_B =&gt; "NO_CHANGE" 
   )
   port map (
      -- Cascade Signals outputs: Multi-BRAM cascade signals
      CASDOUTA =&gt; CASDOUTA,               -- 16-bit output: Port A cascade output data
      CASDOUTB =&gt; CASDOUTB,               -- 16-bit output: Port B cascade output data
      CASDOUTPA =&gt; CASDOUTPA,             -- 2-bit output: Port A cascade output parity data
      CASDOUTPB =&gt; CASDOUTPB,             -- 2-bit output: Port B cascade output parity data
      -- Port A Data outputs: Port A data
      DOUTADOUT =&gt; DOUTADOUT,             -- 16-bit output: Port A data/LSB data
      DOUTPADOUTP =&gt; DOUTPADOUTP,         -- 2-bit output: Port A parity/LSB parity
      -- Port B Data outputs: Port B data
      DOUTBDOUT =&gt; DOUTBDOUT,             -- 16-bit output: Port B data/MSB data
      DOUTPBDOUTP =&gt; DOUTPBDOUTP,         -- 2-bit output: Port B parity/MSB parity
      -- Cascade Signals inputs: Multi-BRAM cascade signals
      CASDIMUXA =&gt; CASDIMUXA,             -- 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      CASDIMUXB =&gt; CASDIMUXB,             -- 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      CASDINA =&gt; CASDINA,                 -- 16-bit input: Port A cascade input data
      CASDINB =&gt; CASDINB,                 -- 16-bit input: Port B cascade input data
      CASDINPA =&gt; CASDINPA,               -- 2-bit input: Port A cascade input parity data
      CASDINPB =&gt; CASDINPB,               -- 2-bit input: Port B cascade input parity data
      CASDOMUXA =&gt; CASDOMUXA,             -- 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      CASDOMUXB =&gt; CASDOMUXB,             -- 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      CASDOMUXEN_A =&gt; CASDOMUXEN_A,       -- 1-bit input: Port A unregistered output data enable
      CASDOMUXEN_B =&gt; CASDOMUXEN_B,       -- 1-bit input: Port B unregistered output data enable
      CASOREGIMUXA =&gt; CASOREGIMUXA,       -- 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      CASOREGIMUXB =&gt; CASOREGIMUXB,       -- 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      CASOREGIMUXEN_A =&gt; CASOREGIMUXEN_A, -- 1-bit input: Port A registered output data enable
      CASOREGIMUXEN_B =&gt; CASOREGIMUXEN_B, -- 1-bit input: Port B registered output data enable
      -- Port A Address/Control Signals inputs: Port A address and control signals
      ADDRARDADDR =&gt; ADDRARDADDR,         -- 14-bit input: A/Read port address
      ADDRENA =&gt; ADDRENA,                 -- 1-bit input: Active-High A/Read port address enable
      CLKARDCLK =&gt; CLKARDCLK,             -- 1-bit input: A/Read port clock
      ENARDEN =&gt; ENARDEN,                 -- 1-bit input: Port A enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,         -- 1-bit input: Port A register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM,     -- 1-bit input: Port A set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG,     -- 1-bit input: Port A register set/reset
      WEA =&gt; WEA,                         -- 2-bit input: Port A write enable
      -- Port A Data inputs: Port A data
      DINADIN =&gt; DINADIN,                 -- 16-bit input: Port A data/LSB data
      DINPADINP =&gt; DINPADINP,             -- 2-bit input: Port A parity/LSB parity
      -- Port B Address/Control Signals inputs: Port B address and control signals
      ADDRBWRADDR =&gt; ADDRBWRADDR,         -- 14-bit input: B/Write port address
      ADDRENB =&gt; ADDRENB,                 -- 1-bit input: Active-High B/Write port address enable
      CLKBWRCLK =&gt; CLKBWRCLK,             -- 1-bit input: B/Write port clock
      ENBWREN =&gt; ENBWREN,                 -- 1-bit input: Port B enable/Write enable
      REGCEB =&gt; REGCEB,                   -- 1-bit input: Port B register enable
      RSTRAMB =&gt; RSTRAMB,                 -- 1-bit input: Port B set/reset
      RSTREGB =&gt; RSTREGB,                 -- 1-bit input: Port B register set/reset
      SLEEP =&gt; SLEEP,                     -- 1-bit input: Sleep Mode
      WEBWE =&gt; WEBWE,                     -- 4-bit input: Port B write enable/Write enable
      -- Port B Data inputs: Port B data
      DINBDIN =&gt; DINBDIN,                 -- 16-bit input: Port B data/MSB data
      DINPBDINP =&gt; DINPBDINP              -- 2-bit input: Port B parity/MSB parity
   );

   -- End of RAMB18E2_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E2)" treetype="template">
--  RAMB36E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB36E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB36E2: 36K-bit Configurable Synchronous Block RAM
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAMB36E2_inst : RAMB36E2
   generic map (
      -- CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      CASCADE_ORDER_A =&gt; "NONE",
      CASCADE_ORDER_B =&gt; "NONE",
      -- CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      CLOCK_DOMAINS =&gt; "INDEPENDENT",
      DOB_REG =&gt; 1,
      -- Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0, 1)
      DOA_REG =&gt; 1,
      -- ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      ENADDRENA =&gt; "FALSE",
      ENADDRENB =&gt; "FALSE",
      -- EN_ECC_PIPE: ECC pipeline register, "TRUE"/"FALSE" 
      EN_ECC_PIPE =&gt; "FALSE",
      -- EN_ECC_READ: Enable ECC decoder, "TRUE"/"FALSE" 
      EN_ECC_READ =&gt; "FALSE",
      -- EN_ECC_WRITE: Enable ECC encoder, "TRUE"/"FALSE" 
      EN_ECC_WRITE =&gt; "FALSE",
      -- INITP_00 to INITP_0F: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_7F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"000000000",
      INIT_B =&gt; X"000000000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLKARDCLK_INVERTED =&gt; '0',
      IS_CLKBWRCLK_INVERTED =&gt; '0',
      IS_ENARDEN_INVERTED =&gt; '0',
      IS_ENBWREN_INVERTED =&gt; '0',
      IS_RSTRAMARSTRAM_INVERTED =&gt; '0',
      IS_RSTRAMB_INVERTED =&gt; '0',
      IS_RSTREGARSTREG_INVERTED =&gt; '0',
      IS_RSTREGB_INVERTED =&gt; '0',
      -- RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      RDADDRCHANGEA =&gt; "FALSE",
      RDADDRCHANGEB =&gt; "FALSE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-9
      READ_WIDTH_B =&gt; 0,                                                               -- 0-9
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-9
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-9
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"000000000",
      SRVAL_B =&gt; X"000000000",
      -- Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      SLEEP_ASYNC =&gt; "FALSE",
      -- WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      WRITE_MODE_A =&gt; "NO_CHANGE",
      WRITE_MODE_B =&gt; "NO_CHANGE" 
   )
   port map (
      -- Cascade Signals outputs: Multi-BRAM cascade signals
      CASDOUTA =&gt; CASDOUTA,               -- 32-bit output: Port A cascade output data
      CASDOUTB =&gt; CASDOUTB,               -- 32-bit output: Port B cascade output data
      CASDOUTPA =&gt; CASDOUTPA,             -- 4-bit output: Port A cascade output parity data
      CASDOUTPB =&gt; CASDOUTPB,             -- 4-bit output: Port B cascade output parity data
      CASOUTDBITERR =&gt; CASOUTDBITERR,     -- 1-bit output: DBITERR cascade output
      CASOUTSBITERR =&gt; CASOUTSBITERR,     -- 1-bit output: SBITERR cascade output
      -- ECC Signals outputs: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,                 -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,             -- 8-bit output: Generated error correction parity
      RDADDRECC =&gt; RDADDRECC,             -- 9-bit output: ECC Read Address
      SBITERR =&gt; SBITERR,                 -- 1-bit output: Single bit error status
      -- Port A Data outputs: Port A data
      DOUTADOUT =&gt; DOUTADOUT,             -- 32-bit output: Port A ata/LSB data
      DOUTPADOUTP =&gt; DOUTPADOUTP,         -- 4-bit output: Port A parity/LSB parity
      -- Port B Data outputs: Port B data
      DOUTBDOUT =&gt; DOUTBDOUT,             -- 32-bit output: Port B data/MSB data
      DOUTPBDOUTP =&gt; DOUTPBDOUTP,         -- 4-bit output: Port B parity/MSB parity
      -- Cascade Signals inputs: Multi-BRAM cascade signals
      CASDIMUXA =&gt; CASDIMUXA,             -- 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      CASDIMUXB =&gt; CASDIMUXB,             -- 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      CASDINA =&gt; CASDINA,                 -- 32-bit input: Port A cascade input data
      CASDINB =&gt; CASDINB,                 -- 32-bit input: Port B cascade input data
      CASDINPA =&gt; CASDINPA,               -- 4-bit input: Port A cascade input parity data
      CASDINPB =&gt; CASDINPB,               -- 4-bit input: Port B cascade input parity data
      CASDOMUXA =&gt; CASDOMUXA,             -- 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      CASDOMUXB =&gt; CASDOMUXB,             -- 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      CASDOMUXEN_A =&gt; CASDOMUXEN_A,       -- 1-bit input: Port A unregistered output data enable
      CASDOMUXEN_B =&gt; CASDOMUXEN_B,       -- 1-bit input: Port B unregistered output data enable
      CASINDBITERR =&gt; CASINDBITERR,       -- 1-bit input: DBITERR cascade input
      CASINSBITERR =&gt; CASINSBITERR,       -- 1-bit input: SBITERR cascade input
      CASOREGIMUXA =&gt; CASOREGIMUXA,       -- 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      CASOREGIMUXB =&gt; CASOREGIMUXB,       -- 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      CASOREGIMUXEN_A =&gt; CASOREGIMUXEN_A, -- 1-bit input: Port A registered output data enable
      CASOREGIMUXEN_B =&gt; CASOREGIMUXEN_B, -- 1-bit input: Port B registered output data enable
      -- ECC Signals inputs: Error Correction Circuitry ports
      ECCPIPECE =&gt; ECCPIPECE,             -- 1-bit input: ECC Pipeline Register Enable
      INJECTDBITERR =&gt; INJECTDBITERR,     -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR,
      -- Port A Address/Control Signals inputs: Port A address and control signals
      ADDRARDADDR =&gt; ADDRARDADDR,         -- 15-bit input: A/Read port address
      ADDRENA =&gt; ADDRENA,                 -- 1-bit input: Active-High A/Read port address enable
      CLKARDCLK =&gt; CLKARDCLK,             -- 1-bit input: A/Read port clock
      ENARDEN =&gt; ENARDEN,                 -- 1-bit input: Port A enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,         -- 1-bit input: Port A register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM,     -- 1-bit input: Port A set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG,     -- 1-bit input: Port A register set/reset
      SLEEP =&gt; SLEEP,                     -- 1-bit input: Sleep Mode
      WEA =&gt; WEA,                         -- 4-bit input: Port A write enable
      -- Port A Data inputs: Port A data
      DINADIN =&gt; DINADIN,                 -- 32-bit input: Port A data/LSB data
      DINPADINP =&gt; DINPADINP,             -- 4-bit input: Port A parity/LSB parity
      -- Port B Address/Control Signals inputs: Port B address and control signals
      ADDRBWRADDR =&gt; ADDRBWRADDR,         -- 15-bit input: B/Write port address
      ADDRENB =&gt; ADDRENB,                 -- 1-bit input: Active-High B/Write port address enable
      CLKBWRCLK =&gt; CLKBWRCLK,             -- 1-bit input: B/Write port clock
      ENBWREN =&gt; ENBWREN,                 -- 1-bit input: Port B enable/Write enable
      REGCEB =&gt; REGCEB,                   -- 1-bit input: Port B register enable
      RSTRAMB =&gt; RSTRAMB,                 -- 1-bit input: Port B set/reset
      RSTREGB =&gt; RSTREGB,                 -- 1-bit input: Port B register set/reset
      WEBWE =&gt; WEBWE,                     -- 8-bit input: Port B write enable/Write enable
      -- Port B Data inputs: Port B data
      DINBDIN =&gt; DINBDIN,                 -- 32-bit input: Port B data/MSB data
      DINPBDINP =&gt; DINPBDINP              -- 4-bit input: Port B parity/MSB parity
   );

   -- End of RAMB36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E2)" treetype="template">
--  FIFO18E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO18E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO18E2: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FIFO18E2_inst : FIFO18E2
   generic map (
      CASCADE_ORDER =&gt; "NONE",            -- FIRST, LAST, MIDDLE, NONE, PARALLEL
      CLOCK_DOMAINS =&gt; "INDEPENDENT",     -- COMMON, INDEPENDENT
      FIRST_WORD_FALL_THROUGH =&gt; "FALSE", -- FALSE, TRUE
      INIT =&gt; X"000000000",               -- Initial values on output port
      PROG_EMPTY_THRESH =&gt; 256,           -- Programmable Empty Threshold
      PROG_FULL_THRESH =&gt; 256,            -- Programmable Full Threshold
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_RDCLK_INVERTED =&gt; '0',           -- Optional inversion for RDCLK
      IS_RDEN_INVERTED =&gt; '0',            -- Optional inversion for RDEN
      IS_RSTREG_INVERTED =&gt; '0',          -- Optional inversion for RSTREG
      IS_RST_INVERTED =&gt; '0',             -- Optional inversion for RST
      IS_WRCLK_INVERTED =&gt; '0',           -- Optional inversion for WRCLK
      IS_WREN_INVERTED =&gt; '0',            -- Optional inversion for WREN
      RDCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      READ_WIDTH =&gt; 4,                    -- 18-9
      REGISTER_MODE =&gt; "UNREGISTERED",    -- DO_PIPELINED, REGISTERED, UNREGISTERED
      RSTREG_PRIORITY =&gt; "RSTREG",        -- REGCE, RSTREG
      SLEEP_ASYNC =&gt; "FALSE",             -- FALSE, TRUE
      SRVAL =&gt; X"000000000",              -- SET/reset value of the FIFO outputs
      WRCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      WRITE_WIDTH =&gt; 4                    -- 18-9
   )
   port map (
      -- Cascade Signals outputs: Multi-FIFO cascade signals
      CASDOUT =&gt; CASDOUT,             -- 32-bit output: Data cascade output bus
      CASDOUTP =&gt; CASDOUTP,           -- 4-bit output: Parity data cascade output bus
      CASNXTEMPTY =&gt; CASNXTEMPTY,     -- 1-bit output: Cascade next empty
      CASPRVRDEN =&gt; CASPRVRDEN,       -- 1-bit output: Cascade previous read enable
      -- Read Data outputs: Read output data
      DOUT =&gt; DOUT,                   -- 32-bit output: FIFO data output bus
      DOUTP =&gt; DOUTP,                 -- 4-bit output: FIFO parity output bus.
      -- Status outputs: Flags and other FIFO status outputs
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty
      FULL =&gt; FULL,                   -- 1-bit output: Full
      PROGEMPTY =&gt; PROGEMPTY,         -- 1-bit output: Programmable empty
      PROGFULL =&gt; PROGFULL,           -- 1-bit output: Programmable full
      RDCOUNT =&gt; RDCOUNT,             -- 13-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      RDRSTBUSY =&gt; RDRSTBUSY,         -- 1-bit output: Reset busy (sync to RDCLK)
      WRCOUNT =&gt; WRCOUNT,             -- 13-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write Error
      WRRSTBUSY =&gt; WRRSTBUSY,         -- 1-bit output: Reset busy (sync to WRCLK)
      -- Cascade Signals inputs: Multi-FIFO cascade signals
      CASDIN =&gt; CASDIN,               -- 32-bit input: Data cascade input bus
      CASDINP =&gt; CASDINP,             -- 4-bit input: Parity data cascade input bus
      CASDOMUX =&gt; CASDOMUX,           -- 1-bit input: Cascade MUX select
      CASDOMUXEN =&gt; CASDOMUXEN,       -- 1-bit input: Enable for cascade MUX select
      CASNXTRDEN =&gt; CASNXTRDEN,       -- 1-bit input: Cascade next read enable
      CASOREGIMUX =&gt; CASOREGIMUX,     -- 1-bit input: Cascade output MUX select
      CASOREGIMUXEN =&gt; CASOREGIMUXEN, -- 1-bit input: Cascade output MUX select enable
      CASPRVEMPTY =&gt; CASPRVEMPTY,     -- 1-bit input: Cascade previous empty
      -- Read Control Signals inputs: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Output register clock enable
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register reset
      SLEEP =&gt; SLEEP,                 -- 1-bit input: Sleep Mode
      -- Write Control Signals inputs: Write clock and enable input signals
      RST =&gt; RST,                     -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Write clock
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data inputs: Write input data
      DIN =&gt; DIN,                     -- 32-bit input: FIFO data input bus
      DINP =&gt; DINP                    -- 4-bit input: FIFO parity input bus
   );

   -- End of FIFO18E2_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E2)" treetype="template">
--  FIFO36E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO36E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO36E2: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FIFO36E2_inst : FIFO36E2
   generic map (
      CASCADE_ORDER =&gt; "NONE",            -- FIRST, LAST, MIDDLE, NONE, PARALLEL
      CLOCK_DOMAINS =&gt; "INDEPENDENT",     -- COMMON, INDEPENDENT
      EN_ECC_PIPE =&gt; "FALSE",             -- ECC pipeline register, (FALSE, TRUE)
      EN_ECC_READ =&gt; "FALSE",             -- Enable ECC decoder, (FALSE, TRUE)
      EN_ECC_WRITE =&gt; "FALSE",            -- Enable ECC encoder, (FALSE, TRUE)
      FIRST_WORD_FALL_THROUGH =&gt; "FALSE", -- FALSE, TRUE
      INIT =&gt; X"000000000000000000",      -- Initial values on output port
      PROG_EMPTY_THRESH =&gt; 256,           -- Programmable Empty Threshold
      PROG_FULL_THRESH =&gt; 256,            -- Programmable Full Threshold
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_RDCLK_INVERTED =&gt; '0',           -- Optional inversion for RDCLK
      IS_RDEN_INVERTED =&gt; '0',            -- Optional inversion for RDEN
      IS_RSTREG_INVERTED =&gt; '0',          -- Optional inversion for RSTREG
      IS_RST_INVERTED =&gt; '0',             -- Optional inversion for RST
      IS_WRCLK_INVERTED =&gt; '0',           -- Optional inversion for WRCLK
      IS_WREN_INVERTED =&gt; '0',            -- Optional inversion for WREN
      RDCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      READ_WIDTH =&gt; 4,                    -- 18-9
      REGISTER_MODE =&gt; "UNREGISTERED",    -- DO_PIPELINED, REGISTERED, UNREGISTERED
      RSTREG_PRIORITY =&gt; "RSTREG",        -- REGCE, RSTREG
      SLEEP_ASYNC =&gt; "FALSE",             -- FALSE, TRUE
      SRVAL =&gt; X"000000000000000000",     -- SET/reset value of the FIFO outputs
      WRCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      WRITE_WIDTH =&gt; 4                    -- 18-9
   )
   port map (
      -- Cascade Signals outputs: Multi-FIFO cascade signals
      CASDOUT =&gt; CASDOUT,             -- 64-bit output: Data cascade output bus
      CASDOUTP =&gt; CASDOUTP,           -- 8-bit output: Parity data cascade output bus
      CASNXTEMPTY =&gt; CASNXTEMPTY,     -- 1-bit output: Cascade next empty
      CASPRVRDEN =&gt; CASPRVRDEN,       -- 1-bit output: Cascade previous read enable
      -- ECC Signals outputs: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Read Data outputs: Read output data
      DOUT =&gt; DOUT,                   -- 64-bit output: FIFO data output bus
      DOUTP =&gt; DOUTP,                 -- 8-bit output: FIFO parity output bus.
      -- Status outputs: Flags and other FIFO status outputs
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty
      FULL =&gt; FULL,                   -- 1-bit output: Full
      PROGEMPTY =&gt; PROGEMPTY,         -- 1-bit output: Programmable empty
      PROGFULL =&gt; PROGFULL,           -- 1-bit output: Programmable full
      RDCOUNT =&gt; RDCOUNT,             -- 14-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      RDRSTBUSY =&gt; RDRSTBUSY,         -- 1-bit output: Reset busy (sync to RDCLK)
      WRCOUNT =&gt; WRCOUNT,             -- 14-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write Error
      WRRSTBUSY =&gt; WRRSTBUSY,         -- 1-bit output: Reset busy (sync to WRCLK)
      -- Cascade Signals inputs: Multi-FIFO cascade signals
      CASDIN =&gt; CASDIN,               -- 64-bit input: Data cascade input bus
      CASDINP =&gt; CASDINP,             -- 8-bit input: Parity data cascade input bus
      CASDOMUX =&gt; CASDOMUX,           -- 1-bit input: Cascade MUX select input
      CASDOMUXEN =&gt; CASDOMUXEN,       -- 1-bit input: Enable for cascade MUX select
      CASNXTRDEN =&gt; CASNXTRDEN,       -- 1-bit input: Cascade next read enable
      CASOREGIMUX =&gt; CASOREGIMUX,     -- 1-bit input: Cascade output MUX select
      CASOREGIMUXEN =&gt; CASOREGIMUXEN, -- 1-bit input: Cascade output MUX select enable
      CASPRVEMPTY =&gt; CASPRVEMPTY,     -- 1-bit input: Cascade previous empty
      -- ECC Signals inputs: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR, -- 1-bit input: Inject a single bit error
      -- Read Control Signals inputs: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Output register clock enable
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register reset
      SLEEP =&gt; SLEEP,                 -- 1-bit input: Sleep Mode
      -- Write Control Signals inputs: Write clock and enable input signals
      RST =&gt; RST,                     -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Write clock
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data inputs: Write input data
      DIN =&gt; DIN,                     -- 64-bit input: FIFO data input bus
      DINP =&gt; DINP                    -- 8-bit input: FIFO parity input bus
   );

   -- End of FIFO36E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLB" treetype="folder">
				<SubFolder label="CARRY" treetype="folder">
					<Template label="Fast Carry Logic with Look Ahead (CARRY8)" treetype="template">
--   CARRY8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CARRY8_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CARRY8: Fast Carry Logic with Look Ahead
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   CARRY8_inst : CARRY8
   generic map (
      CARRY_TYPE =&gt; "SINGLE_CY8"  -- 8-bit or dual 4-bit carry (DUAL_CY4, SINGLE_CY8)
   )
   port map (
      CO =&gt; CO,         -- 8-bit output: Carry-out
      O =&gt; O,           -- 8-bit output: Carry chain XOR data out
      CI =&gt; CI,         -- 1-bit input: Lower Carry-In
      CI_TOP =&gt; CI_TOP, -- 1-bit input: Upper Carry-In
      DI =&gt; DI,         -- 8-bit input: Carry-MUX data in
      S =&gt; S            -- 8-bit input: Carry-mux select
   );

   -- End of CARRY8_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Two input AND gate implemented in place of a CLB Latch (AND2B1L)" treetype="template">
--   AND2B1L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (AND2B1L_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- AND2B1L: Two input AND gate implemented in place of a CLB Latch
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   AND2B1L_inst : AND2B1L
   generic map (
      IS_SRI_INVERTED =&gt; '0'  -- Optional inversion for SRI
   )
   port map (
      O =&gt; O,     -- 1-bit output: AND gate output
      DI =&gt; DI,   -- 1-bit input: Data input connected to LUT logic
      SRI =&gt; SRI  -- 1-bit input: External CLB data
   );

   -- End of AND2B1L_inst instantiation
					</Template>
					<Template label="Two input OR gate implemented in place of a CLB Latch (OR2L)" treetype="template">
--    OR2L     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OR2L_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OR2L: Two input OR gate implemented in place of a CLB Latch
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OR2L_inst : OR2L
   generic map (
      IS_SRI_INVERTED =&gt; '0'  -- Optional inversion for SRI
   )
   port map (
      O =&gt; O,     -- 1-bit output: OR gate output
      DI =&gt; DI,   -- 1-bit input: Data input connected to LUT logic
      SRI =&gt; SRI  -- 1-bit input: External CLB data
   );

   -- End of OR2L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUT" treetype="folder">
					<Template label="1-Bit Look-Up Table (LUT1)" treetype="template">
--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-Bit Look-Up Table
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; X"0"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0  -- 1-bit input: LUT
   );

   -- End of LUT1_inst instantiation
					</Template>
					<Template label="2-Bit Look-Up Table (LUT2)" treetype="template">
--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-Bit Look-Up Table
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1  -- 1-bit input: LUT
   );

   -- End of LUT2_inst instantiation
					</Template>
					<Template label="3-Bit Look-Up Table (LUT3)" treetype="template">
--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-Bit Look-Up Table
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2  -- 1-bit input: LUT
   );

   -- End of LUT3_inst instantiation
					</Template>
					<Template label="4-Bit Look-Up Table (LUT4)" treetype="template">
--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-Bit Look-Up Table
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3  -- 1-bit input: LUT
   );

   -- End of LUT4_inst instantiation
					</Template>
					<Template label="5-Bit Look-Up Table (LUT5)" treetype="template">
--    LUT5     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT5_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5: 5-Bit Look-Up Table
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_inst : LUT5
   generic map (
      INIT =&gt; X"00000000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3, -- 1-bit input: LUT
      I4 =&gt; I4  -- 1-bit input: LUT
   );

   -- End of LUT5_inst instantiation
					</Template>
					<Template label="5-input Dynamically Reconfigurable Look-Up Table (LUT) (CFGLUT5)" treetype="template">
--   CFGLUT5   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CFGLUT5_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CFGLUT5: 5-input Dynamically Reconfigurable Look-Up Table (LUT)
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   CFGLUT5_inst : CFGLUT5
   generic map (
      INIT =&gt; X"00000000",    -- Initial logic function
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      CDO =&gt; CDO, -- 1-bit output: Reconfiguration cascade
      O5 =&gt; O5,   -- 1-bit output: 4-LUT
      O6 =&gt; O6,   -- 1-bit output: 5-LUT
      CDI =&gt; CDI, -- 1-bit input: Reconfiguration data
      CE =&gt; CE,   -- 1-bit input: Reconfiguration enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      -- LUT Inputs inputs: Logic inputs
      I0 =&gt; I0,
      I1 =&gt; I1,
      I2 =&gt; I2,
      I3 =&gt; I3,
      I4 =&gt; I4 
   );

   -- End of CFGLUT5_inst instantiation
					</Template>
					<Template label="6-Bit Look-Up Table (LUT6)" treetype="template">
--    LUT6     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT6_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6: 6-Bit Look-Up Table
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_inst : LUT6
   generic map (
      INIT =&gt; X"0000000000000000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3, -- 1-bit input: LUT
      I4 =&gt; I4, -- 1-bit input: LUT
      I5 =&gt; I5  -- 1-bit input: LUT
   );

   -- End of LUT6_inst instantiation
					</Template>
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
-- The INIT constant for the FPGA LUT primitive is what gives the LUT its 
-- logical value. By default this value is zero thus driving the output to a  
-- zero regardless of the input values (acting as a ground) however in most 
-- cases an new INIT value must be determined in order to specify the logic 
-- function for the LUT primitive.  There are a few methods in which the LUT 
-- value can be determined and two of those methods will be discussed here.
--
-- The Truth Table Method
-- ----------------------
--
--  A common method to determine the desired INIT value for a LUT is using a 
-- truth table.  To do so, simply create a binary truth table of all possible 
-- inputs, specify the desired logic value of the output and then create the 
-- INIT string from those output values.  An example is shown below:
--
-- Example of determining an XOR INIT equation for a LUT4:
--
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | 0 |\
--     |  0  0  0  1 | 1 | \ = 0110 = 6 -----------+
--     |  0  0  1  0 | 1 | /                       |
--     |  0  0  1  1 | 0 |/                        |
--     |-------------|---|                         |
--     |  0  1  0  0 | 1 |\                        |
--     |  0  1  0  1 | 0 | \ = 1001 = 9            |
--     |  0  1  1  0 | 0 | /                       |
--     |  0  1  1  1 | 1 |/                        |                     
--     |-------------|---|               INIT = 6996
--     |  1  0  0  0 | 1 |\                     |
--     |  1  0  0  1 | 0 | \ = 0110 = 9         |
--     |  1  0  1  0 | 0 | /                    |
--     |  1  0  1  1 | 1 |/                     |
--     |-------------|---|                      |
--     |  1  1  0  0 | 0 |\                     |
--     |  1  1  0  1 | 1 | \ = 1001 = 6---------+
--     |  1  1  1  0 | 1 | /
--     |  1  1  1  1 | 0 |/
--     -------------------
--
-- Example of determining a 3-input AND gate:
--
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | 0 |\
--     |  0  0  1 | 0 | \ = 0000 = 0 -----------+
--     |  0  1  0 | 0 | /                       |
--     |  0  1  1 | 0 |/                        |
--     |----------|---|                 INIT = 80 
--     |  1  0  0 | 0 |\                       |
--     |  1  0  1 | 0 | \ = 1000 = 8-----------+
--     |  1  1  0 | 0 | / 
--     |  1  1  1 | 1 |/                      
--     ----------------
--
-- The Equation Method
-- -------------------
--
-- Another method to determine the LUT value is to define constants for each 
-- input to the LUT that correspond to their listed truth value and use those to
-- build the logic equation you are after.  This method is easier to understand 
-- once you have grasped the concept and more self-documenting that the above 
-- method however does require the code to first specify the appropriate 
-- constants.  See the example below.
--
-- Example of specifying the equation (A and B) or (C and D) for a LUT4:
--
   -- The following constants are defined to allow for
   --   equation-based INIT specification.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00"; 


   -- LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; (I3 and I2) or (I1 and I0))
   port map (
      O =&gt; O_LUT,   -- LUT general output
      I0 =&gt; A, -- LUT input
      I1 =&gt; B, -- LUT input
      I2 =&gt; C, -- LUT input
      I3 =&gt; D  -- LUT input
   );
   -- End of LUT4_inst instantiation

-- With the constants specifying all possible cases for the truth table, a 
-- VHDL equation can be written to determine the end INIT value.

						</Template>
						<SubFolder label="INIT Constants" treetype="folder">
							<Template label="LUT1" treetype="template">
   -- The following constant is defined to allow for
   --   equation-based INIT specification for a LUT1.
   constant I0 : BIT_VECTOR(1 downto 0) := "10";
							</Template>
							<Template label="LUT2" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT2.
   constant I0 : BIT_VECTOR(3 downto 0) := X"A";
   constant I1 : BIT_VECTOR(3 downto 0) := X"C";
							</Template>
							<Template label="LUT3" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT3.
   constant I0 : BIT_VECTOR(7 downto 0) := X"AA";
   constant I1 : BIT_VECTOR(7 downto 0) := X"CC";
   constant I2 : BIT_VECTOR(7 downto 0) := X"F0";
							</Template>
							<Template label="LUT4" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT4.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";
							</Template>
							<Template label="LUT5" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT5.
   constant I0 : BIT_VECTOR(31 downto 0) := X"AAAAAAAA";
   constant I1 : BIT_VECTOR(31 downto 0) := X"CCCCCCCC";
   constant I2 : BIT_VECTOR(31 downto 0) := X"F0F0F0F0";
   constant I3 : BIT_VECTOR(31 downto 0) := X"FF00FF00";
   constant I4 : BIT_VECTOR(31 downto 0) := X"FFFF0000";
							</Template>
							<Template label="LUT6" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT6.
   constant I0 : BIT_VECTOR(63 downto 0) := X"AAAAAAAAAAAAAAAA";
   constant I1 : BIT_VECTOR(63 downto 0) := X"CCCCCCCCCCCCCCCC";
   constant I2 : BIT_VECTOR(63 downto 0) := X"F0F0F0F0F0F0F0F0";
   constant I3 : BIT_VECTOR(63 downto 0) := X"FF00FF00FF00FF00";
   constant I4 : BIT_VECTOR(63 downto 0) := X"FFFF0000FFFF0000";
   constant I5 : BIT_VECTOR(63 downto 0) := X"FFFFFFFF00000000";
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
--  Truth Table to determine INIT value for a LUT1
--      ________
--     | I0 | O |
--     |--------|
--     |  0 | ? |\
--     |  1 | ? |/ = 2'b??
--     ----------
							</Template>
							<Template label="LUT2" treetype="template">
--  Truth Table to determine INIT value for a LUT2
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
--     |  0  1  0 | ? | /
--     |  0  1  1 | ? |/ 
--      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
--  Truth Table to determine INIT value for a LUT3
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
--     |  0  1  0 | ? | /                                |
--     |  0  1  1 | ? |/                                 |
--     |----------|---|                       INIT = 8'h?? 
--     |  1  0  0 | ? |\                                |
--     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
--     |  1  1  0 | ? | / 
--     |  1  1  1 | ? |/                      
--     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
--  Truth Table to determine INIT value for a LUT4
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | ? |\
--     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
--     |  0  0  1  0 | ? | /                                 |
--     |  0  0  1  1 | ? |/                                  |
--     |-------------|---|                                   |
--     |  0  1  0  0 | ? |\                                  |
--     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
--     |  0  1  1  0 | ? | /                                 |
--     |  0  1  1  1 | ? |/                                  |                     
--     |-------------|---|                     INIT = 16'h????
--     |  1  0  0  0 | ? |\                               |
--     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  0 | ? | /                              |
--     |  1  0  1  1 | ? |/                               |
--     |-------------|---|                                |
--     |  1  1  0  0 | ? |\                               |
--     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  0 | ? | /
--     |  1  1  1  1 | ? |/
--     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
--  Truth Table to determine INIT value for a LUT5
--      ____________________
--     | I4 I3 I2 I1 I0 | O |
--     |--------------------|
--     |  0  0  0  0  0 | ? |\
--     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  0  1  0  0 | ? |\                                      |
--     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1 | ? |/                                      |                     
--     |----------------|---|                                       |
--     |  0  1  0  0  0 | ? |\                                      |
--     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  0 | ? | /                                     |
--     |  0  1  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  1  0  0 | ? |\                                      |
--     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1 | ? |/                                      |
--     ----------------------                     INIT = 32'h????????
--     |  1  0  0  0  0 | ? |\                               |
--     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  0  1  0 | ? | /                              |
--     |  1  0  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  0  1  0  0 | ? |\                               |
--     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  1  0 | ? | /                              |
--     |  1  0  1  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  0  0  0 | ? |\                               |
--     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  1  0  1  0 | ? | /                              |
--     |  1  1  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  1  0  0 | ? |\                               |
--     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1 | ? |/
--     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
--  Truth Table to determine INIT value for a LUT6
--      _______________________
--     | I5 I4 I3 I2 I1 I0 | O |
--     |-----------------------|
--     |  0  0  0  0  0  0 | ? |\
--     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  0  1  0  0 | ? |\                                      |
--     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  0  1  1  0 | ? | /                                     |
--     |  0  0  0  1  1  1 | ? |/                                      |                     
--     |-------------------|---|                                       |
--     |  0  0  1  0  0  0 | ? |\                                      |
--     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  0  1  0 | ? | /                                     |
--     |  0  0  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  1  0  0 | ? |\                                      |
--     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1  1 | ? |/                                      |
--     -------------------------                                       |
--     |  0  1  0  0  0  0 | ? |\                                      |
--     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  0  1  0 | ? | /                                     |
--     |  0  1  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  0  1  0  0 | ? |\                                      |
--     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  1  0 | ? | /                                     |
--     |  0  1  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  0  0  0 | ? |\                                      |
--     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  0  1  0 | ? | /                                     |
--     |  0  1  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  1  0  0 | ? |\                                      |
--     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1  1 | ? |/                                      |
--     ------------------------              INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     -----------------------
							</Template>
							<Template label="LUT6_2" treetype="template">
--  Truth Table to determine INIT value for a LUT6_2
--      _____________________________
--     | I5 I4 I3 I2 I1 I0 | O6 | O5 |
--     |-----------------------------|
--     |  0  0  0  0  0  0 |    ?    |\
--     |  0  0  0  0  0  1 |    ?    | \ = 4'b???? = 4'h? -------------+
--     |  0  0  0  0  1  0 |    ?    | /                               |
--     |  0  0  0  0  1  1 |	?    |/				       |
--     |-------------------|---------|                                 |
--     |  0  0  0  1  0  0 |	?    |\                                |
--     |  0  0  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  0  0  1  1  0 |	?    | /                               |
--     |  0  0  0  1  1  1 |	?    |/                                |                     
--     |-------------------|---------|                                 |
--     |  0  0  1  0  0  0 |	?    |\                                |
--     |  0  0  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  0  1  0  1  0 |	?    | /                               |
--     |  0  0  1  0  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  0  1  1  0  0 |	?    |\                                |
--     |  0  0  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  0  1  1  1  0 |	?    | /                               |
--     |  0  0  1  1  1  1 |	?    |/                                |
--     -------------------------------                                 |
--     |  0  1  0  0  0  0 |	?    |\                                |
--     |  0  1  0  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  0  0  1  0 |	?    | /                               |
--     |  0  1  0  0  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  1  0  1  0  0 |	?    |\                                |
--     |  0  1  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  0  1  1  0 |	?    | /                               |
--     |  0  1  0  1  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  1  1  0  0  0 |	?    |\                                |
--     |  0  1  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  1  0  1  0 |	?    | /                               |
--     |  0  1  1  0  1  1 |	?    |/                                |
--     |-------------------|---------|                                 |
--     |  0  1  1  1  0  0 |	?    |\                                |
--     |  0  1  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
--     |  0  1  1  1  1  0 |	?    | /                               |
--     |  0  1  1  1  1  1 |	?    |/                                |
--     ------------------------------        INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT6_2" treetype="template">

--   LUT6_2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_2: 6-input  2 output Look-Up Table
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_2_inst : LUT6_2
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      O6 =&gt; O6,  -- 6/5-LUT output (1-bit)
      O5 =&gt; O5,  -- 5-LUT output (1-bit)
      I0 =&gt; I0,   -- LUT input (1-bit)
      I1 =&gt; I1,   -- LUT input (1-bit)
      I2 =&gt; I2,   -- LUT input (1-bit)
      I3 =&gt; I3,   -- LUT input (1-bit)
      I4 =&gt; I4,   -- LUT input (1-bit)
      I5 =&gt; I5    -- LUT input (1-bit)
   );

   -- End of LUT6_2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUTRAM" treetype="folder">
					<Template label="64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM) (RAM64X8SW)" treetype="template">
--  RAM64X8SW  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAM64X8SW_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X8SW: 64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM)
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X8SW_inst : RAM64X8SW
   generic map (
      INIT_A =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 7
      INIT_B =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 6
      INIT_C =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 5
      INIT_D =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 4
      INIT_E =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 3
      INIT_F =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 2
      INIT_G =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 1
      INIT_H =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 0
      IS_WCLK_INVERTED =&gt; '0'        -- Optional inversion for WCLK
   )
   port map (
      O =&gt; O,       -- 8-bit data output
      A =&gt; A,       -- 6-bit address input
      D =&gt; D,       -- 1-bit input: Write data input
      WCLK =&gt; WCLK, -- 1-bit input: Write clock input
      WE =&gt; WE,     -- 1-bit input: Write enable input
      WSEL =&gt; WSEL  -- 3-bit write select
   );

   -- End of RAM64X8SW_inst instantiation
					</Template>
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 x 1 negedge write (RAM32X1D_1)" treetype="template">

-- RAM32X1D_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_1_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D_1: 32 x 1 negative edge write, asynchronous read 
   --             dual-port distributed RAM
   --             Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1_inst : RAM32X1D_1
   generic map (
      INIT =&gt; X"00000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_1_inst instantiation
						</Template>
						<Template label="32 x 1 posedge write (RAM32X1D)" treetype="template">

--   RAM32X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D: 32 x 1 positive edge write, asynchronous read 
   --              dual-port distributed RAM
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_inst : RAM32X1D
   generic map (
      INIT =&gt; X"00000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_inst instantiation

						</Template>
						<Template label="64 x 1 posedge write (RAM64X1D)" treetype="template">

--   RAM64X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1D: 64 x 1 positive edge write, asynchronous read 
   --           dual-port distributed RAM
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1D_inst : RAM64X1D
   generic map (
      INIT =&gt; X"0000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      A5 =&gt; A5,       -- R/W address[5] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      DPRA5 =&gt; DPRA5, -- Read-only address[5] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM64X1D_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">

--  RAM128X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read 
   --            dual-port distributed LUT RAM
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1D_inst : RAM128X1D
   generic map (
      INIT =&gt; X"00000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read/Write port 1-bit ouput
      SPO =&gt; SPO,     -- Read port 1-bit output
      A =&gt; A,         -- Read/Write port 7-bit address input
      D =&gt; D,         -- RAM data input
      DPRA =&gt; DPRA,   -- Read port 7-bit address input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1D_inst instantiation

						</Template>
						<Template label="256 X 1 posedge write (RAM256X1D)" treetype="template">

--  RAM256X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM256X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM256X1D: 256-deep by 1-wide positive edge write, asynchronous read 
   --            dual-port distributed LUT RAM
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM256X1D_inst : RAM256X1D
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DPO =&gt; DPO,     -- Read/Write port 1-bit ouput
      SPO =&gt; SPO,     -- Read port 1-bit output
      A =&gt; A,         -- Read/Write port 8-bit address input
      D =&gt; D,         -- RAM data input
      DPRA =&gt; DPRA,   -- Read port 8-bit address input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM256X1D_inst instantiation


						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">

--   RAM32M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M: 32-deep by 8-wide Multi Port LUT RAM
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32M_inst : RAM32M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",    -- Initial contents of D port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read/Write port D 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 5-bit address input
      DIA =&gt; DIA, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M_inst instantiation


--   RAM32M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M: 32-deep by 8-wide Multi Port LUT RAM
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32M_inst : RAM32M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",    -- Initial contents of D port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read/Write port D 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 5-bit address input
      DIA =&gt; DIA, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M_inst instantiation
						</Template>
						<Template label="32 X 16 (RAM32M16)" treetype="template">
--   RAM32M16  : In order to incorporate this function into the design,
--     VHDL    : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M16_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M16: 32-deep by 16-wide Multi Port LUT RAM
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4
 RAM32M16_inst : RAM32M16
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",   -- Initial contents of D port
      INIT_E =&gt; X"0000000000000000",   -- Initial contents of E port
      INIT_F =&gt; X"0000000000000000",   -- Initial contents of F port
      INIT_G =&gt; X"0000000000000000",   -- Initial contents of G port
      INIT_H =&gt; X"0000000000000000",   -- Initial contents of H port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read port D 2-bit output
      DOE =&gt; DOE, -- Read port E 2-bit output
      DOF =&gt; DOF, -- Read port F 2-bit output
      DOG =&gt; DOG, -- Read port G 2-bit output
      DOH =&gt; DOH, -- Read/write port H 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read port D 5-bit address input
      ADDRE =&gt; ADDRE,   -- Read port E 5-bit address input
      ADDRF =&gt; ADDRF,   -- Read port F 5-bit address input
      ADDRG =&gt; ADDRG,   -- Read port G 5-bit address input
      ADDRH =&gt; ADDRH,   -- Read/write port H 5-bit address input
      DIA =&gt; DIA,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRA
      DIB =&gt; DIB,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRB
      DIC =&gt; DIC,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRC
      DID =&gt; DID,       -- RAM 2-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRD
      DIE =&gt; DIE,       -- RAM 2-bit data write input addressed by ADDRE,
                        -- read addressed by ADDRE
      DIF =&gt; DIF,       -- RAM 2-bit data write input addressed by ADDRF,
                        -- read addressed by ADDRF
      DIG =&gt; DIG,       -- RAM 2-bit data write input addressed by ADDRG,
                        -- read addressed by ADDRG
      DIH =&gt; DIH,       -- RAM 2-bit data write input addressed by ADDRH,
                        -- read addressed by ADDRH
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M16_inst instantiation
						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">

--   RAM64M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64M: 64-deep by 4-wide Multi Port LUT RAM 
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM64M_inst : RAM64M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",    -- Initial contents of D port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 1-bit output
      DOB =&gt; DOB, -- Read port B 1-bit output
      DOC =&gt; DOC, -- Read port C 1-bit output
      DOD =&gt; DOD, -- Read/Write port D 1-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 6-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 6-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 6-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 6-bit address input
      DIA =&gt; DIA, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM64M_inst instantiation

						</Template>
						<Template label="64 X 8 (RAM64M8)" treetype="template">
--   RAM64M8  : In order to incorporate this function into the design,
--     VHDL    : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64M8_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64M8: 64-deep by 8-wide Multi Port LUT RAM
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4
 RAM64M8_inst : RAM64M8
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000",   -- Initial contents of D port
      INIT_E =&gt; X"0000000000000000",   -- Initial contents of E port
      INIT_F =&gt; X"0000000000000000",   -- Initial contents of F port
      INIT_G =&gt; X"0000000000000000",   -- Initial contents of G port
      INIT_H =&gt; X"0000000000000000",   -- Initial contents of H port
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      DOA =&gt; DOA, -- Read port A 1-bit output
      DOB =&gt; DOB, -- Read port B 1-bit output
      DOC =&gt; DOC, -- Read port C 1-bit output
      DOD =&gt; DOD, -- Read port D 1-bit output
      DOE =&gt; DOE, -- Read port E 1-bit output
      DOF =&gt; DOF, -- Read port F 1-bit output
      DOG =&gt; DOG, -- Read port G 1-bit output
      DOH =&gt; DOH, -- Read/write port H 1-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 6-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 6-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 6-bit address input
      ADDRD =&gt; ADDRD,   -- Read port D 6-bit address input
      ADDRE =&gt; ADDRE,   -- Read port E 6-bit address input
      ADDRF =&gt; ADDRF,   -- Read port F 6-bit address input
      ADDRG =&gt; ADDRG,   -- Read port G 6-bit address input
      ADDRH =&gt; ADDRH,   -- Read/write port H 6-bit address input
      DIA =&gt; DIA,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRA
      DIB =&gt; DIB,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRB
      DIC =&gt; DIC,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRC
      DID =&gt; DID,       -- RAM 1-bit data write input addressed by ADDRD,
                        -- read addressed by ADDRD
      DIE =&gt; DIE,       -- RAM 1-bit data write input addressed by ADDRE,
                        -- read addressed by ADDRE
      DIF =&gt; DIF,       -- RAM 1-bit data write input addressed by ADDRF,
                        -- read addressed by ADDRF
      DIG =&gt; DIG,       -- RAM 1-bit data write input addressed by ADDRG,
                        -- read addressed by ADDRG
      DIH =&gt; DIH,       -- RAM 1-bit data write input addressed by ADDRH,
                        -- read addressed by ADDRH
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64M8_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">

--  RAM32X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM 
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1S_inst : RAM32X1S
   generic map (
      INIT =&gt; X"00000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,       -- RAM output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D =&gt; D,       -- RAM data input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X1S_inst instantiation
						</Template>
						<SubFolder label="64 Deep (6-bit address)" treetype="folder">
							<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">

--  RAM64X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port distributed RAM
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1S_inst : RAM64X1S
   generic map (
      INIT =&gt; X"0000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,        -- 1-bit data output
      A0 =&gt; A0,      -- Address[0] input bit
      A1 =&gt; A1,      -- Address[1] input bit
      A2 =&gt; A2,      -- Address[2] input bit
      A3 =&gt; A3,      -- Address[3] input bit
      A4 =&gt; A4,      -- Address[4] input bit
      A5 =&gt; A5,      -- Address[5] input bit
      D =&gt; D,        -- 1-bit data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="128 Deep (7-bit address)" treetype="folder">
							<Template label="128 x 1 negedge write (RAM128X1S_1)" treetype="template">

--RAM128X1S_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S_1: 128-deep x 1 negative edge write, asynchronous read 
   --              single-port distributed RAM
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation
							</Template>
							<Template label="128 x 1 posedge write (RAM128X1S)" treetype="template">

--  RAM128X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S: 128-deep x 1 positive edge write, asynchronous read 
   --            single-port distributed RAM
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation

							</Template>
						</SubFolder>
						<SubFolder label="256 Deep (8-bit address)" treetype="folder">
							<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">

--  RAM256X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM256X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read 
   --            single-port distributed LUT RAM
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM256X1S_inst : RAM256X1S
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,  -- Read/Write port 1-bit ouput
      A =&gt; A,  -- Read/Write port 8-bit address input
      D =&gt; D,  -- RAM data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE -- Write enable input
   );

   -- End of RAM256X1S_inst instantiation

							</Template>
						</SubFolder>
						<SubFolder label="512 Deep (9-bit address)" treetype="folder">
							<Template label="512 X 1 posedge write (RAM512X1S)" treetype="template">

--  RAM512X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM512X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM512X1S: 512-deep by 1-wide positive edge write, asynchronous read 
   --            single-port distributed LUT RAM
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RAM512X1S_inst : RAM512X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", -- Initial contents of RAM
      IS_WCLK_INVERTED =&gt; '0') -- Specifies active high/low WCLK
   port map (
      O =&gt; O,  -- Read/Write port 1-bit ouput
      A =&gt; A,  -- Read/Write port 9-bit address input
      D =&gt; D,  -- RAM data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE -- Write enable input
   );

   -- End of RAM512X1S_inst instantiation

							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="MUXF" treetype="folder">
					<Template label="CLB MUX to connect two LUT6's Together (MUXF7)" treetype="template">
--    MUXF7    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF7_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7: CLB MUX to connect two LUT6's Together
   --        Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_inst : MUXF7
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to LUT6 output
      I1 =&gt; I1, -- 1-bit input: Connect to LUT6 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF7_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF7's Together (MUXF8)" treetype="template">
--    MUXF8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF8_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8: CLB MUX to connect two MUXF7's Together
   --        Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_inst : MUXF8
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to MUXF7 output
      I1 =&gt; I1, -- 1-bit input: Connect to MUXF7 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF8_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF8's Together (MUXF9)" treetype="template">
--    MUXF9    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF9_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF9: CLB MUX to connect two MUXF8's Together
   --        Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MUXF9_inst : MUXF9
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to MUXF8 output
      I1 =&gt; I1, -- 1-bit input: Connect to MUXF8 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF9_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="16-Bit Shift Register Look-Up Table (LUT) (SRL16E)" treetype="template">
--   SRL16E    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SRL16E_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRL16E: 16-Bit Shift Register Look-Up Table (LUT)
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   SRL16E_inst : SRL16E
   generic map (
      INIT =&gt; X"0000",        -- Initial contents of shift register
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: SRL Data
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      D =&gt; D,     -- 1-bit input: SRL Data
      -- Depth Selection inputs: A0-A3 select SRL depth
      A0 =&gt; A0,
      A1 =&gt; A1,
      A2 =&gt; A2,
      A3 =&gt; A3 
   );

   -- End of SRL16E_inst instantiation
					</Template>
					<Template label="32-Bit Shift Register Look-Up Table (LUT) (SRLC32E)" treetype="template">
--   SRLC32E   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SRLC32E_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRLC32E: 32-Bit Shift Register Look-Up Table (LUT)
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   SRLC32E_inst : SRLC32E
   generic map (
      INIT =&gt; X"00000000",    -- Initial contents of shift register
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: SRL Data
      Q31 =&gt; Q31, -- 1-bit output: SRL Cascade Data
      A =&gt; A,     -- 5-bit input: Selects SRL depth
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      D =&gt; D      -- 1-bit input: SRL Data
   );

   -- End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLOCK" treetype="folder">
				<SubFolder label="BUFFER" treetype="folder">
					<Template label="Clock Buffer Driven by Gigabit Transceiver (BUFG_GT)" treetype="template">
--   BUFG_GT   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_GT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_GT: Clock Buffer Driven by Gigabit Transceiver
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_GT_inst : BUFG_GT
   port map (
      O =&gt; O,             -- 1-bit output: Buffer
      CE =&gt; CE,           -- 1-bit input: Buffer enable
      CEMASK =&gt; CEMASK,   -- 1-bit input: CE Mask
      CLR =&gt; CLR,         -- 1-bit input: Asynchronous clear
      CLRMASK =&gt; CLRMASK, -- 1-bit input: CLR Mask
      DIV =&gt; DIV,         -- 3-bit input: Dynamic divide Value
      I =&gt; I              -- 1-bit input: Buffer
   );

   -- End of BUFG_GT_inst instantiation
					</Template>
					<Template label="General Clock Buffer (BUFG)" treetype="template">
--    BUFG     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG: General Clock Buffer
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_inst : BUFG
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFG_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
--   BUFGCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE: General Clock Buffer with Clock Enable
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_inst : BUFGCE
   generic map (
      CE_TYPE =&gt; "SYNC",     -- ASYNC, SYNC
      IS_CE_INVERTED =&gt; '0', -- Programmable inversion on CE
      IS_I_INVERTED =&gt; '0'   -- Programmable inversion on I
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer
      CE =&gt; CE, -- 1-bit input: Buffer enable
      I =&gt; I    -- 1-bit input: Buffer
   );

   -- End of BUFGCE_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Divide (BUFGCE_DIV)" treetype="template">
-- BUFGCE_DIV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_DIV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_DIV: General Clock Buffer with Divide Function
   --             Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_DIV_inst : BUFGCE_DIV
   generic map (
      BUFGCE_DIVIDE =&gt; 1,     -- 1-8
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CE_INVERTED =&gt; '0',  -- Optional inversion for CE
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_I_INVERTED =&gt; '0'    -- Optional inversion for I
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer
      CE =&gt; CE,   -- 1-bit input: Buffer enable
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      I =&gt; I      -- 1-bit input: Buffer
   );

   -- End of BUFGCE_DIV_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
--  BUFGCE_1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_1: General Clock Buffer with Clock Enable and Output State 1
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_1_inst : BUFGCE_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock buffer active-High enable
      I =&gt; I    -- 1-bit input: Clock input
   );

   -- End of BUFGCE_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="CLOCK_SYNC" treetype="folder">
					<Template label="Synchronizer for BUFG_GT Control Signals (BUFG_GT_SYNC)" treetype="template">
-- BUFG_GT_SYNC : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFG_GT_SYNC_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_GT_SYNC: Synchronizer for BUFG_GT Control Signals
   --               Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_GT_SYNC_inst : BUFG_GT_SYNC
   port map (
      CESYNC =&gt; CESYNC,   -- 1-bit output: Synchronized CE
      CLRSYNC =&gt; CLRSYNC, -- 1-bit output: Synchronized CLR
      CE =&gt; CE,           -- 1-bit input: Asynchronous enable
      CLK =&gt; CLK,         -- 1-bit input: Clock
      CLR =&gt; CLR          -- 1-bit input: Asynchronous clear
   );

   -- End of BUFG_GT_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUX" treetype="folder">
					<Template label="2-to-1 General Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
-- BUFGMUX_CTRL : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_CTRL: 2-to-1 General Clock MUX Buffer
   --               Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL_inst : BUFGMUX_CTRL
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="General Clock Control Buffer (BUFGCTRL)" treetype="template">
--  BUFGCTRL   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCTRL: General Clock Control Buffer
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCTRL_inst : BUFGCTRL
   generic map (
      INIT_OUT =&gt; 0,              -- Initial value of BUFGCTRL output, 0-1
      PRESELECT_I0 =&gt; FALSE,      -- BUFGCTRL output uses I0 input, FALSE, TRUE
      PRESELECT_I1 =&gt; FALSE,      -- BUFGCTRL output uses I1 input, FALSE, TRUE
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CE0_INVERTED =&gt; '0',     -- Optional inversion for CE0
      IS_CE1_INVERTED =&gt; '0',     -- Optional inversion for CE1
      IS_I0_INVERTED =&gt; '0',      -- Optional inversion for I0
      IS_I1_INVERTED =&gt; '0',      -- Optional inversion for I1
      IS_IGNORE0_INVERTED =&gt; '0', -- Optional inversion for IGNORE0
      IS_IGNORE1_INVERTED =&gt; '0', -- Optional inversion for IGNORE1
      IS_S0_INVERTED =&gt; '0',      -- Optional inversion for S0
      IS_S1_INVERTED =&gt; '0'       -- Optional inversion for S1
   )
   port map (
      O =&gt; O,             -- 1-bit output: Clock output
      CE0 =&gt; CE0,         -- 1-bit input: Clock enable input for I0
      CE1 =&gt; CE1,         -- 1-bit input: Clock enable input for I1
      I0 =&gt; I0,           -- 1-bit input: Primary clock
      I1 =&gt; I1,           -- 1-bit input: Secondary clock
      IGNORE0 =&gt; IGNORE0, -- 1-bit input: Clock ignore input for I0
      IGNORE1 =&gt; IGNORE1, -- 1-bit input: Clock ignore input for I1
      S0 =&gt; S0,           -- 1-bit input: Clock select for I0
      S1 =&gt; S1            -- 1-bit input: Clock select for I1
   );

   -- End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer (BUFGMUX)" treetype="template">
--   BUFGMUX   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX: General Clock Mux Buffer
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_inst : BUFGMUX
   generic map (
      CLK_SEL_TYPE =&gt; "SYNC"  -- ASYNC, SYNC
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
--  BUFGMUX_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_1: General Clock Mux Buffer with Output State 1
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1_inst : BUFGMUX_1
   generic map (
      CLK_SEL_TYPE =&gt; "SYNC"  -- ASYNC, SYNC
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME3_ADV)" treetype="template">
-- MMCME3_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME3_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME3_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   --             Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MMCME3_ADV_inst : MMCME3_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",        -- Jitter programming (HIGH, LOW, OPTIMIZED)
      CLKFBOUT_MULT_F =&gt; 5.0,          -- Multiply value for all CLKOUT (2.000-64.000)
      CLKFBOUT_PHASE =&gt; 0.0,           -- Phase offset in degrees of CLKFB (-360.000-360.000)
      -- CLKIN_PERIOD: Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      CLKOUT0_DIVIDE_F =&gt; 1.0,         -- Divide amount for CLKOUT0 (1.000-128.000)
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      -- CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_CASCADE =&gt; "FALSE",
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      COMPENSATION =&gt; "AUTO",          -- AUTO, BUF_IN, EXTERNAL, INTERNAL, ZHOLD
      DIVCLK_DIVIDE =&gt; 1,              -- Master division value (1-106)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0',      -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',       -- Optional inversion for CLKIN1
      IS_CLKIN2_INVERTED =&gt; '0',       -- Optional inversion for CLKIN2
      IS_CLKINSEL_INVERTED =&gt; '0',     -- Optional inversion for CLKINSEL
      IS_PSEN_INVERTED =&gt; '0',         -- Optional inversion for PSEN
      IS_PSINCDEC_INVERTED =&gt; '0',     -- Optional inversion for PSINCDEC
      IS_PWRDWN_INVERTED =&gt; '0',       -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',          -- Optional inversion for RST
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; "FALSE",         -- Delays DONE until MMCM is locked (FALSE, TRUE)
      -- Spread Spectrum: Spread Spectrum Attributes
      SS_EN =&gt; "FALSE",                -- Enables spread spectrum (FALSE, TRUE)
      SS_MODE =&gt; "CENTER_HIGH",        -- CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      SS_MOD_PERIOD =&gt; 10000,          -- Spread spectrum modulation period (ns) (4000-40000)
      -- USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      CLKFBOUT_USE_FINE_PS =&gt; "FALSE",
      CLKOUT0_USE_FINE_PS =&gt; "FALSE",
      CLKOUT1_USE_FINE_PS =&gt; "FALSE",
      CLKOUT2_USE_FINE_PS =&gt; "FALSE",
      CLKOUT3_USE_FINE_PS =&gt; "FALSE",
      CLKOUT4_USE_FINE_PS =&gt; "FALSE",
      CLKOUT5_USE_FINE_PS =&gt; "FALSE",
      CLKOUT6_USE_FINE_PS =&gt; "FALSE" 
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,           -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,         -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,           -- 1-bit output: Primary clock
      CLKOUT1B =&gt; CLKOUT1B,         -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,           -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,         -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,           -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,         -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,           -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,           -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,           -- 1-bit output: CLKOUT6
      -- DRP Ports outputs: Dynamic reconfiguration ports
      DO =&gt; DO,                     -- 16-bit output: DRP data
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP ready
      -- Dynamic Phase Shift Ports outputs: Ports used for dynamic phase shifting of the outputs
      PSDONE =&gt; PSDONE,             -- 1-bit output: Phase shift done
      -- Feedback outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,         -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB,       -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports outputs: MMCM status ports
      CDDCDONE =&gt; CDDCDONE,         -- 1-bit output: Clock dynamic divide done
      CLKFBSTOPPED =&gt; CLKFBSTOPPED, -- 1-bit output: Feedback clock stopped
      CLKINSTOPPED =&gt; CLKINSTOPPED, -- 1-bit output: Input clock stopped
      LOCKED =&gt; LOCKED,             -- 1-bit output: LOCK
      CDDCREQ =&gt; CDDCREQ,           -- 1-bit input: Request to dynamic divide clock
      -- Clock Inputs inputs: Clock inputs
      CLKIN1 =&gt; CLKIN1,             -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,             -- 1-bit input: Secondary clock
      -- Control Ports inputs: MMCM control ports
      CLKINSEL =&gt; CLKINSEL,         -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,             -- 1-bit input: Power-down
      RST =&gt; RST,                   -- 1-bit input: Reset
      -- DRP Ports inputs: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable
      DI =&gt; DI,                     -- 16-bit input: DRP data
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- Dynamic Phase Shift Ports inputs: Ports used for dynamic phase shifting of the outputs
      PSCLK =&gt; PSCLK,               -- 1-bit input: Phase shift clock
      PSEN =&gt; PSEN,                 -- 1-bit input: Phase shift enable
      PSINCDEC =&gt; PSINCDEC,         -- 1-bit input: Phase shift increment/decrement
      -- Feedback inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN            -- 1-bit input: Feedback clock
   );

   -- End of MMCME3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE3_ADV)" treetype="template">
--  PLLE3_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE3_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE3_ADV: Advanced Phase-Locked Loop (PLL)
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   PLLE3_ADV_inst : PLLE3_ADV
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT, (1-19)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB, (-360.000-360.000)
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0 (1-128)
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0 (0.001-0.999)
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0 (-360.000-360.000)
      -- CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1 (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1 (0.001-0.999)
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1 (-360.000-360.000)
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      COMPENSATION =&gt; "AUTO",     -- AUTO, BUF_IN, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value, (1-15)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      -- DRP Ports outputs: Dynamic reconfiguration ports
      DO =&gt; DO,                   -- 16-bit output: DRP data
      DRDY =&gt; DRDY,               -- 1-bit output: DRP ready
      -- Feedback Clocks outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      -- Control Ports inputs: PLL control ports
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST,                 -- 1-bit input: Reset
      -- DRP Ports inputs: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,             -- 7-bit input: DRP address
      DCLK =&gt; DCLK,               -- 1-bit input: DRP clock
      DEN =&gt; DEN,                 -- 1-bit input: DRP enable
      DI =&gt; DI,                   -- 16-bit input: DRP data
      DWE =&gt; DWE,                 -- 1-bit input: DRP write enable
      -- Feedback Clocks inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN          -- 1-bit input: Feedback clock
   );

   -- End of PLLE3_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME3_BASE)" treetype="template">
-- MMCME3_BASE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME3_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME3_BASE: Base Mixed Mode Clock Manager (MMCM)
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MMCME3_BASE_inst : MMCME3_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",   -- Jitter programming (HIGH, LOW, OPTIMIZED)
      CLKFBOUT_MULT_F =&gt; 5.0,     -- Multiply value for all CLKOUT (2.000-64.000)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB (-360.000-360.000)
      CLKIN1_PERIOD =&gt; 0.0,       -- Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE_F =&gt; 1.0,    -- Divide amount for CLKOUT0 (1.000-128.000)
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      -- CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT4_CASCADE =&gt; "FALSE", -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value (1-106)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',  -- Optional inversion for CLKIN1
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER1 =&gt; 0.0,         -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,     -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,   -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,     -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,   -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,     -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,   -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,     -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,   -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,     -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,     -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,     -- 1-bit output: CLKOUT6
      -- Feedback outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,   -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB, -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports outputs: MMCM status ports
      LOCKED =&gt; LOCKED,       -- 1-bit output: LOCK
      -- Clock Inputs inputs: Clock input
      CLKIN1 =&gt; CLKIN1,       -- 1-bit input: Clock
      -- Control Ports inputs: MMCM control ports
      PWRDWN =&gt; PWRDWN,       -- 1-bit input: Power-down
      RST =&gt; RST,             -- 1-bit input: Reset
      -- Feedback inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN      -- 1-bit input: Feedback clock
   );

   -- End of MMCME3_BASE_inst instantiation
					</Template>
					<Template label="Base Phase-Locked Loop (PLL) (PLLE3_BASE)" treetype="template">
-- PLLE3_BASE  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE3_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE3_BASE: Base Phase-Locked Loop (PLL)
   --             Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   PLLE3_BASE_inst : PLLE3_BASE
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT, (1-19)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB, (-360.000-360.000)
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0 (1-128)
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0 (0.001-0.999)
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0 (-360.000-360.000)
      -- CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1 (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1 (0.001-0.999)
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1 (-360.000-360.000)
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value, (1-15)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      -- Feedback Clocks outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      -- Control Ports inputs: PLL control ports
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST,                 -- 1-bit input: Reset
      -- Feedback Clocks inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN          -- 1-bit input: Feedback clock
   );

   -- End of PLLE3_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CONFIGURATION" treetype="folder">
				<SubFolder label="BSCAN" treetype="folder">
					<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
--   BSCANE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BSCANE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BSCANE2: Boundary-Scan User Instruction
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BSCANE2_inst : BSCANE2
   generic map (
      JTAG_CHAIN =&gt; 1  -- Value for USER command
   )
   port map (
      CAPTURE =&gt; CAPTURE, -- 1-bit output: CAPTURE output from TAP controller.
      DRCK =&gt; DRCK,       -- 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                          -- SHIFT are asserted.

      RESET =&gt; RESET,     -- 1-bit output: Reset output for TAP controller.
      RUNTEST =&gt; RUNTEST, -- 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      SEL =&gt; SEL,         -- 1-bit output: USER instruction active output.
      SHIFT =&gt; SHIFT,     -- 1-bit output: SHIFT output from TAP controller.
      TCK =&gt; TCK,         -- 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      TDI =&gt; TDI,         -- 1-bit output: Test Data Input (TDI) output from TAP controller.
      TMS =&gt; TMS,         -- 1-bit output: Test Mode Select output. Fabric connection to TAP.
      UPDATE =&gt; UPDATE,   -- 1-bit output: UPDATE output from TAP controller
      TDO =&gt; TDO          -- 1-bit input: Test Data Output (TDO) input for USER function.
   );

   -- End of BSCANE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DNA" treetype="folder">
					<Template label="Device DNA Access Port (DNA_PORTE2)" treetype="template">
-- DNA_PORTE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DNA_PORTE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DNA_PORTE2: Device DNA Access Port
   --             Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   DNA_PORTE2_inst : DNA_PORTE2
   generic map (
      SIM_DNA_VALUE =&gt; X"000000000000000000000000"  -- Specifies a sample 96-bit DNA value for simulation
   )
   port map (
      DOUT =&gt; DOUT,   -- 1-bit output: DNA output data
      CLK =&gt; CLK,     -- 1-bit input: Clock input
      DIN =&gt; DIN,     -- 1-bit input: User data input pin
      READ =&gt; READ,   -- 1-bit input: Active-High load DNA, active-Low read input
      SHIFT =&gt; SHIFT  -- 1-bit input: Active-High shift enable input
   );

   -- End of DNA_PORTE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="EFUSE" treetype="folder">
					<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
--  EFUSE_USR  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (EFUSE_USR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EFUSE_USR: 32-bit non-volatile design ID
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   EFUSE_USR_inst : EFUSE_USR
   generic map (
      SIM_EFUSE_VALUE =&gt; X"00000000"  -- Value of the 32-bit non-volatile value used in simulation
   )
   port map (
      EFUSEUSR =&gt; EFUSEUSR  -- 32-bit output: User eFUSE register value output
   );

   -- End of EFUSE_USR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="ICAP" treetype="folder">
					<Template label="Internal Configuration Access Port (ICAPE3)" treetype="template">
--   ICAPE3    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ICAPE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ICAPE3: Internal Configuration Access Port
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   ICAPE3_inst : ICAPE3
   generic map (
      DEVICE_ID =&gt; X"03628093",      -- Specifies the pre-programmed Device ID value to be used for simulation
                                     -- purposes.
      ICAP_AUTO_SWITCH =&gt; "DISABLE", -- Enable switch ICAP using sync word
      SIM_CFG_FILE_NAME =&gt; "NONE"    -- Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                     -- model
   )
   port map (
      AVAIL =&gt; AVAIL,     -- 1-bit output: Availability status of ICAP
      O =&gt; O,             -- 32-bit output: Configuration data output bus
      PRDONE =&gt; PRDONE,   -- 1-bit output: Indicates completion of Partial Reconfiguration
      PRERROR =&gt; PRERROR, -- 1-bit output: Indicates Error during Partial Reconfiguration
      CLK =&gt; CLK,         -- 1-bit input: Clock input
      CSIB =&gt; CSIB,       -- 1-bit input: Active-Low ICAP enable
      I =&gt; I,             -- 32-bit input: Configuration data input bus
      RDWRB =&gt; RDWRB      -- 1-bit input: Read/Write Select input
   );

   -- End of ICAPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MASTER_JTAG" treetype="folder">
					<Template label="JTAG Port Access (MASTER_JTAG)" treetype="template">
-- MASTER_JTAG : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MASTER_JTAG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MASTER_JTAG: JTAG Port Access
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   MASTER_JTAG_inst : MASTER_JTAG
   port map (
      TDO =&gt; TDO, -- 1-bit output: JTAG TDO output pin
      TCK =&gt; TCK, -- 1-bit input: JTAG TCK input pin
      TDI =&gt; TDI, -- 1-bit input: JTAG TDI input pin
      TMS =&gt; TMS  -- 1-bit input: JTAG TMS input pin
   );

   -- End of MASTER_JTAG_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="STARTUP" treetype="folder">
					<Template label="STARTUP Block (STARTUPE3)" treetype="template">
--  STARTUPE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (STARTUPE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- STARTUPE3: STARTUP Block
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   STARTUPE3_inst : STARTUPE3
   generic map (
      PROG_USR =&gt; "FALSE",  -- Activate program event security feature. Requires encrypted bitstreams.
      SIM_CCLK_FREQ =&gt; 0.0  -- Set the Configuration Clock Frequency (ns) for simulation
   )
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration main clock output
      CFGMCLK =&gt; CFGMCLK,     -- 1-bit output: Configuration internal oscillator clock output
      DI =&gt; DI,               -- 4-bit output: Allow receiving on the D input pin
      EOS =&gt; EOS,             -- 1-bit output: Active-High output signal indicating the End Of Startup
      PREQ =&gt; PREQ,           -- 1-bit output: PROGRAM request to fabric output
      DO =&gt; DO,               -- 4-bit input: Allows control of the D pin output
      DTS =&gt; DTS,             -- 4-bit input: Allows tristate of the D pin
      FCSBO =&gt; FCSBO,         -- 1-bit input: Controls the FCS_B pin for flash access
      FCSBTS =&gt; FCSBTS,       -- 1-bit input: Tristate the FCS_B pin
      GSR =&gt; GSR,             -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port)
      GTS =&gt; GTS,             -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      KEYCLEARB =&gt; KEYCLEARB, -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      PACK =&gt; PACK,           -- 1-bit input: PROGRAM acknowledge input
      USRCCLKO =&gt; USRCCLKO,   -- 1-bit input: User CCLK input
      USRCCLKTS =&gt; USRCCLKTS, -- 1-bit input: User CCLK 3-state enable input
      USRDONEO =&gt; USRDONEO,   -- 1-bit input: User DONE pin output control
      USRDONETS =&gt; USRDONETS  -- 1-bit input: User DONE 3-state enable output
   );

   -- End of STARTUPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="USR_ACCESS" treetype="folder">
					<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
-- USR_ACCESSE2 : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (USR_ACCESSE2_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- USR_ACCESSE2: Configuration Data Access
   --               Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2_inst : USR_ACCESSE2
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration Clock
      DATA =&gt; DATA,           -- 32-bit output: Configuration Data reflecting the contents of the AXSS register
      DATAVALID =&gt; DATAVALID  -- 1-bit output: Active High Data Valid
   );

   -- End of USR_ACCESSE2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="BIDIR_BUFFER" treetype="folder">
					<Template label="Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable (IOBUF_INTERMDISABLE)" treetype="template">
-- IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
--        VHDL         : the following instance declaration needs to be placed
--      instance       : in the body of the design code.  The instance name
--     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations after the
--        code         : "=&gt;" declaration maybe changed to properly reference and
--                     : connect this function to the design.  All inputs and outputs
--                     : must be connected.

--       Library       : In addition to adding the instance declaration, a use
--     declaration     : statement for the UNISIM.vcomponents library needs to be
--         for         : added before the entity declaration.  This library
--       Xilinx        : contains the component declarations for all Xilinx
--     primitives      : primitives and points to the models that will be used
--                     : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_INTERMDISABLE: Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable
   --                      Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_INTERMDISABLE_inst : IOBUF_INTERMDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T                          -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Bidirectional I/O Buffer with Offset Calibration and VREF Tuning (IOBUFE3)" treetype="template">
--   IOBUFE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFE3: Bidirectional I/O Buffer with Offset Calibration and VREF Tuning
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFE3_inst : IOBUFE3
   generic map (
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Buffer inout (connect directly to top-level port)
      OSC =&gt; OSC,                       -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,                 -- 1-bit input: Offset cancellation enable
      T =&gt; T,                           -- 1-bit input: 3-state enable input
      VREF =&gt; VREF                      -- 1-bit input: Vref input from HPIO_VREF
   );

   -- End of IOBUFE3_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
-- IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
--              VHDL              : the following instance declaration needs to be placed
--            instance            : in the body of the design code.  The instance name
--          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations after the
--              code              : "=&gt;" declaration maybe changed to properly reference and
--                                : connect this function to the design.  All inputs and outputs
--                                : must be connected.

--            Library             : In addition to adding the instance declaration, a use
--          declaration           : statement for the UNISIM.vcomponents library needs to be
--              for               : added before the entity declaration.  This library
--             Xilinx             : contains the component declarations for all Xilinx
--           primitives           : primitives and points to the models that will be used
--                                : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable
   --                                 Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst : IOBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                       -- 1-bit output: Buffer diff_n output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Must be tied to a logic '0'
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                     -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,                       -- 1-bit input: 3-state master enable input
      TS =&gt; TS                        -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
-- IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
--          VHDL          : the following instance declaration needs to be placed
--        instance        : in the body of the design code.  The instance name
--      declaration       : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations after the
--          code          : "=&gt;" declaration maybe changed to properly reference and
--                        : connect this function to the design.  All inputs and outputs
--                        : must be connected.

--        Library         : In addition to adding the instance declaration, a use
--      declaration       : statement for the UNISIM.vcomponents library needs to be
--          for           : added before the entity declaration.  This library
--         Xilinx         : contains the component declarations for all Xilinx
--       primitives       : primitives and points to the models that will be used
--                        : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_DCIEN: Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable
   --                         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_DCIEN_inst : IOBUFDS_DIFF_OUT_DCIEN
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                         -- 1-bit output: Buffer diff_n output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Must be tied to a logic '0'
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,                         -- 1-bit input: 3-state master enable input
      TS =&gt; TS                          -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input (IOBUFDS_INTERMDISABLE)" treetype="template">
-- IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--         VHDL          : the following instance declaration needs to be placed
--       instance        : in the body of the design code.  The instance name
--      declaration      : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations after the
--         code          : "=&gt;" declaration maybe changed to properly reference and
--                       : connect this function to the design.  All inputs and outputs
--                       : must be connected.

--        Library        : In addition to adding the instance declaration, a use
--      declaration      : statement for the UNISIM.vcomponents library needs to be
--          for          : added before the entity declaration.  This library
--        Xilinx         : contains the component declarations for all Xilinx
--      primitives       : primitives and points to the models that will be used
--                       : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_INTERMDISABLE: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input
   --                        Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_INTERMDISABLE_inst : IOBUFDS_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                     -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T                          -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DCIEN)" treetype="template">
-- IOBUFDS_DCIEN : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the body of the design code.  The instance name
--  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations after the
--     code      : "=&gt;" declaration maybe changed to properly reference and
--               : connect this function to the design.  All inputs and outputs
--               : must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--  primitives   : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DCIEN: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DCIEN_inst : IOBUFDS_DCIEN
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional I/O Buffer with Offset Calibration (IOBUFDSE3)" treetype="template">
--  IOBUFDSE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFDSE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDSE3: Differential Bidirectional I/O Buffer with Offset Calibration
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDSE3_inst : IOBUFDSE3
   generic map (
      DQS_BIAS =&gt; "FALSE",          -- (FALSE, TRUE)
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      OSC =&gt; OSC,                       -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,                 -- 2-bit input: Offset cancellation enable
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDSE3_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer (IOBUFDS)" treetype="template">
--   IOBUFDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS: Differential Input/Output Buffer
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_inst : IOBUFDS
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer output
      I =&gt; I,     -- 1-bit input: Buffer input
      IO =&gt; IO,   -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T      -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer (IOBUFDS_DIFF_OUT)" treetype="template">
-- IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT: Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer
   --                   Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_inst : IOBUFDS_DIFF_OUT
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,   -- 1-bit output: Buffer diff_n output
      I =&gt; I,     -- 1-bit input: Buffer input
      IO =&gt; IO,   -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,   -- 1-bit input: 3-state master enable input
      TS =&gt; TS    -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Input/Output Buffer DCI Enable (IOBUF_DCIEN)" treetype="template">
-- IOBUF_DCIEN : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUF_DCIEN_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_DCIEN: Input/Output Buffer DCI Enable
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_DCIEN_inst : IOBUF_DCIEN
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Input/Output Buffer (IOBUF)" treetype="template">
--    IOBUF    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF: Input/Output Buffer
   --        Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_inst : IOBUF
   port map (
      O =&gt; O,   -- 1-bit output: Buffer output
      I =&gt; I,   -- 1-bit input: Buffer input
      IO =&gt; IO, -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T    -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="BITSLICE" treetype="folder">
					<Template label="BITSLICE_CONTROL (BITSLICE_CONTROL)" treetype="template">
-- BITSLICE_CONTROL : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (BITSLICE_CONTROL_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BITSLICE_CONTROL: BITSLICE_CONTROL for control using Native Mode
   --                   Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   BITSLICE_CONTROL_inst : BITSLICE_CONTROL
   generic map (
      DIV_MODE =&gt; "DIV2",               -- Controller DIV2/DIV4 mode (DIV2, DIV4)
      EN_CLK_TO_EXT_NORTH =&gt; "DISABLE", -- Enable clock forwarding to north
      EN_CLK_TO_EXT_SOUTH =&gt; "DISABLE", -- Enable clock forwarding to south
      EN_DYN_ODLY_MODE =&gt; "FALSE",      -- Enable dynamic output delay mode
      EN_OTHER_NCLK =&gt; "FALSE",         -- Select the NCLK from the other BITSLICE_CONTROL in the nibble
                                        -- (FALSE, TRUE)
      EN_OTHER_PCLK =&gt; "FALSE",         -- Select the PCLK from the other BITSLICE_CONTROL in the nibble
                                        -- (FALSE, TRUE)
      IDLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for input delays
      INV_RXCLK =&gt; "FALSE",             -- Invert clock path from IOB to upper RX bitslice
      ODLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for output delays
      QDLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for clock delays
      READ_IDLE_COUNT =&gt; X"00",         -- Gap count between read bursts for ODT control counter (0-3f)
      REFCLK_SRC =&gt; "PLLCLK",           -- Select the input clock for the delay control (PLLCLK, REFCLK)
      ROUNDING_FACTOR =&gt; 16,            -- Rounding factor in BISC spec (128-8)
      RXGATE_EXTEND =&gt; "FALSE",         -- Reserved for use by MIG Memory Controller. Do Not Change.
      RX_CLK_PHASE_N =&gt; "SHIFT_0",      -- Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                        -- SHIFT_90)
      RX_CLK_PHASE_P =&gt; "SHIFT_0",      -- Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                        -- SHIFT_90)
      RX_GATING =&gt; "DISABLE",           -- ENABLE/DISABLE read DQS gating
      SELF_CALIBRATE =&gt; "ENABLE",       -- Enable BISC of nibble controlled by BITSLICE_CONTROL
      SERIAL_MODE =&gt; "FALSE",           -- Put BITSLICE read paths into serial mode (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE",       -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                        -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TX_GATING =&gt; "DISABLE"            -- ENABLE/DISABLE clock gating in WClkgen
   )
   port map (
      CLK_TO_EXT_NORTH =&gt; CLK_TO_EXT_NORTH,       -- 1-bit output: Inter-byte clock going to north
                                                  -- BITSLICE_CONTROL

      CLK_TO_EXT_SOUTH =&gt; CLK_TO_EXT_SOUTH,       -- 1-bit output: Inter-byte clock going to south
                                                  -- BITSLICE_CONTROL

      DLY_RDY =&gt; DLY_RDY,                         -- 1-bit output: Fixed delay calibration complete
      DYN_DCI =&gt; DYN_DCI,                         -- 7-bit output: Direct control of IOB DCI when using a
                                                  -- memory interface

      NCLK_NIBBLE_OUT =&gt; NCLK_NIBBLE_OUT,         -- 1-bit output: Intra-byte DQS strobes/clock to other
                                                  -- control block

      PCLK_NIBBLE_OUT =&gt; PCLK_NIBBLE_OUT,         -- 1-bit output: Intra-byte DQS strobes/clock to other
                                                  -- control block

      RIU_RD_DATA =&gt; RIU_RD_DATA,                 -- 16-bit output: RIU Output Read data to the controller
      RIU_VALID =&gt; RIU_VALID,                     -- 1-bit output: Last data written has been accepted when High
      RX_BIT_CTRL_OUT0 =&gt; RX_BIT_CTRL_OUT0,       -- 40-bit output: Output bus to Bitslice 0
      RX_BIT_CTRL_OUT1 =&gt; RX_BIT_CTRL_OUT1,       -- 40-bit output: Output bus to Bitslice 1
      RX_BIT_CTRL_OUT2 =&gt; RX_BIT_CTRL_OUT2,       -- 40-bit output: Output bus to Bitslice 2
      RX_BIT_CTRL_OUT3 =&gt; RX_BIT_CTRL_OUT3,       -- 40-bit output: Output bus to Bitslice 3
      RX_BIT_CTRL_OUT4 =&gt; RX_BIT_CTRL_OUT4,       -- 40-bit output: Output bus to Bitslice 4
      RX_BIT_CTRL_OUT5 =&gt; RX_BIT_CTRL_OUT5,       -- 40-bit output: Output bus to Bitslice 5
      RX_BIT_CTRL_OUT6 =&gt; RX_BIT_CTRL_OUT6,       -- 40-bit output: Output bus to Bitslice 6
      TX_BIT_CTRL_OUT0 =&gt; TX_BIT_CTRL_OUT0,       -- 40-bit output: Output bus to Bitslice 0
      TX_BIT_CTRL_OUT1 =&gt; TX_BIT_CTRL_OUT1,       -- 40-bit output: Output bus to Bitslice 1
      TX_BIT_CTRL_OUT2 =&gt; TX_BIT_CTRL_OUT2,       -- 40-bit output: Output bus to Bitslice 2
      TX_BIT_CTRL_OUT3 =&gt; TX_BIT_CTRL_OUT3,       -- 40-bit output: Output bus to Bitslice 3
      TX_BIT_CTRL_OUT4 =&gt; TX_BIT_CTRL_OUT4,       -- 40-bit output: Output bus to Bitslice 4
      TX_BIT_CTRL_OUT5 =&gt; TX_BIT_CTRL_OUT5,       -- 40-bit output: Output bus to Bitslice 5
      TX_BIT_CTRL_OUT6 =&gt; TX_BIT_CTRL_OUT6,       -- 40-bit output: Output bus to Bitslice 6
      TX_BIT_CTRL_OUT_TRI =&gt; TX_BIT_CTRL_OUT_TRI, -- 40-bit output: Output bus to 3-state TX_BITSLICE_TRI
      VTC_RDY =&gt; VTC_RDY,                         -- 1-bit output: PHY calibration is complete
      CLK_FROM_EXT =&gt; CLK_FROM_EXT,               -- 1-bit input: Inter-byte clock coming from north or south
                                                  -- BITSLICE_CONTROL

      EN_VTC =&gt; EN_VTC,                           -- 1-bit input: Enables voltage and temperature compensation
                                                  -- when High

      NCLK_NIBBLE_IN =&gt; NCLK_NIBBLE_IN,           -- 1-bit input: Intra-byte DQS strobes from other/clock
                                                  -- control block

      PCLK_NIBBLE_IN =&gt; PCLK_NIBBLE_IN,           -- 1-bit input: Intra-byte DQS strobes/clock from other
                                                  -- control block

      PHY_RDCS0 =&gt; PHY_RDCS0,                     -- 4-bit input: Rank select
      PHY_RDCS1 =&gt; PHY_RDCS1,                     -- 4-bit input: Rank select
      PHY_RDEN =&gt; PHY_RDEN,                       -- 4-bit input: Read burst enable when using a memory
                                                  -- interface

      PHY_WRCS0 =&gt; PHY_WRCS0,                     -- 4-bit input: Rank select
      PHY_WRCS1 =&gt; PHY_WRCS1,                     -- 4-bit input: Rank select
      PLL_CLK =&gt; PLL_CLK,                         -- 1-bit input: PLL clock input
      REFCLK =&gt; REFCLK,                           -- 1-bit input: Frequency reference clock for delay control
      RIU_ADDR =&gt; RIU_ADDR,                       -- 6-bit input: Address input for RIU
      RIU_CLK =&gt; RIU_CLK,                         -- 1-bit input: System clock from fabric for RIU access
      RIU_NIBBLE_SEL =&gt; RIU_NIBBLE_SEL,           -- 1-bit input: Nibble select to enable RIU read/write
      RIU_WR_DATA =&gt; RIU_WR_DATA,                 -- 16-bit input: RIU Input Write data from the controller
      RIU_WR_EN =&gt; RIU_WR_EN,                     -- 1-bit input: Enables write to RIU when High
      RST =&gt; RST,                                 -- 1-bit input: Asynchronous global reset
      RX_BIT_CTRL_IN0 =&gt; RX_BIT_CTRL_IN0,         -- 40-bit input: Input bus from Bitslice 0
      RX_BIT_CTRL_IN1 =&gt; RX_BIT_CTRL_IN1,         -- 40-bit input: Input bus from Bitslice 1
      RX_BIT_CTRL_IN2 =&gt; RX_BIT_CTRL_IN2,         -- 40-bit input: Input bus from Bitslice 2
      RX_BIT_CTRL_IN3 =&gt; RX_BIT_CTRL_IN3,         -- 40-bit input: Input bus from Bitslice 3
      RX_BIT_CTRL_IN4 =&gt; RX_BIT_CTRL_IN4,         -- 40-bit input: Input bus from Bitslice 4
      RX_BIT_CTRL_IN5 =&gt; RX_BIT_CTRL_IN5,         -- 40-bit input: Input bus from Bitslice 5
      RX_BIT_CTRL_IN6 =&gt; RX_BIT_CTRL_IN6,         -- 40-bit input: Input bus from Bitslice 6
      TBYTE_IN =&gt; TBYTE_IN,                       -- 4-bit input: Output enable for 3-state control
      TX_BIT_CTRL_IN0 =&gt; TX_BIT_CTRL_IN0,         -- 40-bit input: Input bus from Bitslice 0
      TX_BIT_CTRL_IN1 =&gt; TX_BIT_CTRL_IN1,         -- 40-bit input: Input bus from Bitslice 1
      TX_BIT_CTRL_IN2 =&gt; TX_BIT_CTRL_IN2,         -- 40-bit input: Input bus from Bitslice 2
      TX_BIT_CTRL_IN3 =&gt; TX_BIT_CTRL_IN3,         -- 40-bit input: Input bus from Bitslice 3
      TX_BIT_CTRL_IN4 =&gt; TX_BIT_CTRL_IN4,         -- 40-bit input: Input bus from Bitslice 4
      TX_BIT_CTRL_IN5 =&gt; TX_BIT_CTRL_IN5,         -- 40-bit input: Input bus from Bitslice 5
      TX_BIT_CTRL_IN6 =&gt; TX_BIT_CTRL_IN6,         -- 40-bit input: Input bus from Bitslice 6
      TX_BIT_CTRL_IN_TRI =&gt; TX_BIT_CTRL_IN_TRI    -- 40-bit input: Input bus from 3-state TX_BITSLICE_TRI
   );

   -- End of BITSLICE_CONTROL_inst instantiation
					</Template>
					<Template label="Register Interface Unit Selection Block (RIU_OR)" treetype="template">
--   RIU_OR    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RIU_OR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RIU_OR: Register Interface Unit Selection Block
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RIU_OR_inst : RIU_OR
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      RIU_RD_DATA =&gt; RIU_RD_DATA,           -- 16-bit output: RIU data bus to the controller
      RIU_RD_VALID =&gt; RIU_RD_VALID,         -- 1-bit output: Combined RIU read valid signal to the controller
      RIU_RD_DATA_LOW =&gt; RIU_RD_DATA_LOW,   -- 16-bit input: RIU data bus from the controller to the lower
                                            -- nibble BITSLICE_CONTROL

      RIU_RD_DATA_UPP =&gt; RIU_RD_DATA_UPP,   -- 16-bit input: RIU data bus from the controller to the upper
                                            -- nibble BITSLICE_CONTROL

      RIU_RD_VALID_LOW =&gt; RIU_RD_VALID_LOW, -- 1-bit input: RIU_VALID of the lower nibble BITSLICE_CONTROL
      RIU_RD_VALID_UPP =&gt; RIU_RD_VALID_UPP  -- 1-bit input: RIU_VALID of the upper nibble BITSLICE_CONTROL
   );

   -- End of RIU_OR_inst instantiation
					</Template>
					<Template label="RX_BITSLICE (RX_BITSLICE)" treetype="template">
-- RX_BITSLICE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RX_BITSLICE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RX_BITSLICE: RX_BITSLICE for input using Native Mode
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RX_BITSLICE_inst : RX_BITSLICE
   generic map (
      CASCADE =&gt; "FALSE",             -- Enables cascading of IDELAY and ODELAY lines
      DATA_TYPE =&gt; "DATA",            -- Defines what the input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                      -- SERIAL)
      DATA_WIDTH =&gt; 8,                -- Defines the width of the serial-to-parallel converter (4-8)
      DELAY_FORMAT =&gt; "TIME",         -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",          -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,               -- Input delay value setting in ps
      DELAY_VALUE_EXT =&gt; 0,           -- Value of the extended input delay value in ps
      FIFO_SYNC_MODE =&gt; "FALSE",      -- Internal write clock and FIFO_RD_CLK are coming from a common source
      IS_CLK_EXT_INVERTED =&gt; '0',     -- Optional inversion for CLK_EXT
      IS_CLK_INVERTED =&gt; '0',         -- Optional inversion for CLK
      IS_RST_DLY_EXT_INVERTED =&gt; '0', -- Optional inversion for RST_DLY_EXT
      IS_RST_DLY_INVERTED =&gt; '0',     -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',         -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,      -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC",         -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
      UPDATE_MODE_EXT =&gt; "ASYNC"      -- Determines when updates to the extended input delay will take effect
                                      -- (ASYNC, MANUAL, SYNC)
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT,         -- 9-bit output: Counter value to device logic
      CNTVALUEOUT_EXT =&gt; CNTVALUEOUT_EXT, -- 9-bit output: Optional extended (cascaded delay) counter value
                                          -- going to the device logic

      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      FIFO_WRCLK_OUT =&gt; FIFO_WRCLK_OUT,   -- 1-bit output: FIFO source synchronous write clock out to the
                                          -- device logic (currently unsupported, do not connect)

      Q =&gt; Q,                             -- 8-bit output: Registered output data from FIFO
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      CE =&gt; CE,                           -- 1-bit input: Clock enable for IDELAY
      CE_EXT =&gt; CE_EXT,                   -- 1-bit input: Optional extended (cascaded delay) clock enable
      CLK =&gt; CLK,                         -- 1-bit input: Clock used to sample LOAD, CE, INC
      CLK_EXT =&gt; CLK_EXT,                 -- 1-bit input: Optional extended (cascaded delay) clock
      CNTVALUEIN =&gt; CNTVALUEIN,           -- 9-bit input: Counter value from device logic
      CNTVALUEIN_EXT =&gt; CNTVALUEIN_EXT,   -- 9-bit input: Optional extended (cascaded delay) counter value from
                                          -- device logic

      DATAIN =&gt; DATAIN,                   -- 1-bit input: Input signal from IBUF
      EN_VTC =&gt; EN_VTC,                   -- 1-bit input: Enable IDELAYCTRL to keep stable delay over VT
      EN_VTC_EXT =&gt; EN_VTC_EXT,           -- 1-bit input: Optional extended (cascaded delay) to keep stable
                                          -- delay over VT

      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: FIFO read enable
      INC =&gt; INC,                         -- 1-bit input: Increment the current delay tap setting
      INC_EXT =&gt; INC_EXT,                 -- 1-bit input: Optional extended (cascaded delay) increments the
                                          -- current delay tap setting

      LOAD =&gt; LOAD,                       -- 1-bit input: Load the CNTVALUEIN tap setting
      LOAD_EXT =&gt; LOAD_EXT,               -- 1-bit input: Optional extended (cascaded delay) load the
                                          -- CNTVALUEIN_EXT tap setting

      RST =&gt; RST,                         -- 1-bit input: Asynchronous assert, synchronous deassert for
                                          -- RX_BITSLICE ISERDES

      RST_DLY =&gt; RST_DLY,                 -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      RST_DLY_EXT =&gt; RST_DLY_EXT,         -- 1-bit input: Optional extended (cascaded delay) reset delay to
                                          -- DELAY_VALUE_EXT

      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN    -- 40-bit input: Input bus from BITSLICE_CONTROL
   );

   -- End of RX_BITSLICE_inst instantiation
					</Template>
					<Template label="RXTX_BITSLICE (RXTX_BITSLICE)" treetype="template">
-- RXTX_BITSLICE : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the body of the design code.  The instance name
--  declaration  : (RXTX_BITSLICE_inst) and/or the port declarations after the
--     code      : "=&gt;" declaration maybe changed to properly reference and
--               : connect this function to the design.  All inputs and outputs
--               : must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--  primitives   : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RXTX_BITSLICE: RXTX_BITSLICE for bidirectional I/O using Native Mode
   --                Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   RXTX_BITSLICE_inst : RXTX_BITSLICE
   generic map (
      ENABLE_PRE_EMPHASIS =&gt; "FALSE", -- Enable the pre-emphasis
      FIFO_SYNC_MODE =&gt; "FALSE",      -- Internal write clock and FIFO_RD_CLK are coming from a common source
      INIT =&gt; '1',                    -- Defines initial O value
      IS_RX_CLK_INVERTED =&gt; '0',      -- Optional inversion for RX_CLK
      IS_RX_RST_DLY_INVERTED =&gt; '0',  -- Optional inversion for RX_RST_DLY
      IS_RX_RST_INVERTED =&gt; '0',      -- Optional inversion for RX_RST
      IS_TX_CLK_INVERTED =&gt; '0',      -- Optional inversion for TX_CLK
      IS_TX_RST_DLY_INVERTED =&gt; '0',  -- Optional inversion for TX_RST_DLY
      IS_TX_RST_INVERTED =&gt; '0',      -- Optional inversion for TX_RST
      RX_DATA_TYPE =&gt; "DATA",         -- Defines what the RX input pin is carrying (CLOCK, DATA,
                                      -- DATA_AND_CLOCK, SERIAL)
      RX_DATA_WIDTH =&gt; 8,             -- Defines the width of the serial-to-parallel converter (4-8)
      RX_DELAY_FORMAT =&gt; "TIME",      -- Units of the RX DELAY_VALUE (COUNT, TIME)
      RX_DELAY_TYPE =&gt; "FIXED",       -- Set the type of RX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      RX_DELAY_VALUE =&gt; 0,            -- RX Input delay value setting in ps
      RX_REFCLK_FREQUENCY =&gt; 300.0,   -- Specification of the RX reference clock frequency in MHz
                                      -- (200.0-2667.0)
      RX_UPDATE_MODE =&gt; "ASYNC",      -- Determines when updates to the RX delay will take effect (ASYNC,
                                      -- MANUAL, SYNC)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TBYTE_CTL =&gt; "TBYTE_IN",        -- Select between T and TBYTE_IN inputs
      TX_DATA_WIDTH =&gt; 8,             -- Parallel data input width (4-8)
      TX_DELAY_FORMAT =&gt; "TIME",      -- Units of the TX DELAY_VALUE (COUNT, TIME)
      TX_DELAY_TYPE =&gt; "FIXED",       -- Set the type of TX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      TX_DELAY_VALUE =&gt; 0,            -- TX Input delay value setting in ps
      TX_OUTPUT_PHASE_90 =&gt; "FALSE",  -- Delays the output phase by 90-degrees
      TX_REFCLK_FREQUENCY =&gt; 300.0,   -- Specification of the TX reference clock frequency in MHz
                                      -- (200.0-2667.0)
      TX_UPDATE_MODE =&gt; "ASYNC"       -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
   )
   port map (
      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      FIFO_WRCLK_OUT =&gt; FIFO_WRCLK_OUT,   -- 1-bit output: FIFO source synchronous write clock out to the
                                          -- device logic (currently unsupported, do not connect)

      O =&gt; O,                             -- 1-bit output: Serialized output going to output buffer
      Q =&gt; Q,                             -- 8-bit output: Registered output data from FIFO
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: RX Output bus to BITSLICE_CONTROL
      RX_CNTVALUEOUT =&gt; RX_CNTVALUEOUT,   -- 9-bit output: RX Counter value from device logic
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL for TX
      TX_CNTVALUEOUT =&gt; TX_CNTVALUEOUT,   -- 9-bit output: TX Counter value to device logic
      T_OUT =&gt; T_OUT,                     -- 1-bit output: Byte group 3-state output
      D =&gt; D,                             -- 8-bit input: Data from device logic
      DATAIN =&gt; DATAIN,                   -- 1-bit input: Input signal from IOBUF
      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: FIFO read enable
      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: RX Input bus from BITSLICE_CONTROL
      RX_CE =&gt; RX_CE,                     -- 1-bit input: Clock enable for IDELAY
      RX_CLK =&gt; RX_CLK,                   -- 1-bit input: RX Clock used to sample LOAD, CE, INC
      RX_CNTVALUEIN =&gt; RX_CNTVALUEIN,     -- 9-bit input: RX Counter value from device logic
      RX_EN_VTC =&gt; RX_EN_VTC,             -- 1-bit input: RX Enable to keep stable delay over VT
      RX_INC =&gt; RX_INC,                   -- 1-bit input: RX Increment the current delay tap setting
      RX_LOAD =&gt; RX_LOAD,                 -- 1-bit input: RX Load the CNTVALUEIN tap setting
      RX_RST =&gt; RX_RST,                   -- 1-bit input: RX Asynchronous assert, synchronous deassert for
                                          -- RXTX_BITSLICE ISERDES

      RX_RST_DLY =&gt; RX_RST_DLY,           -- 1-bit input: RX Reset the internal DELAY value to DELAY_VALUE
      T =&gt; T,                             -- 1-bit input: Legacy T byte input from device logic
      TBYTE_IN =&gt; TBYTE_IN,               -- 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN,   -- 40-bit input: TX Input bus from BITSLICE_CONTROL
      TX_CE =&gt; TX_CE,                     -- 1-bit input: Clock enable for ODELAY
      TX_CLK =&gt; TX_CLK,                   -- 1-bit input: TX Clock used to sample LOAD, CE, INC
      TX_CNTVALUEIN =&gt; TX_CNTVALUEIN,     -- 9-bit input: TX Counter value from device logic
      TX_EN_VTC =&gt; TX_EN_VTC,             -- 1-bit input: TX Enable to keep stable delay over VT
      TX_INC =&gt; TX_INC,                   -- 1-bit input: TX Increment the current delay tap setting
      TX_LOAD =&gt; TX_LOAD,                 -- 1-bit input: TX Load the CNTVALUEIN tap setting
      TX_RST =&gt; TX_RST,                   -- 1-bit input: TX Asynchronous assert, synchronous deassert for
                                          -- RXTX_BITSLICE OSERDES

      TX_RST_DLY =&gt; TX_RST_DLY            -- 1-bit input: TX Reset the internal DELAY value to DELAY_VALUE
   );

   -- End of RXTX_BITSLICE_inst instantiation
					</Template>
					<Template label="TX_BITSLICE_TRI (TX_BITSLICE_TRI)" treetype="template">
-- TX_BITSLICE_TRI : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (TX_BITSLICE_TRI_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- TX_BITSLICE_TRI: TX_BITSLICE_TRI for tristate using Native Mode
   --                  Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_TRI_inst : TX_BITSLICE_TRI
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel data input width (4-8)
      DELAY_FORMAT =&gt; "TIME",     -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Output delay value setting
      INIT =&gt; '1',                -- Defines initial O value
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_DLY_INVERTED =&gt; '0', -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      OUTPUT_PHASE_90 =&gt; "FALSE", -- Delays the output phase by 90-degrees
      REFCLK_FREQUENCY =&gt; 300.0,  -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      BIT_CTRL_OUT =&gt; BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      CNTVALUEOUT =&gt; CNTVALUEOUT,   -- 9-bit output: Counter value to device logic
      TRI_OUT =&gt; TRI_OUT,           -- 1-bit output: Output to the TBYTE_IN pins of the bitslices
      BIT_CTRL_IN =&gt; BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      CE =&gt; CE,                     -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                   -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,     -- 9-bit input: Counter value input
      EN_VTC =&gt; EN_VTC,             -- 1-bit input: Enable to keep stable delay over VT
      INC =&gt; INC,                   -- 1-bit input: Increment the current delay tap setting
      LOAD =&gt; LOAD,                 -- 1-bit input: Load the CNTVALUEIN tap setting
      RST =&gt; RST,                   -- 1-bit input: Asynchronous assert, synchronous deassert
      RST_DLY =&gt; RST_DLY            -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
   );

   -- End of TX_BITSLICE_TRI_inst instantiation
					</Template>
					<Template label="TX_BITSLICE (TX_BITSLICE)" treetype="template">
-- TX_BITSLICE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (TX_BITSLICE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- TX_BITSLICE: TX_BITSLICE for output using Native Mode
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_inst : TX_BITSLICE
   generic map (
      DATA_WIDTH =&gt; 8,                -- Parallel data input width (4-8)
      DELAY_FORMAT =&gt; "TIME",         -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",          -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,               -- Output delay value setting
      ENABLE_PRE_EMPHASIS =&gt; "FALSE", -- Enable the pre-emphasis
      INIT =&gt; '1',                    -- Defines initial O value
      IS_CLK_INVERTED =&gt; '0',         -- Optional inversion for CLK
      IS_RST_DLY_INVERTED =&gt; '0',     -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',         -- Optional inversion for RST
      OUTPUT_PHASE_90 =&gt; "FALSE",     -- Delays the output phase by 90-degrees
      REFCLK_FREQUENCY =&gt; 300.0,      -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TBYTE_CTL =&gt; "TBYTE_IN",        -- Select between T and TBYTE_IN inputs
      UPDATE_MODE =&gt; "ASYNC"          -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT,         -- 9-bit output: Counter value to device logic
      O =&gt; O,                             -- 1-bit output: Serialized output going to output buffer
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      T_OUT =&gt; T_OUT,                     -- 1-bit output: Byte group 3-state output
      CE =&gt; CE,                           -- 1-bit input: Clock enable for ODELAY
      CLK =&gt; CLK,                         -- 1-bit input: Clock used to sample LOAD, CE, INC
      CNTVALUEIN =&gt; CNTVALUEIN,           -- 9-bit input: Counter value from device logic
      D =&gt; D,                             -- 8-bit input: Data from device logic
      EN_VTC =&gt; EN_VTC,                   -- 1-bit input: Enable to keep stable delay over VT
      INC =&gt; INC,                         -- 1-bit input: Increment the current delay tap setting
      LOAD =&gt; LOAD,                       -- 1-bit input: Load the CNTVALUEIN tap setting
      RST =&gt; RST,                         -- 1-bit input: Asynchronous assert, synchronous deassert for
                                          -- TX_BITSLICE OSERDES

      RST_DLY =&gt; RST_DLY,                 -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      T =&gt; T,                             -- 1-bit input: Legacy T byte input from device logic
      TBYTE_IN =&gt; TBYTE_IN,               -- 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN    -- 40-bit input: Input bus from BITSLICE_CONTROL
   );

   -- End of TX_BITSLICE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DCI_RESET" treetype="folder">
					<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
--  DCIRESET   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DCIRESET_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DCIRESET: Digitally Controlled Impedance Reset Component
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   DCIRESET_inst : DCIRESET
   port map (
      LOCKED =&gt; LOCKED, -- 1-bit output: LOCK status output
      RST =&gt; RST        -- 1-bit input: Active-High asynchronous reset input
   );

   -- End of DCIRESET_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DELAY" treetype="folder">
					<Template label="IDELAYE3/ODELAYE3 Tap Delay Value Control (IDELAYCTRL)" treetype="template">
-- IDELAYCTRL  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYCTRL: IDELAYE3/ODELAYE3 Tap Delay Value Control
   --             Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL_inst : IDELAYCTRL
   generic map (
      SIM_DEVICE =&gt; "7SERIES"  -- Set the device version (7SERIES, ULTRASCALE)
   )
   port map (
      RDY =&gt; RDY,       -- 1-bit output: Ready output
      REFCLK =&gt; REFCLK, -- 1-bit input: Reference clock input
      RST =&gt; RST        -- 1-bit input: Active high reset input. Asynchronous assert, synchronous deassert to
                        -- REFCLK.

   );

   -- End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE3)" treetype="template">
--  IDELAYE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYE3: Input Fixed or Variable Delay Element
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYE3_inst : IDELAYE3
   generic map (
      CASCADE =&gt; "NONE",          -- Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      DELAY_FORMAT =&gt; "TIME",     -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_SRC =&gt; "IDATAIN",     -- Delay input (DATAIN, IDATAIN)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Input delay value setting
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,  -- IDELAYCTRL clock input frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      CASC_OUT =&gt; CASC_OUT,       -- 1-bit output: Cascade delay output to ODELAY input cascade
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 9-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data output
      CASC_IN =&gt; CASC_IN,         -- 1-bit input: Cascade delay input from slave ODELAY CASCADE_OUT
      CASC_RETURN =&gt; CASC_RETURN, -- 1-bit input: Cascade delay returning from slave ODELAY DATAOUT
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                 -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 9-bit input: Counter value input
      DATAIN =&gt; DATAIN,           -- 1-bit input: Data input from the logic
      EN_VTC =&gt; EN_VTC,           -- 1-bit input: Keep delay constant over VT
      IDATAIN =&gt; IDATAIN,         -- 1-bit input: Data input from the IOBUF
      INC =&gt; INC,                 -- 1-bit input: Increment / Decrement tap delay input
      LOAD =&gt; LOAD,               -- 1-bit input: Load DELAY_VALUE input
      RST =&gt; RST                  -- 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   -- End of IDELAYE3_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE3)" treetype="template">
--  ODELAYE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODELAYE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODELAYE3: Output Fixed or Variable Delay Element
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   ODELAYE3_inst : ODELAYE3
   generic map (
      CASCADE =&gt; "NONE",          -- Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      DELAY_FORMAT =&gt; "TIME",     -- (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Output delay tap setting
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,  -- IDELAYCTRL clock input frequency in MHz (200.0-2667.0).
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      CASC_OUT =&gt; CASC_OUT,       -- 1-bit output: Cascade delay output to IDELAY input cascade
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 9-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data from ODATAIN input port
      CASC_IN =&gt; CASC_IN,         -- 1-bit input: Cascade delay input from slave IDELAY CASCADE_OUT
      CASC_RETURN =&gt; CASC_RETURN, -- 1-bit input: Cascade delay returning from slave IDELAY DATAOUT
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                 -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 9-bit input: Counter value input
      EN_VTC =&gt; EN_VTC,           -- 1-bit input: Keep delay constant over VT
      INC =&gt; INC,                 -- 1-bit input: Increment/Decrement tap delay input
      LOAD =&gt; LOAD,               -- 1-bit input: Load DELAY_VALUE input
      ODATAIN =&gt; ODATAIN,         -- 1-bit input: Data input
      RST =&gt; RST                  -- 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   -- End of ODELAYE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="INPUT_BUFFER" treetype="folder">
					<Template label="Analog Auxiliary SYSMON Input Buffer (IBUF_ANALOG)" treetype="template">
-- IBUF_ANALOG : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUF_ANALOG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_ANALOG: Analog Auxiliary SYSMON Input Buffer
   --              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_ANALOG_inst : IBUF_ANALOG
   port map (
      O =&gt; O, -- 1-bit output: Connect to a VAUXP/VAUXN port of the SYSMONE1
      I =&gt; I  -- 1-bit input: Connect to a top-level design port
   );

   -- End of IBUF_ANALOG_inst instantiation
					</Template>
					<Template label="Differential Input Buffer (IBUFDS)" treetype="template">
--   IBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS: Differential Input Buffer
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_inst : IBUFDS
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer output
      I =&gt; I,   -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB  -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs and Input Buffer Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
-- IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
--            VHDL             : the following instance declaration needs to be placed
--          instance           : in the body of the design code.  The instance name
--         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations after the
--            code             : "=&gt;" declaration maybe changed to properly reference and
--                             : connect this function to the design.  All inputs and outputs
--                             : must be connected.

--           Library           : In addition to adding the instance declaration, a use
--         declaration         : statement for the UNISIM.vcomponents library needs to be
--             for             : added before the entity declaration.  This library
--           Xilinx            : contains the component declarations for all Xilinx
--         primitives          : primitives and points to the models that will be used
--                             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer With Complementary Outputs and Input Buffer Disable
   --                              Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE_inst : IBUFDS_DIFF_OUT_IBUFDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                   -- 1-bit output: Buffer diff_n output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Must be tied to a logic '0'
   );

   -- End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs (IBUFDS_DIFF_OUT)" treetype="template">
-- IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT: Differential Input Buffer With Complementary Outputs
   --                  Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_inst : IBUFDS_DIFF_OUT
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer diff_p output
      OB =&gt; OB, -- 1-bit output: Buffer diff_n output
      I =&gt; I,   -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB  -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
-- IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
--             VHDL              : the following instance declaration needs to be placed
--           instance            : in the body of the design code.  The instance name
--          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations after the
--             code              : "=&gt;" declaration maybe changed to properly reference and
--                               : connect this function to the design.  All inputs and outputs
--                               : must be connected.

--            Library            : In addition to adding the instance declaration, a use
--          declaration          : statement for the UNISIM.vcomponents library needs to be
--              for              : added before the entity declaration.  This library
--            Xilinx             : contains the component declarations for all Xilinx
--          primitives           : primitives and points to the models that will be used
--                               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable
   --                                Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE_inst : IBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                       -- 1-bit output: Buffer diff_n output
      I =&gt; I,                         -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                       -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Must be tied to a logic '0'
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Buffer termination disable, high=disable
   );

   -- End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
-- IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--         VHDL         : the following instance declaration needs to be placed
--       instance       : in the body of the design code.  The instance name
--     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations after the
--         code         : "=&gt;" declaration maybe changed to properly reference and
--                      : connect this function to the design.  All inputs and outputs
--                      : must be connected.

--       Library        : In addition to adding the instance declaration, a use
--     declaration      : statement for the UNISIM.vcomponents library needs to be
--         for          : added before the entity declaration.  This library
--        Xilinx        : contains the component declarations for all Xilinx
--      primitives      : primitives and points to the models that will be used
--                      : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_INTERMDISABLE: Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE_inst : IBUFDS_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                       -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer input disable, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Buffer termination disable, high=disable
   );

   -- End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable (IBUFDS_IBUFDISABLE)" treetype="template">
-- IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--        VHDL        : the following instance declaration needs to be placed
--      instance      : in the body of the design code.  The instance name
--    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations after the
--        code        : "=&gt;" declaration maybe changed to properly reference and
--                    : connect this function to the design.  All inputs and outputs
--                    : must be connected.

--      Library       : In addition to adding the instance declaration, a use
--    declaration     : statement for the UNISIM.vcomponents library needs to be
--        for         : added before the entity declaration.  This library
--       Xilinx       : contains the component declarations for all Xilinx
--     primitives     : primitives and points to the models that will be used
--                    : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_IBUFDISABLE: Differential Input Buffer With Input Buffer Disable
   --                     Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE_inst : IBUFDS_IBUFDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Must be tied to a logic '0'
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Offset Calibration (IBUFDSE3)" treetype="template">
--  IBUFDSE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDSE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDSE3: Differential Input Buffer with Offset Calibration
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDSE3_inst : IBUFDSE3
   generic map (
      DQS_BIAS =&gt; "FALSE",          -- (FALSE, TRUE)
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- 1-bit input: Buffer disable input, high=disable
      OSC =&gt; OSC,                 -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN            -- 2-bit input: Offset cancellation enable
   );

   -- End of IBUFDSE3_inst instantiation
					</Template>
					<Template label="Input Buffer (IBUF)" treetype="template">
--    IBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF: Input Buffer
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_inst : IBUF
   port map (
      O =&gt; O, -- 1-bit output: Buffer output
      I =&gt; I  -- 1-bit input: Buffer input
   );

   -- End of IBUF_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
-- IBUF_INTERMDISABLE : In order to incorporate this function into the design,
--        VHDL        : the following instance declaration needs to be placed
--      instance      : in the body of the design code.  The instance name
--    declaration     : (IBUF_INTERMDISABLE_inst) and/or the port declarations after the
--        code        : "=&gt;" declaration maybe changed to properly reference and
--                    : connect this function to the design.  All inputs and outputs
--                    : must be connected.

--      Library       : In addition to adding the instance declaration, a use
--    declaration     : statement for the UNISIM.vcomponents library needs to be
--        for         : added before the entity declaration.  This library
--       Xilinx       : contains the component declarations for all Xilinx
--     primitives     : primitives and points to the models that will be used
--                    : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_INTERMDISABLE: Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                     Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_INTERMDISABLE_inst : IBUF_INTERMDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Input Termination Disable
   );

   -- End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable (IBUF_IBUFDISABLE)" treetype="template">
-- IBUF_IBUFDISABLE : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_IBUFDISABLE: Input Buffer With Input Buffer Disable
   --                   Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_IBUFDISABLE_inst : IBUF_IBUFDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Buffer disable input, high=disable
   );

   -- End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer with Offset Calibration and VREF Tuning (IBUFE3)" treetype="template">
--   IBUFE3    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFE3: Input Buffer with Offset Calibration and VREF Tuning
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IBUFE3_inst : IBUFE3
   generic map (
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- 1-bit input: Buffer disable input, high=disable
      OSC =&gt; OSC,                 -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,           -- 1-bit input: Offset cancellation enable
      VREF =&gt; VREF                -- 1-bit input: Vref input from HPIO_VREF
   );

   -- End of IBUFE3_inst instantiation
					</Template>
					<Template label="VREF Scan (HPIO_VREF)" treetype="template">
--  HPIO_VREF  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (HPIO_VREF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- HPIO_VREF: VREF Scan
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   HPIO_VREF_inst : HPIO_VREF
   generic map (
      VREF_CNTR =&gt; "OFF"  -- FABRIC_RANGE1, FABRIC_RANGE2, OFF
   )
   port map (
      VREF =&gt; VREF,                         -- 1-bit output: Tuned output (connect to associated IBUFE3
                                            -- component)

      FABRIC_VREF_TUNE =&gt; FABRIC_VREF_TUNE  -- 7-bit input: VREF tuning value
   );

   -- End of HPIO_VREF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="OUTPUT_BUFFER" treetype="folder">
					<Template label="3-State Output Buffer (OBUFT)" treetype="template">
--    OBUFT    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFT: 3-State Output Buffer
   --        Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFT_inst : OBUFT
   port map (
      O =&gt; O, -- 1-bit output: Buffer output (connect directly to top-level port)
      I =&gt; I, -- 1-bit input: Buffer input
      T =&gt; T  -- 1-bit input: 3-state enable input
   );

   -- End of OBUFT_inst instantiation
					</Template>
					<Template label="Differential Output Buffer (OBUFDS)" treetype="template">
--   OBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS: Differential Output Buffer
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_inst : OBUFDS
   port map (
      O =&gt; O,   -- 1-bit output: Diff_p output (connect directly to top-level port)
      OB =&gt; OB, -- 1-bit output: Diff_n output (connect directly to top-level port)
      I =&gt; I    -- 1-bit input: Buffer input
   );

   -- End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential 3-state Output Buffer (OBUFTDS)" treetype="template">
--   OBUFTDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFTDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFTDS: Differential 3-state Output Buffer
   --          Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUFTDS_inst : OBUFTDS
   port map (
      O =&gt; O,   -- 1-bit output: Diff_p output (connect directly to top-level port)
      OB =&gt; OB, -- 1-bit output: Diff_n output (connect directly to top-level port)
      I =&gt; I,   -- 1-bit input: Buffer input
      T =&gt; T    -- 1-bit input: 3-state enable input
   );

   -- End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Output Buffer (OBUF)" treetype="template">
--    OBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUF: Output Buffer
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OBUF_inst : OBUF
   port map (
      O =&gt; O, -- 1-bit output: Buffer output (connect directly to top-level port)
      I =&gt; I  -- 1-bit input: Buffer input
   );

   -- End of OBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer (ISERDESE3)" treetype="template">
--  ISERDESE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ISERDESE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ISERDESE3: Input SERial/DESerializer
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   ISERDESE3_inst : ISERDESE3
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel data width (4,8)
      FIFO_ENABLE =&gt; "FALSE",     -- Enables the use of the FIFO
      FIFO_SYNC_MODE =&gt; "FALSE",  -- Enables the use of internal 2-stage synchronizers on the FIFO
      IS_CLK_B_INVERTED =&gt; '0',   -- Optional inversion for CLK_B
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      INTERNAL_DIVCLK =&gt; INTERNAL_DIVCLK, -- 1-bit output: Internally divided down clock used when FIFO is
                                          -- disabled (do not connect)

      Q =&gt; Q,                             -- 8-bit registered output
      CLK =&gt; CLK,                         -- 1-bit input: High-speed clock
      CLKDIV =&gt; CLKDIV,                   -- 1-bit input: Divided Clock
      CLK_B =&gt; CLK_B,                     -- 1-bit input: Inversion of High-speed clock CLK
      D =&gt; D,                             -- 1-bit input: Serial Data Input
      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: Enables reading the FIFO when asserted
      RST =&gt; RST                          -- 1-bit input: Asynchronous Reset
   );

   -- End of ISERDESE3_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer (OSERDESE3)" treetype="template">
--  OSERDESE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OSERDESE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OSERDESE3: Output SERial/DESerializer
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   OSERDESE3_inst : OSERDESE3
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel Data Width (4-8)
      INIT =&gt; '0',                -- Initialization value of the OSERDES flip-flops
      IS_CLKDIV_INVERTED =&gt; '0',  -- Optional inversion for CLKDIV
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      OQ =&gt; OQ,         -- 1-bit output: Serial Output Data
      T_OUT =&gt; T_OUT,   -- 1-bit output: 3-state control output to IOB
      CLK =&gt; CLK,       -- 1-bit input: High-speed clock
      CLKDIV =&gt; CLKDIV, -- 1-bit input: Divided Clock
      D =&gt; D,           -- 8-bit input: Parallel Data Input
      RST =&gt; RST,       -- 1-bit input: Asynchronous Reset
      T =&gt; T            -- 1-bit input: Tristate input from fabric
   );

   -- End of OSERDESE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="WEAK_DRIVER" treetype="folder">
					<Template label="I/O Pulldown (PULLDOWN)" treetype="template">
--  PULLDOWN   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PULLDOWN_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLDOWN: I/O Pulldown
   --           Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   PULLDOWN_inst : PULLDOWN
   port map (
      O =&gt; O  -- 1-bit output: Pulldown output (connect directly to top-level port)
   );

   -- End of PULLDOWN_inst instantiation
					</Template>
					<Template label="I/O Pullup (PULLUP)" treetype="template">
--   PULLUP    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PULLUP_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLUP: I/O Pullup
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   PULLUP_inst : PULLUP
   port map (
      O =&gt; O  -- 1-bit output: Pullup output (connect directly to top-level port)
   );

   -- End of PULLUP_inst instantiation
					</Template>
					<Template label="I/O Weak Keeper (KEEPER)" treetype="template">
--   KEEPER    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (KEEPER_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- KEEPER: I/O Weak Keeper
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   KEEPER_inst : KEEPER
   port map (
      O =&gt; O  -- 1-bit inout: Keeper output (connect directly to top-level port)
   );

   -- End of KEEPER_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="REGISTER" treetype="folder">
				<SubFolder label="DDR" treetype="folder">
					<Template label="Input DDR (IDDRE1)" treetype="template">
--   IDDRE1    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDDRE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDRE1: Dedicated Dual Data Rate (DDR) Input Register
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   IDDRE1_inst : IDDRE1
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- IDDRE1 mode (OPPOSITE_EDGE, SAME_EDGE, SAME_EDGE_PIPELINED)
      IS_CB_INVERTED =&gt; '0',           -- Optional inversion for CB
      IS_C_INVERTED =&gt; '0'             -- Optional inversion for C
   )
   port map (
      Q1 =&gt; Q1, -- 1-bit output: Registered parallel output 1
      Q2 =&gt; Q2, -- 1-bit output: Registered parallel output 2
      C =&gt; C,   -- 1-bit input: High-speed clock
      CB =&gt; CB, -- 1-bit input: Inversion of High-speed clock C
      D =&gt; D,   -- 1-bit input: Serial Data Input
      R =&gt; R    -- 1-bit input: Active High Async Reset
   );

   -- End of IDDRE1_inst instantiation
					</Template>
					<Template label="Output DDR (ODDRE1)" treetype="template">
--   ODDRE1    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODDRE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDRE1: Dedicated Dual Data Rate (DDR) Output Register
   --         Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   ODDRE1_inst : ODDRE1
   generic map (
      IS_C_INVERTED =&gt; '0',  -- Optional inversion for C
      IS_D1_INVERTED =&gt; '0', -- Optional inversion for D1
      IS_D2_INVERTED =&gt; '0', -- Optional inversion for D2
      SRVAL =&gt; '0'           -- Initializes the ODDRE1 Flip-Flops to the specified value ('0', '1')
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data output to IOB
      C =&gt; C,   -- 1-bit input: High-speed clock input
      D1 =&gt; D1, -- 1-bit input: Parallel data input 1
      D2 =&gt; D2, -- 1-bit input: Parallel data input 2
      SR =&gt; SR  -- 1-bit input: Active High Async Reset
   );

   -- End of ODDRE1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Transparent Latch with Clock Enable and Asynchronous Clear (LDCE)" treetype="template">
--    LDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LDCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDCE: Transparent Latch with Clock Enable and Asynchronous Clear
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LDCE_inst : LDCE
   generic map (
      INIT =&gt; '0',            -- Initial value of latch, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_G_INVERTED =&gt; '0'    -- Optional inversion for G
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      D =&gt; D,     -- 1-bit input: Data
      G =&gt; G,     -- 1-bit input: Gate
      GE =&gt; GE    -- 1-bit input: Gate enable
   );

   -- End of LDCE_inst instantiation
					</Template>
					<Template label="Transparent Latch with Clock Enable and Asynchronous Preset (LDPE)" treetype="template">
--    LDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LDPE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDPE: Transparent Latch with Clock Enable and Asynchronous Preset
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   LDPE_inst : LDPE
   generic map (
      INIT =&gt; '1',            -- Initial value of latch, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_G_INVERTED =&gt; '0',   -- Optional inversion for G
      IS_PRE_INVERTED =&gt; '0'  -- Optional inversion for PRE
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      D =&gt; D,     -- 1-bit input: Data
      G =&gt; G,     -- 1-bit input: Gate
      GE =&gt; GE,   -- 1-bit input: Gate enable
      PRE =&gt; PRE  -- 1-bit input: Asynchronous preset
   );

   -- End of LDPE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="METASTABILITY" treetype="folder">
					<Template label="Metastability Hardened Registers (HARD_SYNC)" treetype="template">
--  HARD_SYNC  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (HARD_SYNC_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- HARD_SYNC: Metastability Hardened Registers
   --            Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   HARD_SYNC_inst : HARD_SYNC
   generic map (
      INIT =&gt; '0',            -- Initial values, '0', '1'
      IS_CLK_INVERTED =&gt; '0', -- Programmable inversion on CLK input
      LATENCY =&gt; 2            -- 2-3
   )
   port map (
      DOUT =&gt; DOUT, -- 1-bit output: Data
      CLK =&gt; CLK,   -- 1-bit input: Clock
      DIN =&gt; DIN    -- 1-bit input: Data
   );

   -- End of HARD_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SDR" treetype="folder">
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Clear (FDCE)" treetype="template">
--    FDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDCE: D Flip-Flop with Clock Enable and Asynchronous Clear
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FDCE_inst : FDCE
   generic map (
      INIT =&gt; '0',            -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_C_INVERTED =&gt; '0',   -- Optional inversion for C
      IS_D_INVERTED =&gt; '0'    -- Optional inversion for D
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      C =&gt; C,     -- 1-bit input: Clock
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      D =&gt; D      -- 1-bit input: Data
   );

   -- End of FDCE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Preset (FDPE)" treetype="template">
--    FDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDPE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDPE: D Flip-Flop with Clock Enable and Asynchronous Preset
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FDPE_inst : FDPE
   generic map (
      INIT =&gt; '1',            -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0',   -- Optional inversion for C
      IS_D_INVERTED =&gt; '0',   -- Optional inversion for D
      IS_PRE_INVERTED =&gt; '0'  -- Optional inversion for PRE
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      C =&gt; C,     -- 1-bit input: Clock
      CE =&gt; CE,   -- 1-bit input: Clock enable
      D =&gt; D,     -- 1-bit input: Data
      PRE =&gt; PRE  -- 1-bit input: Asynchronous preset
   );

   -- End of FDPE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Reset (FDRE)" treetype="template">
--    FDRE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDRE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDRE: D Flip-Flop with Clock Enable and Synchronous Reset
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FDRE_inst : FDRE
   generic map (
      INIT =&gt; '0',          -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0', -- Optional inversion for C
      IS_D_INVERTED =&gt; '0', -- Optional inversion for D
      IS_R_INVERTED =&gt; '0'  -- Optional inversion for R
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data
      C =&gt; C,   -- 1-bit input: Clock
      CE =&gt; CE, -- 1-bit input: Clock enable
      D =&gt; D,   -- 1-bit input: Data
      R =&gt; R    -- 1-bit input: Synchronous reset
   );

   -- End of FDRE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Set (FDSE)" treetype="template">
--    FDSE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDSE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDSE: D Flip-Flop with Clock Enable and Synchronous Set
   --       Virtex UltraScale
   -- Xilinx HDL Language Template, version 2016.4

   FDSE_inst : FDSE
   generic map (
      INIT =&gt; '1',          -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0', -- Optional inversion for C
      IS_D_INVERTED =&gt; '0', -- Optional inversion for D
      IS_S_INVERTED =&gt; '0'  -- Optional inversion for S
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data
      C =&gt; C,   -- 1-bit input: Clock
      CE =&gt; CE, -- 1-bit input: Clock enable
      D =&gt; D,   -- 1-bit input: Data
      S =&gt; S    -- 1-bit input: Synchronous set
   );

   -- End of FDSE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Virtex UltraScale+" treetype="folder">
			<SubFolder label="ADVANCED" treetype="folder">
				<SubFolder label="GT" treetype="folder">
					<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE4)" treetype="template">
-- IBUFDS_GTE4 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_GTE4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_GTE4: Gigabit Transceiver Buffer
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE4_inst : IBUFDS_GTE4
   generic map (
      REFCLK_EN_TX_PATH =&gt; '0',   -- Refer to Transceiver User Guide
      REFCLK_HROW_CK_SEL =&gt; "00", -- Refer to Transceiver User Guide
      REFCLK_ICNTL_RX =&gt; "00"     -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,         -- 1-bit output: Refer to Transceiver User Guide
      ODIV2 =&gt; ODIV2, -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,     -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,         -- 1-bit input: Refer to Transceiver User Guide
      IB =&gt; IB        -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of IBUFDS_GTE4_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE4_ADV)" treetype="template">
-- OBUFDS_GTE4_ADV : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (OBUFDS_GTE4_ADV_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_GTE4_ADV: Gigabit Transceiver Buffer
   --                  Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE4_ADV_inst : OBUFDS_GTE4_ADV
   generic map (
      REFCLK_EN_TX_PATH =&gt; '1',   -- Refer to Transceiver User Guide
      REFCLK_ICNTL_TX =&gt; "00000"  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,                       -- 1-bit output: Refer to Transceiver User Guide
      OB =&gt; OB,                     -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,                   -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,                       -- 4-bit input: Refer to Transceiver User Guide
      RXRECCLK_SEL =&gt; RXRECCLK_SEL  -- 2-bit input: Refer to Transceiver User Guide
   );

   -- End of OBUFDS_GTE4_ADV_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE4)" treetype="template">
-- OBUFDS_GTE4 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_GTE4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_GTE4: Gigabit Transceiver Buffer
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE4_inst : OBUFDS_GTE4
   generic map (
      REFCLK_EN_TX_PATH =&gt; '1',   -- Refer to Transceiver User Guide
      REFCLK_ICNTL_TX =&gt; "00000"  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,     -- 1-bit output: Refer to Transceiver User Guide
      OB =&gt; OB,   -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB, -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I      -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of OBUFDS_GTE4_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SYSMON" treetype="folder">
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE1)" treetype="template">
--  SYSMONE1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SYSMONE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SYSMONE1: Xilinx Analog-to-Digital Converter and System Monitor
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   SYSMONE1_inst : SYSMONE1
   generic map (
      -- INIT_40 - INIT_44: SYSMON configuration registers
      INIT_40 =&gt; X"0000",
      INIT_41 =&gt; X"0000",
      INIT_42 =&gt; X"0000",
      INIT_43 =&gt; X"0000",
      INIT_44 =&gt; X"0000",
      INIT_45 =&gt; X"0000",               -- Analog Bus Register
      -- INIT_46 - INIT_4F: Sequence Registers
      INIT_46 =&gt; X"0000",
      INIT_47 =&gt; X"0000",
      INIT_48 =&gt; X"0000",
      INIT_49 =&gt; X"0000",
      INIT_4A =&gt; X"0000",
      INIT_4B =&gt; X"0000",
      INIT_4C =&gt; X"0000",
      INIT_4D =&gt; X"0000",
      INIT_4E =&gt; X"0000",
      INIT_4F =&gt; X"0000",
      -- INIT_50 - INIT_5F: Alarm Limit Registers
      INIT_50 =&gt; X"0000",
      INIT_51 =&gt; X"0000",
      INIT_52 =&gt; X"0000",
      INIT_53 =&gt; X"0000",
      INIT_54 =&gt; X"0000",
      INIT_55 =&gt; X"0000",
      INIT_56 =&gt; X"0000",
      INIT_57 =&gt; X"0000",
      INIT_58 =&gt; X"0000",
      INIT_59 =&gt; X"0000",
      INIT_5A =&gt; X"0000",
      INIT_5B =&gt; X"0000",
      INIT_5C =&gt; X"0000",
      INIT_5D =&gt; X"0000",
      INIT_5E =&gt; X"0000",
      INIT_5F =&gt; X"0000",
      -- INIT_60 - INIT_6F: User Supply Alarms
      INIT_60 =&gt; X"0000",
      INIT_61 =&gt; X"0000",
      INIT_62 =&gt; X"0000",
      INIT_63 =&gt; X"0000",
      INIT_64 =&gt; X"0000",
      INIT_65 =&gt; X"0000",
      INIT_66 =&gt; X"0000",
      INIT_67 =&gt; X"0000",
      INIT_68 =&gt; X"0000",
      INIT_69 =&gt; X"0000",
      INIT_6A =&gt; X"0000",
      INIT_6B =&gt; X"0000",
      INIT_6C =&gt; X"0000",
      INIT_6D =&gt; X"0000",
      INIT_6E =&gt; X"0000",
      INIT_6F =&gt; X"0000",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      -- specific pins
      IS_CONVSTCLK_INVERTED =&gt; '0',     -- Optional inversion for CONVSTCLK, 0-1
      IS_DCLK_INVERTED =&gt; '0',          -- Optional inversion for DCLK, 0-1
      -- Simulation attributes: Set for proper simulation behavior
      SIM_MONITOR_FILE =&gt; "design.txt", -- Analog simulation data file name
      -- User Voltage Monitor: SYSMON User voltage monitor
      SYSMON_VUSER0_BANK =&gt; 0,          -- Specify IO Bank for User0
      SYSMON_VUSER0_MONITOR =&gt; "NONE",  -- Specify Voltage for User0
      SYSMON_VUSER1_BANK =&gt; 0,          -- Specify IO Bank for User1
      SYSMON_VUSER1_MONITOR =&gt; "NONE",  -- Specify Voltage for User1
      SYSMON_VUSER2_BANK =&gt; 0,          -- Specify IO Bank for User2
      SYSMON_VUSER2_MONITOR =&gt; "NONE",  -- Specify Voltage for User2
      SYSMON_VUSER3_MONITOR =&gt; "NONE"   -- Specify Voltage for User3
   )
   port map (
      -- ALARMS outputs: ALM, OT
      ALM =&gt; ALM,                   -- 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      OT =&gt; OT,                     -- 1-bit output: Over-Temperature alarm
      -- Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      DO =&gt; DO,                     -- 16-bit output: DRP output data bus
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP data ready
      -- I2C Interface outputs: Ports used with the I2C DRP interface
      I2C_SCLK_TS =&gt; I2C_SCLK_TS,   -- 1-bit output: I2C_SCLK output port
      I2C_SDA_TS =&gt; I2C_SDA_TS,     -- 1-bit output: I2C_SDA_TS output port
      -- STATUS outputs: SYSMON status ports
      BUSY =&gt; BUSY,                 -- 1-bit output: System Monitor busy output
      CHANNEL =&gt; CHANNEL,           -- 6-bit output: Channel selection outputs
      EOC =&gt; EOC,                   -- 1-bit output: End of Conversion
      EOS =&gt; EOS,                   -- 1-bit output: End of Sequence
      JTAGBUSY =&gt; JTAGBUSY,         -- 1-bit output: JTAG DRP transaction in progress output
      JTAGLOCKED =&gt; JTAGLOCKED,     -- 1-bit output: JTAG requested DRP port lock
      JTAGMODIFIED =&gt; JTAGMODIFIED, -- 1-bit output: JTAG Write to the DRP has occurred
      MUXADDR =&gt; MUXADDR,           -- 5-bit output: External MUX channel decode
      -- Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      VAUXN =&gt; VAUXN,               -- 16-bit input: N-side auxiliary analog input
      VAUXP =&gt; VAUXP,               -- 16-bit input: P-side auxiliary analog input
      -- CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      CONVST =&gt; CONVST,             -- 1-bit input: Convert start input
      CONVSTCLK =&gt; CONVSTCLK,       -- 1-bit input: Convert start input
      RESET =&gt; RESET,               -- 1-bit input: Active-High reset
      -- Dedicated Analog Input Pair inputs: VP/VN
      VN =&gt; VN,                     -- 1-bit input: N-side analog input
      VP =&gt; VP,                     -- 1-bit input: P-side analog input
      -- Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      DADDR =&gt; DADDR,               -- 8-bit input: DRP address bus
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable signal
      DI =&gt; DI,                     -- 16-bit input: DRP input data bus
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- I2C Interface inputs: Ports used with the I2C DRP interface
      I2C_SCLK =&gt; I2C_SCLK,         -- 1-bit input: I2C_SCLK input port
      I2C_SDA =&gt; I2C_SDA            -- 1-bit input: I2C_SDA input port
   );

   -- End of SYSMONE1_inst instantiation
					</Template>
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE4)" treetype="template">
--  SYSMONE4   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SYSMONE4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SYSMONE4: Xilinx Analog-to-Digital Converter and System Monitor
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   SYSMONE4_inst : SYSMONE4
   generic map (
      -- INIT_40 - INIT_44: SYSMON configuration registers
      INIT_40 =&gt; X"0000",
      INIT_41 =&gt; X"0000",
      INIT_42 =&gt; X"0000",
      INIT_43 =&gt; X"0000",
      INIT_44 =&gt; X"0000",
      INIT_45 =&gt; X"0000",               -- Analog Bus Register
      -- INIT_46 - INIT_4F: Sequence Registers
      INIT_46 =&gt; X"0000",
      INIT_47 =&gt; X"0000",
      INIT_48 =&gt; X"0000",
      INIT_49 =&gt; X"0000",
      INIT_4A =&gt; X"0000",
      INIT_4B =&gt; X"0000",
      INIT_4C =&gt; X"0000",
      INIT_4D =&gt; X"0000",
      INIT_4E =&gt; X"0000",
      INIT_4F =&gt; X"0000",
      -- INIT_50 - INIT_5F: Alarm Limit Registers
      INIT_50 =&gt; X"0000",
      INIT_51 =&gt; X"0000",
      INIT_52 =&gt; X"0000",
      INIT_53 =&gt; X"0000",
      INIT_54 =&gt; X"0000",
      INIT_55 =&gt; X"0000",
      INIT_56 =&gt; X"0000",
      INIT_57 =&gt; X"0000",
      INIT_58 =&gt; X"0000",
      INIT_59 =&gt; X"0000",
      INIT_5A =&gt; X"0000",
      INIT_5B =&gt; X"0000",
      INIT_5C =&gt; X"0000",
      INIT_5D =&gt; X"0000",
      INIT_5E =&gt; X"0000",
      INIT_5F =&gt; X"0000",
      -- INIT_60 - INIT_6F: User Supply Alarms
      INIT_60 =&gt; X"0000",
      INIT_61 =&gt; X"0000",
      INIT_62 =&gt; X"0000",
      INIT_63 =&gt; X"0000",
      INIT_64 =&gt; X"0000",
      INIT_65 =&gt; X"0000",
      INIT_66 =&gt; X"0000",
      INIT_67 =&gt; X"0000",
      INIT_68 =&gt; X"0000",
      INIT_69 =&gt; X"0000",
      INIT_6A =&gt; X"0000",
      INIT_6B =&gt; X"0000",
      INIT_6C =&gt; X"0000",
      INIT_6D =&gt; X"0000",
      INIT_6E =&gt; X"0000",
      INIT_6F =&gt; X"0000",
      -- Primitive attributes: Primitive Attributes
      COMMON_N_SOURCE =&gt; X"ffff",       -- Sets the auxiliary analog input that is used for the Common-N input.
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      -- specific pins
      IS_CONVSTCLK_INVERTED =&gt; '0',     -- Optional inversion for CONVSTCLK, 0-1
      IS_DCLK_INVERTED =&gt; '0',          -- Optional inversion for DCLK, 0-1
      -- Simulation attributes: Set for proper simulation behavior
      SIM_DEVICE =&gt; "ULTRASCALE_PLUS",  -- Sets the correct target device for simulation functionality.
      SIM_MONITOR_FILE =&gt; "design.txt", -- Analog simulation data file name
      -- User Voltage Monitor: SYSMON User voltage monitor
      SYSMON_VUSER0_BANK =&gt; 0,          -- Specify IO Bank for User0
      SYSMON_VUSER0_MONITOR =&gt; "NONE",  -- Specify Voltage for User0
      SYSMON_VUSER1_BANK =&gt; 0,          -- Specify IO Bank for User1
      SYSMON_VUSER1_MONITOR =&gt; "NONE",  -- Specify Voltage for User1
      SYSMON_VUSER2_BANK =&gt; 0,          -- Specify IO Bank for User2
      SYSMON_VUSER2_MONITOR =&gt; "NONE",  -- Specify Voltage for User2
      SYSMON_VUSER3_MONITOR =&gt; "NONE"   -- Specify Voltage for User3
   )
   port map (
      -- ALARMS outputs: ALM, OT
      ALM =&gt; ALM,                   -- 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      OT =&gt; OT,                     -- 1-bit output: Over-Temperature alarm
      -- Direct Data Out outputs: ADC_DATA
      ADC_DATA =&gt; ADC_DATA,         -- 16-bit output: Direct Data Out
      -- Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      DO =&gt; DO,                     -- 16-bit output: DRP output data bus
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP data ready
      -- I2C Interface outputs: Ports used with the I2C DRP interface
      I2C_SCLK_TS =&gt; I2C_SCLK_TS,   -- 1-bit output: I2C_SCLK output port
      I2C_SDA_TS =&gt; I2C_SDA_TS,     -- 1-bit output: I2C_SDA_TS output port
      SMBALERT_TS =&gt; SMBALERT_TS,   -- 1-bit output: Output control signal for SMBALERT.
      -- STATUS outputs: SYSMON status ports
      BUSY =&gt; BUSY,                 -- 1-bit output: System Monitor busy output
      CHANNEL =&gt; CHANNEL,           -- 6-bit output: Channel selection outputs
      EOC =&gt; EOC,                   -- 1-bit output: End of Conversion
      EOS =&gt; EOS,                   -- 1-bit output: End of Sequence
      JTAGBUSY =&gt; JTAGBUSY,         -- 1-bit output: JTAG DRP transaction in progress output
      JTAGLOCKED =&gt; JTAGLOCKED,     -- 1-bit output: JTAG requested DRP port lock
      JTAGMODIFIED =&gt; JTAGMODIFIED, -- 1-bit output: JTAG Write to the DRP has occurred
      MUXADDR =&gt; MUXADDR,           -- 5-bit output: External MUX channel decode
      -- Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      VAUXN =&gt; VAUXN,               -- 16-bit input: N-side auxiliary analog input
      VAUXP =&gt; VAUXP,               -- 16-bit input: P-side auxiliary analog input
      -- CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      CONVST =&gt; CONVST,             -- 1-bit input: Convert start input
      CONVSTCLK =&gt; CONVSTCLK,       -- 1-bit input: Convert start input
      RESET =&gt; RESET,               -- 1-bit input: Active-High reset
      -- Dedicated Analog Input Pair inputs: VP/VN
      VN =&gt; VN,                     -- 1-bit input: N-side analog input
      VP =&gt; VP,                     -- 1-bit input: P-side analog input
      -- Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      DADDR =&gt; DADDR,               -- 8-bit input: DRP address bus
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable signal
      DI =&gt; DI,                     -- 16-bit input: DRP input data bus
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- I2C Interface inputs: Ports used with the I2C DRP interface
      I2C_SCLK =&gt; I2C_SCLK,         -- 1-bit input: I2C_SCLK input port
      I2C_SDA =&gt; I2C_SDA            -- 1-bit input: I2C_SDA input port
   );

   -- End of SYSMONE4_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="ARITHMETIC" treetype="folder">
				<SubFolder label="DSP" treetype="folder">
					<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E2)" treetype="template">
--   DSP48E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DSP48E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DSP48E2: 48-bit Multi-Functional Arithmetic Block
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   DSP48E2_inst : DSP48E2
   generic map (
      -- Feature Control Attributes: Data Path Selection
      AMULTSEL =&gt; "A",                   -- Selects A input to multiplier (A, AD)
      A_INPUT =&gt; "DIRECT",               -- Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      BMULTSEL =&gt; "B",                   -- Selects B input to multiplier (AD, B)
      B_INPUT =&gt; "DIRECT",               -- Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      PREADDINSEL =&gt; "A",                -- Selects input to pre-adder (A, B)
      RND =&gt; X"000000000000",            -- Rounding Constant
      USE_MULT =&gt; "MULTIPLY",            -- Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
      USE_SIMD =&gt; "ONE48",               -- SIMD selection (FOUR12, ONE48, TWO24)
      USE_WIDEXOR =&gt; "FALSE",            -- Use the Wide XOR function (FALSE, TRUE)
      XORSIMD =&gt; "XOR24_48_96",          -- Mode of operation for the Wide XOR (XOR12, XOR24_48_96)
      -- Pattern Detector Attributes: Pattern Detection Configuration
      AUTORESET_PATDET =&gt; "NO_RESET",    -- NO_RESET, RESET_MATCH, RESET_NOT_MATCH
      AUTORESET_PRIORITY =&gt; "RESET",     -- Priority of AUTORESET vs. CEP (CEP, RESET).
      MASK =&gt; X"3fffffffffff",           -- 48-bit mask value for pattern detect (1=ignore)
      PATTERN =&gt; X"000000000000",        -- 48-bit pattern match for pattern detect
      SEL_MASK =&gt; "MASK",                -- C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
      SEL_PATTERN =&gt; "PATTERN",          -- Select pattern value (C, PATTERN)
      USE_PATTERN_DETECT =&gt; "NO_PATDET", -- Enable pattern detect (NO_PATDET, PATDET)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_ALUMODE_INVERTED =&gt; "0000",     -- Optional inversion for ALUMODE
      IS_CARRYIN_INVERTED =&gt; '0',        -- Optional inversion for CARRYIN
      IS_CLK_INVERTED =&gt; '0',            -- Optional inversion for CLK
      IS_INMODE_INVERTED =&gt; "00000",     -- Optional inversion for INMODE
      IS_OPMODE_INVERTED =&gt; "000000000", -- Optional inversion for OPMODE
      IS_RSTALLCARRYIN_INVERTED =&gt; '0',  -- Optional inversion for RSTALLCARRYIN
      IS_RSTALUMODE_INVERTED =&gt; '0',     -- Optional inversion for RSTALUMODE
      IS_RSTA_INVERTED =&gt; '0',           -- Optional inversion for RSTA
      IS_RSTB_INVERTED =&gt; '0',           -- Optional inversion for RSTB
      IS_RSTCTRL_INVERTED =&gt; '0',        -- Optional inversion for RSTCTRL
      IS_RSTC_INVERTED =&gt; '0',           -- Optional inversion for RSTC
      IS_RSTD_INVERTED =&gt; '0',           -- Optional inversion for RSTD
      IS_RSTINMODE_INVERTED =&gt; '0',      -- Optional inversion for RSTINMODE
      IS_RSTM_INVERTED =&gt; '0',           -- Optional inversion for RSTM
      IS_RSTP_INVERTED =&gt; '0',           -- Optional inversion for RSTP
      -- Register Control Attributes: Pipeline Register Configuration
      ACASCREG =&gt; 1,                     -- Number of pipeline stages between A/ACIN and ACOUT (0-2)
      ADREG =&gt; 1,                        -- Pipeline stages for pre-adder (0-1)
      ALUMODEREG =&gt; 1,                   -- Pipeline stages for ALUMODE (0-1)
      AREG =&gt; 1,                         -- Pipeline stages for A (0-2)
      BCASCREG =&gt; 1,                     -- Number of pipeline stages between B/BCIN and BCOUT (0-2)
      BREG =&gt; 1,                         -- Pipeline stages for B (0-2)
      CARRYINREG =&gt; 1,                   -- Pipeline stages for CARRYIN (0-1)
      CARRYINSELREG =&gt; 1,                -- Pipeline stages for CARRYINSEL (0-1)
      CREG =&gt; 1,                         -- Pipeline stages for C (0-1)
      DREG =&gt; 1,                         -- Pipeline stages for D (0-1)
      INMODEREG =&gt; 1,                    -- Pipeline stages for INMODE (0-1)
      MREG =&gt; 1,                         -- Multiplier pipeline stages (0-1)
      OPMODEREG =&gt; 1,                    -- Pipeline stages for OPMODE (0-1)
      PREG =&gt; 1                          -- Number of pipeline stages for P (0-1)
   )
   port map (
      -- Cascade outputs: Cascade Ports
      ACOUT =&gt; ACOUT,                   -- 30-bit output: A port cascade
      BCOUT =&gt; BCOUT,                   -- 18-bit output: B cascade
      CARRYCASCOUT =&gt; CARRYCASCOUT,     -- 1-bit output: Cascade carry
      MULTSIGNOUT =&gt; MULTSIGNOUT,       -- 1-bit output: Multiplier sign cascade
      PCOUT =&gt; PCOUT,                   -- 48-bit output: Cascade output
      -- Control outputs: Control Inputs/Status Bits
      OVERFLOW =&gt; OVERFLOW,             -- 1-bit output: Overflow in add/acc
      PATTERNBDETECT =&gt; PATTERNBDETECT, -- 1-bit output: Pattern bar detect
      PATTERNDETECT =&gt; PATTERNDETECT,   -- 1-bit output: Pattern detect
      UNDERFLOW =&gt; UNDERFLOW,           -- 1-bit output: Underflow in add/acc
      -- Data outputs: Data Ports
      CARRYOUT =&gt; CARRYOUT,             -- 4-bit output: Carry
      P =&gt; P,                           -- 48-bit output: Primary data
      XOROUT =&gt; XOROUT,                 -- 8-bit output: XOR data
      -- Cascade inputs: Cascade Ports
      ACIN =&gt; ACIN,                     -- 30-bit input: A cascade data
      BCIN =&gt; BCIN,                     -- 18-bit input: B cascade
      CARRYCASCIN =&gt; CARRYCASCIN,       -- 1-bit input: Cascade carry
      MULTSIGNIN =&gt; MULTSIGNIN,         -- 1-bit input: Multiplier sign cascade
      PCIN =&gt; PCIN,                     -- 48-bit input: P cascade
      -- Control inputs: Control Inputs/Status Bits
      ALUMODE =&gt; ALUMODE,               -- 4-bit input: ALU control
      CARRYINSEL =&gt; CARRYINSEL,         -- 3-bit input: Carry select
      CLK =&gt; CLK,                       -- 1-bit input: Clock
      INMODE =&gt; INMODE,                 -- 5-bit input: INMODE control
      OPMODE =&gt; OPMODE,                 -- 9-bit input: Operation mode
      -- Data inputs: Data Ports
      A =&gt; A,                           -- 30-bit input: A data
      B =&gt; B,                           -- 18-bit input: B data
      C =&gt; C,                           -- 48-bit input: C data
      CARRYIN =&gt; CARRYIN,               -- 1-bit input: Carry-in
      D =&gt; D,                           -- 27-bit input: D data
      -- Reset/Clock Enable inputs: Reset/Clock Enable Inputs
      CEA1 =&gt; CEA1,                     -- 1-bit input: Clock enable for 1st stage AREG
      CEA2 =&gt; CEA2,                     -- 1-bit input: Clock enable for 2nd stage AREG
      CEAD =&gt; CEAD,                     -- 1-bit input: Clock enable for ADREG
      CEALUMODE =&gt; CEALUMODE,           -- 1-bit input: Clock enable for ALUMODE
      CEB1 =&gt; CEB1,                     -- 1-bit input: Clock enable for 1st stage BREG
      CEB2 =&gt; CEB2,                     -- 1-bit input: Clock enable for 2nd stage BREG
      CEC =&gt; CEC,                       -- 1-bit input: Clock enable for CREG
      CECARRYIN =&gt; CECARRYIN,           -- 1-bit input: Clock enable for CARRYINREG
      CECTRL =&gt; CECTRL,                 -- 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
      CED =&gt; CED,                       -- 1-bit input: Clock enable for DREG
      CEINMODE =&gt; CEINMODE,             -- 1-bit input: Clock enable for INMODEREG
      CEM =&gt; CEM,                       -- 1-bit input: Clock enable for MREG
      CEP =&gt; CEP,                       -- 1-bit input: Clock enable for PREG
      RSTA =&gt; RSTA,                     -- 1-bit input: Reset for AREG
      RSTALLCARRYIN =&gt; RSTALLCARRYIN,   -- 1-bit input: Reset for CARRYINREG
      RSTALUMODE =&gt; RSTALUMODE,         -- 1-bit input: Reset for ALUMODEREG
      RSTB =&gt; RSTB,                     -- 1-bit input: Reset for BREG
      RSTC =&gt; RSTC,                     -- 1-bit input: Reset for CREG
      RSTCTRL =&gt; RSTCTRL,               -- 1-bit input: Reset for OPMODEREG and CARRYINSELREG
      RSTD =&gt; RSTD,                     -- 1-bit input: Reset for DREG and ADREG
      RSTINMODE =&gt; RSTINMODE,           -- 1-bit input: Reset for INMODEREG
      RSTM =&gt; RSTM,                     -- 1-bit input: Reset for MREG
      RSTP =&gt; RSTP                      -- 1-bit input: Reset for PREG
   );

   -- End of DSP48E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="BLOCKRAM" treetype="folder">
				<SubFolder label="BRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E2)" treetype="template">
--  RAMB18E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB18E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB18E2: 18K-bit Configurable Synchronous Block RAM
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAMB18E2_inst : RAMB18E2
   generic map (
      -- CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      CASCADE_ORDER_A =&gt; "NONE",
      CASCADE_ORDER_B =&gt; "NONE",
      -- CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      CLOCK_DOMAINS =&gt; "INDEPENDENT",
      -- Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0, 1)
      DOA_REG =&gt; 1,
      DOB_REG =&gt; 1,
      -- ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      ENADDRENA =&gt; "FALSE",
      ENADDRENB =&gt; "FALSE",
      -- INITP_00 to INITP_07: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_3F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"00000",
      INIT_B =&gt; X"00000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLKARDCLK_INVERTED =&gt; '0',
      IS_CLKBWRCLK_INVERTED =&gt; '0',
      IS_ENARDEN_INVERTED =&gt; '0',
      IS_ENBWREN_INVERTED =&gt; '0',
      IS_RSTRAMARSTRAM_INVERTED =&gt; '0',
      IS_RSTRAMB_INVERTED =&gt; '0',
      IS_RSTREGARSTREG_INVERTED =&gt; '0',
      IS_RSTREGB_INVERTED =&gt; '0',
      -- RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      RDADDRCHANGEA =&gt; "FALSE",
      RDADDRCHANGEB =&gt; "FALSE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-9
      READ_WIDTH_B =&gt; 0,                                                               -- 0-9
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-9
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-9
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"00000",
      SRVAL_B =&gt; X"00000",
      -- Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      SLEEP_ASYNC =&gt; "FALSE",
      -- WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      WRITE_MODE_A =&gt; "NO_CHANGE",
      WRITE_MODE_B =&gt; "NO_CHANGE" 
   )
   port map (
      -- Cascade Signals outputs: Multi-BRAM cascade signals
      CASDOUTA =&gt; CASDOUTA,               -- 16-bit output: Port A cascade output data
      CASDOUTB =&gt; CASDOUTB,               -- 16-bit output: Port B cascade output data
      CASDOUTPA =&gt; CASDOUTPA,             -- 2-bit output: Port A cascade output parity data
      CASDOUTPB =&gt; CASDOUTPB,             -- 2-bit output: Port B cascade output parity data
      -- Port A Data outputs: Port A data
      DOUTADOUT =&gt; DOUTADOUT,             -- 16-bit output: Port A data/LSB data
      DOUTPADOUTP =&gt; DOUTPADOUTP,         -- 2-bit output: Port A parity/LSB parity
      -- Port B Data outputs: Port B data
      DOUTBDOUT =&gt; DOUTBDOUT,             -- 16-bit output: Port B data/MSB data
      DOUTPBDOUTP =&gt; DOUTPBDOUTP,         -- 2-bit output: Port B parity/MSB parity
      -- Cascade Signals inputs: Multi-BRAM cascade signals
      CASDIMUXA =&gt; CASDIMUXA,             -- 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      CASDIMUXB =&gt; CASDIMUXB,             -- 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      CASDINA =&gt; CASDINA,                 -- 16-bit input: Port A cascade input data
      CASDINB =&gt; CASDINB,                 -- 16-bit input: Port B cascade input data
      CASDINPA =&gt; CASDINPA,               -- 2-bit input: Port A cascade input parity data
      CASDINPB =&gt; CASDINPB,               -- 2-bit input: Port B cascade input parity data
      CASDOMUXA =&gt; CASDOMUXA,             -- 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      CASDOMUXB =&gt; CASDOMUXB,             -- 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      CASDOMUXEN_A =&gt; CASDOMUXEN_A,       -- 1-bit input: Port A unregistered output data enable
      CASDOMUXEN_B =&gt; CASDOMUXEN_B,       -- 1-bit input: Port B unregistered output data enable
      CASOREGIMUXA =&gt; CASOREGIMUXA,       -- 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      CASOREGIMUXB =&gt; CASOREGIMUXB,       -- 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      CASOREGIMUXEN_A =&gt; CASOREGIMUXEN_A, -- 1-bit input: Port A registered output data enable
      CASOREGIMUXEN_B =&gt; CASOREGIMUXEN_B, -- 1-bit input: Port B registered output data enable
      -- Port A Address/Control Signals inputs: Port A address and control signals
      ADDRARDADDR =&gt; ADDRARDADDR,         -- 14-bit input: A/Read port address
      ADDRENA =&gt; ADDRENA,                 -- 1-bit input: Active-High A/Read port address enable
      CLKARDCLK =&gt; CLKARDCLK,             -- 1-bit input: A/Read port clock
      ENARDEN =&gt; ENARDEN,                 -- 1-bit input: Port A enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,         -- 1-bit input: Port A register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM,     -- 1-bit input: Port A set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG,     -- 1-bit input: Port A register set/reset
      WEA =&gt; WEA,                         -- 2-bit input: Port A write enable
      -- Port A Data inputs: Port A data
      DINADIN =&gt; DINADIN,                 -- 16-bit input: Port A data/LSB data
      DINPADINP =&gt; DINPADINP,             -- 2-bit input: Port A parity/LSB parity
      -- Port B Address/Control Signals inputs: Port B address and control signals
      ADDRBWRADDR =&gt; ADDRBWRADDR,         -- 14-bit input: B/Write port address
      ADDRENB =&gt; ADDRENB,                 -- 1-bit input: Active-High B/Write port address enable
      CLKBWRCLK =&gt; CLKBWRCLK,             -- 1-bit input: B/Write port clock
      ENBWREN =&gt; ENBWREN,                 -- 1-bit input: Port B enable/Write enable
      REGCEB =&gt; REGCEB,                   -- 1-bit input: Port B register enable
      RSTRAMB =&gt; RSTRAMB,                 -- 1-bit input: Port B set/reset
      RSTREGB =&gt; RSTREGB,                 -- 1-bit input: Port B register set/reset
      SLEEP =&gt; SLEEP,                     -- 1-bit input: Sleep Mode
      WEBWE =&gt; WEBWE,                     -- 4-bit input: Port B write enable/Write enable
      -- Port B Data inputs: Port B data
      DINBDIN =&gt; DINBDIN,                 -- 16-bit input: Port B data/MSB data
      DINPBDINP =&gt; DINPBDINP              -- 2-bit input: Port B parity/MSB parity
   );

   -- End of RAMB18E2_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E2)" treetype="template">
--  RAMB36E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB36E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB36E2: 36K-bit Configurable Synchronous Block RAM
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAMB36E2_inst : RAMB36E2
   generic map (
      -- CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      CASCADE_ORDER_A =&gt; "NONE",
      CASCADE_ORDER_B =&gt; "NONE",
      -- CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      CLOCK_DOMAINS =&gt; "INDEPENDENT",
      DOB_REG =&gt; 1,
      -- Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0, 1)
      DOA_REG =&gt; 1,
      -- ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      ENADDRENA =&gt; "FALSE",
      ENADDRENB =&gt; "FALSE",
      -- EN_ECC_PIPE: ECC pipeline register, "TRUE"/"FALSE" 
      EN_ECC_PIPE =&gt; "FALSE",
      -- EN_ECC_READ: Enable ECC decoder, "TRUE"/"FALSE" 
      EN_ECC_READ =&gt; "FALSE",
      -- EN_ECC_WRITE: Enable ECC encoder, "TRUE"/"FALSE" 
      EN_ECC_WRITE =&gt; "FALSE",
      -- INITP_00 to INITP_0F: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_7F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"000000000",
      INIT_B =&gt; X"000000000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLKARDCLK_INVERTED =&gt; '0',
      IS_CLKBWRCLK_INVERTED =&gt; '0',
      IS_ENARDEN_INVERTED =&gt; '0',
      IS_ENBWREN_INVERTED =&gt; '0',
      IS_RSTRAMARSTRAM_INVERTED =&gt; '0',
      IS_RSTRAMB_INVERTED =&gt; '0',
      IS_RSTREGARSTREG_INVERTED =&gt; '0',
      IS_RSTREGB_INVERTED =&gt; '0',
      -- RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      RDADDRCHANGEA =&gt; "FALSE",
      RDADDRCHANGEB =&gt; "FALSE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-9
      READ_WIDTH_B =&gt; 0,                                                               -- 0-9
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-9
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-9
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"000000000",
      SRVAL_B =&gt; X"000000000",
      -- Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      SLEEP_ASYNC =&gt; "FALSE",
      -- WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      WRITE_MODE_A =&gt; "NO_CHANGE",
      WRITE_MODE_B =&gt; "NO_CHANGE" 
   )
   port map (
      -- Cascade Signals outputs: Multi-BRAM cascade signals
      CASDOUTA =&gt; CASDOUTA,               -- 32-bit output: Port A cascade output data
      CASDOUTB =&gt; CASDOUTB,               -- 32-bit output: Port B cascade output data
      CASDOUTPA =&gt; CASDOUTPA,             -- 4-bit output: Port A cascade output parity data
      CASDOUTPB =&gt; CASDOUTPB,             -- 4-bit output: Port B cascade output parity data
      CASOUTDBITERR =&gt; CASOUTDBITERR,     -- 1-bit output: DBITERR cascade output
      CASOUTSBITERR =&gt; CASOUTSBITERR,     -- 1-bit output: SBITERR cascade output
      -- ECC Signals outputs: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,                 -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,             -- 8-bit output: Generated error correction parity
      RDADDRECC =&gt; RDADDRECC,             -- 9-bit output: ECC Read Address
      SBITERR =&gt; SBITERR,                 -- 1-bit output: Single bit error status
      -- Port A Data outputs: Port A data
      DOUTADOUT =&gt; DOUTADOUT,             -- 32-bit output: Port A ata/LSB data
      DOUTPADOUTP =&gt; DOUTPADOUTP,         -- 4-bit output: Port A parity/LSB parity
      -- Port B Data outputs: Port B data
      DOUTBDOUT =&gt; DOUTBDOUT,             -- 32-bit output: Port B data/MSB data
      DOUTPBDOUTP =&gt; DOUTPBDOUTP,         -- 4-bit output: Port B parity/MSB parity
      -- Cascade Signals inputs: Multi-BRAM cascade signals
      CASDIMUXA =&gt; CASDIMUXA,             -- 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      CASDIMUXB =&gt; CASDIMUXB,             -- 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      CASDINA =&gt; CASDINA,                 -- 32-bit input: Port A cascade input data
      CASDINB =&gt; CASDINB,                 -- 32-bit input: Port B cascade input data
      CASDINPA =&gt; CASDINPA,               -- 4-bit input: Port A cascade input parity data
      CASDINPB =&gt; CASDINPB,               -- 4-bit input: Port B cascade input parity data
      CASDOMUXA =&gt; CASDOMUXA,             -- 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      CASDOMUXB =&gt; CASDOMUXB,             -- 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      CASDOMUXEN_A =&gt; CASDOMUXEN_A,       -- 1-bit input: Port A unregistered output data enable
      CASDOMUXEN_B =&gt; CASDOMUXEN_B,       -- 1-bit input: Port B unregistered output data enable
      CASINDBITERR =&gt; CASINDBITERR,       -- 1-bit input: DBITERR cascade input
      CASINSBITERR =&gt; CASINSBITERR,       -- 1-bit input: SBITERR cascade input
      CASOREGIMUXA =&gt; CASOREGIMUXA,       -- 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      CASOREGIMUXB =&gt; CASOREGIMUXB,       -- 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      CASOREGIMUXEN_A =&gt; CASOREGIMUXEN_A, -- 1-bit input: Port A registered output data enable
      CASOREGIMUXEN_B =&gt; CASOREGIMUXEN_B, -- 1-bit input: Port B registered output data enable
      -- ECC Signals inputs: Error Correction Circuitry ports
      ECCPIPECE =&gt; ECCPIPECE,             -- 1-bit input: ECC Pipeline Register Enable
      INJECTDBITERR =&gt; INJECTDBITERR,     -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR,
      -- Port A Address/Control Signals inputs: Port A address and control signals
      ADDRARDADDR =&gt; ADDRARDADDR,         -- 15-bit input: A/Read port address
      ADDRENA =&gt; ADDRENA,                 -- 1-bit input: Active-High A/Read port address enable
      CLKARDCLK =&gt; CLKARDCLK,             -- 1-bit input: A/Read port clock
      ENARDEN =&gt; ENARDEN,                 -- 1-bit input: Port A enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,         -- 1-bit input: Port A register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM,     -- 1-bit input: Port A set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG,     -- 1-bit input: Port A register set/reset
      SLEEP =&gt; SLEEP,                     -- 1-bit input: Sleep Mode
      WEA =&gt; WEA,                         -- 4-bit input: Port A write enable
      -- Port A Data inputs: Port A data
      DINADIN =&gt; DINADIN,                 -- 32-bit input: Port A data/LSB data
      DINPADINP =&gt; DINPADINP,             -- 4-bit input: Port A parity/LSB parity
      -- Port B Address/Control Signals inputs: Port B address and control signals
      ADDRBWRADDR =&gt; ADDRBWRADDR,         -- 15-bit input: B/Write port address
      ADDRENB =&gt; ADDRENB,                 -- 1-bit input: Active-High B/Write port address enable
      CLKBWRCLK =&gt; CLKBWRCLK,             -- 1-bit input: B/Write port clock
      ENBWREN =&gt; ENBWREN,                 -- 1-bit input: Port B enable/Write enable
      REGCEB =&gt; REGCEB,                   -- 1-bit input: Port B register enable
      RSTRAMB =&gt; RSTRAMB,                 -- 1-bit input: Port B set/reset
      RSTREGB =&gt; RSTREGB,                 -- 1-bit input: Port B register set/reset
      WEBWE =&gt; WEBWE,                     -- 8-bit input: Port B write enable/Write enable
      -- Port B Data inputs: Port B data
      DINBDIN =&gt; DINBDIN,                 -- 32-bit input: Port B data/MSB data
      DINPBDINP =&gt; DINPBDINP              -- 4-bit input: Port B parity/MSB parity
   );

   -- End of RAMB36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E2)" treetype="template">
--  FIFO18E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO18E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO18E2: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FIFO18E2_inst : FIFO18E2
   generic map (
      CASCADE_ORDER =&gt; "NONE",            -- FIRST, LAST, MIDDLE, NONE, PARALLEL
      CLOCK_DOMAINS =&gt; "INDEPENDENT",     -- COMMON, INDEPENDENT
      FIRST_WORD_FALL_THROUGH =&gt; "FALSE", -- FALSE, TRUE
      INIT =&gt; X"000000000",               -- Initial values on output port
      PROG_EMPTY_THRESH =&gt; 256,           -- Programmable Empty Threshold
      PROG_FULL_THRESH =&gt; 256,            -- Programmable Full Threshold
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_RDCLK_INVERTED =&gt; '0',           -- Optional inversion for RDCLK
      IS_RDEN_INVERTED =&gt; '0',            -- Optional inversion for RDEN
      IS_RSTREG_INVERTED =&gt; '0',          -- Optional inversion for RSTREG
      IS_RST_INVERTED =&gt; '0',             -- Optional inversion for RST
      IS_WRCLK_INVERTED =&gt; '0',           -- Optional inversion for WRCLK
      IS_WREN_INVERTED =&gt; '0',            -- Optional inversion for WREN
      RDCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      READ_WIDTH =&gt; 4,                    -- 18-9
      REGISTER_MODE =&gt; "UNREGISTERED",    -- DO_PIPELINED, REGISTERED, UNREGISTERED
      RSTREG_PRIORITY =&gt; "RSTREG",        -- REGCE, RSTREG
      SLEEP_ASYNC =&gt; "FALSE",             -- FALSE, TRUE
      SRVAL =&gt; X"000000000",              -- SET/reset value of the FIFO outputs
      WRCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      WRITE_WIDTH =&gt; 4                    -- 18-9
   )
   port map (
      -- Cascade Signals outputs: Multi-FIFO cascade signals
      CASDOUT =&gt; CASDOUT,             -- 32-bit output: Data cascade output bus
      CASDOUTP =&gt; CASDOUTP,           -- 4-bit output: Parity data cascade output bus
      CASNXTEMPTY =&gt; CASNXTEMPTY,     -- 1-bit output: Cascade next empty
      CASPRVRDEN =&gt; CASPRVRDEN,       -- 1-bit output: Cascade previous read enable
      -- Read Data outputs: Read output data
      DOUT =&gt; DOUT,                   -- 32-bit output: FIFO data output bus
      DOUTP =&gt; DOUTP,                 -- 4-bit output: FIFO parity output bus.
      -- Status outputs: Flags and other FIFO status outputs
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty
      FULL =&gt; FULL,                   -- 1-bit output: Full
      PROGEMPTY =&gt; PROGEMPTY,         -- 1-bit output: Programmable empty
      PROGFULL =&gt; PROGFULL,           -- 1-bit output: Programmable full
      RDCOUNT =&gt; RDCOUNT,             -- 13-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      RDRSTBUSY =&gt; RDRSTBUSY,         -- 1-bit output: Reset busy (sync to RDCLK)
      WRCOUNT =&gt; WRCOUNT,             -- 13-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write Error
      WRRSTBUSY =&gt; WRRSTBUSY,         -- 1-bit output: Reset busy (sync to WRCLK)
      -- Cascade Signals inputs: Multi-FIFO cascade signals
      CASDIN =&gt; CASDIN,               -- 32-bit input: Data cascade input bus
      CASDINP =&gt; CASDINP,             -- 4-bit input: Parity data cascade input bus
      CASDOMUX =&gt; CASDOMUX,           -- 1-bit input: Cascade MUX select
      CASDOMUXEN =&gt; CASDOMUXEN,       -- 1-bit input: Enable for cascade MUX select
      CASNXTRDEN =&gt; CASNXTRDEN,       -- 1-bit input: Cascade next read enable
      CASOREGIMUX =&gt; CASOREGIMUX,     -- 1-bit input: Cascade output MUX select
      CASOREGIMUXEN =&gt; CASOREGIMUXEN, -- 1-bit input: Cascade output MUX select enable
      CASPRVEMPTY =&gt; CASPRVEMPTY,     -- 1-bit input: Cascade previous empty
      -- Read Control Signals inputs: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Output register clock enable
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register reset
      SLEEP =&gt; SLEEP,                 -- 1-bit input: Sleep Mode
      -- Write Control Signals inputs: Write clock and enable input signals
      RST =&gt; RST,                     -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Write clock
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data inputs: Write input data
      DIN =&gt; DIN,                     -- 32-bit input: FIFO data input bus
      DINP =&gt; DINP                    -- 4-bit input: FIFO parity input bus
   );

   -- End of FIFO18E2_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E2)" treetype="template">
--  FIFO36E2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO36E2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO36E2: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FIFO36E2_inst : FIFO36E2
   generic map (
      CASCADE_ORDER =&gt; "NONE",            -- FIRST, LAST, MIDDLE, NONE, PARALLEL
      CLOCK_DOMAINS =&gt; "INDEPENDENT",     -- COMMON, INDEPENDENT
      EN_ECC_PIPE =&gt; "FALSE",             -- ECC pipeline register, (FALSE, TRUE)
      EN_ECC_READ =&gt; "FALSE",             -- Enable ECC decoder, (FALSE, TRUE)
      EN_ECC_WRITE =&gt; "FALSE",            -- Enable ECC encoder, (FALSE, TRUE)
      FIRST_WORD_FALL_THROUGH =&gt; "FALSE", -- FALSE, TRUE
      INIT =&gt; X"000000000000000000",      -- Initial values on output port
      PROG_EMPTY_THRESH =&gt; 256,           -- Programmable Empty Threshold
      PROG_FULL_THRESH =&gt; 256,            -- Programmable Full Threshold
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_RDCLK_INVERTED =&gt; '0',           -- Optional inversion for RDCLK
      IS_RDEN_INVERTED =&gt; '0',            -- Optional inversion for RDEN
      IS_RSTREG_INVERTED =&gt; '0',          -- Optional inversion for RSTREG
      IS_RST_INVERTED =&gt; '0',             -- Optional inversion for RST
      IS_WRCLK_INVERTED =&gt; '0',           -- Optional inversion for WRCLK
      IS_WREN_INVERTED =&gt; '0',            -- Optional inversion for WREN
      RDCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      READ_WIDTH =&gt; 4,                    -- 18-9
      REGISTER_MODE =&gt; "UNREGISTERED",    -- DO_PIPELINED, REGISTERED, UNREGISTERED
      RSTREG_PRIORITY =&gt; "RSTREG",        -- REGCE, RSTREG
      SLEEP_ASYNC =&gt; "FALSE",             -- FALSE, TRUE
      SRVAL =&gt; X"000000000000000000",     -- SET/reset value of the FIFO outputs
      WRCOUNT_TYPE =&gt; "RAW_PNTR",         -- EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      WRITE_WIDTH =&gt; 4                    -- 18-9
   )
   port map (
      -- Cascade Signals outputs: Multi-FIFO cascade signals
      CASDOUT =&gt; CASDOUT,             -- 64-bit output: Data cascade output bus
      CASDOUTP =&gt; CASDOUTP,           -- 8-bit output: Parity data cascade output bus
      CASNXTEMPTY =&gt; CASNXTEMPTY,     -- 1-bit output: Cascade next empty
      CASPRVRDEN =&gt; CASPRVRDEN,       -- 1-bit output: Cascade previous read enable
      -- ECC Signals outputs: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Read Data outputs: Read output data
      DOUT =&gt; DOUT,                   -- 64-bit output: FIFO data output bus
      DOUTP =&gt; DOUTP,                 -- 8-bit output: FIFO parity output bus.
      -- Status outputs: Flags and other FIFO status outputs
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty
      FULL =&gt; FULL,                   -- 1-bit output: Full
      PROGEMPTY =&gt; PROGEMPTY,         -- 1-bit output: Programmable empty
      PROGFULL =&gt; PROGFULL,           -- 1-bit output: Programmable full
      RDCOUNT =&gt; RDCOUNT,             -- 14-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      RDRSTBUSY =&gt; RDRSTBUSY,         -- 1-bit output: Reset busy (sync to RDCLK)
      WRCOUNT =&gt; WRCOUNT,             -- 14-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write Error
      WRRSTBUSY =&gt; WRRSTBUSY,         -- 1-bit output: Reset busy (sync to WRCLK)
      -- Cascade Signals inputs: Multi-FIFO cascade signals
      CASDIN =&gt; CASDIN,               -- 64-bit input: Data cascade input bus
      CASDINP =&gt; CASDINP,             -- 8-bit input: Parity data cascade input bus
      CASDOMUX =&gt; CASDOMUX,           -- 1-bit input: Cascade MUX select input
      CASDOMUXEN =&gt; CASDOMUXEN,       -- 1-bit input: Enable for cascade MUX select
      CASNXTRDEN =&gt; CASNXTRDEN,       -- 1-bit input: Cascade next read enable
      CASOREGIMUX =&gt; CASOREGIMUX,     -- 1-bit input: Cascade output MUX select
      CASOREGIMUXEN =&gt; CASOREGIMUXEN, -- 1-bit input: Cascade output MUX select enable
      CASPRVEMPTY =&gt; CASPRVEMPTY,     -- 1-bit input: Cascade previous empty
      -- ECC Signals inputs: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR, -- 1-bit input: Inject a single bit error
      -- Read Control Signals inputs: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Output register clock enable
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register reset
      SLEEP =&gt; SLEEP,                 -- 1-bit input: Sleep Mode
      -- Write Control Signals inputs: Write clock and enable input signals
      RST =&gt; RST,                     -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Write clock
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data inputs: Write input data
      DIN =&gt; DIN,                     -- 64-bit input: FIFO data input bus
      DINP =&gt; DINP                    -- 8-bit input: FIFO parity input bus
   );

   -- End of FIFO36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="URAM" treetype="folder">
					<Template label="288K-bit High-Density Base Memory Building Block (URAM288_BASE)" treetype="template">
-- URAM288_BASE : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (URAM288_BASE_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- URAM288_BASE: 288K-bit High-Density Base Memory Building Block
   --               Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   URAM288_BASE_inst : URAM288_BASE
   generic map (
      AUTO_SLEEP_LATENCY =&gt; 8,            -- Latency requirement to enter sleep mode
      AVG_CONS_INACTIVE_CYCLES =&gt; 10,     -- Average concecutive inactive cycles when is SLEEP mode for power
                                          -- estimation
      BWE_MODE_A =&gt; "PARITY_INTERLEAVED", -- Port A Byte write control
      BWE_MODE_B =&gt; "PARITY_INTERLEAVED", -- Port B Byte write control
      EN_AUTO_SLEEP_MODE =&gt; "FALSE",      -- Enable to automatically enter sleep mode
      EN_ECC_RD_A =&gt; "FALSE",             -- Port A ECC encoder
      EN_ECC_RD_B =&gt; "FALSE",             -- Port B ECC encoder
      EN_ECC_WR_A =&gt; "FALSE",             -- Port A ECC decoder
      EN_ECC_WR_B =&gt; "FALSE",             -- Port B ECC decoder
      IREG_PRE_A =&gt; "FALSE",              -- Optional Port A input pipeline registers
      IREG_PRE_B =&gt; "FALSE",              -- Optional Port B input pipeline registers
      IS_CLK_INVERTED =&gt; '0',             -- Optional inverter for CLK
      IS_EN_A_INVERTED =&gt; '0',            -- Optional inverter for Port A enable
      IS_EN_B_INVERTED =&gt; '0',            -- Optional inverter for Port B enable
      IS_RDB_WR_A_INVERTED =&gt; '0',        -- Optional inverter for Port A read/write select
      IS_RDB_WR_B_INVERTED =&gt; '0',        -- Optional inverter for Port B read/write select
      IS_RST_A_INVERTED =&gt; '0',           -- Optional inverter for Port A reset
      IS_RST_B_INVERTED =&gt; '0',           -- Optional inverter for Port B reset
      MATRIX_ID =&gt; "NONE",
      NUM_UNIQUE_SELF_ADDR_A =&gt; 1,
      NUM_UNIQUE_SELF_ADDR_B =&gt; 1,
      NUM_URAM_IN_MATRIX =&gt; 1,
      OREG_A =&gt; "FALSE",                  -- Optional Port A output pipeline registers
      OREG_B =&gt; "FALSE",                  -- Optional Port B output pipeline registers
      OREG_ECC_A =&gt; "FALSE",              -- Port A ECC decoder output
      OREG_ECC_B =&gt; "FALSE",              -- Port B output ECC decoder
      RST_MODE_A =&gt; "SYNC",               -- Port A reset mode
      RST_MODE_B =&gt; "SYNC",               -- Port B reset mode
      USE_EXT_CE_A =&gt; "FALSE",            -- Enable Port A external CE inputs for output registers
      USE_EXT_CE_B =&gt; "FALSE"             -- Enable Port B external CE inputs for output registers
   )
   port map (
      DBITERR_A =&gt; DBITERR_A,               -- 1-bit output: Port A double-bit error flag status
      DBITERR_B =&gt; DBITERR_B,               -- 1-bit output: Port B double-bit error flag status
      DOUT_A =&gt; DOUT_A,                     -- 72-bit output: Port A read data output
      DOUT_B =&gt; DOUT_B,                     -- 72-bit output: Port B read data output
      SBITERR_A =&gt; SBITERR_A,               -- 1-bit output: Port A single-bit error flag status
      SBITERR_B =&gt; SBITERR_B,               -- 1-bit output: Port B single-bit error flag status
      ADDR_A =&gt; ADDR_A,                     -- 23-bit input: Port A address
      ADDR_B =&gt; ADDR_B,                     -- 23-bit input: Port B address
      BWE_A =&gt; BWE_A,                       -- 9-bit input: Port A Byte-write enable
      BWE_B =&gt; BWE_B,                       -- 9-bit input: Port B Byte-write enable
      CLK =&gt; CLK,                           -- 1-bit input: Clock source
      DIN_A =&gt; DIN_A,                       -- 72-bit input: Port A write data input
      DIN_B =&gt; DIN_B,                       -- 72-bit input: Port B write data input
      EN_A =&gt; EN_A,                         -- 1-bit input: Port A enable
      EN_B =&gt; EN_B,                         -- 1-bit input: Port B enable
      INJECT_DBITERR_A =&gt; INJECT_DBITERR_A, -- 1-bit input: Port A double-bit error injection
      INJECT_DBITERR_B =&gt; INJECT_DBITERR_B, -- 1-bit input: Port B double-bit error injection
      INJECT_SBITERR_A =&gt; INJECT_SBITERR_A, -- 1-bit input: Port A single-bit error injection
      INJECT_SBITERR_B =&gt; INJECT_SBITERR_B, -- 1-bit input: Port B single-bit error injection
      OREG_CE_A =&gt; OREG_CE_A,               -- 1-bit input: Port A output register clock enable
      OREG_CE_B =&gt; OREG_CE_B,               -- 1-bit input: Port B output register clock enable
      OREG_ECC_CE_A =&gt; OREG_ECC_CE_A,       -- 1-bit input: Port A ECC decoder output register clock enable
      OREG_ECC_CE_B =&gt; OREG_ECC_CE_B,       -- 1-bit input: Port B ECC decoder output register clock enable
      RDB_WR_A =&gt; RDB_WR_A,                 -- 1-bit input: Port A read/write select
      RDB_WR_B =&gt; RDB_WR_B,                 -- 1-bit input: Port B read/write select
      RST_A =&gt; RST_A,                       -- 1-bit input: Port A asynchronous or synchronous reset for output
                                            -- registers

      RST_B =&gt; RST_B,                       -- 1-bit input: Port B asynchronous or synchronous reset for output
                                            -- registers

      SLEEP =&gt; SLEEP                        -- 1-bit input: Dynamic power gating control
   );

   -- End of URAM288_BASE_inst instantiation
					</Template>
					<Template label="288K-bit High-Density Memory Building Block (URAM288)" treetype="template">
--   URAM288   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (URAM288_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- URAM288: 288K-bit High-Density Memory Building Block
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   URAM288_inst : URAM288
   generic map (
      AUTO_SLEEP_LATENCY =&gt; 8,            -- Latency requirement to enter sleep mode
      AVG_CONS_INACTIVE_CYCLES =&gt; 10,     -- Average concecutive inactive cycles when is SLEEP mode for power
                                          -- estimation
      BWE_MODE_A =&gt; "PARITY_INTERLEAVED", -- Port A Byte write control
      BWE_MODE_B =&gt; "PARITY_INTERLEAVED", -- Port B Byte write control
      CASCADE_ORDER_A =&gt; "NONE",          -- Port A position in cascade chain
      CASCADE_ORDER_B =&gt; "NONE",          -- Port B position in cascade chain
      EN_AUTO_SLEEP_MODE =&gt; "FALSE",      -- Enable to automatically enter sleep mode
      EN_ECC_RD_A =&gt; "FALSE",             -- Port A ECC encoder
      EN_ECC_RD_B =&gt; "FALSE",             -- Port B ECC encoder
      EN_ECC_WR_A =&gt; "FALSE",             -- Port A ECC decoder
      EN_ECC_WR_B =&gt; "FALSE",             -- Port B ECC decoder
      IREG_PRE_A =&gt; "FALSE",              -- Optional Port A input pipeline registers
      IREG_PRE_B =&gt; "FALSE",              -- Optional Port B input pipeline registers
      IS_CLK_INVERTED =&gt; '0',             -- Optional inverter for CLK
      IS_EN_A_INVERTED =&gt; '0',            -- Optional inverter for Port A enable
      IS_EN_B_INVERTED =&gt; '0',            -- Optional inverter for Port B enable
      IS_RDB_WR_A_INVERTED =&gt; '0',        -- Optional inverter for Port A read/write select
      IS_RDB_WR_B_INVERTED =&gt; '0',        -- Optional inverter for Port B read/write select
      IS_RST_A_INVERTED =&gt; '0',           -- Optional inverter for Port A reset
      IS_RST_B_INVERTED =&gt; '0',           -- Optional inverter for Port B reset
      MATRIX_ID =&gt; "NONE",                -- Custom label to set a matrix ID name used by the power reporting
                                          -- tools to tag all of the UltraRAM blocks that belong to a cascade
                                          -- chain or matrix.
      NUM_UNIQUE_SELF_ADDR_A =&gt; 1,        -- The number of unique SELF_ADDR_A UltraRAM blocks in a cascade
                                          -- chain or matrix.
      NUM_UNIQUE_SELF_ADDR_B =&gt; 1,        -- The number of unique SELF_ADDR_B UltraRAM blocks in a cascade
                                          -- chain or matrix.
      NUM_URAM_IN_MATRIX =&gt; 1,            -- Defines the cascade/matrix size (the number of UltraRAMs in a
                                          -- matrix).
      OREG_A =&gt; "FALSE",                  -- Optional Port A output pipeline registers
      OREG_B =&gt; "FALSE",                  -- Optional Port B output pipeline registers
      OREG_ECC_A =&gt; "FALSE",              -- Port A ECC decoder output
      OREG_ECC_B =&gt; "FALSE",              -- Port B output ECC decoder
      REG_CAS_A =&gt; "FALSE",               -- Optional Port A cascade register
      REG_CAS_B =&gt; "FALSE",               -- Optional Port B cascade register
      RST_MODE_A =&gt; "SYNC",               -- Port A reset mode
      RST_MODE_B =&gt; "SYNC",               -- Port B reset mode
      SELF_ADDR_A =&gt; X"000",              -- Port A self-address value
      SELF_ADDR_B =&gt; X"000",              -- Port B self-address value
      SELF_MASK_A =&gt; X"7ff",              -- Port A self-address mask
      SELF_MASK_B =&gt; X"7ff",              -- Port B self-address mask
      USE_EXT_CE_A =&gt; "FALSE",            -- Enable Port A external CE inputs for output registers
      USE_EXT_CE_B =&gt; "FALSE"             -- Enable Port B external CE inputs for output registers
   )
   port map (
      CAS_OUT_ADDR_A =&gt; CAS_OUT_ADDR_A,         -- 23-bit output: Port A cascade output address
      CAS_OUT_ADDR_B =&gt; CAS_OUT_ADDR_B,         -- 23-bit output: Port B cascade output address
      CAS_OUT_BWE_A =&gt; CAS_OUT_BWE_A,           -- 9-bit output: Port A cascade Byte-write enable output
      CAS_OUT_BWE_B =&gt; CAS_OUT_BWE_B,           -- 9-bit output: Port B cascade Byte-write enable output
      CAS_OUT_DBITERR_A =&gt; CAS_OUT_DBITERR_A,   -- 1-bit output: Port A cascade double-bit error flag output
      CAS_OUT_DBITERR_B =&gt; CAS_OUT_DBITERR_B,   -- 1-bit output: Port B cascade double-bit error flag output
      CAS_OUT_DIN_A =&gt; CAS_OUT_DIN_A,           -- 72-bit output: Port A cascade output write mode data
      CAS_OUT_DIN_B =&gt; CAS_OUT_DIN_B,           -- 72-bit output: Port B cascade output write mode data
      CAS_OUT_DOUT_A =&gt; CAS_OUT_DOUT_A,         -- 72-bit output: Port A cascade output read mode data
      CAS_OUT_DOUT_B =&gt; CAS_OUT_DOUT_B,         -- 72-bit output: Port B cascade output read mode data
      CAS_OUT_EN_A =&gt; CAS_OUT_EN_A,             -- 1-bit output: Port A cascade output enable
      CAS_OUT_EN_B =&gt; CAS_OUT_EN_B,             -- 1-bit output: Port B cascade output enable
      CAS_OUT_RDACCESS_A =&gt; CAS_OUT_RDACCESS_A, -- 1-bit output: Port A cascade read status output
      CAS_OUT_RDACCESS_B =&gt; CAS_OUT_RDACCESS_B, -- 1-bit output: Port B cascade read status output
      CAS_OUT_RDB_WR_A =&gt; CAS_OUT_RDB_WR_A,     -- 1-bit output: Port A cascade read/write select output
      CAS_OUT_RDB_WR_B =&gt; CAS_OUT_RDB_WR_B,     -- 1-bit output: Port B cascade read/write select output
      CAS_OUT_SBITERR_A =&gt; CAS_OUT_SBITERR_A,   -- 1-bit output: Port A cascade single-bit error flag output
      CAS_OUT_SBITERR_B =&gt; CAS_OUT_SBITERR_B,   -- 1-bit output: Port B cascade single-bit error flag output
      DBITERR_A =&gt; DBITERR_A,                   -- 1-bit output: Port A double-bit error flag status
      DBITERR_B =&gt; DBITERR_B,                   -- 1-bit output: Port B double-bit error flag status
      DOUT_A =&gt; DOUT_A,                         -- 72-bit output: Port A read data output
      DOUT_B =&gt; DOUT_B,                         -- 72-bit output: Port B read data output
      RDACCESS_A =&gt; RDACCESS_A,                 -- 1-bit output: Port A read status
      RDACCESS_B =&gt; RDACCESS_B,                 -- 1-bit output: Port B read status
      SBITERR_A =&gt; SBITERR_A,                   -- 1-bit output: Port A single-bit error flag status
      SBITERR_B =&gt; SBITERR_B,                   -- 1-bit output: Port B single-bit error flag status
      ADDR_A =&gt; ADDR_A,                         -- 23-bit input: Port A address
      ADDR_B =&gt; ADDR_B,                         -- 23-bit input: Port B address
      BWE_A =&gt; BWE_A,                           -- 9-bit input: Port A Byte-write enable
      BWE_B =&gt; BWE_B,                           -- 9-bit input: Port B Byte-write enable
      CAS_IN_ADDR_A =&gt; CAS_IN_ADDR_A,           -- 23-bit input: Port A cascade input address
      CAS_IN_ADDR_B =&gt; CAS_IN_ADDR_B,           -- 23-bit input: Port B cascade input address
      CAS_IN_BWE_A =&gt; CAS_IN_BWE_A,             -- 9-bit input: Port A cascade Byte-write enable input
      CAS_IN_BWE_B =&gt; CAS_IN_BWE_B,             -- 9-bit input: Port B cascade Byte-write enable input
      CAS_IN_DBITERR_A =&gt; CAS_IN_DBITERR_A,     -- 1-bit input: Port A cascade double-bit error flag input
      CAS_IN_DBITERR_B =&gt; CAS_IN_DBITERR_B,     -- 1-bit input: Port B cascade double-bit error flag input
      CAS_IN_DIN_A =&gt; CAS_IN_DIN_A,             -- 72-bit input: Port A cascade input write mode data
      CAS_IN_DIN_B =&gt; CAS_IN_DIN_B,             -- 72-bit input: Port B cascade input write mode data
      CAS_IN_DOUT_A =&gt; CAS_IN_DOUT_A,           -- 72-bit input: Port A cascade input read mode data
      CAS_IN_DOUT_B =&gt; CAS_IN_DOUT_B,           -- 72-bit input: Port B cascade input read mode data
      CAS_IN_EN_A =&gt; CAS_IN_EN_A,               -- 1-bit input: Port A cascade enable input
      CAS_IN_EN_B =&gt; CAS_IN_EN_B,               -- 1-bit input: Port B cascade enable input
      CAS_IN_RDACCESS_A =&gt; CAS_IN_RDACCESS_A,   -- 1-bit input: Port A cascade read status input
      CAS_IN_RDACCESS_B =&gt; CAS_IN_RDACCESS_B,   -- 1-bit input: Port B cascade read status input
      CAS_IN_RDB_WR_A =&gt; CAS_IN_RDB_WR_A,       -- 1-bit input: Port A cascade read/write select input
      CAS_IN_RDB_WR_B =&gt; CAS_IN_RDB_WR_B,       -- 1-bit input: Port A cascade read/write select input
      CAS_IN_SBITERR_A =&gt; CAS_IN_SBITERR_A,     -- 1-bit input: Port A cascade single-bit error flag input
      CAS_IN_SBITERR_B =&gt; CAS_IN_SBITERR_B,     -- 1-bit input: Port B cascade single-bit error flag input
      CLK =&gt; CLK,                               -- 1-bit input: Clock source
      DIN_A =&gt; DIN_A,                           -- 72-bit input: Port A write data input
      DIN_B =&gt; DIN_B,                           -- 72-bit input: Port B write data input
      EN_A =&gt; EN_A,                             -- 1-bit input: Port A enable
      EN_B =&gt; EN_B,                             -- 1-bit input: Port B enable
      INJECT_DBITERR_A =&gt; INJECT_DBITERR_A,     -- 1-bit input: Port A double-bit error injection
      INJECT_DBITERR_B =&gt; INJECT_DBITERR_B,     -- 1-bit input: Port B double-bit error injection
      INJECT_SBITERR_A =&gt; INJECT_SBITERR_A,     -- 1-bit input: Port A single-bit error injection
      INJECT_SBITERR_B =&gt; INJECT_SBITERR_B,     -- 1-bit input: Port B single-bit error injection
      OREG_CE_A =&gt; OREG_CE_A,                   -- 1-bit input: Port A output register clock enable
      OREG_CE_B =&gt; OREG_CE_B,                   -- 1-bit input: Port B output register clock enable
      OREG_ECC_CE_A =&gt; OREG_ECC_CE_A,           -- 1-bit input: Port A ECC decoder output register clock enable
      OREG_ECC_CE_B =&gt; OREG_ECC_CE_B,           -- 1-bit input: Port B ECC decoder output register clock enable
      RDB_WR_A =&gt; RDB_WR_A,                     -- 1-bit input: Port A read/write select
      RDB_WR_B =&gt; RDB_WR_B,                     -- 1-bit input: Port B read/write select
      RST_A =&gt; RST_A,                           -- 1-bit input: Port A asynchronous or synchronous reset for
                                                -- output registers

      RST_B =&gt; RST_B,                           -- 1-bit input: Port B asynchronous or synchronous reset for
                                                -- output registers

      SLEEP =&gt; SLEEP                            -- 1-bit input: Dynamic power gating control
   );

   -- End of URAM288_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLB" treetype="folder">
				<SubFolder label="CARRY" treetype="folder">
					<Template label="Fast Carry Logic with Look Ahead (CARRY8)" treetype="template">
--   CARRY8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CARRY8_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CARRY8: Fast Carry Logic with Look Ahead
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   CARRY8_inst : CARRY8
   generic map (
      CARRY_TYPE =&gt; "SINGLE_CY8"  -- 8-bit or dual 4-bit carry (DUAL_CY4, SINGLE_CY8)
   )
   port map (
      CO =&gt; CO,         -- 8-bit output: Carry-out
      O =&gt; O,           -- 8-bit output: Carry chain XOR data out
      CI =&gt; CI,         -- 1-bit input: Lower Carry-In
      CI_TOP =&gt; CI_TOP, -- 1-bit input: Upper Carry-In
      DI =&gt; DI,         -- 8-bit input: Carry-MUX data in
      S =&gt; S            -- 8-bit input: Carry-mux select
   );

   -- End of CARRY8_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Two input AND gate implemented in place of a CLB Latch (AND2B1L)" treetype="template">
--   AND2B1L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (AND2B1L_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- AND2B1L: Two input AND gate implemented in place of a CLB Latch
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   AND2B1L_inst : AND2B1L
   generic map (
      IS_SRI_INVERTED =&gt; '0'  -- Optional inversion for SRI
   )
   port map (
      O =&gt; O,     -- 1-bit output: AND gate output
      DI =&gt; DI,   -- 1-bit input: Data input connected to LUT logic
      SRI =&gt; SRI  -- 1-bit input: External CLB data
   );

   -- End of AND2B1L_inst instantiation
					</Template>
					<Template label="Two input OR gate implemented in place of a CLB Latch (OR2L)" treetype="template">
--    OR2L     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OR2L_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OR2L: Two input OR gate implemented in place of a CLB Latch
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OR2L_inst : OR2L
   generic map (
      IS_SRI_INVERTED =&gt; '0'  -- Optional inversion for SRI
   )
   port map (
      O =&gt; O,     -- 1-bit output: OR gate output
      DI =&gt; DI,   -- 1-bit input: Data input connected to LUT logic
      SRI =&gt; SRI  -- 1-bit input: External CLB data
   );

   -- End of OR2L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUT" treetype="folder">
					<Template label="1-Bit Look-Up Table (LUT1)" treetype="template">
--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-Bit Look-Up Table
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; X"0"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0  -- 1-bit input: LUT
   );

   -- End of LUT1_inst instantiation
					</Template>
					<Template label="2-Bit Look-Up Table (LUT2)" treetype="template">
--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-Bit Look-Up Table
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1  -- 1-bit input: LUT
   );

   -- End of LUT2_inst instantiation
					</Template>
					<Template label="3-Bit Look-Up Table (LUT3)" treetype="template">
--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-Bit Look-Up Table
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2  -- 1-bit input: LUT
   );

   -- End of LUT3_inst instantiation
					</Template>
					<Template label="4-Bit Look-Up Table (LUT4)" treetype="template">
--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT4_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-Bit Look-Up Table
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3  -- 1-bit input: LUT
   );

   -- End of LUT4_inst instantiation
					</Template>
					<Template label="5-Bit Look-Up Table (LUT5)" treetype="template">
--    LUT5     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT5_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5: 5-Bit Look-Up Table
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_inst : LUT5
   generic map (
      INIT =&gt; X"00000000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3, -- 1-bit input: LUT
      I4 =&gt; I4  -- 1-bit input: LUT
   );

   -- End of LUT5_inst instantiation
					</Template>
					<Template label="5-input Dynamically Reconfigurable Look-Up Table (LUT) (CFGLUT5)" treetype="template">
--   CFGLUT5   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CFGLUT5_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CFGLUT5: 5-input Dynamically Reconfigurable Look-Up Table (LUT)
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   CFGLUT5_inst : CFGLUT5
   generic map (
      INIT =&gt; X"00000000",    -- Initial logic function
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      CDO =&gt; CDO, -- 1-bit output: Reconfiguration cascade
      O5 =&gt; O5,   -- 1-bit output: 4-LUT
      O6 =&gt; O6,   -- 1-bit output: 5-LUT
      CDI =&gt; CDI, -- 1-bit input: Reconfiguration data
      CE =&gt; CE,   -- 1-bit input: Reconfiguration enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      -- LUT Inputs inputs: Logic inputs
      I0 =&gt; I0,
      I1 =&gt; I1,
      I2 =&gt; I2,
      I3 =&gt; I3,
      I4 =&gt; I4 
   );

   -- End of CFGLUT5_inst instantiation
					</Template>
					<Template label="6-Bit Look-Up Table (LUT6)" treetype="template">
--    LUT6     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LUT6_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6: 6-Bit Look-Up Table
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_inst : LUT6
   generic map (
      INIT =&gt; X"0000000000000000"  -- Logic function
   )
   port map (
      O =&gt; O,   -- 1-bit output: LUT
      I0 =&gt; I0, -- 1-bit input: LUT
      I1 =&gt; I1, -- 1-bit input: LUT
      I2 =&gt; I2, -- 1-bit input: LUT
      I3 =&gt; I3, -- 1-bit input: LUT
      I4 =&gt; I4, -- 1-bit input: LUT
      I5 =&gt; I5  -- 1-bit input: LUT
   );

   -- End of LUT6_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUTRAM" treetype="folder">
					<Template label="64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM) (RAM64X8SW)" treetype="template">
--  RAM64X8SW  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAM64X8SW_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X8SW: 64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM)
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X8SW_inst : RAM64X8SW
   generic map (
      INIT_A =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 7
      INIT_B =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 6
      INIT_C =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 5
      INIT_D =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 4
      INIT_E =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 3
      INIT_F =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 2
      INIT_G =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 1
      INIT_H =&gt; X"0000000000000000", -- Initial contents of the RAM for Bit 0
      IS_WCLK_INVERTED =&gt; '0'        -- Optional inversion for WCLK
   )
   port map (
      O =&gt; O,       -- 8-bit data output
      A =&gt; A,       -- 6-bit address input
      D =&gt; D,       -- 1-bit input: Write data input
      WCLK =&gt; WCLK, -- 1-bit input: Write clock input
      WE =&gt; WE,     -- 1-bit input: Write enable input
      WSEL =&gt; WSEL  -- 3-bit write select
   );

   -- End of RAM64X8SW_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUXF" treetype="folder">
					<Template label="CLB MUX to connect two LUT6's Together (MUXF7)" treetype="template">
--    MUXF7    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF7_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7: CLB MUX to connect two LUT6's Together
   --        Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_inst : MUXF7
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to LUT6 output
      I1 =&gt; I1, -- 1-bit input: Connect to LUT6 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF7_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF7's Together (MUXF8)" treetype="template">
--    MUXF8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF8_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8: CLB MUX to connect two MUXF7's Together
   --        Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_inst : MUXF8
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to MUXF7 output
      I1 =&gt; I1, -- 1-bit input: Connect to MUXF7 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF8_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF8's Together (MUXF9)" treetype="template">
--    MUXF9    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MUXF9_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF9: CLB MUX to connect two MUXF8's Together
   --        Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MUXF9_inst : MUXF9
   port map (
      O =&gt; O,   -- 1-bit output: Output of MUX
      I0 =&gt; I0, -- 1-bit input: Connect to MUXF8 output
      I1 =&gt; I1, -- 1-bit input: Connect to MUXF8 output
      S =&gt; S    -- 1-bit input: Input select to MUX
   );

   -- End of MUXF9_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="16-Bit Shift Register Look-Up Table (LUT) (SRL16E)" treetype="template">
--   SRL16E    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SRL16E_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRL16E: 16-Bit Shift Register Look-Up Table (LUT)
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   SRL16E_inst : SRL16E
   generic map (
      INIT =&gt; X"0000",        -- Initial contents of shift register
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: SRL Data
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      D =&gt; D,     -- 1-bit input: SRL Data
      -- Depth Selection inputs: A0-A3 select SRL depth
      A0 =&gt; A0,
      A1 =&gt; A1,
      A2 =&gt; A2,
      A3 =&gt; A3 
   );

   -- End of SRL16E_inst instantiation
					</Template>
					<Template label="32-Bit Shift Register Look-Up Table (LUT) (SRLC32E)" treetype="template">
--   SRLC32E   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (SRLC32E_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRLC32E: 32-Bit Shift Register Look-Up Table (LUT)
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   SRLC32E_inst : SRLC32E
   generic map (
      INIT =&gt; X"00000000",    -- Initial contents of shift register
      IS_CLK_INVERTED =&gt; '0'  -- Optional inversion for CLK
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: SRL Data
      Q31 =&gt; Q31, -- 1-bit output: SRL Cascade Data
      A =&gt; A,     -- 5-bit input: Selects SRL depth
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLK =&gt; CLK, -- 1-bit input: Clock
      D =&gt; D      -- 1-bit input: SRL Data
   );

   -- End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLOCK" treetype="folder">
				<SubFolder label="BUFFER" treetype="folder">
					<Template label="A high-fanout buffer for low-skew distribution of the PS Clock signals (BUFG_PS)" treetype="template">
--   BUFG_PS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_PS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_PS: A high-fanout buffer for low-skew distribution of the PS Clock signals
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_PS_inst : BUFG_PS
   port map (
      O =&gt; O, -- 1-bit output: Clock buffer output
      I =&gt; I  -- 1-bit input: Clock buffer input
   );

   -- End of BUFG_PS_inst instantiation
					</Template>
					<Template label="Clock Buffer Driven by Gigabit Transceiver (BUFG_GT)" treetype="template">
--   BUFG_GT   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_GT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_GT: Clock Buffer Driven by Gigabit Transceiver
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_GT_inst : BUFG_GT
   port map (
      O =&gt; O,             -- 1-bit output: Buffer
      CE =&gt; CE,           -- 1-bit input: Buffer enable
      CEMASK =&gt; CEMASK,   -- 1-bit input: CE Mask
      CLR =&gt; CLR,         -- 1-bit input: Asynchronous clear
      CLRMASK =&gt; CLRMASK, -- 1-bit input: CLR Mask
      DIV =&gt; DIV,         -- 3-bit input: Dynamic divide Value
      I =&gt; I              -- 1-bit input: Buffer
   );

   -- End of BUFG_GT_inst instantiation
					</Template>
					<Template label="General Clock Buffer (BUFG)" treetype="template">
--    BUFG     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG: General Clock Buffer
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_inst : BUFG
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFG_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
--   BUFGCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE: General Clock Buffer with Clock Enable
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_inst : BUFGCE
   generic map (
      CE_TYPE =&gt; "SYNC",     -- ASYNC, SYNC
      IS_CE_INVERTED =&gt; '0', -- Programmable inversion on CE
      IS_I_INVERTED =&gt; '0'   -- Programmable inversion on I
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer
      CE =&gt; CE, -- 1-bit input: Buffer enable
      I =&gt; I    -- 1-bit input: Buffer
   );

   -- End of BUFGCE_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Divide (BUFGCE_DIV)" treetype="template">
-- BUFGCE_DIV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_DIV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_DIV: General Clock Buffer with Divide Function
   --             Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_DIV_inst : BUFGCE_DIV
   generic map (
      BUFGCE_DIVIDE =&gt; 1,     -- 1-8
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CE_INVERTED =&gt; '0',  -- Optional inversion for CE
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_I_INVERTED =&gt; '0'    -- Optional inversion for I
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer
      CE =&gt; CE,   -- 1-bit input: Buffer enable
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      I =&gt; I      -- 1-bit input: Buffer
   );

   -- End of BUFGCE_DIV_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
--  BUFGCE_1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_1: General Clock Buffer with Clock Enable and Output State 1
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_1_inst : BUFGCE_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock buffer active-High enable
      I =&gt; I    -- 1-bit input: Clock input
   );

   -- End of BUFGCE_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="CLOCK_SYNC" treetype="folder">
					<Template label="Synchronizer for BUFG_GT Control Signals (BUFG_GT_SYNC)" treetype="template">
-- BUFG_GT_SYNC : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFG_GT_SYNC_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG_GT_SYNC: Synchronizer for BUFG_GT Control Signals
   --               Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_GT_SYNC_inst : BUFG_GT_SYNC
   port map (
      CESYNC =&gt; CESYNC,   -- 1-bit output: Synchronized CE
      CLRSYNC =&gt; CLRSYNC, -- 1-bit output: Synchronized CLR
      CE =&gt; CE,           -- 1-bit input: Asynchronous enable
      CLK =&gt; CLK,         -- 1-bit input: Clock
      CLR =&gt; CLR          -- 1-bit input: Asynchronous clear
   );

   -- End of BUFG_GT_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUX" treetype="folder">
					<Template label="2-to-1 General Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
-- BUFGMUX_CTRL : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_CTRL: 2-to-1 General Clock MUX Buffer
   --               Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL_inst : BUFGMUX_CTRL
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="General Clock Control Buffer (BUFGCTRL)" treetype="template">
--  BUFGCTRL   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCTRL: General Clock Control Buffer
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCTRL_inst : BUFGCTRL
   generic map (
      INIT_OUT =&gt; 0,              -- Initial value of BUFGCTRL output, 0-1
      PRESELECT_I0 =&gt; FALSE,      -- BUFGCTRL output uses I0 input, FALSE, TRUE
      PRESELECT_I1 =&gt; FALSE,      -- BUFGCTRL output uses I1 input, FALSE, TRUE
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CE0_INVERTED =&gt; '0',     -- Optional inversion for CE0
      IS_CE1_INVERTED =&gt; '0',     -- Optional inversion for CE1
      IS_I0_INVERTED =&gt; '0',      -- Optional inversion for I0
      IS_I1_INVERTED =&gt; '0',      -- Optional inversion for I1
      IS_IGNORE0_INVERTED =&gt; '0', -- Optional inversion for IGNORE0
      IS_IGNORE1_INVERTED =&gt; '0', -- Optional inversion for IGNORE1
      IS_S0_INVERTED =&gt; '0',      -- Optional inversion for S0
      IS_S1_INVERTED =&gt; '0'       -- Optional inversion for S1
   )
   port map (
      O =&gt; O,             -- 1-bit output: Clock output
      CE0 =&gt; CE0,         -- 1-bit input: Clock enable input for I0
      CE1 =&gt; CE1,         -- 1-bit input: Clock enable input for I1
      I0 =&gt; I0,           -- 1-bit input: Primary clock
      I1 =&gt; I1,           -- 1-bit input: Secondary clock
      IGNORE0 =&gt; IGNORE0, -- 1-bit input: Clock ignore input for I0
      IGNORE1 =&gt; IGNORE1, -- 1-bit input: Clock ignore input for I1
      S0 =&gt; S0,           -- 1-bit input: Clock select for I0
      S1 =&gt; S1            -- 1-bit input: Clock select for I1
   );

   -- End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer (BUFGMUX)" treetype="template">
--   BUFGMUX   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX: General Clock Mux Buffer
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_inst : BUFGMUX
   generic map (
      CLK_SEL_TYPE =&gt; "SYNC"  -- ASYNC, SYNC
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
--  BUFGMUX_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_1: General Clock Mux Buffer with Output State 1
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1_inst : BUFGMUX_1
   generic map (
      CLK_SEL_TYPE =&gt; "SYNC"  -- ASYNC, SYNC
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME3_ADV)" treetype="template">
-- MMCME3_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME3_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME3_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   --             Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MMCME3_ADV_inst : MMCME3_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",        -- Jitter programming (HIGH, LOW, OPTIMIZED)
      CLKFBOUT_MULT_F =&gt; 5.0,          -- Multiply value for all CLKOUT (2.000-64.000)
      CLKFBOUT_PHASE =&gt; 0.0,           -- Phase offset in degrees of CLKFB (-360.000-360.000)
      -- CLKIN_PERIOD: Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      CLKOUT0_DIVIDE_F =&gt; 1.0,         -- Divide amount for CLKOUT0 (1.000-128.000)
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      -- CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_CASCADE =&gt; "FALSE",
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      COMPENSATION =&gt; "AUTO",          -- AUTO, BUF_IN, EXTERNAL, INTERNAL, ZHOLD
      DIVCLK_DIVIDE =&gt; 1,              -- Master division value (1-106)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0',      -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',       -- Optional inversion for CLKIN1
      IS_CLKIN2_INVERTED =&gt; '0',       -- Optional inversion for CLKIN2
      IS_CLKINSEL_INVERTED =&gt; '0',     -- Optional inversion for CLKINSEL
      IS_PSEN_INVERTED =&gt; '0',         -- Optional inversion for PSEN
      IS_PSINCDEC_INVERTED =&gt; '0',     -- Optional inversion for PSINCDEC
      IS_PWRDWN_INVERTED =&gt; '0',       -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',          -- Optional inversion for RST
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; "FALSE",         -- Delays DONE until MMCM is locked (FALSE, TRUE)
      -- Spread Spectrum: Spread Spectrum Attributes
      SS_EN =&gt; "FALSE",                -- Enables spread spectrum (FALSE, TRUE)
      SS_MODE =&gt; "CENTER_HIGH",        -- CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      SS_MOD_PERIOD =&gt; 10000,          -- Spread spectrum modulation period (ns) (4000-40000)
      -- USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      CLKFBOUT_USE_FINE_PS =&gt; "FALSE",
      CLKOUT0_USE_FINE_PS =&gt; "FALSE",
      CLKOUT1_USE_FINE_PS =&gt; "FALSE",
      CLKOUT2_USE_FINE_PS =&gt; "FALSE",
      CLKOUT3_USE_FINE_PS =&gt; "FALSE",
      CLKOUT4_USE_FINE_PS =&gt; "FALSE",
      CLKOUT5_USE_FINE_PS =&gt; "FALSE",
      CLKOUT6_USE_FINE_PS =&gt; "FALSE" 
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,           -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,         -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,           -- 1-bit output: Primary clock
      CLKOUT1B =&gt; CLKOUT1B,         -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,           -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,         -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,           -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,         -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,           -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,           -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,           -- 1-bit output: CLKOUT6
      -- DRP Ports outputs: Dynamic reconfiguration ports
      DO =&gt; DO,                     -- 16-bit output: DRP data
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP ready
      -- Dynamic Phase Shift Ports outputs: Ports used for dynamic phase shifting of the outputs
      PSDONE =&gt; PSDONE,             -- 1-bit output: Phase shift done
      -- Feedback outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,         -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB,       -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports outputs: MMCM status ports
      CDDCDONE =&gt; CDDCDONE,         -- 1-bit output: Clock dynamic divide done
      CLKFBSTOPPED =&gt; CLKFBSTOPPED, -- 1-bit output: Feedback clock stopped
      CLKINSTOPPED =&gt; CLKINSTOPPED, -- 1-bit output: Input clock stopped
      LOCKED =&gt; LOCKED,             -- 1-bit output: LOCK
      CDDCREQ =&gt; CDDCREQ,           -- 1-bit input: Request to dynamic divide clock
      -- Clock Inputs inputs: Clock inputs
      CLKIN1 =&gt; CLKIN1,             -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,             -- 1-bit input: Secondary clock
      -- Control Ports inputs: MMCM control ports
      CLKINSEL =&gt; CLKINSEL,         -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,             -- 1-bit input: Power-down
      RST =&gt; RST,                   -- 1-bit input: Reset
      -- DRP Ports inputs: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable
      DI =&gt; DI,                     -- 16-bit input: DRP data
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- Dynamic Phase Shift Ports inputs: Ports used for dynamic phase shifting of the outputs
      PSCLK =&gt; PSCLK,               -- 1-bit input: Phase shift clock
      PSEN =&gt; PSEN,                 -- 1-bit input: Phase shift enable
      PSINCDEC =&gt; PSINCDEC,         -- 1-bit input: Phase shift increment/decrement
      -- Feedback inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN            -- 1-bit input: Feedback clock
   );

   -- End of MMCME3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME4_ADV)" treetype="template">
-- MMCME4_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME4_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME4_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   --             Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MMCME4_ADV_inst : MMCME4_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",        -- Jitter programming
      CLKFBOUT_MULT_F =&gt; 5.0,          -- Multiply value for all CLKOUT
      CLKFBOUT_PHASE =&gt; 0.0,           -- Phase offset in degrees of CLKFB
      CLKFBOUT_USE_FINE_PS =&gt; "FALSE", -- Fine phase shift enable (TRUE/FALSE)
      CLKIN1_PERIOD =&gt; 0.0,            -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN2_PERIOD =&gt; 0.0,            -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE_F =&gt; 1.0,         -- Divide amount for CLKOUT0
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT0
      CLKOUT0_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT0
      CLKOUT0_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT1_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT1_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT1_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT2_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT2_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT2_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT3_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT3_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT3_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT4_CASCADE =&gt; "FALSE",      -- Divide amount for CLKOUT (1-128)
      CLKOUT4_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT4_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT4_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT5_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT5_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT5_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      CLKOUT6_DIVIDE =&gt; 1,             -- Divide amount for CLKOUT (1-128)
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,       -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT6_PHASE =&gt; 0.0,            -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT6_USE_FINE_PS =&gt; "FALSE",  -- Fine phase shift enable (TRUE/FALSE)
      COMPENSATION =&gt; "AUTO",          -- Clock input compensation
      DIVCLK_DIVIDE =&gt; 1,              -- Master division value
      IS_CLKFBIN_INVERTED =&gt; '0',      -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',       -- Optional inversion for CLKIN1
      IS_CLKIN2_INVERTED =&gt; '0',       -- Optional inversion for CLKIN2
      IS_CLKINSEL_INVERTED =&gt; '0',     -- Optional inversion for CLKINSEL
      IS_PSEN_INVERTED =&gt; '0',         -- Optional inversion for PSEN
      IS_PSINCDEC_INVERTED =&gt; '0',     -- Optional inversion for PSINCDEC
      IS_PWRDWN_INVERTED =&gt; '0',       -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',          -- Optional inversion for RST
      REF_JITTER1 =&gt; 0.0,              -- Reference input jitter in UI (0.000-0.999).
      REF_JITTER2 =&gt; 0.0,              -- Reference input jitter in UI (0.000-0.999).
      SS_EN =&gt; "FALSE",                -- Enables spread spectrum
      SS_MODE =&gt; "CENTER_HIGH",        -- Spread spectrum frequency deviation and the spread type
      SS_MOD_PERIOD =&gt; 10000,          -- Spread spectrum modulation period (ns)
      STARTUP_WAIT =&gt; "FALSE"          -- Delays DONE until MMCM is locked
   )
   port map (
      CDDCDONE =&gt; CDDCDONE,         -- 1-bit output: Clock dynamic divide done
      CLKFBOUT =&gt; CLKFBOUT,         -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB,       -- 1-bit output: Inverted CLKFBOUT
      CLKFBSTOPPED =&gt; CLKFBSTOPPED, -- 1-bit output: Feedback clock stopped
      CLKINSTOPPED =&gt; CLKINSTOPPED, -- 1-bit output: Input clock stopped
      CLKOUT0 =&gt; CLKOUT0,           -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,         -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,           -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,         -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,           -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,         -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,           -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,         -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,           -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,           -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,           -- 1-bit output: CLKOUT6
      DO =&gt; DO,                     -- 16-bit output: DRP data output
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP ready
      LOCKED =&gt; LOCKED,             -- 1-bit output: LOCK
      PSDONE =&gt; PSDONE,             -- 1-bit output: Phase shift done
      CDDCREQ =&gt; CDDCREQ,           -- 1-bit input: Request to dynamic divide clock
      CLKFBIN =&gt; CLKFBIN,           -- 1-bit input: Feedback clock
      CLKIN1 =&gt; CLKIN1,             -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,             -- 1-bit input: Secondary clock
      CLKINSEL =&gt; CLKINSEL,         -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable
      DI =&gt; DI,                     -- 16-bit input: DRP data input
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      PSCLK =&gt; PSCLK,               -- 1-bit input: Phase shift clock
      PSEN =&gt; PSEN,                 -- 1-bit input: Phase shift enable
      PSINCDEC =&gt; PSINCDEC,         -- 1-bit input: Phase shift increment/decrement
      PWRDWN =&gt; PWRDWN,             -- 1-bit input: Power-down
      RST =&gt; RST                    -- 1-bit input: Reset
   );

   -- End of MMCME4_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE3_ADV)" treetype="template">
--  PLLE3_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE3_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE3_ADV: Advanced Phase-Locked Loop (PLL)
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PLLE3_ADV_inst : PLLE3_ADV
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT, (1-19)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB, (-360.000-360.000)
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0 (1-128)
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0 (0.001-0.999)
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0 (-360.000-360.000)
      -- CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1 (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1 (0.001-0.999)
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1 (-360.000-360.000)
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      COMPENSATION =&gt; "AUTO",     -- AUTO, BUF_IN, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value, (1-15)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      -- DRP Ports outputs: Dynamic reconfiguration ports
      DO =&gt; DO,                   -- 16-bit output: DRP data
      DRDY =&gt; DRDY,               -- 1-bit output: DRP ready
      -- Feedback Clocks outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      -- Control Ports inputs: PLL control ports
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST,                 -- 1-bit input: Reset
      -- DRP Ports inputs: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,             -- 7-bit input: DRP address
      DCLK =&gt; DCLK,               -- 1-bit input: DRP clock
      DEN =&gt; DEN,                 -- 1-bit input: DRP enable
      DI =&gt; DI,                   -- 16-bit input: DRP data
      DWE =&gt; DWE,                 -- 1-bit input: DRP write enable
      -- Feedback Clocks inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN          -- 1-bit input: Feedback clock
   );

   -- End of PLLE3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE4_ADV)" treetype="template">
--  PLLE4_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE4_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE4_ADV: Advanced Phase-Locked Loop (PLL)
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PLLE4_ADV_inst : PLLE4_ADV
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY
      COMPENSATION =&gt; "AUTO",     -- Clock input compensation
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked
   )
   port map (
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      DO =&gt; DO,                   -- 16-bit output: DRP data output
      DRDY =&gt; DRDY,               -- 1-bit output: DRP ready
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKFBIN =&gt; CLKFBIN,         -- 1-bit input: Feedback clock
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      DADDR =&gt; DADDR,             -- 7-bit input: DRP address
      DCLK =&gt; DCLK,               -- 1-bit input: DRP clock
      DEN =&gt; DEN,                 -- 1-bit input: DRP enable
      DI =&gt; DI,                   -- 16-bit input: DRP data input
      DWE =&gt; DWE,                 -- 1-bit input: DRP write enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST                  -- 1-bit input: Reset
   );

   -- End of PLLE4_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE4_BASE)" treetype="template">
-- PLLE4_BASE  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE4_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE4_BASE: Advanced Phase-Locked Loop (PLL)
   --             Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PLLE4_BASE_inst : PLLE4_BASE
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked
   )
   port map (
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKFBIN =&gt; CLKFBIN,         -- 1-bit input: Feedback clock
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST                  -- 1-bit input: Reset
   );

   -- End of PLLE4_BASE_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME3_BASE)" treetype="template">
-- MMCME3_BASE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME3_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME3_BASE: Base Mixed Mode Clock Manager (MMCM)
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MMCME3_BASE_inst : MMCME3_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",   -- Jitter programming (HIGH, LOW, OPTIMIZED)
      CLKFBOUT_MULT_F =&gt; 5.0,     -- Multiply value for all CLKOUT (2.000-64.000)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB (-360.000-360.000)
      CLKIN1_PERIOD =&gt; 0.0,       -- Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE_F =&gt; 1.0,    -- Divide amount for CLKOUT0 (1.000-128.000)
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      -- CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT4_CASCADE =&gt; "FALSE", -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value (1-106)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',  -- Optional inversion for CLKIN1
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER1 =&gt; 0.0,         -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,     -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,   -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,     -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,   -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,     -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,   -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,     -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,   -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,     -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,     -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,     -- 1-bit output: CLKOUT6
      -- Feedback outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,   -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB, -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports outputs: MMCM status ports
      LOCKED =&gt; LOCKED,       -- 1-bit output: LOCK
      -- Clock Inputs inputs: Clock input
      CLKIN1 =&gt; CLKIN1,       -- 1-bit input: Clock
      -- Control Ports inputs: MMCM control ports
      PWRDWN =&gt; PWRDWN,       -- 1-bit input: Power-down
      RST =&gt; RST,             -- 1-bit input: Reset
      -- Feedback inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN      -- 1-bit input: Feedback clock
   );

   -- End of MMCME3_BASE_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME4_BASE)" treetype="template">
-- MMCME4_BASE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME4_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME4_BASE: Base Mixed Mode Clock Manager (MMCM)
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MMCME4_BASE_inst : MMCME4_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",   -- Jitter programming
      CLKFBOUT_MULT_F =&gt; 5.0,     -- Multiply value for all CLKOUT
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB
      CLKIN1_PERIOD =&gt; 0.0,       -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKOUT0_DIVIDE_F =&gt; 1.0,    -- Divide amount for CLKOUT0
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT2_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT2_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT3_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT3_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT4_CASCADE =&gt; "FALSE", -- Divide amount for CLKOUT (1-128)
      CLKOUT4_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT4_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT5_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT5_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT6_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT (1-128)
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT6_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT outputs (-360.000-360.000).
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN1_INVERTED =&gt; '0',  -- Optional inversion for CLKIN1
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER1 =&gt; 0.0,         -- Reference input jitter in UI (0.000-0.999).
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until MMCM is locked
   )
   port map (
      CLKFBOUT =&gt; CLKFBOUT,   -- 1-bit output: Feedback clock pin to the MMCM
      CLKFBOUTB =&gt; CLKFBOUTB, -- 1-bit output: Inverted CLKFBOUT
      CLKOUT0 =&gt; CLKOUT0,     -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,   -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,     -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,   -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,     -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,   -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,     -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,   -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,     -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,     -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,     -- 1-bit output: CLKOUT6
      LOCKED =&gt; LOCKED,       -- 1-bit output: LOCK
      CLKFBIN =&gt; CLKFBIN,     -- 1-bit input: Feedback clock pin to the MMCM
      CLKIN1 =&gt; CLKIN1,       -- 1-bit input: Primary clock
      PWRDWN =&gt; PWRDWN,       -- 1-bit input: Power-down
      RST =&gt; RST              -- 1-bit input: Reset
   );

   -- End of MMCME4_BASE_inst instantiation
					</Template>
					<Template label="Base Phase-Locked Loop (PLL) (PLLE3_BASE)" treetype="template">
-- PLLE3_BASE  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE3_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE3_BASE: Base Phase-Locked Loop (PLL)
   --             Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PLLE3_BASE_inst : PLLE3_BASE
   generic map (
      CLKFBOUT_MULT =&gt; 5,         -- Multiply value for all CLKOUT, (1-19)
      CLKFBOUT_PHASE =&gt; 0.0,      -- Phase offset in degrees of CLKFB, (-360.000-360.000)
      CLKIN_PERIOD =&gt; 0.0,        -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      CLKOUT0_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT0 (1-128)
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT0 (0.001-0.999)
      CLKOUT0_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT0 (-360.000-360.000)
      -- CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      CLKOUT1_DIVIDE =&gt; 1,        -- Divide amount for CLKOUT1 (1-128)
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,  -- Duty cycle for CLKOUT1 (0.001-0.999)
      CLKOUT1_PHASE =&gt; 0.0,       -- Phase offset for CLKOUT1 (-360.000-360.000)
      CLKOUTPHY_MODE =&gt; "VCO_2X", -- Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      DIVCLK_DIVIDE =&gt; 1,         -- Master division value, (1-15)
      -- Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      IS_CLKFBIN_INVERTED =&gt; '0', -- Optional inversion for CLKFBIN
      IS_CLKIN_INVERTED =&gt; '0',   -- Optional inversion for CLKIN
      IS_PWRDWN_INVERTED =&gt; '0',  -- Optional inversion for PWRDWN
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REF_JITTER =&gt; 0.0,          -- Reference input jitter in UI (0.000-0.999)
      STARTUP_WAIT =&gt; "FALSE"     -- Delays DONE until PLL is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs outputs: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,         -- 1-bit output: General Clock output
      CLKOUT0B =&gt; CLKOUT0B,       -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,         -- 1-bit output: General Clock output
      CLKOUT1B =&gt; CLKOUT1B,       -- 1-bit output: Inverted CLKOUT1
      CLKOUTPHY =&gt; CLKOUTPHY,     -- 1-bit output: Bitslice clock
      -- Feedback Clocks outputs: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,       -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,           -- 1-bit output: LOCK
      CLKIN =&gt; CLKIN,             -- 1-bit input: Input clock
      -- Control Ports inputs: PLL control ports
      CLKOUTPHYEN =&gt; CLKOUTPHYEN, -- 1-bit input: CLKOUTPHY enable
      PWRDWN =&gt; PWRDWN,           -- 1-bit input: Power-down
      RST =&gt; RST,                 -- 1-bit input: Reset
      -- Feedback Clocks inputs: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN          -- 1-bit input: Feedback clock
   );

   -- End of PLLE3_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CONFIGURATION" treetype="folder">
				<SubFolder label="BSCAN" treetype="folder">
					<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
--   BSCANE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BSCANE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BSCANE2: Boundary-Scan User Instruction
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BSCANE2_inst : BSCANE2
   generic map (
      JTAG_CHAIN =&gt; 1  -- Value for USER command
   )
   port map (
      CAPTURE =&gt; CAPTURE, -- 1-bit output: CAPTURE output from TAP controller.
      DRCK =&gt; DRCK,       -- 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                          -- SHIFT are asserted.

      RESET =&gt; RESET,     -- 1-bit output: Reset output for TAP controller.
      RUNTEST =&gt; RUNTEST, -- 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      SEL =&gt; SEL,         -- 1-bit output: USER instruction active output.
      SHIFT =&gt; SHIFT,     -- 1-bit output: SHIFT output from TAP controller.
      TCK =&gt; TCK,         -- 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      TDI =&gt; TDI,         -- 1-bit output: Test Data Input (TDI) output from TAP controller.
      TMS =&gt; TMS,         -- 1-bit output: Test Mode Select output. Fabric connection to TAP.
      UPDATE =&gt; UPDATE,   -- 1-bit output: UPDATE output from TAP controller
      TDO =&gt; TDO          -- 1-bit input: Test Data Output (TDO) input for USER function.
   );

   -- End of BSCANE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DNA" treetype="folder">
					<Template label="Device DNA Access Port (DNA_PORTE2)" treetype="template">
-- DNA_PORTE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DNA_PORTE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DNA_PORTE2: Device DNA Access Port
   --             Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   DNA_PORTE2_inst : DNA_PORTE2
   generic map (
      SIM_DNA_VALUE =&gt; X"000000000000000000000000"  -- Specifies a sample 96-bit DNA value for simulation
   )
   port map (
      DOUT =&gt; DOUT,   -- 1-bit output: DNA output data
      CLK =&gt; CLK,     -- 1-bit input: Clock input
      DIN =&gt; DIN,     -- 1-bit input: User data input pin
      READ =&gt; READ,   -- 1-bit input: Active-High load DNA, active-Low read input
      SHIFT =&gt; SHIFT  -- 1-bit input: Active-High shift enable input
   );

   -- End of DNA_PORTE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="EFUSE" treetype="folder">
					<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
--  EFUSE_USR  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (EFUSE_USR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EFUSE_USR: 32-bit non-volatile design ID
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   EFUSE_USR_inst : EFUSE_USR
   generic map (
      SIM_EFUSE_VALUE =&gt; X"00000000"  -- Value of the 32-bit non-volatile value used in simulation
   )
   port map (
      EFUSEUSR =&gt; EFUSEUSR  -- 32-bit output: User eFUSE register value output
   );

   -- End of EFUSE_USR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="ICAP" treetype="folder">
					<Template label="Internal Configuration Access Port (ICAPE3)" treetype="template">
--   ICAPE3    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ICAPE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ICAPE3: Internal Configuration Access Port
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   ICAPE3_inst : ICAPE3
   generic map (
      DEVICE_ID =&gt; X"03628093",      -- Specifies the pre-programmed Device ID value to be used for simulation
                                     -- purposes.
      ICAP_AUTO_SWITCH =&gt; "DISABLE", -- Enable switch ICAP using sync word
      SIM_CFG_FILE_NAME =&gt; "NONE"    -- Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                     -- model
   )
   port map (
      AVAIL =&gt; AVAIL,     -- 1-bit output: Availability status of ICAP
      O =&gt; O,             -- 32-bit output: Configuration data output bus
      PRDONE =&gt; PRDONE,   -- 1-bit output: Indicates completion of Partial Reconfiguration
      PRERROR =&gt; PRERROR, -- 1-bit output: Indicates Error during Partial Reconfiguration
      CLK =&gt; CLK,         -- 1-bit input: Clock input
      CSIB =&gt; CSIB,       -- 1-bit input: Active-Low ICAP enable
      I =&gt; I,             -- 32-bit input: Configuration data input bus
      RDWRB =&gt; RDWRB      -- 1-bit input: Read/Write Select input
   );

   -- End of ICAPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MASTER_JTAG" treetype="folder">
					<Template label="JTAG Port Access (MASTER_JTAG)" treetype="template">
-- MASTER_JTAG : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MASTER_JTAG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MASTER_JTAG: JTAG Port Access
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   MASTER_JTAG_inst : MASTER_JTAG
   port map (
      TDO =&gt; TDO, -- 1-bit output: JTAG TDO output pin
      TCK =&gt; TCK, -- 1-bit input: JTAG TCK input pin
      TDI =&gt; TDI, -- 1-bit input: JTAG TDI input pin
      TMS =&gt; TMS  -- 1-bit input: JTAG TMS input pin
   );

   -- End of MASTER_JTAG_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="STARTUP" treetype="folder">
					<Template label="STARTUP Block (STARTUPE3)" treetype="template">
--  STARTUPE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (STARTUPE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- STARTUPE3: STARTUP Block
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   STARTUPE3_inst : STARTUPE3
   generic map (
      PROG_USR =&gt; "FALSE",  -- Activate program event security feature. Requires encrypted bitstreams.
      SIM_CCLK_FREQ =&gt; 0.0  -- Set the Configuration Clock Frequency (ns) for simulation
   )
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration main clock output
      CFGMCLK =&gt; CFGMCLK,     -- 1-bit output: Configuration internal oscillator clock output
      DI =&gt; DI,               -- 4-bit output: Allow receiving on the D input pin
      EOS =&gt; EOS,             -- 1-bit output: Active-High output signal indicating the End Of Startup
      PREQ =&gt; PREQ,           -- 1-bit output: PROGRAM request to fabric output
      DO =&gt; DO,               -- 4-bit input: Allows control of the D pin output
      DTS =&gt; DTS,             -- 4-bit input: Allows tristate of the D pin
      FCSBO =&gt; FCSBO,         -- 1-bit input: Controls the FCS_B pin for flash access
      FCSBTS =&gt; FCSBTS,       -- 1-bit input: Tristate the FCS_B pin
      GSR =&gt; GSR,             -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port)
      GTS =&gt; GTS,             -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      KEYCLEARB =&gt; KEYCLEARB, -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      PACK =&gt; PACK,           -- 1-bit input: PROGRAM acknowledge input
      USRCCLKO =&gt; USRCCLKO,   -- 1-bit input: User CCLK input
      USRCCLKTS =&gt; USRCCLKTS, -- 1-bit input: User CCLK 3-state enable input
      USRDONEO =&gt; USRDONEO,   -- 1-bit input: User DONE pin output control
      USRDONETS =&gt; USRDONETS  -- 1-bit input: User DONE 3-state enable output
   );

   -- End of STARTUPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="USR_ACCESS" treetype="folder">
					<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
-- USR_ACCESSE2 : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (USR_ACCESSE2_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- USR_ACCESSE2: Configuration Data Access
   --               Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2_inst : USR_ACCESSE2
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration Clock
      DATA =&gt; DATA,           -- 32-bit output: Configuration Data reflecting the contents of the AXSS register
      DATAVALID =&gt; DATAVALID  -- 1-bit output: Active High Data Valid
   );

   -- End of USR_ACCESSE2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="BIDIR_BUFFER" treetype="folder">
					<Template label="Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable (IOBUF_INTERMDISABLE)" treetype="template">
-- IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
--        VHDL         : the following instance declaration needs to be placed
--      instance       : in the body of the design code.  The instance name
--     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations after the
--        code         : "=&gt;" declaration maybe changed to properly reference and
--                     : connect this function to the design.  All inputs and outputs
--                     : must be connected.

--       Library       : In addition to adding the instance declaration, a use
--     declaration     : statement for the UNISIM.vcomponents library needs to be
--         for         : added before the entity declaration.  This library
--       Xilinx        : contains the component declarations for all Xilinx
--     primitives      : primitives and points to the models that will be used
--                     : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_INTERMDISABLE: Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable
   --                      Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_INTERMDISABLE_inst : IOBUF_INTERMDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T                          -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Bidirectional I/O Buffer with Offset Calibration and VREF Tuning (IOBUFE3)" treetype="template">
--   IOBUFE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFE3: Bidirectional I/O Buffer with Offset Calibration and VREF Tuning
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFE3_inst : IOBUFE3
   generic map (
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Buffer inout (connect directly to top-level port)
      OSC =&gt; OSC,                       -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,                 -- 1-bit input: Offset cancellation enable
      T =&gt; T,                           -- 1-bit input: 3-state enable input
      VREF =&gt; VREF                      -- 1-bit input: Vref input from HPIO_VREF
   );

   -- End of IOBUFE3_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
-- IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
--              VHDL              : the following instance declaration needs to be placed
--            instance            : in the body of the design code.  The instance name
--          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations after the
--              code              : "=&gt;" declaration maybe changed to properly reference and
--                                : connect this function to the design.  All inputs and outputs
--                                : must be connected.

--            Library             : In addition to adding the instance declaration, a use
--          declaration           : statement for the UNISIM.vcomponents library needs to be
--              for               : added before the entity declaration.  This library
--             Xilinx             : contains the component declarations for all Xilinx
--           primitives           : primitives and points to the models that will be used
--                                : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable
   --                                 Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst : IOBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                       -- 1-bit output: Buffer diff_n output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Must be tied to a logic '0'
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                     -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,                       -- 1-bit input: 3-state master enable input
      TS =&gt; TS                        -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
-- IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
--          VHDL          : the following instance declaration needs to be placed
--        instance        : in the body of the design code.  The instance name
--      declaration       : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations after the
--          code          : "=&gt;" declaration maybe changed to properly reference and
--                        : connect this function to the design.  All inputs and outputs
--                        : must be connected.

--        Library         : In addition to adding the instance declaration, a use
--      declaration       : statement for the UNISIM.vcomponents library needs to be
--          for           : added before the entity declaration.  This library
--         Xilinx         : contains the component declarations for all Xilinx
--       primitives       : primitives and points to the models that will be used
--                        : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_DCIEN: Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable
   --                         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_DCIEN_inst : IOBUFDS_DIFF_OUT_DCIEN
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                         -- 1-bit output: Buffer diff_n output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Must be tied to a logic '0'
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,                         -- 1-bit input: 3-state master enable input
      TS =&gt; TS                          -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input (IOBUFDS_INTERMDISABLE)" treetype="template">
-- IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--         VHDL          : the following instance declaration needs to be placed
--       instance        : in the body of the design code.  The instance name
--      declaration      : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations after the
--         code          : "=&gt;" declaration maybe changed to properly reference and
--                       : connect this function to the design.  All inputs and outputs
--                       : must be connected.

--        Library        : In addition to adding the instance declaration, a use
--      declaration      : statement for the UNISIM.vcomponents library needs to be
--          for          : added before the entity declaration.  This library
--        Xilinx         : contains the component declarations for all Xilinx
--      primitives       : primitives and points to the models that will be used
--                       : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_INTERMDISABLE: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input
   --                        Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_INTERMDISABLE_inst : IOBUFDS_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- 1-bit input: Input Termination Disable
      IO =&gt; IO,                       -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                     -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T                          -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DCIEN)" treetype="template">
-- IOBUFDS_DCIEN : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the body of the design code.  The instance name
--  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations after the
--     code      : "=&gt;" declaration maybe changed to properly reference and
--               : connect this function to the design.  All inputs and outputs
--               : must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--  primitives   : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DCIEN: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DCIEN_inst : IOBUFDS_DCIEN
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional I/O Buffer with Offset Calibration (IOBUFDSE3)" treetype="template">
--  IOBUFDSE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFDSE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDSE3: Differential Bidirectional I/O Buffer with Offset Calibration
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDSE3_inst : IOBUFDSE3
   generic map (
      DQS_BIAS =&gt; "FALSE",          -- (FALSE, TRUE)
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB,                       -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      OSC =&gt; OSC,                       -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,                 -- 2-bit input: Offset cancellation enable
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDSE3_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer (IOBUFDS)" treetype="template">
--   IOBUFDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS: Differential Input/Output Buffer
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_inst : IOBUFDS
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer output
      I =&gt; I,     -- 1-bit input: Buffer input
      IO =&gt; IO,   -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      T =&gt; T      -- 1-bit input: 3-state enable input
   );

   -- End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer (IOBUFDS_DIFF_OUT)" treetype="template">
-- IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT: Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer
   --                   Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_inst : IOBUFDS_DIFF_OUT
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,     -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,   -- 1-bit output: Buffer diff_n output
      I =&gt; I,     -- 1-bit input: Buffer input
      IO =&gt; IO,   -- 1-bit inout: Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- 1-bit inout: Diff_n inout (connect directly to top-level port)
      TM =&gt; TM,   -- 1-bit input: 3-state master enable input
      TS =&gt; TS    -- 1-bit input: 3-state slave enable input
   );

   -- End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Input/Output Buffer DCI Enable (IOBUF_DCIEN)" treetype="template">
-- IOBUF_DCIEN : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUF_DCIEN_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_DCIEN: Input/Output Buffer DCI Enable
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_DCIEN_inst : IOBUF_DCIEN
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                           -- 1-bit output: Buffer output
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- 1-bit input: DCI Termination Disable
      I =&gt; I,                           -- 1-bit input: Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE,       -- 1-bit input: Buffer disable input, high=disable
      IO =&gt; IO,                         -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T                            -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Input/Output Buffer (IOBUF)" treetype="template">
--    IOBUF    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IOBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF: Input/Output Buffer
   --        Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IOBUF_inst : IOBUF
   port map (
      O =&gt; O,   -- 1-bit output: Buffer output
      I =&gt; I,   -- 1-bit input: Buffer input
      IO =&gt; IO, -- 1-bit inout: Buffer inout (connect directly to top-level port)
      T =&gt; T    -- 1-bit input: 3-state enable input
   );

   -- End of IOBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="BITSLICE" treetype="folder">
					<Template label="BITSLICE_CONTROL (BITSLICE_CONTROL)" treetype="template">
-- BITSLICE_CONTROL : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (BITSLICE_CONTROL_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BITSLICE_CONTROL: BITSLICE_CONTROL for control using Native Mode
   --                   Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   BITSLICE_CONTROL_inst : BITSLICE_CONTROL
   generic map (
      DIV_MODE =&gt; "DIV2",               -- Controller DIV2/DIV4 mode (DIV2, DIV4)
      EN_CLK_TO_EXT_NORTH =&gt; "DISABLE", -- Enable clock forwarding to north
      EN_CLK_TO_EXT_SOUTH =&gt; "DISABLE", -- Enable clock forwarding to south
      EN_DYN_ODLY_MODE =&gt; "FALSE",      -- Enable dynamic output delay mode
      EN_OTHER_NCLK =&gt; "FALSE",         -- Select the NCLK from the other BITSLICE_CONTROL in the nibble
                                        -- (FALSE, TRUE)
      EN_OTHER_PCLK =&gt; "FALSE",         -- Select the PCLK from the other BITSLICE_CONTROL in the nibble
                                        -- (FALSE, TRUE)
      IDLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for input delays
      INV_RXCLK =&gt; "FALSE",             -- Invert clock path from IOB to upper RX bitslice
      ODLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for output delays
      QDLY_VT_TRACK =&gt; "TRUE",          -- Enable VT tracking for clock delays
      READ_IDLE_COUNT =&gt; X"00",         -- Gap count between read bursts for ODT control counter (0-3f)
      REFCLK_SRC =&gt; "PLLCLK",           -- Select the input clock for the delay control (PLLCLK, REFCLK)
      ROUNDING_FACTOR =&gt; 16,            -- Rounding factor in BISC spec (128-8)
      RXGATE_EXTEND =&gt; "FALSE",         -- Reserved for use by MIG Memory Controller. Do Not Change.
      RX_CLK_PHASE_N =&gt; "SHIFT_0",      -- Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                        -- SHIFT_90)
      RX_CLK_PHASE_P =&gt; "SHIFT_0",      -- Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                        -- SHIFT_90)
      RX_GATING =&gt; "DISABLE",           -- ENABLE/DISABLE read DQS gating
      SELF_CALIBRATE =&gt; "ENABLE",       -- Enable BISC of nibble controlled by BITSLICE_CONTROL
      SERIAL_MODE =&gt; "FALSE",           -- Put BITSLICE read paths into serial mode (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE",       -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                        -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TX_GATING =&gt; "DISABLE"            -- ENABLE/DISABLE clock gating in WClkgen
   )
   port map (
      CLK_TO_EXT_NORTH =&gt; CLK_TO_EXT_NORTH,       -- 1-bit output: Inter-byte clock going to north
                                                  -- BITSLICE_CONTROL

      CLK_TO_EXT_SOUTH =&gt; CLK_TO_EXT_SOUTH,       -- 1-bit output: Inter-byte clock going to south
                                                  -- BITSLICE_CONTROL

      DLY_RDY =&gt; DLY_RDY,                         -- 1-bit output: Fixed delay calibration complete
      DYN_DCI =&gt; DYN_DCI,                         -- 7-bit output: Direct control of IOB DCI when using a
                                                  -- memory interface

      NCLK_NIBBLE_OUT =&gt; NCLK_NIBBLE_OUT,         -- 1-bit output: Intra-byte DQS strobes/clock to other
                                                  -- control block

      PCLK_NIBBLE_OUT =&gt; PCLK_NIBBLE_OUT,         -- 1-bit output: Intra-byte DQS strobes/clock to other
                                                  -- control block

      RIU_RD_DATA =&gt; RIU_RD_DATA,                 -- 16-bit output: RIU Output Read data to the controller
      RIU_VALID =&gt; RIU_VALID,                     -- 1-bit output: Last data written has been accepted when High
      RX_BIT_CTRL_OUT0 =&gt; RX_BIT_CTRL_OUT0,       -- 40-bit output: Output bus to Bitslice 0
      RX_BIT_CTRL_OUT1 =&gt; RX_BIT_CTRL_OUT1,       -- 40-bit output: Output bus to Bitslice 1
      RX_BIT_CTRL_OUT2 =&gt; RX_BIT_CTRL_OUT2,       -- 40-bit output: Output bus to Bitslice 2
      RX_BIT_CTRL_OUT3 =&gt; RX_BIT_CTRL_OUT3,       -- 40-bit output: Output bus to Bitslice 3
      RX_BIT_CTRL_OUT4 =&gt; RX_BIT_CTRL_OUT4,       -- 40-bit output: Output bus to Bitslice 4
      RX_BIT_CTRL_OUT5 =&gt; RX_BIT_CTRL_OUT5,       -- 40-bit output: Output bus to Bitslice 5
      RX_BIT_CTRL_OUT6 =&gt; RX_BIT_CTRL_OUT6,       -- 40-bit output: Output bus to Bitslice 6
      TX_BIT_CTRL_OUT0 =&gt; TX_BIT_CTRL_OUT0,       -- 40-bit output: Output bus to Bitslice 0
      TX_BIT_CTRL_OUT1 =&gt; TX_BIT_CTRL_OUT1,       -- 40-bit output: Output bus to Bitslice 1
      TX_BIT_CTRL_OUT2 =&gt; TX_BIT_CTRL_OUT2,       -- 40-bit output: Output bus to Bitslice 2
      TX_BIT_CTRL_OUT3 =&gt; TX_BIT_CTRL_OUT3,       -- 40-bit output: Output bus to Bitslice 3
      TX_BIT_CTRL_OUT4 =&gt; TX_BIT_CTRL_OUT4,       -- 40-bit output: Output bus to Bitslice 4
      TX_BIT_CTRL_OUT5 =&gt; TX_BIT_CTRL_OUT5,       -- 40-bit output: Output bus to Bitslice 5
      TX_BIT_CTRL_OUT6 =&gt; TX_BIT_CTRL_OUT6,       -- 40-bit output: Output bus to Bitslice 6
      TX_BIT_CTRL_OUT_TRI =&gt; TX_BIT_CTRL_OUT_TRI, -- 40-bit output: Output bus to 3-state TX_BITSLICE_TRI
      VTC_RDY =&gt; VTC_RDY,                         -- 1-bit output: PHY calibration is complete
      CLK_FROM_EXT =&gt; CLK_FROM_EXT,               -- 1-bit input: Inter-byte clock coming from north or south
                                                  -- BITSLICE_CONTROL

      EN_VTC =&gt; EN_VTC,                           -- 1-bit input: Enables voltage and temperature compensation
                                                  -- when High

      NCLK_NIBBLE_IN =&gt; NCLK_NIBBLE_IN,           -- 1-bit input: Intra-byte DQS strobes from other/clock
                                                  -- control block

      PCLK_NIBBLE_IN =&gt; PCLK_NIBBLE_IN,           -- 1-bit input: Intra-byte DQS strobes/clock from other
                                                  -- control block

      PHY_RDCS0 =&gt; PHY_RDCS0,                     -- 4-bit input: Rank select
      PHY_RDCS1 =&gt; PHY_RDCS1,                     -- 4-bit input: Rank select
      PHY_RDEN =&gt; PHY_RDEN,                       -- 4-bit input: Read burst enable when using a memory
                                                  -- interface

      PHY_WRCS0 =&gt; PHY_WRCS0,                     -- 4-bit input: Rank select
      PHY_WRCS1 =&gt; PHY_WRCS1,                     -- 4-bit input: Rank select
      PLL_CLK =&gt; PLL_CLK,                         -- 1-bit input: PLL clock input
      REFCLK =&gt; REFCLK,                           -- 1-bit input: Frequency reference clock for delay control
      RIU_ADDR =&gt; RIU_ADDR,                       -- 6-bit input: Address input for RIU
      RIU_CLK =&gt; RIU_CLK,                         -- 1-bit input: System clock from fabric for RIU access
      RIU_NIBBLE_SEL =&gt; RIU_NIBBLE_SEL,           -- 1-bit input: Nibble select to enable RIU read/write
      RIU_WR_DATA =&gt; RIU_WR_DATA,                 -- 16-bit input: RIU Input Write data from the controller
      RIU_WR_EN =&gt; RIU_WR_EN,                     -- 1-bit input: Enables write to RIU when High
      RST =&gt; RST,                                 -- 1-bit input: Asynchronous global reset
      RX_BIT_CTRL_IN0 =&gt; RX_BIT_CTRL_IN0,         -- 40-bit input: Input bus from Bitslice 0
      RX_BIT_CTRL_IN1 =&gt; RX_BIT_CTRL_IN1,         -- 40-bit input: Input bus from Bitslice 1
      RX_BIT_CTRL_IN2 =&gt; RX_BIT_CTRL_IN2,         -- 40-bit input: Input bus from Bitslice 2
      RX_BIT_CTRL_IN3 =&gt; RX_BIT_CTRL_IN3,         -- 40-bit input: Input bus from Bitslice 3
      RX_BIT_CTRL_IN4 =&gt; RX_BIT_CTRL_IN4,         -- 40-bit input: Input bus from Bitslice 4
      RX_BIT_CTRL_IN5 =&gt; RX_BIT_CTRL_IN5,         -- 40-bit input: Input bus from Bitslice 5
      RX_BIT_CTRL_IN6 =&gt; RX_BIT_CTRL_IN6,         -- 40-bit input: Input bus from Bitslice 6
      TBYTE_IN =&gt; TBYTE_IN,                       -- 4-bit input: Output enable for 3-state control
      TX_BIT_CTRL_IN0 =&gt; TX_BIT_CTRL_IN0,         -- 40-bit input: Input bus from Bitslice 0
      TX_BIT_CTRL_IN1 =&gt; TX_BIT_CTRL_IN1,         -- 40-bit input: Input bus from Bitslice 1
      TX_BIT_CTRL_IN2 =&gt; TX_BIT_CTRL_IN2,         -- 40-bit input: Input bus from Bitslice 2
      TX_BIT_CTRL_IN3 =&gt; TX_BIT_CTRL_IN3,         -- 40-bit input: Input bus from Bitslice 3
      TX_BIT_CTRL_IN4 =&gt; TX_BIT_CTRL_IN4,         -- 40-bit input: Input bus from Bitslice 4
      TX_BIT_CTRL_IN5 =&gt; TX_BIT_CTRL_IN5,         -- 40-bit input: Input bus from Bitslice 5
      TX_BIT_CTRL_IN6 =&gt; TX_BIT_CTRL_IN6,         -- 40-bit input: Input bus from Bitslice 6
      TX_BIT_CTRL_IN_TRI =&gt; TX_BIT_CTRL_IN_TRI    -- 40-bit input: Input bus from 3-state TX_BITSLICE_TRI
   );

   -- End of BITSLICE_CONTROL_inst instantiation
					</Template>
					<Template label="Register Interface Unit Selection Block (RIU_OR)" treetype="template">
--   RIU_OR    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RIU_OR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RIU_OR: Register Interface Unit Selection Block
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RIU_OR_inst : RIU_OR
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      RIU_RD_DATA =&gt; RIU_RD_DATA,           -- 16-bit output: RIU data bus to the controller
      RIU_RD_VALID =&gt; RIU_RD_VALID,         -- 1-bit output: Combined RIU read valid signal to the controller
      RIU_RD_DATA_LOW =&gt; RIU_RD_DATA_LOW,   -- 16-bit input: RIU data bus from the controller to the lower
                                            -- nibble BITSLICE_CONTROL

      RIU_RD_DATA_UPP =&gt; RIU_RD_DATA_UPP,   -- 16-bit input: RIU data bus from the controller to the upper
                                            -- nibble BITSLICE_CONTROL

      RIU_RD_VALID_LOW =&gt; RIU_RD_VALID_LOW, -- 1-bit input: RIU_VALID of the lower nibble BITSLICE_CONTROL
      RIU_RD_VALID_UPP =&gt; RIU_RD_VALID_UPP  -- 1-bit input: RIU_VALID of the upper nibble BITSLICE_CONTROL
   );

   -- End of RIU_OR_inst instantiation
					</Template>
					<Template label="RX_BITSLICE (RX_BITSLICE)" treetype="template">
-- RX_BITSLICE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RX_BITSLICE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RX_BITSLICE: RX_BITSLICE for input using Native Mode
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RX_BITSLICE_inst : RX_BITSLICE
   generic map (
      CASCADE =&gt; "FALSE",             -- Enables cascading of IDELAY and ODELAY lines
      DATA_TYPE =&gt; "DATA",            -- Defines what the input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                      -- SERIAL)
      DATA_WIDTH =&gt; 8,                -- Defines the width of the serial-to-parallel converter (4-8)
      DELAY_FORMAT =&gt; "TIME",         -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",          -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,               -- Input delay value setting in ps
      DELAY_VALUE_EXT =&gt; 0,           -- Value of the extended input delay value in ps
      FIFO_SYNC_MODE =&gt; "FALSE",      -- Internal write clock and FIFO_RD_CLK are coming from a common source
      IS_CLK_EXT_INVERTED =&gt; '0',     -- Optional inversion for CLK_EXT
      IS_CLK_INVERTED =&gt; '0',         -- Optional inversion for CLK
      IS_RST_DLY_EXT_INVERTED =&gt; '0', -- Optional inversion for RST_DLY_EXT
      IS_RST_DLY_INVERTED =&gt; '0',     -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',         -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,      -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC",         -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
      UPDATE_MODE_EXT =&gt; "ASYNC"      -- Determines when updates to the extended input delay will take effect
                                      -- (ASYNC, MANUAL, SYNC)
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT,         -- 9-bit output: Counter value to device logic
      CNTVALUEOUT_EXT =&gt; CNTVALUEOUT_EXT, -- 9-bit output: Optional extended (cascaded delay) counter value
                                          -- going to the device logic

      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      FIFO_WRCLK_OUT =&gt; FIFO_WRCLK_OUT,   -- 1-bit output: FIFO source synchronous write clock out to the
                                          -- device logic (currently unsupported, do not connect)

      Q =&gt; Q,                             -- 8-bit output: Registered output data from FIFO
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      CE =&gt; CE,                           -- 1-bit input: Clock enable for IDELAY
      CE_EXT =&gt; CE_EXT,                   -- 1-bit input: Optional extended (cascaded delay) clock enable
      CLK =&gt; CLK,                         -- 1-bit input: Clock used to sample LOAD, CE, INC
      CLK_EXT =&gt; CLK_EXT,                 -- 1-bit input: Optional extended (cascaded delay) clock
      CNTVALUEIN =&gt; CNTVALUEIN,           -- 9-bit input: Counter value from device logic
      CNTVALUEIN_EXT =&gt; CNTVALUEIN_EXT,   -- 9-bit input: Optional extended (cascaded delay) counter value from
                                          -- device logic

      DATAIN =&gt; DATAIN,                   -- 1-bit input: Input signal from IBUF
      EN_VTC =&gt; EN_VTC,                   -- 1-bit input: Enable IDELAYCTRL to keep stable delay over VT
      EN_VTC_EXT =&gt; EN_VTC_EXT,           -- 1-bit input: Optional extended (cascaded delay) to keep stable
                                          -- delay over VT

      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: FIFO read enable
      INC =&gt; INC,                         -- 1-bit input: Increment the current delay tap setting
      INC_EXT =&gt; INC_EXT,                 -- 1-bit input: Optional extended (cascaded delay) increments the
                                          -- current delay tap setting

      LOAD =&gt; LOAD,                       -- 1-bit input: Load the CNTVALUEIN tap setting
      LOAD_EXT =&gt; LOAD_EXT,               -- 1-bit input: Optional extended (cascaded delay) load the
                                          -- CNTVALUEIN_EXT tap setting

      RST =&gt; RST,                         -- 1-bit input: Asynchronous assert, synchronous deassert for
                                          -- RX_BITSLICE ISERDES

      RST_DLY =&gt; RST_DLY,                 -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      RST_DLY_EXT =&gt; RST_DLY_EXT,         -- 1-bit input: Optional extended (cascaded delay) reset delay to
                                          -- DELAY_VALUE_EXT

      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN    -- 40-bit input: Input bus from BITSLICE_CONTROL
   );

   -- End of RX_BITSLICE_inst instantiation
					</Template>
					<Template label="RXTX_BITSLICE (RXTX_BITSLICE)" treetype="template">
-- RXTX_BITSLICE : In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the body of the design code.  The instance name
--  declaration  : (RXTX_BITSLICE_inst) and/or the port declarations after the
--     code      : "=&gt;" declaration maybe changed to properly reference and
--               : connect this function to the design.  All inputs and outputs
--               : must be connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--  primitives   : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RXTX_BITSLICE: RXTX_BITSLICE for bidirectional I/O using Native Mode
   --                Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   RXTX_BITSLICE_inst : RXTX_BITSLICE
   generic map (
      ENABLE_PRE_EMPHASIS =&gt; "FALSE", -- Enable the pre-emphasis
      FIFO_SYNC_MODE =&gt; "FALSE",      -- Internal write clock and FIFO_RD_CLK are coming from a common source
      INIT =&gt; '1',                    -- Defines initial O value
      IS_RX_CLK_INVERTED =&gt; '0',      -- Optional inversion for RX_CLK
      IS_RX_RST_DLY_INVERTED =&gt; '0',  -- Optional inversion for RX_RST_DLY
      IS_RX_RST_INVERTED =&gt; '0',      -- Optional inversion for RX_RST
      IS_TX_CLK_INVERTED =&gt; '0',      -- Optional inversion for TX_CLK
      IS_TX_RST_DLY_INVERTED =&gt; '0',  -- Optional inversion for TX_RST_DLY
      IS_TX_RST_INVERTED =&gt; '0',      -- Optional inversion for TX_RST
      RX_DATA_TYPE =&gt; "DATA",         -- Defines what the RX input pin is carrying (CLOCK, DATA,
                                      -- DATA_AND_CLOCK, SERIAL)
      RX_DATA_WIDTH =&gt; 8,             -- Defines the width of the serial-to-parallel converter (4-8)
      RX_DELAY_FORMAT =&gt; "TIME",      -- Units of the RX DELAY_VALUE (COUNT, TIME)
      RX_DELAY_TYPE =&gt; "FIXED",       -- Set the type of RX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      RX_DELAY_VALUE =&gt; 0,            -- RX Input delay value setting in ps
      RX_REFCLK_FREQUENCY =&gt; 300.0,   -- Specification of the RX reference clock frequency in MHz
                                      -- (200.0-2667.0)
      RX_UPDATE_MODE =&gt; "ASYNC",      -- Determines when updates to the RX delay will take effect (ASYNC,
                                      -- MANUAL, SYNC)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TBYTE_CTL =&gt; "TBYTE_IN",        -- Select between T and TBYTE_IN inputs
      TX_DATA_WIDTH =&gt; 8,             -- Parallel data input width (4-8)
      TX_DELAY_FORMAT =&gt; "TIME",      -- Units of the TX DELAY_VALUE (COUNT, TIME)
      TX_DELAY_TYPE =&gt; "FIXED",       -- Set the type of TX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      TX_DELAY_VALUE =&gt; 0,            -- TX Input delay value setting in ps
      TX_OUTPUT_PHASE_90 =&gt; "FALSE",  -- Delays the output phase by 90-degrees
      TX_REFCLK_FREQUENCY =&gt; 300.0,   -- Specification of the TX reference clock frequency in MHz
                                      -- (200.0-2667.0)
      TX_UPDATE_MODE =&gt; "ASYNC"       -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
   )
   port map (
      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      FIFO_WRCLK_OUT =&gt; FIFO_WRCLK_OUT,   -- 1-bit output: FIFO source synchronous write clock out to the
                                          -- device logic (currently unsupported, do not connect)

      O =&gt; O,                             -- 1-bit output: Serialized output going to output buffer
      Q =&gt; Q,                             -- 8-bit output: Registered output data from FIFO
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: RX Output bus to BITSLICE_CONTROL
      RX_CNTVALUEOUT =&gt; RX_CNTVALUEOUT,   -- 9-bit output: RX Counter value from device logic
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL for TX
      TX_CNTVALUEOUT =&gt; TX_CNTVALUEOUT,   -- 9-bit output: TX Counter value to device logic
      T_OUT =&gt; T_OUT,                     -- 1-bit output: Byte group 3-state output
      D =&gt; D,                             -- 8-bit input: Data from device logic
      DATAIN =&gt; DATAIN,                   -- 1-bit input: Input signal from IOBUF
      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: FIFO read enable
      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: RX Input bus from BITSLICE_CONTROL
      RX_CE =&gt; RX_CE,                     -- 1-bit input: Clock enable for IDELAY
      RX_CLK =&gt; RX_CLK,                   -- 1-bit input: RX Clock used to sample LOAD, CE, INC
      RX_CNTVALUEIN =&gt; RX_CNTVALUEIN,     -- 9-bit input: RX Counter value from device logic
      RX_EN_VTC =&gt; RX_EN_VTC,             -- 1-bit input: RX Enable to keep stable delay over VT
      RX_INC =&gt; RX_INC,                   -- 1-bit input: RX Increment the current delay tap setting
      RX_LOAD =&gt; RX_LOAD,                 -- 1-bit input: RX Load the CNTVALUEIN tap setting
      RX_RST =&gt; RX_RST,                   -- 1-bit input: RX Asynchronous assert, synchronous deassert for
                                          -- RXTX_BITSLICE ISERDES

      RX_RST_DLY =&gt; RX_RST_DLY,           -- 1-bit input: RX Reset the internal DELAY value to DELAY_VALUE
      T =&gt; T,                             -- 1-bit input: Legacy T byte input from device logic
      TBYTE_IN =&gt; TBYTE_IN,               -- 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN,   -- 40-bit input: TX Input bus from BITSLICE_CONTROL
      TX_CE =&gt; TX_CE,                     -- 1-bit input: Clock enable for ODELAY
      TX_CLK =&gt; TX_CLK,                   -- 1-bit input: TX Clock used to sample LOAD, CE, INC
      TX_CNTVALUEIN =&gt; TX_CNTVALUEIN,     -- 9-bit input: TX Counter value from device logic
      TX_EN_VTC =&gt; TX_EN_VTC,             -- 1-bit input: TX Enable to keep stable delay over VT
      TX_INC =&gt; TX_INC,                   -- 1-bit input: TX Increment the current delay tap setting
      TX_LOAD =&gt; TX_LOAD,                 -- 1-bit input: TX Load the CNTVALUEIN tap setting
      TX_RST =&gt; TX_RST,                   -- 1-bit input: TX Asynchronous assert, synchronous deassert for
                                          -- RXTX_BITSLICE OSERDES

      TX_RST_DLY =&gt; TX_RST_DLY            -- 1-bit input: TX Reset the internal DELAY value to DELAY_VALUE
   );

   -- End of RXTX_BITSLICE_inst instantiation
					</Template>
					<Template label="TX_BITSLICE_TRI (TX_BITSLICE_TRI)" treetype="template">
-- TX_BITSLICE_TRI : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (TX_BITSLICE_TRI_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- TX_BITSLICE_TRI: TX_BITSLICE_TRI for tristate using Native Mode
   --                  Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_TRI_inst : TX_BITSLICE_TRI
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel data input width (4-8)
      DELAY_FORMAT =&gt; "TIME",     -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Output delay value setting
      INIT =&gt; '1',                -- Defines initial O value
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_DLY_INVERTED =&gt; '0', -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      OUTPUT_PHASE_90 =&gt; "FALSE", -- Delays the output phase by 90-degrees
      REFCLK_FREQUENCY =&gt; 300.0,  -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      BIT_CTRL_OUT =&gt; BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      CNTVALUEOUT =&gt; CNTVALUEOUT,   -- 9-bit output: Counter value to device logic
      TRI_OUT =&gt; TRI_OUT,           -- 1-bit output: Output to the TBYTE_IN pins of the bitslices
      BIT_CTRL_IN =&gt; BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      CE =&gt; CE,                     -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                   -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,     -- 9-bit input: Counter value input
      EN_VTC =&gt; EN_VTC,             -- 1-bit input: Enable to keep stable delay over VT
      INC =&gt; INC,                   -- 1-bit input: Increment the current delay tap setting
      LOAD =&gt; LOAD,                 -- 1-bit input: Load the CNTVALUEIN tap setting
      RST =&gt; RST,                   -- 1-bit input: Asynchronous assert, synchronous deassert
      RST_DLY =&gt; RST_DLY            -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
   );

   -- End of TX_BITSLICE_TRI_inst instantiation
					</Template>
					<Template label="TX_BITSLICE (TX_BITSLICE)" treetype="template">
-- TX_BITSLICE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (TX_BITSLICE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- TX_BITSLICE: TX_BITSLICE for output using Native Mode
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_inst : TX_BITSLICE
   generic map (
      DATA_WIDTH =&gt; 8,                -- Parallel data input width (4-8)
      DELAY_FORMAT =&gt; "TIME",         -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",          -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,               -- Output delay value setting
      ENABLE_PRE_EMPHASIS =&gt; "FALSE", -- Enable the pre-emphasis
      INIT =&gt; '1',                    -- Defines initial O value
      IS_CLK_INVERTED =&gt; '0',         -- Optional inversion for CLK
      IS_RST_DLY_INVERTED =&gt; '0',     -- Optional inversion for RST_DLY
      IS_RST_INVERTED =&gt; '0',         -- Optional inversion for RST
      OUTPUT_PHASE_90 =&gt; "FALSE",     -- Delays the output phase by 90-degrees
      REFCLK_FREQUENCY =&gt; 300.0,      -- Specification of the reference clock frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE",     -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      -- ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      TBYTE_CTL =&gt; "TBYTE_IN",        -- Select between T and TBYTE_IN inputs
      UPDATE_MODE =&gt; "ASYNC"          -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      -- SYNC)
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT,         -- 9-bit output: Counter value to device logic
      O =&gt; O,                             -- 1-bit output: Serialized output going to output buffer
      RX_BIT_CTRL_OUT =&gt; RX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      TX_BIT_CTRL_OUT =&gt; TX_BIT_CTRL_OUT, -- 40-bit output: Output bus to BITSLICE_CONTROL
      T_OUT =&gt; T_OUT,                     -- 1-bit output: Byte group 3-state output
      CE =&gt; CE,                           -- 1-bit input: Clock enable for ODELAY
      CLK =&gt; CLK,                         -- 1-bit input: Clock used to sample LOAD, CE, INC
      CNTVALUEIN =&gt; CNTVALUEIN,           -- 9-bit input: Counter value from device logic
      D =&gt; D,                             -- 8-bit input: Data from device logic
      EN_VTC =&gt; EN_VTC,                   -- 1-bit input: Enable to keep stable delay over VT
      INC =&gt; INC,                         -- 1-bit input: Increment the current delay tap setting
      LOAD =&gt; LOAD,                       -- 1-bit input: Load the CNTVALUEIN tap setting
      RST =&gt; RST,                         -- 1-bit input: Asynchronous assert, synchronous deassert for
                                          -- TX_BITSLICE OSERDES

      RST_DLY =&gt; RST_DLY,                 -- 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      RX_BIT_CTRL_IN =&gt; RX_BIT_CTRL_IN,   -- 40-bit input: Input bus from BITSLICE_CONTROL
      T =&gt; T,                             -- 1-bit input: Legacy T byte input from device logic
      TBYTE_IN =&gt; TBYTE_IN,               -- 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      TX_BIT_CTRL_IN =&gt; TX_BIT_CTRL_IN    -- 40-bit input: Input bus from BITSLICE_CONTROL
   );

   -- End of TX_BITSLICE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DCI_RESET" treetype="folder">
					<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
--  DCIRESET   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DCIRESET_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DCIRESET: Digitally Controlled Impedance Reset Component
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   DCIRESET_inst : DCIRESET
   port map (
      LOCKED =&gt; LOCKED, -- 1-bit output: LOCK status output
      RST =&gt; RST        -- 1-bit input: Active-High asynchronous reset input
   );

   -- End of DCIRESET_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DELAY" treetype="folder">
					<Template label="IDELAYE3/ODELAYE3 Tap Delay Value Control (IDELAYCTRL)" treetype="template">
-- IDELAYCTRL  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYCTRL: IDELAYE3/ODELAYE3 Tap Delay Value Control
   --             Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL_inst : IDELAYCTRL
   generic map (
      SIM_DEVICE =&gt; "7SERIES"  -- Set the device version (7SERIES, ULTRASCALE)
   )
   port map (
      RDY =&gt; RDY,       -- 1-bit output: Ready output
      REFCLK =&gt; REFCLK, -- 1-bit input: Reference clock input
      RST =&gt; RST        -- 1-bit input: Active high reset input. Asynchronous assert, synchronous deassert to
                        -- REFCLK.

   );

   -- End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE3)" treetype="template">
--  IDELAYE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYE3: Input Fixed or Variable Delay Element
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYE3_inst : IDELAYE3
   generic map (
      CASCADE =&gt; "NONE",          -- Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      DELAY_FORMAT =&gt; "TIME",     -- Units of the DELAY_VALUE (COUNT, TIME)
      DELAY_SRC =&gt; "IDATAIN",     -- Delay input (DATAIN, IDATAIN)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Input delay value setting
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,  -- IDELAYCTRL clock input frequency in MHz (200.0-2667.0)
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      CASC_OUT =&gt; CASC_OUT,       -- 1-bit output: Cascade delay output to ODELAY input cascade
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 9-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data output
      CASC_IN =&gt; CASC_IN,         -- 1-bit input: Cascade delay input from slave ODELAY CASCADE_OUT
      CASC_RETURN =&gt; CASC_RETURN, -- 1-bit input: Cascade delay returning from slave ODELAY DATAOUT
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                 -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 9-bit input: Counter value input
      DATAIN =&gt; DATAIN,           -- 1-bit input: Data input from the logic
      EN_VTC =&gt; EN_VTC,           -- 1-bit input: Keep delay constant over VT
      IDATAIN =&gt; IDATAIN,         -- 1-bit input: Data input from the IOBUF
      INC =&gt; INC,                 -- 1-bit input: Increment / Decrement tap delay input
      LOAD =&gt; LOAD,               -- 1-bit input: Load DELAY_VALUE input
      RST =&gt; RST                  -- 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   -- End of IDELAYE3_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE3)" treetype="template">
--  ODELAYE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODELAYE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODELAYE3: Output Fixed or Variable Delay Element
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   ODELAYE3_inst : ODELAYE3
   generic map (
      CASCADE =&gt; "NONE",          -- Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      DELAY_FORMAT =&gt; "TIME",     -- (COUNT, TIME)
      DELAY_TYPE =&gt; "FIXED",      -- Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      DELAY_VALUE =&gt; 0,           -- Output delay tap setting
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      REFCLK_FREQUENCY =&gt; 300.0,  -- IDELAYCTRL clock input frequency in MHz (200.0-2667.0).
      SIM_DEVICE =&gt; "ULTRASCALE", -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
      UPDATE_MODE =&gt; "ASYNC"      -- Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  -- SYNC)
   )
   port map (
      CASC_OUT =&gt; CASC_OUT,       -- 1-bit output: Cascade delay output to IDELAY input cascade
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 9-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data from ODATAIN input port
      CASC_IN =&gt; CASC_IN,         -- 1-bit input: Cascade delay input from slave IDELAY CASCADE_OUT
      CASC_RETURN =&gt; CASC_RETURN, -- 1-bit input: Cascade delay returning from slave IDELAY DATAOUT
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CLK =&gt; CLK,                 -- 1-bit input: Clock input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 9-bit input: Counter value input
      EN_VTC =&gt; EN_VTC,           -- 1-bit input: Keep delay constant over VT
      INC =&gt; INC,                 -- 1-bit input: Increment/Decrement tap delay input
      LOAD =&gt; LOAD,               -- 1-bit input: Load DELAY_VALUE input
      ODATAIN =&gt; ODATAIN,         -- 1-bit input: Data input
      RST =&gt; RST                  -- 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   -- End of ODELAYE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="INPUT_BUFFER" treetype="folder">
					<Template label="Analog Auxiliary SYSMON Input Buffer (IBUF_ANALOG)" treetype="template">
-- IBUF_ANALOG : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUF_ANALOG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_ANALOG: Analog Auxiliary SYSMON Input Buffer
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_ANALOG_inst : IBUF_ANALOG
   port map (
      O =&gt; O, -- 1-bit output: Connect to a VAUXP/VAUXN port of the SYSMONE1
      I =&gt; I  -- 1-bit input: Connect to a top-level design port
   );

   -- End of IBUF_ANALOG_inst instantiation
					</Template>
					<Template label="Differential Input Buffer (IBUFDS)" treetype="template">
--   IBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS: Differential Input Buffer
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_inst : IBUFDS
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer output
      I =&gt; I,   -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB  -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs and Input Buffer Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
-- IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
--            VHDL             : the following instance declaration needs to be placed
--          instance           : in the body of the design code.  The instance name
--         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations after the
--            code             : "=&gt;" declaration maybe changed to properly reference and
--                             : connect this function to the design.  All inputs and outputs
--                             : must be connected.

--           Library           : In addition to adding the instance declaration, a use
--         declaration         : statement for the UNISIM.vcomponents library needs to be
--             for             : added before the entity declaration.  This library
--           Xilinx            : contains the component declarations for all Xilinx
--         primitives          : primitives and points to the models that will be used
--                             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer With Complementary Outputs and Input Buffer Disable
   --                              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE_inst : IBUFDS_DIFF_OUT_IBUFDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                   -- 1-bit output: Buffer diff_n output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Must be tied to a logic '0'
   );

   -- End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs (IBUFDS_DIFF_OUT)" treetype="template">
-- IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations after the
--      code       : "=&gt;" declaration maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and outputs
--                 : must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--   primitives    : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT: Differential Input Buffer With Complementary Outputs
   --                  Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_inst : IBUFDS_DIFF_OUT
   generic map (
      DQS_BIAS =&gt; "FALSE"  -- (FALSE, TRUE)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Buffer diff_p output
      OB =&gt; OB, -- 1-bit output: Buffer diff_n output
      I =&gt; I,   -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB  -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
-- IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
--             VHDL              : the following instance declaration needs to be placed
--           instance            : in the body of the design code.  The instance name
--          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations after the
--             code              : "=&gt;" declaration maybe changed to properly reference and
--                               : connect this function to the design.  All inputs and outputs
--                               : must be connected.

--            Library            : In addition to adding the instance declaration, a use
--          declaration          : statement for the UNISIM.vcomponents library needs to be
--              for              : added before the entity declaration.  This library
--            Xilinx             : contains the component declarations for all Xilinx
--          primitives           : primitives and points to the models that will be used
--                               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable
   --                                Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE_inst : IBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer diff_p output
      OB =&gt; OB,                       -- 1-bit output: Buffer diff_n output
      I =&gt; I,                         -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                       -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Must be tied to a logic '0'
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Buffer termination disable, high=disable
   );

   -- End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
-- IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--         VHDL         : the following instance declaration needs to be placed
--       instance       : in the body of the design code.  The instance name
--     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations after the
--         code         : "=&gt;" declaration maybe changed to properly reference and
--                      : connect this function to the design.  All inputs and outputs
--                      : must be connected.

--       Library        : In addition to adding the instance declaration, a use
--     declaration      : statement for the UNISIM.vcomponents library needs to be
--         for          : added before the entity declaration.  This library
--        Xilinx        : contains the component declarations for all Xilinx
--      primitives      : primitives and points to the models that will be used
--                      : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_INTERMDISABLE: Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE_inst : IBUFDS_INTERMDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                       -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer input disable, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Buffer termination disable, high=disable
   );

   -- End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable (IBUFDS_IBUFDISABLE)" treetype="template">
-- IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--        VHDL        : the following instance declaration needs to be placed
--      instance      : in the body of the design code.  The instance name
--    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations after the
--        code        : "=&gt;" declaration maybe changed to properly reference and
--                    : connect this function to the design.  All inputs and outputs
--                    : must be connected.

--      Library       : In addition to adding the instance declaration, a use
--    declaration     : statement for the UNISIM.vcomponents library needs to be
--        for         : added before the entity declaration.  This library
--       Xilinx       : contains the component declarations for all Xilinx
--     primitives     : primitives and points to the models that will be used
--                    : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_IBUFDISABLE: Differential Input Buffer With Input Buffer Disable
   --                     Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE_inst : IBUFDS_IBUFDISABLE
   generic map (
      DQS_BIAS =&gt; "FALSE",        -- (FALSE, TRUE)
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Must be tied to a logic '0'
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with MIPI support (IBUFDS_DPHY)" treetype="template">
-- IBUFDS_DPHY : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_DPHY_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DPHY: Differential Input Buffer with MIPI support
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DPHY_inst : IBUFDS_DPHY
   generic map (
      DIFF_TERM =&gt; TRUE,       -- Differential termination
      IOSTANDARD =&gt; "DEFAULT"  -- I/O standard
   )
   port map (
      HSRX_O =&gt; HSRX_O,             -- 1-bit output: HS RX output
      LPRX_O_N =&gt; LPRX_O_N,         -- 1-bit output: LP RX output (Slave)
      LPRX_O_P =&gt; LPRX_O_P,         -- 1-bit output: LP RX output (Master)
      HSRX_DISABLE =&gt; HSRX_DISABLE, -- 1-bit input: Disable control for HS mode
      I =&gt; I,                       -- 1-bit input: Data input0 PAD
      IB =&gt; IB,                     -- 1-bit input: Data input1 PAD
      LPRX_DISABLE =&gt; LPRX_DISABLE  -- 1-bit input: Disable control for LP mode
   );

   -- End of IBUFDS_DPHY_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Offset Calibration (IBUFDSE3)" treetype="template">
--  IBUFDSE3   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDSE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDSE3: Differential Input Buffer with Offset Calibration
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDSE3_inst : IBUFDSE3
   generic map (
      DQS_BIAS =&gt; "FALSE",          -- (FALSE, TRUE)
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB,                   -- 1-bit input: Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- 1-bit input: Buffer disable input, high=disable
      OSC =&gt; OSC,                 -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN            -- 2-bit input: Offset cancellation enable
   );

   -- End of IBUFDSE3_inst instantiation
					</Template>
					<Template label="Input Buffer (IBUF)" treetype="template">
--    IBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF: Input Buffer
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_inst : IBUF
   port map (
      O =&gt; O, -- 1-bit output: Buffer output
      I =&gt; I  -- 1-bit input: Buffer input
   );

   -- End of IBUF_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
-- IBUF_INTERMDISABLE : In order to incorporate this function into the design,
--        VHDL        : the following instance declaration needs to be placed
--      instance      : in the body of the design code.  The instance name
--    declaration     : (IBUF_INTERMDISABLE_inst) and/or the port declarations after the
--        code        : "=&gt;" declaration maybe changed to properly reference and
--                    : connect this function to the design.  All inputs and outputs
--                    : must be connected.

--      Library       : In addition to adding the instance declaration, a use
--    declaration     : statement for the UNISIM.vcomponents library needs to be
--        for         : added before the entity declaration.  This library
--       Xilinx       : contains the component declarations for all Xilinx
--     primitives     : primitives and points to the models that will be used
--                    : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_INTERMDISABLE: Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   --                     Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_INTERMDISABLE_inst : IBUF_INTERMDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                         -- 1-bit output: Buffer output
      I =&gt; I,                         -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE,     -- 1-bit input: Buffer disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE  -- 1-bit input: Input Termination Disable
   );

   -- End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable (IBUF_IBUFDISABLE)" treetype="template">
-- IBUF_IBUFDISABLE : In order to incorporate this function into the design,
--       VHDL       : the following instance declaration needs to be placed
--     instance     : in the body of the design code.  The instance name
--   declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations after the
--       code       : "=&gt;" declaration maybe changed to properly reference and
--                  : connect this function to the design.  All inputs and outputs
--                  : must be connected.

--     Library      : In addition to adding the instance declaration, a use
--   declaration    : statement for the UNISIM.vcomponents library needs to be
--       for        : added before the entity declaration.  This library
--      Xilinx      : contains the component declarations for all Xilinx
--    primitives    : primitives and points to the models that will be used
--                  : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_IBUFDISABLE: Input Buffer With Input Buffer Disable
   --                   Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUF_IBUFDISABLE_inst : IBUF_IBUFDISABLE
   generic map (
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Must be set to "ULTRASCALE" 
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE  -- 1-bit input: Buffer disable input, high=disable
   );

   -- End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer with Offset Calibration and VREF Tuning (IBUFE3)" treetype="template">
--   IBUFE3    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFE3: Input Buffer with Offset Calibration and VREF Tuning
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IBUFE3_inst : IBUFE3
   generic map (
      SIM_INPUT_BUFFER_OFFSET =&gt; 0  -- Offset value for simulation (-50-50)
   )
   port map (
      O =&gt; O,                     -- 1-bit output: Buffer output
      I =&gt; I,                     -- 1-bit input: Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- 1-bit input: Buffer disable input, high=disable
      OSC =&gt; OSC,                 -- 4-bit input: Offset cancellation value
      OSC_EN =&gt; OSC_EN,           -- 1-bit input: Offset cancellation enable
      VREF =&gt; VREF                -- 1-bit input: Vref input from HPIO_VREF
   );

   -- End of IBUFE3_inst instantiation
					</Template>
					<Template label="VREF Scan (HPIO_VREF)" treetype="template">
--  HPIO_VREF  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (HPIO_VREF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- HPIO_VREF: VREF Scan
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   HPIO_VREF_inst : HPIO_VREF
   generic map (
      VREF_CNTR =&gt; "OFF"  -- FABRIC_RANGE1, FABRIC_RANGE2, OFF
   )
   port map (
      VREF =&gt; VREF,                         -- 1-bit output: Tuned output (connect to associated IBUFE3
                                            -- component)

      FABRIC_VREF_TUNE =&gt; FABRIC_VREF_TUNE  -- 7-bit input: VREF tuning value
   );

   -- End of HPIO_VREF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="OUTPUT_BUFFER" treetype="folder">
					<Template label="3-State Output Buffer (OBUFT)" treetype="template">
--    OBUFT    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFT: 3-State Output Buffer
   --        Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFT_inst : OBUFT
   port map (
      O =&gt; O, -- 1-bit output: Buffer output (connect directly to top-level port)
      I =&gt; I, -- 1-bit input: Buffer input
      T =&gt; T  -- 1-bit input: 3-state enable input
   );

   -- End of OBUFT_inst instantiation
					</Template>
					<Template label="Differential Output Buffer (OBUFDS)" treetype="template">
--   OBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS: Differential Output Buffer
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_inst : OBUFDS
   port map (
      O =&gt; O,   -- 1-bit output: Diff_p output (connect directly to top-level port)
      OB =&gt; OB, -- 1-bit output: Diff_n output (connect directly to top-level port)
      I =&gt; I    -- 1-bit input: Buffer input
   );

   -- End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential Output Buffer with MIPI support (OBUFDS_DPHY)" treetype="template">
-- OBUFDS_DPHY : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFDS_DPHY_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS_DPHY: Differential Output Buffer with MIPI support
   --              Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFDS_DPHY_inst : OBUFDS_DPHY
   generic map (
      IOSTANDARD =&gt; "DEFAULT"  -- I/O standard
   )
   port map (
      O =&gt; O,               -- 1-bit output: Diff_P Data output
      OB =&gt; OB,             -- 1-bit output: Diff_N Data output
      HSTX_I =&gt; HSTX_I,     -- 1-bit input: Data input (HS TX)
      HSTX_T =&gt; HSTX_T,     -- 1-bit input: Tristate Control input (HS TX)
      LPTX_I_N =&gt; LPTX_I_N, -- 1-bit input: Data input (LP TX) (Master-N)
      LPTX_I_P =&gt; LPTX_I_P, -- 1-bit input: Data input (LP TX) (Master-P)
      LPTX_T =&gt; LPTX_T      -- 1-bit input: Tristate Control input (LP TX)
   );

   -- End of OBUFDS_DPHY_inst instantiation
					</Template>
					<Template label="Differential 3-state Output Buffer (OBUFTDS)" treetype="template">
--   OBUFTDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUFTDS_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFTDS: Differential 3-state Output Buffer
   --          Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUFTDS_inst : OBUFTDS
   port map (
      O =&gt; O,   -- 1-bit output: Diff_p output (connect directly to top-level port)
      OB =&gt; OB, -- 1-bit output: Diff_n output (connect directly to top-level port)
      I =&gt; I,   -- 1-bit input: Buffer input
      T =&gt; T    -- 1-bit input: 3-state enable input
   );

   -- End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Output Buffer (OBUF)" treetype="template">
--    OBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OBUF_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUF: Output Buffer
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OBUF_inst : OBUF
   port map (
      O =&gt; O, -- 1-bit output: Buffer output (connect directly to top-level port)
      I =&gt; I  -- 1-bit input: Buffer input
   );

   -- End of OBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer (ISERDESE3)" treetype="template">
--  ISERDESE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ISERDESE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ISERDESE3: Input SERial/DESerializer
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   ISERDESE3_inst : ISERDESE3
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel data width (4,8)
      FIFO_ENABLE =&gt; "FALSE",     -- Enables the use of the FIFO
      FIFO_SYNC_MODE =&gt; "FALSE",  -- Enables the use of internal 2-stage synchronizers on the FIFO
      IS_CLK_B_INVERTED =&gt; '0',   -- Optional inversion for CLK_B
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      FIFO_EMPTY =&gt; FIFO_EMPTY,           -- 1-bit output: FIFO empty flag
      INTERNAL_DIVCLK =&gt; INTERNAL_DIVCLK, -- 1-bit output: Internally divided down clock used when FIFO is
                                          -- disabled (do not connect)

      Q =&gt; Q,                             -- 8-bit registered output
      CLK =&gt; CLK,                         -- 1-bit input: High-speed clock
      CLKDIV =&gt; CLKDIV,                   -- 1-bit input: Divided Clock
      CLK_B =&gt; CLK_B,                     -- 1-bit input: Inversion of High-speed clock CLK
      D =&gt; D,                             -- 1-bit input: Serial Data Input
      FIFO_RD_CLK =&gt; FIFO_RD_CLK,         -- 1-bit input: FIFO read clock
      FIFO_RD_EN =&gt; FIFO_RD_EN,           -- 1-bit input: Enables reading the FIFO when asserted
      RST =&gt; RST                          -- 1-bit input: Asynchronous Reset
   );

   -- End of ISERDESE3_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer (OSERDESE3)" treetype="template">
--  OSERDESE3  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OSERDESE3_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OSERDESE3: Output SERial/DESerializer
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   OSERDESE3_inst : OSERDESE3
   generic map (
      DATA_WIDTH =&gt; 8,            -- Parallel Data Width (4-8)
      INIT =&gt; '0',                -- Initialization value of the OSERDES flip-flops
      IS_CLKDIV_INVERTED =&gt; '0',  -- Optional inversion for CLKDIV
      IS_CLK_INVERTED =&gt; '0',     -- Optional inversion for CLK
      IS_RST_INVERTED =&gt; '0',     -- Optional inversion for RST
      SIM_DEVICE =&gt; "ULTRASCALE"  -- Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  -- ULTRASCALE_PLUS_ES2)
   )
   port map (
      OQ =&gt; OQ,         -- 1-bit output: Serial Output Data
      T_OUT =&gt; T_OUT,   -- 1-bit output: 3-state control output to IOB
      CLK =&gt; CLK,       -- 1-bit input: High-speed clock
      CLKDIV =&gt; CLKDIV, -- 1-bit input: Divided Clock
      D =&gt; D,           -- 8-bit input: Parallel Data Input
      RST =&gt; RST,       -- 1-bit input: Asynchronous Reset
      T =&gt; T            -- 1-bit input: Tristate input from fabric
   );

   -- End of OSERDESE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="WEAK_DRIVER" treetype="folder">
					<Template label="I/O Pulldown (PULLDOWN)" treetype="template">
--  PULLDOWN   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PULLDOWN_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLDOWN: I/O Pulldown
   --           Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PULLDOWN_inst : PULLDOWN
   port map (
      O =&gt; O  -- 1-bit output: Pulldown output (connect directly to top-level port)
   );

   -- End of PULLDOWN_inst instantiation
					</Template>
					<Template label="I/O Pullup (PULLUP)" treetype="template">
--   PULLUP    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PULLUP_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLUP: I/O Pullup
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   PULLUP_inst : PULLUP
   port map (
      O =&gt; O  -- 1-bit output: Pullup output (connect directly to top-level port)
   );

   -- End of PULLUP_inst instantiation
					</Template>
					<Template label="I/O Weak Keeper (KEEPER)" treetype="template">
--   KEEPER    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (KEEPER_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- KEEPER: I/O Weak Keeper
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   KEEPER_inst : KEEPER
   port map (
      O =&gt; O  -- 1-bit inout: Keeper output (connect directly to top-level port)
   );

   -- End of KEEPER_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="REGISTER" treetype="folder">
				<SubFolder label="DDR" treetype="folder">
					<Template label="Input DDR (IDDRE1)" treetype="template">
--   IDDRE1    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDDRE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDRE1: Dedicated Dual Data Rate (DDR) Input Register
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   IDDRE1_inst : IDDRE1
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- IDDRE1 mode (OPPOSITE_EDGE, SAME_EDGE, SAME_EDGE_PIPELINED)
      IS_CB_INVERTED =&gt; '0',           -- Optional inversion for CB
      IS_C_INVERTED =&gt; '0'             -- Optional inversion for C
   )
   port map (
      Q1 =&gt; Q1, -- 1-bit output: Registered parallel output 1
      Q2 =&gt; Q2, -- 1-bit output: Registered parallel output 2
      C =&gt; C,   -- 1-bit input: High-speed clock
      CB =&gt; CB, -- 1-bit input: Inversion of High-speed clock C
      D =&gt; D,   -- 1-bit input: Serial Data Input
      R =&gt; R    -- 1-bit input: Active High Async Reset
   );

   -- End of IDDRE1_inst instantiation
					</Template>
					<Template label="Output DDR (ODDRE1)" treetype="template">
--   ODDRE1    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODDRE1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDRE1: Dedicated Dual Data Rate (DDR) Output Register
   --         Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   ODDRE1_inst : ODDRE1
   generic map (
      IS_C_INVERTED =&gt; '0',  -- Optional inversion for C
      IS_D1_INVERTED =&gt; '0', -- Optional inversion for D1
      IS_D2_INVERTED =&gt; '0', -- Optional inversion for D2
      SRVAL =&gt; '0'           -- Initializes the ODDRE1 Flip-Flops to the specified value ('0', '1')
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data output to IOB
      C =&gt; C,   -- 1-bit input: High-speed clock input
      D1 =&gt; D1, -- 1-bit input: Parallel data input 1
      D2 =&gt; D2, -- 1-bit input: Parallel data input 2
      SR =&gt; SR  -- 1-bit input: Active High Async Reset
   );

   -- End of ODDRE1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Transparent Latch with Clock Enable and Asynchronous Clear (LDCE)" treetype="template">
--    LDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LDCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDCE: Transparent Latch with Clock Enable and Asynchronous Clear
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LDCE_inst : LDCE
   generic map (
      INIT =&gt; '0',            -- Initial value of latch, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_G_INVERTED =&gt; '0'    -- Optional inversion for G
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      D =&gt; D,     -- 1-bit input: Data
      G =&gt; G,     -- 1-bit input: Gate
      GE =&gt; GE    -- 1-bit input: Gate enable
   );

   -- End of LDCE_inst instantiation
					</Template>
					<Template label="Transparent Latch with Clock Enable and Asynchronous Preset (LDPE)" treetype="template">
--    LDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (LDPE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDPE: Transparent Latch with Clock Enable and Asynchronous Preset
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   LDPE_inst : LDPE
   generic map (
      INIT =&gt; '1',            -- Initial value of latch, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_G_INVERTED =&gt; '0',   -- Optional inversion for G
      IS_PRE_INVERTED =&gt; '0'  -- Optional inversion for PRE
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      D =&gt; D,     -- 1-bit input: Data
      G =&gt; G,     -- 1-bit input: Gate
      GE =&gt; GE,   -- 1-bit input: Gate enable
      PRE =&gt; PRE  -- 1-bit input: Asynchronous preset
   );

   -- End of LDPE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="METASTABILITY" treetype="folder">
					<Template label="Metastability Hardened Registers (HARD_SYNC)" treetype="template">
--  HARD_SYNC  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (HARD_SYNC_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- HARD_SYNC: Metastability Hardened Registers
   --            Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   HARD_SYNC_inst : HARD_SYNC
   generic map (
      INIT =&gt; '0',            -- Initial values, '0', '1'
      IS_CLK_INVERTED =&gt; '0', -- Programmable inversion on CLK input
      LATENCY =&gt; 2            -- 2-3
   )
   port map (
      DOUT =&gt; DOUT, -- 1-bit output: Data
      CLK =&gt; CLK,   -- 1-bit input: Clock
      DIN =&gt; DIN    -- 1-bit input: Data
   );

   -- End of HARD_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SDR" treetype="folder">
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Clear (FDCE)" treetype="template">
--    FDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDCE: D Flip-Flop with Clock Enable and Asynchronous Clear
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FDCE_inst : FDCE
   generic map (
      INIT =&gt; '0',            -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_CLR_INVERTED =&gt; '0', -- Optional inversion for CLR
      IS_C_INVERTED =&gt; '0',   -- Optional inversion for C
      IS_D_INVERTED =&gt; '0'    -- Optional inversion for D
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      C =&gt; C,     -- 1-bit input: Clock
      CE =&gt; CE,   -- 1-bit input: Clock enable
      CLR =&gt; CLR, -- 1-bit input: Asynchronous clear
      D =&gt; D      -- 1-bit input: Data
   );

   -- End of FDCE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Preset (FDPE)" treetype="template">
--    FDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDPE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDPE: D Flip-Flop with Clock Enable and Asynchronous Preset
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FDPE_inst : FDPE
   generic map (
      INIT =&gt; '1',            -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0',   -- Optional inversion for C
      IS_D_INVERTED =&gt; '0',   -- Optional inversion for D
      IS_PRE_INVERTED =&gt; '0'  -- Optional inversion for PRE
   )
   port map (
      Q =&gt; Q,     -- 1-bit output: Data
      C =&gt; C,     -- 1-bit input: Clock
      CE =&gt; CE,   -- 1-bit input: Clock enable
      D =&gt; D,     -- 1-bit input: Data
      PRE =&gt; PRE  -- 1-bit input: Asynchronous preset
   );

   -- End of FDPE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Reset (FDRE)" treetype="template">
--    FDRE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDRE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDRE: D Flip-Flop with Clock Enable and Synchronous Reset
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FDRE_inst : FDRE
   generic map (
      INIT =&gt; '0',          -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0', -- Optional inversion for C
      IS_D_INVERTED =&gt; '0', -- Optional inversion for D
      IS_R_INVERTED =&gt; '0'  -- Optional inversion for R
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data
      C =&gt; C,   -- 1-bit input: Clock
      CE =&gt; CE, -- 1-bit input: Clock enable
      D =&gt; D,   -- 1-bit input: Data
      R =&gt; R    -- 1-bit input: Synchronous reset
   );

   -- End of FDRE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Set (FDSE)" treetype="template">
--    FDSE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FDSE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDSE: D Flip-Flop with Clock Enable and Synchronous Set
   --       Virtex UltraScale+
   -- Xilinx HDL Language Template, version 2016.4

   FDSE_inst : FDSE
   generic map (
      INIT =&gt; '1',          -- Initial value of register, '0', '1'
      -- Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      IS_C_INVERTED =&gt; '0', -- Optional inversion for C
      IS_D_INVERTED =&gt; '0', -- Optional inversion for D
      IS_S_INVERTED =&gt; '0'  -- Optional inversion for S
   )
   port map (
      Q =&gt; Q,   -- 1-bit output: Data
      C =&gt; C,   -- 1-bit input: Clock
      CE =&gt; CE, -- 1-bit input: Clock enable
      D =&gt; D,   -- 1-bit input: Data
      S =&gt; S    -- 1-bit input: Synchronous set
   );

   -- End of FDSE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Virtex-7" treetype="folder">
			<SubFolder label="Advanced" treetype="folder">
				<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE2)" treetype="template">
-- IBUFDS_GTE2 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IBUFDS_GTE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_GTE2: Gigabit Transceiver Buffer
   --              Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE2_inst : IBUFDS_GTE2
   generic map (
      CLKCM_CFG =&gt; TRUE,    -- Refer to Transceiver User Guide
      CLKRCV_TRST =&gt; TRUE,  -- Refer to Transceiver User Guide
      CLKSWING_CFG =&gt; '11'  -- Refer to Transceiver User Guide
   )
   port map (
      O =&gt; O,         -- 1-bit output: Refer to Transceiver User Guide
      ODIV2 =&gt; ODIV2, -- 1-bit output: Refer to Transceiver User Guide
      CEB =&gt; CEB,     -- 1-bit input: Refer to Transceiver User Guide
      I =&gt; I,         -- 1-bit input: Refer to Transceiver User Guide
      IB =&gt; IB        -- 1-bit input: Refer to Transceiver User Guide
   );

   -- End of IBUFDS_GTE2_inst instantiation
				</Template>
				<Template label="XADC Simulation File" treetype="template">
-- Must use valid headers on all columns
-- Comments can be added to the stimulus file using '--'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

-- Time stamp data is in nano seconds (ns)
-- Temperature is recorded in C (degrees centigrade)
-- All other channels are recorded as V (Volts)
-- Valid column headers are:
-- TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
-- VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
-- External analog inputs are differential so VP = 0.5 and VN = 0.1 the
-- input on channel VP/VN in 0.5 - 0.1 = 0.4V

				</Template>
				<Template label="Xilinx Analog-to-Digital Converter (XADC)" treetype="template">
--    XADC     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (XADC_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- XADC: Dual 12-Bit 1MSPS Analog-to-Digital Converter
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   XADC_inst : XADC
   generic map (
      -- INIT_40 - INIT_42: XADC configuration registers
      INIT_40 =&gt; X"0000",
      INIT_41 =&gt; X"0000",
      INIT_42 =&gt; X"0800",
      -- INIT_48 - INIT_4F: Sequence Registers
      INIT_48 =&gt; X"0000",
      INIT_49 =&gt; X"0000",
      INIT_4A =&gt; X"0000",
      INIT_4B =&gt; X"0000",
      INIT_4C =&gt; X"0000",
      INIT_4D =&gt; X"0000",
      INIT_4F =&gt; X"0000",
      INIT_4E =&gt; X"0000",                 -- Sequence register 6
      -- INIT_50 - INIT_58, INIT5C: Alarm Limit Registers
      INIT_50 =&gt; X"0000",
      INIT_51 =&gt; X"0000",
      INIT_52 =&gt; X"0000",
      INIT_53 =&gt; X"0000",
      INIT_54 =&gt; X"0000",
      INIT_55 =&gt; X"0000",
      INIT_56 =&gt; X"0000",
      INIT_57 =&gt; X"0000",
      INIT_58 =&gt; X"0000",
      INIT_5C =&gt; X"0000",
      -- Simulation attributes: Set for proper simulation behavior
      SIM_DEVICE =&gt; "7SERIES",            -- Select target device (values)
      SIM_MONITOR_FILE =&gt; "design.txt"  -- Analog simulation data file name
   )
   port map (
      -- ALARMS: 8-bit (each) output: ALM, OT
      ALM =&gt; ALM,                   -- 8-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      OT =&gt; OT,                     -- 1-bit output: Over-Temperature alarm
      -- Dynamic Reconfiguration Port (DRP): 16-bit (each) output: Dynamic Reconfiguration Ports
      DO =&gt; DO,                     -- 16-bit output: DRP output data bus
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP data ready
      -- STATUS: 1-bit (each) output: XADC status ports
      BUSY =&gt; BUSY,                 -- 1-bit output: ADC busy output
      CHANNEL =&gt; CHANNEL,           -- 5-bit output: Channel selection outputs
      EOC =&gt; EOC,                   -- 1-bit output: End of Conversion
      EOS =&gt; EOS,                   -- 1-bit output: End of Sequence
      JTAGBUSY =&gt; JTAGBUSY,         -- 1-bit output: JTAG DRP transaction in progress output
      JTAGLOCKED =&gt; JTAGLOCKED,     -- 1-bit output: JTAG requested DRP port lock
      JTAGMODIFIED =&gt; JTAGMODIFIED, -- 1-bit output: JTAG Write to the DRP has occurred
      MUXADDR =&gt; MUXADDR,           -- 5-bit output: External MUX channel decode
      -- Auxiliary Analog-Input Pairs: 16-bit (each) input: VAUXP[15:0], VAUXN[15:0]
      VAUXN =&gt; VAUXN,               -- 16-bit input: N-side auxiliary analog input
      VAUXP =&gt; VAUXP,               -- 16-bit input: P-side auxiliary analog input
      -- CONTROL and CLOCK: 1-bit (each) input: Reset, conversion start and clock inputs
      CONVST =&gt; CONVST,             -- 1-bit input: Convert start input
      CONVSTCLK =&gt; CONVSTCLK,       -- 1-bit input: Convert start input
      RESET =&gt; RESET,               -- 1-bit input: Active-high reset
      -- Dedicated Analog Input Pair: 1-bit (each) input: VP/VN
      VN =&gt; VN,                     -- 1-bit input: N-side analog input
      VP =&gt; VP,                     -- 1-bit input: P-side analog input
      -- Dynamic Reconfiguration Port (DRP): 7-bit (each) input: Dynamic Reconfiguration Ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address bus
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable signal
      DI =&gt; DI,                     -- 16-bit input: DRP input data bus
      DWE =&gt; DWE                    -- 1-bit input: DRP write enable
   );

   -- End of XADC_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Arithmetic Functions" treetype="folder">
				<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E1)" treetype="template">
--   DSP48E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DSP48E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DSP48E1: 48-bit Multi-Functional Arithmetic Block
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   DSP48E1_inst : DSP48E1
   generic map (
      -- Feature Control Attributes: Data Path Selection
      A_INPUT =&gt; "DIRECT",               -- Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      B_INPUT =&gt; "DIRECT",               -- Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      USE_DPORT =&gt; FALSE,                -- Select D port usage (TRUE or FALSE)
      USE_MULT =&gt; "MULTIPLY",            -- Select multiplier usage ("MULTIPLY", "DYNAMIC", or "NONE")
      USE_SIMD =&gt; "ONE48",               -- SIMD selection ("ONE48", "TWO24", "FOUR12")
      -- Pattern Detector Attributes: Pattern Detection Configuration
      AUTORESET_PATDET =&gt; "NO_RESET",    -- "NO_RESET", "RESET_MATCH", "RESET_NOT_MATCH" 
      MASK =&gt; X"3fffffffffff",           -- 48-bit mask value for pattern detect (1=ignore)
      PATTERN =&gt; X"000000000000",        -- 48-bit pattern match for pattern detect
      SEL_MASK =&gt; "MASK",                -- "C", "MASK", "ROUNDING_MODE1", "ROUNDING_MODE2" 
      SEL_PATTERN =&gt; "PATTERN",          -- Select pattern value ("PATTERN" or "C")
      USE_PATTERN_DETECT =&gt; "NO_PATDET", -- Enable pattern detect ("PATDET" or "NO_PATDET")
      -- Register Control Attributes: Pipeline Register Configuration
      ACASCREG =&gt; 1,                     -- Number of pipeline stages between A/ACIN and ACOUT (0, 1 or 2)
      ADREG =&gt; 1,                        -- Number of pipeline stages for pre-adder (0 or 1)
      ALUMODEREG =&gt; 1,                   -- Number of pipeline stages for ALUMODE (0 or 1)
      AREG =&gt; 1,                         -- Number of pipeline stages for A (0, 1 or 2)
      BCASCREG =&gt; 1,                     -- Number of pipeline stages between B/BCIN and BCOUT (0, 1 or 2)
      BREG =&gt; 1,                         -- Number of pipeline stages for B (0, 1 or 2)
      CARRYINREG =&gt; 1,                   -- Number of pipeline stages for CARRYIN (0 or 1)
      CARRYINSELREG =&gt; 1,                -- Number of pipeline stages for CARRYINSEL (0 or 1)
      CREG =&gt; 1,                         -- Number of pipeline stages for C (0 or 1)
      DREG =&gt; 1,                         -- Number of pipeline stages for D (0 or 1)
      INMODEREG =&gt; 1,                    -- Number of pipeline stages for INMODE (0 or 1)
      MREG =&gt; 1,                         -- Number of multiplier pipeline stages (0 or 1)
      OPMODEREG =&gt; 1,                    -- Number of pipeline stages for OPMODE (0 or 1)
      PREG =&gt; 1                          -- Number of pipeline stages for P (0 or 1)
   )
   port map (
      -- Cascade: 30-bit (each) output: Cascade Ports
      ACOUT =&gt; ACOUT,                   -- 30-bit output: A port cascade output
      BCOUT =&gt; BCOUT,                   -- 18-bit output: B port cascade output
      CARRYCASCOUT =&gt; CARRYCASCOUT,     -- 1-bit output: Cascade carry output
      MULTSIGNOUT =&gt; MULTSIGNOUT,       -- 1-bit output: Multiplier sign cascade output
      PCOUT =&gt; PCOUT,                   -- 48-bit output: Cascade output
      -- Control: 1-bit (each) output: Control Inputs/Status Bits
      OVERFLOW =&gt; OVERFLOW,             -- 1-bit output: Overflow in add/acc output
      PATTERNBDETECT =&gt; PATTERNBDETECT, -- 1-bit output: Pattern bar detect output
      PATTERNDETECT =&gt; PATTERNDETECT,   -- 1-bit output: Pattern detect output
      UNDERFLOW =&gt; UNDERFLOW,           -- 1-bit output: Underflow in add/acc output
      -- Data: 4-bit (each) output: Data Ports
      CARRYOUT =&gt; CARRYOUT,             -- 4-bit output: Carry output
      P =&gt; P,                           -- 48-bit output: Primary data output
      -- Cascade: 30-bit (each) input: Cascade Ports
      ACIN =&gt; ACIN,                     -- 30-bit input: A cascade data input
      BCIN =&gt; BCIN,                     -- 18-bit input: B cascade input
      CARRYCASCIN =&gt; CARRYCASCIN,       -- 1-bit input: Cascade carry input
      MULTSIGNIN =&gt; MULTSIGNIN,         -- 1-bit input: Multiplier sign input
      PCIN =&gt; PCIN,                     -- 48-bit input: P cascade input
      -- Control: 4-bit (each) input: Control Inputs/Status Bits
      ALUMODE =&gt; ALUMODE,               -- 4-bit input: ALU control input
      CARRYINSEL =&gt; CARRYINSEL,         -- 3-bit input: Carry select input
      CLK =&gt; CLK,                       -- 1-bit input: Clock input
      INMODE =&gt; INMODE,                 -- 5-bit input: INMODE control input
      OPMODE =&gt; OPMODE,                 -- 7-bit input: Operation mode input
      -- Data: 30-bit (each) input: Data Ports
      A =&gt; A,                           -- 30-bit input: A data input
      B =&gt; B,                           -- 18-bit input: B data input
      C =&gt; C,                           -- 48-bit input: C data input
      CARRYIN =&gt; CARRYIN,               -- 1-bit input: Carry input signal
      D =&gt; D,                           -- 25-bit input: D data input
      -- Reset/Clock Enable: 1-bit (each) input: Reset/Clock Enable Inputs
      CEA1 =&gt; CEA1,                     -- 1-bit input: Clock enable input for 1st stage AREG
      CEA2 =&gt; CEA2,                     -- 1-bit input: Clock enable input for 2nd stage AREG
      CEAD =&gt; CEAD,                     -- 1-bit input: Clock enable input for ADREG
      CEALUMODE =&gt; CEALUMODE,           -- 1-bit input: Clock enable input for ALUMODE
      CEB1 =&gt; CEB1,                     -- 1-bit input: Clock enable input for 1st stage BREG
      CEB2 =&gt; CEB2,                     -- 1-bit input: Clock enable input for 2nd stage BREG
      CEC =&gt; CEC,                       -- 1-bit input: Clock enable input for CREG
      CECARRYIN =&gt; CECARRYIN,           -- 1-bit input: Clock enable input for CARRYINREG
      CECTRL =&gt; CECTRL,                 -- 1-bit input: Clock enable input for OPMODEREG and CARRYINSELREG
      CED =&gt; CED,                       -- 1-bit input: Clock enable input for DREG
      CEINMODE =&gt; CEINMODE,             -- 1-bit input: Clock enable input for INMODEREG
      CEM =&gt; CEM,                       -- 1-bit input: Clock enable input for MREG
      CEP =&gt; CEP,                       -- 1-bit input: Clock enable input for PREG
      RSTA =&gt; RSTA,                     -- 1-bit input: Reset input for AREG
      RSTALLCARRYIN =&gt; RSTALLCARRYIN,   -- 1-bit input: Reset input for CARRYINREG
      RSTALUMODE =&gt; RSTALUMODE,         -- 1-bit input: Reset input for ALUMODEREG
      RSTB =&gt; RSTB,                     -- 1-bit input: Reset input for BREG
      RSTC =&gt; RSTC,                     -- 1-bit input: Reset input for CREG
      RSTCTRL =&gt; RSTCTRL,               -- 1-bit input: Reset input for OPMODEREG and CARRYINSELREG
      RSTD =&gt; RSTD,                     -- 1-bit input: Reset input for DREG and ADREG
      RSTINMODE =&gt; RSTINMODE,           -- 1-bit input: Reset input for INMODEREG
      RSTM =&gt; RSTM,                     -- 1-bit input: Reset input for MREG
      RSTP =&gt; RSTP                      -- 1-bit input: Reset input for PREG
   );

   -- End of DSP48E1_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Clock Components" treetype="folder">
				<SubFolder label="Clock Buffers" treetype="folder">
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
--  BUFGCE_1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE_1: Global Clock Buffer with Clock Enable and Output State 1
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_1_inst : BUFGCE_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock enable input for I0
      I =&gt; I    -- 1-bit input: Primary clock
   );

   -- End of BUFGCE_1_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
--   BUFGCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCE: Global Clock Buffer with Clock Enable
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCE_inst : BUFGCE
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Clock enable input for I0
      I =&gt; I    -- 1-bit input: Primary clock
   );

   -- End of BUFGCE_inst instantiation
					</Template>
					<Template label="Global Clock Simple Buffer (BUFG)" treetype="template">
--    BUFG     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFG_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFG: Global Clock Simple Buffer
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFG_inst : BUFG
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFG_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer (BUFH)" treetype="template">
--    BUFH     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFH_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFH: HROW Clock Buffer for a Single Clocking Region
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFH_inst : BUFH
   port map (
      O =&gt; O, -- 1-bit output: Clock output
      I =&gt; I  -- 1-bit input: Clock input
   );

   -- End of BUFH_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer with Clock Enable (BUFHCE)" treetype="template">
--   BUFHCE    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFHCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFHCE: HROW Clock Buffer for a Single Clocking Region with Clock Enable
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFHCE_inst : BUFHCE
   generic map (
      CE_TYPE =&gt; "SYNC", -- "SYNC" (glitchless switching) or "ASYNC" (immediate switch)
      INIT_OUT =&gt; 0      -- Initial output value (0-1)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      CE =&gt; CE, -- 1-bit input: Active high enable
      I =&gt; I    -- 1-bit input: Clock input
   );

   -- End of BUFHCE_inst instantiation
					</Template>
					<Template label="I/O Clock Buffer (BUFIO)" treetype="template">
--    BUFIO    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFIO_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFIO: Local Clock Buffer for I/O
   --        Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFIO_inst : BUFIO
   port map (
      O =&gt; O, -- 1-bit output: Clock output (connect to I/O clock loads).
      I =&gt; I  -- 1-bit input: Clock input (connect to an IBUF or BUFMR).
   );

   -- End of BUFIO_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer (BUFMR)" treetype="template">
--    BUFMR    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFMR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFMR: Multi-Region Clock Buffer
   --        Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFMR_inst : BUFMR
   port map (
      O =&gt; O, -- 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      I =&gt; I  -- 1-bit input: Clock input (Connect to IBUF)
   );

   -- End of BUFMR_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer with Clock Enable (BUFMRCE)" treetype="template">
--   BUFMRCE   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFMRCE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFMRCE: Multi-Region Clock Buffer with Clock Enable
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFMRCE_inst : BUFMRCE
   generic map (
      CE_TYPE =&gt; "SYNC", -- SYNC, ASYNC
      INIT_OUT =&gt; 0      -- Initial output and stopped polarity, (0-1)
   )
   port map (
      O =&gt; O,   -- 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      CE =&gt; CE, -- 1-bit input: Active high buffer enable
      I =&gt; I    -- 1-bit input: Clock input (Connect to IBUF)
   );

   -- End of BUFMRCE_inst instantiation
					</Template>
					<Template label="Regional Clock Buffer (BUFR)" treetype="template">
--    BUFR     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFR: Regional Clock Buffer for I/O and Logic Resources within a Clock Region
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFR_inst : BUFR
   generic map (
      BUFR_DIVIDE =&gt; "BYPASS",   -- Values: "BYPASS, 1, 2, 3, 4, 5, 6, 7, 8" 
      SIM_DEVICE =&gt; "7SERIES"  -- Must be set to "7SERIES" 
   )
   port map (
      O =&gt; O,     -- 1-bit output: Clock output port
      CE =&gt; CE,   -- 1-bit input: Active high, clock enable (Divided modes only)
      CLR =&gt; CLR, -- 1-bit input: Active high, asynchronous clear (Divided modes only)
      I =&gt; I      -- 1-bit input: Clock buffer input driven by an IBUF, MMCM or local interconnect
   );

   -- End of BUFR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Clock MUXes" treetype="folder">
					<Template label="2-to-1 Global Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
-- BUFGMUX_CTRL : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_CTRL: 2-to-1 Global Clock MUX Buffer
   --               Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL_inst : BUFGMUX_CTRL
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="Global Clock Control Buffer (BUFGCTRL)" treetype="template">
--  BUFGCTRL   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGCTRL: Global Clock Control Buffer
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGCTRL_inst : BUFGCTRL
   generic map (
      INIT_OUT =&gt; 0,         -- Initial value of BUFGCTRL output ($VALUES;)
      PRESELECT_I0 =&gt; FALSE, -- BUFGCTRL output uses I0 input ($VALUES;)
      PRESELECT_I1 =&gt; FALSE  -- BUFGCTRL output uses I1 input ($VALUES;)
   )
   port map (
      O =&gt; O,             -- 1-bit output: Clock output
      CE0 =&gt; CE0,         -- 1-bit input: Clock enable input for I0
      CE1 =&gt; CE1,         -- 1-bit input: Clock enable input for I1
      I0 =&gt; I0,           -- 1-bit input: Primary clock
      I1 =&gt; I1,           -- 1-bit input: Secondary clock
      IGNORE0 =&gt; IGNORE0, -- 1-bit input: Clock ignore input for I0
      IGNORE1 =&gt; IGNORE1, -- 1-bit input: Clock ignore input for I1
      S0 =&gt; S0,           -- 1-bit input: Clock select for I0
      S1 =&gt; S1            -- 1-bit input: Clock select for I1
   );

   -- End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer (BUFGMUX)" treetype="template">
--   BUFGMUX   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX: Global Clock Mux Buffer
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_inst : BUFGMUX
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
--  BUFGMUX_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BUFGMUX_1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BUFGMUX_1: Global Clock Mux Buffer with Output State 1
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1_inst : BUFGMUX_1
   port map (
      O =&gt; O,   -- 1-bit output: Clock output
      I0 =&gt; I0, -- 1-bit input: Clock input (S=0)
      I1 =&gt; I1, -- 1-bit input: Clock input (S=1)
      S =&gt; S    -- 1-bit input: Clock select
   );

   -- End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MMCM / PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCME2_ADV)" treetype="template">
-- MMCME2_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME2_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME2_ADV: Advanced Mixed Mode Clock Manager
   --             Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   MMCME2_ADV_inst : MMCME2_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",      -- Jitter programming (OPTIMIZED, HIGH, LOW)
      CLKFBOUT_MULT_F =&gt; 5.0,        -- Multiply value for all CLKOUT (2.000-64.000).
      CLKFBOUT_PHASE =&gt; 0.0,         -- Phase offset in degrees of CLKFB (-360.000-360.000).
      -- CLKIN_PERIOD: Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      -- CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT0_DIVIDE_F =&gt; 1.0,       -- Divide amount for CLKOUT0 (1.000-128.000).
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.01-0.99).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      CLKOUT4_CASCADE =&gt; FALSE,      -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      COMPENSATION =&gt; "ZHOLD",       -- ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,            -- Master division value (1-106)
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; FALSE,         -- Delays DONE until MMCM is locked (FALSE, TRUE)
      -- Spread Spectrum: Spread Spectrum Attributes
      SS_EN =&gt; "FALSE",              -- Enables spread spectrum (FALSE, TRUE)
      SS_MODE =&gt; "CENTER_HIGH",      -- CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      SS_MOD_PERIOD =&gt; 10000,        -- Spread spectrum modulation period (ns) (VALUES)
      -- USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      CLKFBOUT_USE_FINE_PS =&gt; FALSE,
      CLKOUT0_USE_FINE_PS =&gt; FALSE,
      CLKOUT1_USE_FINE_PS =&gt; FALSE,
      CLKOUT2_USE_FINE_PS =&gt; FALSE,
      CLKOUT3_USE_FINE_PS =&gt; FALSE,
      CLKOUT4_USE_FINE_PS =&gt; FALSE,
      CLKOUT5_USE_FINE_PS =&gt; FALSE,
      CLKOUT6_USE_FINE_PS =&gt; FALSE 
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,           -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,         -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,           -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,         -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,           -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,         -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,           -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,         -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,           -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,           -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,           -- 1-bit output: CLKOUT6
      -- DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      DO =&gt; DO,                     -- 16-bit output: DRP data
      DRDY =&gt; DRDY,                 -- 1-bit output: DRP ready
      -- Dynamic Phase Shift Ports: 1-bit (each) output: Ports used for dynamic phase shifting of the outputs
      PSDONE =&gt; PSDONE,             -- 1-bit output: Phase shift done
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,         -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB,       -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports: 1-bit (each) output: MMCM status ports
      CLKFBSTOPPED =&gt; CLKFBSTOPPED, -- 1-bit output: Feedback clock stopped
      CLKINSTOPPED =&gt; CLKINSTOPPED, -- 1-bit output: Input clock stopped
      LOCKED =&gt; LOCKED,             -- 1-bit output: LOCK
      -- Clock Inputs: 1-bit (each) input: Clock inputs
      CLKIN1 =&gt; CLKIN1,             -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,             -- 1-bit input: Secondary clock
      -- Control Ports: 1-bit (each) input: MMCM control ports
      CLKINSEL =&gt; CLKINSEL,         -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,             -- 1-bit input: Power-down
      RST =&gt; RST,                   -- 1-bit input: Reset
      -- DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,               -- 7-bit input: DRP address
      DCLK =&gt; DCLK,                 -- 1-bit input: DRP clock
      DEN =&gt; DEN,                   -- 1-bit input: DRP enable
      DI =&gt; DI,                     -- 16-bit input: DRP data
      DWE =&gt; DWE,                   -- 1-bit input: DRP write enable
      -- Dynamic Phase Shift Ports: 1-bit (each) input: Ports used for dynamic phase shifting of the outputs
      PSCLK =&gt; PSCLK,               -- 1-bit input: Phase shift clock
      PSEN =&gt; PSEN,                 -- 1-bit input: Phase shift enable
      PSINCDEC =&gt; PSINCDEC,         -- 1-bit input: Phase shift increment/decrement
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN            -- 1-bit input: Feedback clock
   );

   -- End of MMCME2_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase Locked Loop (PLLE2_ADV)" treetype="template">
--  PLLE2_ADV  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE2_ADV_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE2_ADV: Advanced Phase Locked Loop (PLL)
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   PLLE2_ADV_inst : PLLE2_ADV
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",  -- OPTIMIZED, HIGH, LOW
      CLKFBOUT_MULT =&gt; 5,        -- Multiply value for all CLKOUT, (2-64)
      CLKFBOUT_PHASE =&gt; 0.0,     -- Phase offset in degrees of CLKFB, (-360.000-360.000).
      -- CLKIN_PERIOD: Input clock period in nS to ps resolution (i.e. 33.333 is 30 MHz).
      CLKIN1_PERIOD =&gt; 0.0,
      CLKIN2_PERIOD =&gt; 0.0,
      -- CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for CLKOUT (1-128)
      CLKOUT0_DIVIDE =&gt; 1,
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      -- CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      COMPENSATION =&gt; "ZHOLD",   -- ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      DIVCLK_DIVIDE =&gt; 1,        -- Master division value (1-56)
      -- REF_JITTER: Reference input jitter in UI (0.000-0.999).
      REF_JITTER1 =&gt; 0.0,
      REF_JITTER2 =&gt; 0.0,
      STARTUP_WAIT =&gt; "FALSE"    -- Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,   -- 1-bit output: CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,   -- 1-bit output: CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,   -- 1-bit output: CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,   -- 1-bit output: CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,   -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,   -- 1-bit output: CLKOUT5
      -- DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      DO =&gt; DO,             -- 16-bit output: DRP data
      DRDY =&gt; DRDY,         -- 1-bit output: DRP ready
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT, -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,     -- 1-bit output: LOCK
      -- Clock Inputs: 1-bit (each) input: Clock inputs
      CLKIN1 =&gt; CLKIN1,     -- 1-bit input: Primary clock
      CLKIN2 =&gt; CLKIN2,     -- 1-bit input: Secondary clock
      -- Control Ports: 1-bit (each) input: PLL control ports
      CLKINSEL =&gt; CLKINSEL, -- 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      PWRDWN =&gt; PWRDWN,     -- 1-bit input: Power-down
      RST =&gt; RST,           -- 1-bit input: Reset
      -- DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      DADDR =&gt; DADDR,       -- 7-bit input: DRP address
      DCLK =&gt; DCLK,         -- 1-bit input: DRP clock
      DEN =&gt; DEN,           -- 1-bit input: DRP enable
      DI =&gt; DI,             -- 16-bit input: DRP data
      DWE =&gt; DWE,           -- 1-bit input: DRP write enable
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN    -- 1-bit input: Feedback clock
   );

   -- End of PLLE2_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCME2_BASE)" treetype="template">
-- MMCME2_BASE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (MMCME2_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MMCME2_BASE: Base Mixed Mode Clock Manager
   --              Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   MMCME2_BASE_inst : MMCME2_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",  -- Jitter programming (OPTIMIZED, HIGH, LOW)
      CLKFBOUT_MULT_F =&gt; 5.0,    -- Multiply value for all CLKOUT (2.000-64.000).
      CLKFBOUT_PHASE =&gt; 0.0,     -- Phase offset in degrees of CLKFB (-360.000-360.000).
      CLKIN1_PERIOD =&gt; 0.0,      -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      CLKOUT6_DIVIDE =&gt; 1,
      CLKOUT0_DIVIDE_F =&gt; 1.0,   -- Divide amount for CLKOUT0 (1.000-128.000).
      -- CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.01-0.99).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      CLKOUT6_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      CLKOUT6_PHASE =&gt; 0.0,
      CLKOUT4_CASCADE =&gt; FALSE,  -- Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      DIVCLK_DIVIDE =&gt; 1,        -- Master division value (1-106)
      REF_JITTER1 =&gt; 0.0,        -- Reference input jitter in UI (0.000-0.999).
      STARTUP_WAIT =&gt; FALSE      -- Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,     -- 1-bit output: CLKOUT0
      CLKOUT0B =&gt; CLKOUT0B,   -- 1-bit output: Inverted CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,     -- 1-bit output: CLKOUT1
      CLKOUT1B =&gt; CLKOUT1B,   -- 1-bit output: Inverted CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,     -- 1-bit output: CLKOUT2
      CLKOUT2B =&gt; CLKOUT2B,   -- 1-bit output: Inverted CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,     -- 1-bit output: CLKOUT3
      CLKOUT3B =&gt; CLKOUT3B,   -- 1-bit output: Inverted CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,     -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,     -- 1-bit output: CLKOUT5
      CLKOUT6 =&gt; CLKOUT6,     -- 1-bit output: CLKOUT6
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT,   -- 1-bit output: Feedback clock
      CLKFBOUTB =&gt; CLKFBOUTB, -- 1-bit output: Inverted CLKFBOUT
      -- Status Ports: 1-bit (each) output: MMCM status ports
      LOCKED =&gt; LOCKED,       -- 1-bit output: LOCK
      -- Clock Inputs: 1-bit (each) input: Clock input
      CLKIN1 =&gt; CLKIN1,       -- 1-bit input: Clock
      -- Control Ports: 1-bit (each) input: MMCM control ports
      PWRDWN =&gt; PWRDWN,       -- 1-bit input: Power-down
      RST =&gt; RST,             -- 1-bit input: Reset
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN      -- 1-bit input: Feedback clock
   );

   -- End of MMCME2_BASE_inst instantiation
					</Template>
					<Template label="Base Phase Locked Loop (PLLE2_BASE)" treetype="template">
-- PLLE2_BASE  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (PLLE2_BASE_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PLLE2_BASE: Base Phase Locked Loop (PLL)
   --             Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   PLLE2_BASE_inst : PLLE2_BASE
   generic map (
      BANDWIDTH =&gt; "OPTIMIZED",  -- OPTIMIZED, HIGH, LOW
      CLKFBOUT_MULT =&gt; 5,        -- Multiply value for all CLKOUT, (2-64)
      CLKFBOUT_PHASE =&gt; 0.0,     -- Phase offset in degrees of CLKFB, (-360.000-360.000).
      CLKIN1_PERIOD =&gt; 0.0,      -- Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      -- CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for each CLKOUT (1-128)
      CLKOUT0_DIVIDE =&gt; 1,
      CLKOUT1_DIVIDE =&gt; 1,
      CLKOUT2_DIVIDE =&gt; 1,
      CLKOUT3_DIVIDE =&gt; 1,
      CLKOUT4_DIVIDE =&gt; 1,
      CLKOUT5_DIVIDE =&gt; 1,
      -- CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      CLKOUT0_DUTY_CYCLE =&gt; 0.5,
      CLKOUT1_DUTY_CYCLE =&gt; 0.5,
      CLKOUT2_DUTY_CYCLE =&gt; 0.5,
      CLKOUT3_DUTY_CYCLE =&gt; 0.5,
      CLKOUT4_DUTY_CYCLE =&gt; 0.5,
      CLKOUT5_DUTY_CYCLE =&gt; 0.5,
      -- CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      CLKOUT0_PHASE =&gt; 0.0,
      CLKOUT1_PHASE =&gt; 0.0,
      CLKOUT2_PHASE =&gt; 0.0,
      CLKOUT3_PHASE =&gt; 0.0,
      CLKOUT4_PHASE =&gt; 0.0,
      CLKOUT5_PHASE =&gt; 0.0,
      DIVCLK_DIVIDE =&gt; 1,        -- Master division value, (1-56)
      REF_JITTER1 =&gt; 0.0,        -- Reference input jitter in UI, (0.000-0.999).
      STARTUP_WAIT =&gt; "FALSE"    -- Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   port map (
      -- Clock Outputs: 1-bit (each) output: User configurable clock outputs
      CLKOUT0 =&gt; CLKOUT0,   -- 1-bit output: CLKOUT0
      CLKOUT1 =&gt; CLKOUT1,   -- 1-bit output: CLKOUT1
      CLKOUT2 =&gt; CLKOUT2,   -- 1-bit output: CLKOUT2
      CLKOUT3 =&gt; CLKOUT3,   -- 1-bit output: CLKOUT3
      CLKOUT4 =&gt; CLKOUT4,   -- 1-bit output: CLKOUT4
      CLKOUT5 =&gt; CLKOUT5,   -- 1-bit output: CLKOUT5
      -- Feedback Clocks: 1-bit (each) output: Clock feedback ports
      CLKFBOUT =&gt; CLKFBOUT, -- 1-bit output: Feedback clock
      LOCKED =&gt; LOCKED,     -- 1-bit output: LOCK
      CLKIN1 =&gt; CLKIN1,     -- 1-bit input: Input clock
      -- Control Ports: 1-bit (each) input: PLL control ports
      PWRDWN =&gt; PWRDWN,     -- 1-bit input: Power-down
      RST =&gt; RST,           -- 1-bit input: Reset
      -- Feedback Clocks: 1-bit (each) input: Clock feedback ports
      CLKFBIN =&gt; CLKFBIN    -- 1-bit input: Feedback clock
   );

   -- End of PLLE2_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Config/BSCAN Components" treetype="folder">
				<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
--  EFUSE_USR  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (EFUSE_USR_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- EFUSE_USR: 32-bit non-volatile design ID
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   EFUSE_USR_inst : EFUSE_USR
   generic map (
      SIM_EFUSE_VALUE =&gt; X"00000000"  -- Value of the 32-bit non-volatile value used in simulation
   )
   port map (
      EFUSEUSR =&gt; EFUSEUSR  -- 32-bit output: User eFUSE register value output
   );

   -- End of EFUSE_USR_inst instantiation
				</Template>
				<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
--   BSCANE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (BSCANE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- BSCANE2: Boundary-Scan User Instruction
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   BSCANE2_inst : BSCANE2
   generic map (
      JTAG_CHAIN =&gt; 1  -- Value for USER command.
   )
   port map (
      CAPTURE =&gt; CAPTURE, -- 1-bit output: CAPTURE output from TAP controller.
      DRCK =&gt; DRCK,       -- 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                          -- SHIFT are asserted.

      RESET =&gt; RESET,     -- 1-bit output: Reset output for TAP controller.
      RUNTEST =&gt; RUNTEST, -- 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      SEL =&gt; SEL,         -- 1-bit output: USER instruction active output.
      SHIFT =&gt; SHIFT,     -- 1-bit output: SHIFT output from TAP controller.
      TCK =&gt; TCK,         -- 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      TDI =&gt; TDI,         -- 1-bit output: Test Data Input (TDI) output from TAP controller.
      TMS =&gt; TMS,         -- 1-bit output: Test Mode Select output. Fabric connection to TAP.
      UPDATE =&gt; UPDATE,   -- 1-bit output: UPDATE output from TAP controller
      TDO =&gt; TDO          -- 1-bit input: Test Data Output (TDO) input for USER function.
   );

   -- End of BSCANE2_inst instantiation
				</Template>
				<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
-- USR_ACCESSE2 : In order to incorporate this function into the design,
--     VHDL     : the following instance declaration needs to be placed
--   instance   : in the body of the design code.  The instance name
-- declaration  : (USR_ACCESSE2_inst) and/or the port declarations after the
--     code     : "=&gt;" declaration maybe changed to properly reference and
--              : connect this function to the design.  All inputs and outputs
--              : must be connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--    Xilinx    : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- USR_ACCESSE2: Configuration Data Access
   --               Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2_inst : USR_ACCESSE2
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration Clock output
      DATA =&gt; DATA,           -- 32-bit output: Configuration Data output
      DATAVALID =&gt; DATAVALID  -- 1-bit output: Active high data valid output
   );

   -- End of USR_ACCESSE2_inst instantiation
				</Template>
				<Template label="Configuration Frame Error Correction (FRAME_ECCE2)" treetype="template">
-- FRAME_ECCE2 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FRAME_ECCE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FRAME_ECCE2: Configuration Frame Error Correction
   --              Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   FRAME_ECCE2_inst : FRAME_ECCE2
   generic map (
      FARSRC =&gt; "EFAR",                -- Determines if the output of FAR[25:0] configuration register points
                                       -- to the FAR or EFAR. Sets configuration option register bit CTL0[7].
      FRAME_RBT_IN_FILENAME =&gt; "None"  -- This file is output by the ICAP_E2 model and it contains Frame Data
                                       -- information for the Raw Bitstream (RBT) file. The FRAME_ECCE2 model
                                       -- will parse this file, calculate ECC and output any error conditions.
   )
   port map (
      CRCERROR =&gt; CRCERROR,             -- 1-bit output: Output indicating a CRC error.
      ECCERROR =&gt; ECCERROR,             -- 1-bit output: Output indicating an ECC error.
      ECCERRORSINGLE =&gt; ECCERRORSINGLE, -- 1-bit output: Output Indicating single-bit Frame ECC error detected.
      FAR =&gt; FAR,                       -- 26-bit output: Frame Address Register Value output.
      SYNBIT =&gt; SYNBIT,                 -- 5-bit output: Output bit address of error.
      SYNDROME =&gt; SYNDROME,             -- 13-bit output: Output location of erroneous bit.
      SYNDROMEVALID =&gt; SYNDROMEVALID,   -- 1-bit output: Frame ECC output indicating the SYNDROME output is
                                        -- valid.

      SYNWORD =&gt; SYNWORD                -- 7-bit output: Word output in the frame where an ECC error has been
                                        -- detected.

   );

   -- End of FRAME_ECCE2_inst instantiation
				</Template>
				<Template label="Device DNA Access Port (DNA_PORT)" treetype="template">
--  DNA_PORT   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DNA_PORT_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DNA_PORT: Device DNA Access Port
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   DNA_PORT_inst : DNA_PORT
   generic map (
      SIM_DNA_VALUE =&gt; X"000000000000000"  -- Specifies a sample 57-bit DNA value for simulation
   )
   port map (
      DOUT =&gt; DOUT,   -- 1-bit output: DNA output data.
      CLK =&gt; CLK,     -- 1-bit input: Clock input.
      DIN =&gt; DIN,     -- 1-bit input: User data input pin.
      READ =&gt; READ,   -- 1-bit input: Active high load DNA, active low read input.
      SHIFT =&gt; SHIFT  -- 1-bit input: Active high shift enable input.
   );

   -- End of DNA_PORT_inst instantiation
				</Template>
				<Template label="Internal Configuration Access Port (ICAPE2)" treetype="template">
--   ICAPE2    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ICAPE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ICAPE2: Internal Configuration Access Port
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   ICAPE2_inst : ICAPE2
   generic map (
      DEVICE_ID =&gt; X"3651093",     -- Specifies the pre-programmed Device ID value to be used for simulation
                                   -- purposes.
      ICAP_WIDTH =&gt; "X32",         -- Specifies the input and output data width.
      SIM_CFG_FILE_NAME =&gt; "None"  -- Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                   -- model.
   )
   port map (
      O =&gt; O,         -- 32-bit output: Configuration data output bus
      CLK =&gt; CLK,     -- 1-bit input: Clock Input
      CSIB =&gt; CSIB,   -- 1-bit input: Active-Low ICAP Enable
      I =&gt; I,         -- 32-bit input: Configuration data input bus
      RDWRB =&gt; RDWRB  -- 1-bit input: Read/Write Select input
   );

   -- End of ICAPE2_inst instantiation
				</Template>
				<Template label="Register Capture (CAPTUREE2)" treetype="template">
--  CAPTUREE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (CAPTUREE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CAPTUREE2: Register Capture
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   CAPTUREE2_inst : CAPTUREE2
   generic map (
      ONESHOT =&gt; "TRUE"  -- Specifies the procedure for performing single readback per CAP trigger.
   )
   port map (
      CAP =&gt; CAP, -- 1-bit input: Capture Input
      CLK =&gt; CLK  -- 1-bit input: Clock Input
   );

   -- End of CAPTUREE2_inst instantiation
				</Template>
				<Template label="STARTUP Block (STARTUPE2)" treetype="template">
--  STARTUPE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (STARTUPE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- STARTUPE2: STARTUP Block
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   STARTUPE2_inst : STARTUPE2
   generic map (
      PROG_USR =&gt; "FALSE",  -- Activate program event security feature. Requires encrypted bitstreams.
      SIM_CCLK_FREQ =&gt; 0.0  -- Set the Configuration Clock Frequency(ns) for simulation.
   )
   port map (
      CFGCLK =&gt; CFGCLK,       -- 1-bit output: Configuration main clock output
      CFGMCLK =&gt; CFGMCLK,     -- 1-bit output: Configuration internal oscillator clock output
      EOS =&gt; EOS,             -- 1-bit output: Active high output signal indicating the End Of Startup.
      PREQ =&gt; PREQ,           -- 1-bit output: PROGRAM request to fabric output
      CLK =&gt; CLK,             -- 1-bit input: User start-up clock input
      GSR =&gt; GSR,             -- 1-bit input: Global Set/Reset input (GSR cannot be used for the port name)
      GTS =&gt; GTS,             -- 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      KEYCLEARB =&gt; KEYCLEARB, -- 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      PACK =&gt; PACK,           -- 1-bit input: PROGRAM acknowledge input
      USRCCLKO =&gt; USRCCLKO,   -- 1-bit input: User CCLK input
      USRCCLKTS =&gt; USRCCLKTS, -- 1-bit input: User CCLK 3-state enable input
      USRDONEO =&gt; USRDONEO,   -- 1-bit input: User DONE pin output control
      USRDONETS =&gt; USRDONETS  -- 1-bit input: User DONE 3-state enable output
   );

   -- End of STARTUPE2_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="I/O Components" treetype="folder">
				<SubFolder label="Bi-directional Buffers" treetype="folder">
					<Template label="Differential Buffer (IOBUFDS)" treetype="template">

--   IOBUFDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUFDS_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS: Differential Bi-directional Buffer
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_inst : IOBUFDS
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; TRUE, -- Low Power = TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      SLEW =&gt; "SLOW")       -- Specify the output slew rate
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ input and DCI disable(IOBUFDS_DCIEN)" treetype="template">

--IOBUFDS_DCIEN : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUFDS_DCIEN_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DCIEN: Differential Bi-directional Buffer with Digital Controlled Impedance (DCI)
   --                and Input path enable/disable
   --                May only be placed in High Performance (HP) Banks
   --                Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DCIEN_inst : IOBUFDS_DCIEN
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, HIGH Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      SLEW =&gt; "SLOW",   -- Specify the output slew rate
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable
      T =&gt; T      -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_DCIEN_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ input and input termination disable (IOBUFDS_INTERMDISABLE)" treetype="template">

--IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
--    VHDL              : the following instance declaration needs to be placed
--  instance            : in the architecture body of the design code.  The
-- declaration          : instance name (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations
--    code              : after the "=&gt;" assignment maybe changed to properly
--                      : connect this function to the design. All inputs must be
--                      : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_INTERMDISABLE: Differential Bi-directional Buffer with Input Termination
   --                        and Input path enable/disable
   --                        May only be placed in High Range (HR) Banks
   --                        Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_INTERMDISABLE_inst : IOBUFDS_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, HIGH Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      SLEW =&gt; "SLOW",   -- Specify the output slew rate
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input termination disable input
      T =&gt; T      -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output, input and DCI disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">

--IOBUFDS_DIFF_OUT_DCIEN: In order to incorporate this function into the design,
--    VHDL           : the following instance declaration needs to be placed
--  instance         : in the architecture body of the design code.  The
-- declaration       : instance name (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations
--    code           : after the "=&gt;" assignment maybe changed to properly
--                   : connect this function to the design. All inputs must be
--                   : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_DCIEN: Differential Bi-directional Buffer with Differential Output,
   --                         Digital Controlled Impedance (DCI)and Input path enable/disable
   --                         May only be placed in High Performance (HP) Banks
   --                         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_DCIEN_inst : IOBUFDS_DIFF_OUT_DCIEN
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function, "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer p-side output
      OB =&gt; OB,   -- Buffer n-side output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFTERMDISABLE =&gt; IBUFTERMDISABLE, -- input disable input, low=disable
      TM =&gt; TM,   -- 3-state enable input, high=input, low=output
      TS =&gt; TS    -- 3-state enable input, high=output, low=input
   );
  
   -- End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation

					</Template>
					<Template label="Differential Buffer with Differential Output (IOBUFDS_DIFF_OUT)" treetype="template">

--IOBUFDS_DIFF_OUT   : In order to incorporate this function into the design,
--    VHDL           : the following instance declaration needs to be placed
--  instance         : in the architecture body of the design code.  The
-- declaration       : instance name (IOBUFDS_DIFF_OUT_inst) and/or the port declarations
--    code           : after the "=&gt;" assignment maybe changed to properly
--                   : connect this function to the design. All inputs must be
--                   : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT: Differential Bi-directional Buffer with Diffirential Output
   --                   Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_inst : IOBUFDS_DIFF_OUT
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; TRUE, -- Low Power - TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25") -- Specify the I/O standard
   port map (
      O =&gt; O,     -- Buffer p-side output
      OB =&gt; OB,   -- Buffer n-side output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      TM =&gt; TM,   -- 3-state enable input, high=input, low=output
      TS =&gt; TS    -- 3-state enable input, high=input, low=output
   );
  
   -- End of IOBUFDS_DIFF_OUT_inst instantiation

					</Template>
					<Template label="Differential Global Clock Buffer w/ Differential Output, INTERM and IBUF disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">

--IOBUFDS_DIFF_OUT_INTERMDISABLE: In order to incorporate this function into the design,
--         VHDL                 : the following instance declaration needs to be placed
--       instance               : in the architecture body of the design code.  The
--      declaration             : instance name (IOBUFDS_DIFF_OUT_INTRMDISABLE_inst) and/or the port declarations
--         code                 : after the "=&gt;" assignment maybe changed to properly
--                              : connect this function to the design. All inputs must be
--                              : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUFDS_DIFF_OUT_INTERMDISABLE:  Differential Global Clock Buffer with Differential Output
   --                                  Input Termination and Input Path Disable
   --                                  May only be placed in High Range (HR) Banks
   --                                  Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst : IOBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination (TRUE/FALSE)
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - TRUE, High Performance = FALSE
      IOSTANDARD =&gt; "BLVDS_25", -- Specify the I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Use IBUFDISABLE function, "TRUE" or "FALSE" 
   port map (
      O =&gt; O,     -- Buffer p-side output
      OB =&gt; OB,   -- Buffer n-side output
      IO =&gt; IO,   -- Diff_p inout (connect directly to top-level port)
      IOB =&gt; IOB, -- Diff_n inout (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- input disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input termination disable input 
      TM =&gt; TM,   -- 3-state enable input, high=input, low=output
      TS =&gt; TS    -- 3-state enable input, high=output, low=input
   );
  
   -- End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation

					</Template>
					<Template label="Single-ended Buffer (IOBUF)" treetype="template">

--    IOBUF    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUF_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF: Single-ended Bi-directional Buffer
   --        Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUF_inst : IOBUF
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Buffer inout port (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input, high=input, low=output 
   );
  
   -- End of IOBUF_inst instantiation


					</Template>
					<Template label="Single-ended Buffer w/input and DCI disable (IOBUF_DCIEN)" treetype="template">

-- IOBUF_DCIEN : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IOBUF_DCIEN_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_DCIEN: Single-ended Bi-directional Buffer with Digital Controlled Impedance (DCI)
   --              and Input path enable/disable
   --              May only be placed in High Performance (HP) Banks
   --              Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUF_DCIEN_inst : IOBUF_DCIEN
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      IBUF_LOW_PWR =&gt; "TRUE",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Buffer inout port (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable 
      T =&gt; T      -- 3-state enable input, high=input, low=output 
   );
  
   -- End of IOBUF_DCIEN_inst instantiation

					</Template>
					<Template label="Single-ended Buffer w/ input and INTERM disable (IOBUF_INTERMDISABLE)" treetype="template">

-- IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
--       VHDL          : the following instance declaration needs to be placed
--     instance        : in the architecture body of the design code.  The
--   declaration       : instance name (IOBUF_INTERMDISABLE_inst) and/or the port declarations
--       code          : after the "=&gt;" assignment maybe changed to properly
--                     : connect this function to the design. All inputs must be
--                     : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IOBUF_INTERMDISABLE: Single-ended Bi-directional Buffer with Input Termination
   --                      and Input path enable/disable
   --                      May only be placed in High Range (HR) Banks
   --                      Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IOBUF_INTERMDISABLE_inst : IOBUF_INTERMDISABLE
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT", -- Specify the I/O standard
      IBUF_LOW_PWR =&gt; "TRUE", -- Low Power - "TRUE", High Performance = "FALSE" 
      USE_IBUFDISABLE =&gt; "TRUE", -- Use IBUFDISABLE function "TRUE" or "FALSE" 
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output
      IO =&gt; IO,   -- Buffer inout port (connect directly to top-level port)
      DCITERMDISABLE =&gt; DCITERMDISABLE, -- DCI Termination enable input
      I =&gt; I,     -- Buffer input
      IBUFDISABLE =&gt; IBUFDISABLE, -- Input disable input, high=disable
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input termination disable input
      T =&gt; T      -- 3-state enable input, high=input, low=output 
   );
  
   -- End of IOBUF_DCIEN_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="DDR Registers" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
--    IDDR_2CLK  : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The
--   declaration : instance name (IDDR_2CLK_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design.  All inputs must be 
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   --            Set, Reset and Clock Enable.
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK_inst : IDDR_2CLK 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit primary clock input
      CB =&gt; CB, -- 1-bit secondary clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_2CLK_inst instantiation

					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
--      IDDR     : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The 
--   declaration : instance name (IDDR_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design. All inputs must be
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR: Double Data Rate Input Register with Set, Reset
   --       and Clock Enable. 
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_inst : IDDR 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_inst instantiation

					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
--      ODDR       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (ODDR_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs  
--                 : and outputs must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDR: Output Double Data Rate Output Register with Set, Reset
   --       and Clock Enable. 
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   ODDR_inst : ODDR
   generic map(
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE" or "SAME_EDGE" 
      INIT =&gt; '0',   -- Initial value for Q port ('1' or '0')
      SRTYPE =&gt; "SYNC") -- Reset Type ("ASYNC" or "SYNC")
   port map (
      Q =&gt; Q,   -- 1-bit DDR output
      C =&gt; C,    -- 1-bit clock input
      CE =&gt; CE,  -- 1-bit clock enable input
      D1 =&gt; D1,  -- 1-bit data input (positive edge)
      D2 =&gt; D2,  -- 1-bit data input (negative edge)
      R =&gt; R,    -- 1-bit reset input
      S =&gt; S     -- 1-bit set input
   );
  
   -- End of ODDR_inst instantiation


					</Template>
				</SubFolder>
				<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
--  DCIRESET   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (DCIRESET_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- DCIRESET: Digitally Controlled Impedance Reset Component
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   DCIRESET_inst : DCIRESET
   port map (
      LOCKED =&gt; LOCKED, -- 1-bit output: LOCK status output
      RST =&gt; RST        -- 1-bit input: Active-high asynchronous reset input
   );

   -- End of DCIRESET_inst instantiation
				</Template>
				<SubFolder label="FIFOs" treetype="folder">
					<Template label="Input FIFO (IN_FIFO)" treetype="template">
--   IN_FIFO   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IN_FIFO_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IN_FIFO: Input First-In, First-Out (FIFO)
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IN_FIFO_inst : IN_FIFO
   generic map (
      ALMOST_EMPTY_VALUE =&gt; 1,          -- Almost empty offset (1-2)
      ALMOST_FULL_VALUE =&gt; 1,           -- Almost full offset (1-2)
      ARRAY_MODE =&gt; "ARRAY_MODE_4_X_8", -- ARRAY_MODE_4_X_8, ARRAY_MODE_4_X_4
      SYNCHRONOUS_MODE =&gt; "FALSE"       -- Clock synchronous (FALSE)
   )
   port map (
      -- FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY, -- 1-bit output: Almost empty
      ALMOSTFULL =&gt; ALMOSTFULL,   -- 1-bit output: Almost full
      EMPTY =&gt; EMPTY,             -- 1-bit output: Empty
      FULL =&gt; FULL,               -- 1-bit output: Full
      -- Q0-Q9: 8-bit (each) output: FIFO Outputs
      Q0 =&gt; Q0,                   -- 8-bit output: Channel 0
      Q1 =&gt; Q1,                   -- 8-bit output: Channel 1
      Q2 =&gt; Q2,                   -- 8-bit output: Channel 2
      Q3 =&gt; Q3,                   -- 8-bit output: Channel 3
      Q4 =&gt; Q4,                   -- 8-bit output: Channel 4
      Q5 =&gt; Q5,                   -- 8-bit output: Channel 5
      Q6 =&gt; Q6,                   -- 8-bit output: Channel 6
      Q7 =&gt; Q7,                   -- 8-bit output: Channel 7
      Q8 =&gt; Q8,                   -- 8-bit output: Channel 8
      Q9 =&gt; Q9,                   -- 8-bit output: Channel 9
      -- D0-D9: 4-bit (each) input: FIFO inputs
      D0 =&gt; D0,                   -- 4-bit input: Channel 0
      D1 =&gt; D1,                   -- 4-bit input: Channel 1
      D2 =&gt; D2,                   -- 4-bit input: Channel 2
      D3 =&gt; D3,                   -- 4-bit input: Channel 3
      D4 =&gt; D4,                   -- 4-bit input: Channel 4
      D5 =&gt; D5,                   -- 8-bit input: Channel 5
      D6 =&gt; D6,                   -- 8-bit input: Channel 6
      D7 =&gt; D7,                   -- 4-bit input: Channel 7
      D8 =&gt; D8,                   -- 4-bit input: Channel 8
      D9 =&gt; D9,                   -- 4-bit input: Channel 9
      -- FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      RDCLK =&gt; RDCLK,             -- 1-bit input: Read clock
      RDEN =&gt; RDEN,               -- 1-bit input: Read enable
      RESET =&gt; RESET,             -- 1-bit input: Reset
      WRCLK =&gt; WRCLK,             -- 1-bit input: Write clock
      WREN =&gt; WREN                -- 1-bit input: Write enable
   );

   -- End of IN_FIFO_inst instantiation
					</Template>
					<Template label="Output FIFO (OUT_FIFO)" treetype="template">
--  OUT_FIFO   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OUT_FIFO_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OUT_FIFO: Output First-In, First-Out (FIFO) Buffer
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   OUT_FIFO_inst : OUT_FIFO
   generic map (
      ALMOST_EMPTY_VALUE =&gt; 1,          -- Almost empty offset (1-2)
      ALMOST_FULL_VALUE =&gt; 1,           -- Almost full offset (1-2)
      ARRAY_MODE =&gt; "ARRAY_MODE_8_X_4", -- ARRAY_MODE_8_X_4, ARRAY_MODE_4_X_4
      OUTPUT_DISABLE =&gt; "FALSE",        -- Disable output (FALSE, TRUE)
      SYNCHRONOUS_MODE =&gt; "FALSE"       -- Must always be set to false.
   )
   port map (
      -- FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY, -- 1-bit output: Almost empty flag
      ALMOSTFULL =&gt; ALMOSTFULL,   -- 1-bit output: Almost full flag
      EMPTY =&gt; EMPTY,             -- 1-bit output: Empty flag
      FULL =&gt; FULL,               -- 1-bit output: Full flag
      -- Q0-Q9: 4-bit (each) output: FIFO Outputs
      Q0 =&gt; Q0,                   -- 4-bit output: Channel 0 output bus
      Q1 =&gt; Q1,                   -- 4-bit output: Channel 1 output bus
      Q2 =&gt; Q2,                   -- 4-bit output: Channel 2 output bus
      Q3 =&gt; Q3,                   -- 4-bit output: Channel 3 output bus
      Q4 =&gt; Q4,                   -- 4-bit output: Channel 4 output bus
      Q5 =&gt; Q5,                   -- 8-bit output: Channel 5 output bus
      Q6 =&gt; Q6,                   -- 8-bit output: Channel 6 output bus
      Q7 =&gt; Q7,                   -- 4-bit output: Channel 7 output bus
      Q8 =&gt; Q8,                   -- 4-bit output: Channel 8 output bus
      Q9 =&gt; Q9,                   -- 4-bit output: Channel 9 output bus
      -- D0-D9: 8-bit (each) input: FIFO inputs
      D0 =&gt; D0,                   -- 8-bit input: Channel 0 input bus
      D1 =&gt; D1,                   -- 8-bit input: Channel 1 input bus
      D2 =&gt; D2,                   -- 8-bit input: Channel 2 input bus
      D3 =&gt; D3,                   -- 8-bit input: Channel 3 input bus
      D4 =&gt; D4,                   -- 8-bit input: Channel 4 input bus
      D5 =&gt; D5,                   -- 8-bit input: Channel 5 input bus
      D6 =&gt; D6,                   -- 8-bit input: Channel 6 input bus
      D7 =&gt; D7,                   -- 8-bit input: Channel 7 input bus
      D8 =&gt; D8,                   -- 8-bit input: Channel 8 input bus
      D9 =&gt; D9,                   -- 8-bit input: Channel 9 input bus
      -- FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      RDCLK =&gt; RDCLK,             -- 1-bit input: Read clock
      RDEN =&gt; RDEN,               -- 1-bit input: Read enable
      RESET =&gt; RESET,             -- 1-bit input: Active high reset
      WRCLK =&gt; WRCLK,             -- 1-bit input: Write clock
      WREN =&gt; WREN                -- 1-bit input: Write enable
   );

   -- End of OUT_FIFO_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Input Buffers" treetype="folder">
					<Template label="Differential Buffer (IBUFDS)" treetype="template">

--   IBUFDS    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IBUFDS_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS: Differential Input Buffer
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_inst : IBUFDS
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination 
      IBUF_LOW_PWR =&gt; TRUE, -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT")
   port map (
      O =&gt; O,  -- Buffer output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB -- Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ Disable (IBUFDS_IBUFDISABLE)" treetype="template">

--IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IBUFDS_IBUFDISABLE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_IBUFDISABLE: Differential Input Buffer w/ Disable
   --                     Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE_inst : IBUFDS_IBUFDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,  -- Buffer output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, low=disable
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Differential Buffer with Differential Output (IBUFDS_DIFF_OUT)" treetype="template">

--IBUFDS_DIFF_OUT: In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : instance name (IBUFDS_DIFF_OUT_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT: Differential Input Buffer with Differential Output
   --                  Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_inst : IBUFDS_DIFF_OUT
   generic map (
      DIFF_TERM =&gt; FALSE, -- Differential Termination 
      IBUF_LOW_PWR =&gt; TRUE, -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT") -- Specify the input I/O standard
   port map (
      O =&gt; O,     -- Buffer diff_p output
      OB =&gt; OB,   -- Buffer diff_n output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB -- Diff_n buffer input (connect directly to top-level port)
   );

   -- End of IBUFDS_DIFF_OUT_inst instantiation


					</Template>
					<Template label="Differential Buffer with Differential Output w/Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">

--IBUFDS_DIFF_OUT_IBUFDISABLE: In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : instance name (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer with Differential Output w/ Disable
   --                              Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE_inst : IBUFDS_DIFF_OUT_IBUFDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power "TRUE" vs. performance "FALSE" setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer diff_p output
      OB =&gt; OB,   -- Buffer diff_n output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, low=disable
   );

   -- End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Differential Buffer with Differential Output w/Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">

--IBUFDS_DIFF_OUT_INTERMDISABLE: In order to incorporate this function into the design,
--     VHDL      : the following instance declaration needs to be placed
--   instance    : in the architecture body of the design code.  The
--  declaration  : instance name (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations
--     code      : after the "=&gt;" assignment maybe changed to properly
--               : reference and connect this function to the design.
--               : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Differential Output w/ Disable
   --                                Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE_inst : IBUFDS_DIFF_OUT_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power "TRUE" vs. performance "FALSE" setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer diff_p output
      OB =&gt; OB,   -- Buffer diff_n output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- Buffer disable input, low=disable
      INTERMDISABLE =&gt; INTERMDISABLE -- Input termination disable
   );

   -- End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation

					</Template>
					<Template label="Differential Buffer w/ Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">

--IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (IBUFDS_INTERMDISABLE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUFDS_INTERMDISABLE: Differential Input Buffer with Input Termination Disable
   --                       May only be placed in High Range (HR) Banks
   --                       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE_inst : IBUFDS_INTERMDISABLE
   generic map (
      DIFF_TERM =&gt; "FALSE", -- Differential Termination 
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,  -- Buffer output
      I =&gt; I,  -- Diff_p buffer input (connect directly to top-level port)
      IB =&gt; IB, -- Diff_n buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE, -- Buffer disable input, low=disable
      INTERMDIBSALE =&gt; INTERMDISABLE -- Input termination disable
   );

   -- End of IBUFDS_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Single-ended Buffer (IBUF)" treetype="template">

--      IBUF       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (IBUF_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs must be
--                 : connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF: Single-ended Input Buffer
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IBUF_inst : IBUF
   generic map (
      IBUF_LOW_PWR =&gt; TRUE, -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT")
   port map (
      O =&gt; O,     -- Buffer output
      I =&gt; I      -- Buffer input (connect directly to top-level port)
   );
  
   -- End of IBUF_inst instantiation

					</Template>
					<Template label="Single-ended Buffer w/ Disable (IBUF_IBUFDISABLE)" treetype="template">

--IBUF_IBUFDISABLE : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (IBUF_IBUFDISABLE_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs must be
--                 : connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_IBUFDISABLE: Single-ended Input Buffer with Disable
   --                   Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IBUF_IBUFDISABLE_inst : IBUF_IBUFDISABLE
   generic map (
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer output
      I =&gt; I,     -- Buffer input (connect directly to top-level port)
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, low=disable
   );
  
   -- End of IBUF_IBUFDISABLE_inst instantiation

					</Template>
					<Template label="Single-ended Buffer w/ Termination Disable (IBUF_INTERMDISABLE)" treetype="template">

--IBUF_INTERMDISABLE : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (IBUF_INTERMDISABLE_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs must be
--                 : connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IBUF_INTERMDISABLE: Single-ended Input Buffer with Termination Input Disable
   --                     May only be placed in High Range (HR) Banks
   --                     Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   IBUF_INTERMDISABLE_inst : IBUF_INTERMDISABLE
   generic map (
      IBUF_LOW_PWR =&gt; "TRUE", -- Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards
      IOSTANDARD =&gt; "DEFAULT", -- Specify the input I/O standard
      USE_IBUFDISABLE =&gt; "TRUE") -- Set to "TRUE" to enable IBUFDISABLE feature
   port map (
      O =&gt; O,     -- Buffer output
      I =&gt; I,     -- Buffer input (connect directly to top-level port)
      INTERMDISABLE =&gt; INTERMDISABLE, -- Input Termination Disable
      IBUFDISABLE =&gt; IBUFDISABLE -- Buffer disable input, low=disable
   );
  
   -- End of IBUF_INTERMDISABLE_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="I/O Delay Components" treetype="folder">
					<Template label="Delay Calibration (IDELAYCTRL)" treetype="template">
-- IDELAYCTRL  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYCTRL_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  Put the following attribute before the 'begin' statement
--  Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

attribute IODELAY_GROUP : STRING;
attribute IODELAY_GROUP of &lt;label_name&gt;: label is "&lt;iodelay_group_name&gt;";

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYCTRL: IDELAYE2/ODELAYE2 Tap Delay Value Control
   --             Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL_inst : IDELAYCTRL
   port map (
      RDY =&gt; RDY,       -- 1-bit output: Ready output
      REFCLK =&gt; REFCLK, -- 1-bit input: Reference clock input
      RST =&gt; RST        -- 1-bit input: Active high reset input
   );

   -- End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE2)" treetype="template">
--  IDELAYE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (IDELAYE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  Put the following attribute before the 'begin' statement
--  Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

attribute IODELAY_GROUP : STRING;
attribute IODELAY_GROUP of &lt;label_name&gt;: label is "&lt;iodelay_group_name&gt;";

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDELAYE2: Input Fixed or Variable Delay Element
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDELAYE2_inst : IDELAYE2
   generic map (
      CINVCTRL_SEL =&gt; "FALSE",          -- Enable dynamic clock inversion (FALSE, TRUE)
      DELAY_SRC =&gt; "IDATAIN",           -- Delay input (IDATAIN, DATAIN)
      HIGH_PERFORMANCE_MODE =&gt; "FALSE", -- Reduced jitter ("TRUE"), Reduced power ("FALSE")
      IDELAY_TYPE =&gt; "FIXED",           -- FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      IDELAY_VALUE =&gt; 0,                -- Input delay tap setting (0-31)
      PIPE_SEL =&gt; "FALSE",              -- Select pipelined mode, FALSE, TRUE
      REFCLK_FREQUENCY =&gt; 200.0,        -- IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      SIGNAL_PATTERN =&gt; "DATA"          -- DATA, CLOCK input signal
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 5-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data output
      C =&gt; C,                     -- 1-bit input: Clock input
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CINVCTRL =&gt; CINVCTRL,       -- 1-bit input: Dynamic clock inversion input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 5-bit input: Counter value input
      DATAIN =&gt; DATAIN,           -- 1-bit input: Internal delay data input
      IDATAIN =&gt; IDATAIN,         -- 1-bit input: Data input from the I/O
      INC =&gt; INC,                 -- 1-bit input: Increment / Decrement tap delay input
      LD =&gt; LD,                   -- 1-bit input: Load IDELAY_VALUE input
      LDPIPEEN =&gt; LDPIPEEN,       -- 1-bit input: Enable PIPELINE register to load data input
      REGRST =&gt; REGRST            -- 1-bit input: Active-high reset tap-delay input
   );

   -- End of IDELAYE2_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE2)" treetype="template">
--  ODELAYE2   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ODELAYE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  Put the following attribute before the 'begin' statement
--  Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

attribute IODELAY_GROUP : STRING;
attribute IODELAY_GROUP of &lt;label_name&gt;: label is "&lt;iodelay_group_name&gt;";

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODELAYE2: Output Fixed or Variable Delay Element
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   ODELAYE2_inst : ODELAYE2
   generic map (
      CINVCTRL_SEL =&gt; "FALSE",          -- Enable dynamic clock inversion (FALSE, TRUE)
      DELAY_SRC =&gt; "ODATAIN",           -- Delay input (ODATAIN, CLKIN)
      HIGH_PERFORMANCE_MODE =&gt; "FALSE", -- Reduced jitter ("TRUE"), Reduced power ("FALSE")
      ODELAY_TYPE =&gt; "FIXED",           -- FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      ODELAY_VALUE =&gt; 0,                -- Output delay tap setting (0-31)
      PIPE_SEL =&gt; "FALSE",              -- Select pipelined mode, FALSE, TRUE
      REFCLK_FREQUENCY =&gt; 200.0,        -- IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      SIGNAL_PATTERN =&gt; "DATA"          -- DATA, CLOCK input signal
   )
   port map (
      CNTVALUEOUT =&gt; CNTVALUEOUT, -- 5-bit output: Counter value output
      DATAOUT =&gt; DATAOUT,         -- 1-bit output: Delayed data/clock output
      C =&gt; C,                     -- 1-bit input: Clock input
      CE =&gt; CE,                   -- 1-bit input: Active high enable increment/decrement input
      CINVCTRL =&gt; CINVCTRL,       -- 1-bit input: Dynamic clock inversion input
      CLKIN =&gt; CLKIN,             -- 1-bit input: Clock delay input
      CNTVALUEIN =&gt; CNTVALUEIN,   -- 5-bit input: Counter value input
      INC =&gt; INC,                 -- 1-bit input: Increment / Decrement tap delay input
      LD =&gt; LD,                   -- 1-bit input: Loads ODELAY_VALUE tap delay in VARIABLE mode, in VAR_LOAD or
                                  -- VAR_LOAD_PIPE mode, loads the value of CNTVALUEIN

      LDPIPEEN =&gt; LDPIPEEN,       -- 1-bit input: Enables the pipeline register to load data
      ODATAIN =&gt; ODATAIN,         -- 1-bit input: Output delay data input
      REGRST =&gt; REGRST            -- 1-bit input: Active-high reset tap-delay input
   );

   -- End of ODELAYE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="I/O SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer with Bitslip (ISERDESE2)" treetype="template">
--  ISERDESE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (ISERDESE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ISERDESE2: Input SERial/DESerializer with Bitslip
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   ISERDESE2_inst : ISERDESE2
   generic map (
      DATA_RATE =&gt; "DDR",           -- DDR, SDR
      DATA_WIDTH =&gt; 4,              -- Parallel data width (2-8,10,14)
      DYN_CLKDIV_INV_EN =&gt; "FALSE", -- Enable DYNCLKDIVINVSEL inversion (FALSE, TRUE)
      DYN_CLK_INV_EN =&gt; "FALSE",    -- Enable DYNCLKINVSEL inversion (FALSE, TRUE)
      -- INIT_Q1 - INIT_Q4: Initial value on the Q outputs (0/1)
      INIT_Q1 =&gt; '0',
      INIT_Q2 =&gt; '0',
      INIT_Q3 =&gt; '0',
      INIT_Q4 =&gt; '0',
      INTERFACE_TYPE =&gt; "MEMORY",   -- MEMORY, MEMORY_DDR3, MEMORY_QDR, NETWORKING, OVERSAMPLE
      IOBDELAY =&gt; "NONE",           -- NONE, BOTH, IBUF, IFD
      NUM_CE =&gt; 2,                  -- Number of clock enables (1,2)
      OFB_USED =&gt; "FALSE",          -- Select OFB path (FALSE, TRUE)
      SERDES_MODE =&gt; "MASTER",      -- MASTER, SLAVE
      -- SRVAL_Q1 - SRVAL_Q4: Q output values when SR is used (0/1)
      SRVAL_Q1 =&gt; '0',
      SRVAL_Q2 =&gt; '0',
      SRVAL_Q3 =&gt; '0',
      SRVAL_Q4 =&gt; '0' 
   )
   port map (
      O =&gt; O,                       -- 1-bit output: Combinatorial output
      -- Q1 - Q8: 1-bit (each) output: Registered data outputs
      Q1 =&gt; Q1,
      Q2 =&gt; Q2,
      Q3 =&gt; Q3,
      Q4 =&gt; Q4,
      Q5 =&gt; Q5,
      Q6 =&gt; Q6,
      Q7 =&gt; Q7,
      Q8 =&gt; Q8,
      -- SHIFTOUT1, SHIFTOUT2: 1-bit (each) output: Data width expansion output ports
      SHIFTOUT1 =&gt; SHIFTOUT1,
      SHIFTOUT2 =&gt; SHIFTOUT2,
      BITSLIP =&gt; BITSLIP,           -- 1-bit input: The BITSLIP pin performs a Bitslip operation synchronous to
                                    -- CLKDIV when asserted (active High). Subsequently, the data seen on the
                                    -- Q1 to Q8 output ports will shift, as in a barrel-shifter operation, one
                                    -- position every time Bitslip is invoked (DDR operation is different from
                                    -- SDR).

      -- CE1, CE2: 1-bit (each) input: Data register clock enable inputs
      CE1 =&gt; CE1,
      CE2 =&gt; CE2,
      CLKDIVP =&gt; CLKDIVP,           -- 1-bit input: TBD
      -- Clocks: 1-bit (each) input: ISERDESE2 clock input ports
      CLK =&gt; CLK,                   -- 1-bit input: High-speed clock
      CLKB =&gt; CLKB,                 -- 1-bit input: High-speed secondary clock
      CLKDIV =&gt; CLKDIV,             -- 1-bit input: Divided clock
      OCLK =&gt; OCLK,                 -- 1-bit input: High speed output clock used when INTERFACE_TYPE="MEMORY" 
      -- Dynamic Clock Inversions: 1-bit (each) input: Dynamic clock inversion pins to switch clock polarity
      DYNCLKDIVSEL =&gt; DYNCLKDIVSEL, -- 1-bit input: Dynamic CLKDIV inversion
      DYNCLKSEL =&gt; DYNCLKSEL,       -- 1-bit input: Dynamic CLK/CLKB inversion
      -- Input Data: 1-bit (each) input: ISERDESE2 data input ports
      D =&gt; D,                       -- 1-bit input: Data input
      DDLY =&gt; DDLY,                 -- 1-bit input: Serial data from IDELAYE2
      OFB =&gt; OFB,                   -- 1-bit input: Data feedback from OSERDESE2
      OCLKB =&gt; OCLKB,               -- 1-bit input: High speed negative edge output clock
      RST =&gt; RST,                   -- 1-bit input: Active high asynchronous reset
      -- SHIFTIN1, SHIFTIN2: 1-bit (each) input: Data width expansion input ports
      SHIFTIN1 =&gt; SHIFTIN1,
      SHIFTIN2 =&gt; SHIFTIN2 
   );

   -- End of ISERDESE2_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer with bitslip (OSERDESE2)" treetype="template">
--  OSERDESE2  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (OSERDESE2_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OSERDESE2: Output SERial/DESerializer with bitslip
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   OSERDESE2_inst : OSERDESE2
   generic map (
      DATA_RATE_OQ =&gt; "DDR",   -- DDR, SDR
      DATA_RATE_TQ =&gt; "DDR",   -- DDR, BUF, SDR
      DATA_WIDTH =&gt; 4,         -- Parallel data width (2-8,10,14)
      INIT_OQ =&gt; '0',          -- Initial value of OQ output (1'b0,1'b1)
      INIT_TQ =&gt; '0',          -- Initial value of TQ output (1'b0,1'b1)
      SERDES_MODE =&gt; "MASTER", -- MASTER, SLAVE
      SRVAL_OQ =&gt; '0',         -- OQ output value when SR is used (1'b0,1'b1)
      SRVAL_TQ =&gt; '0',         -- TQ output value when SR is used (1'b0,1'b1)
      TBYTE_CTL =&gt; "FALSE",    -- Enable tristate byte operation (FALSE, TRUE)
      TBYTE_SRC =&gt; "FALSE",    -- Tristate byte source (FALSE, TRUE)
      TRISTATE_WIDTH =&gt; 4      -- 3-state converter width (1,4)
   )
   port map (
      OFB =&gt; OFB,             -- 1-bit output: Feedback path for data
      OQ =&gt; OQ,               -- 1-bit output: Data path output
      -- SHIFTOUT1 / SHIFTOUT2: 1-bit (each) output: Data output expansion (1-bit each)
      SHIFTOUT1 =&gt; SHIFTOUT1,
      SHIFTOUT2 =&gt; SHIFTOUT2,
      TBYTEOUT =&gt; TBYTEOUT,   -- 1-bit output: Byte group tristate
      TFB =&gt; TFB,             -- 1-bit output: 3-state control
      TQ =&gt; TQ,               -- 1-bit output: 3-state control
      CLK =&gt; CLK,             -- 1-bit input: High speed clock
      CLKDIV =&gt; CLKDIV,       -- 1-bit input: Divided clock
      -- D1 - D8: 1-bit (each) input: Parallel data inputs (1-bit each)
      D1 =&gt; D1,
      D2 =&gt; D2,
      D3 =&gt; D3,
      D4 =&gt; D4,
      D5 =&gt; D5,
      D6 =&gt; D6,
      D7 =&gt; D7,
      D8 =&gt; D8,
      OCE =&gt; OCE,             -- 1-bit input: Output data clock enable
      RST =&gt; RST,             -- 1-bit input: Reset
      -- SHIFTIN1 / SHIFTIN2: 1-bit (each) input: Data input expansion (1-bit each)
      SHIFTIN1 =&gt; SHIFTIN1,
      SHIFTIN2 =&gt; SHIFTIN2,
      -- T1 - T4: 1-bit (each) input: Parallel 3-state inputs
      T1 =&gt; T1,
      T2 =&gt; T2,
      T3 =&gt; T3,
      T4 =&gt; T4,
      TBYTEIN =&gt; TBYTEIN,     -- 1-bit input: Byte group tristate
      TCE =&gt; TCE              -- 1-bit input: 3-state clock enable
   );

   -- End of OSERDESE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Output" treetype="folder">
					<Template label="Differential Buffer (OBUFDS)" treetype="template">

--   OBUFDS     : In order to incorporate this function into the design,
--    VHDL      : the following instance declaration needs to be placed
--  instance    : in the architecture body of the design code.  The
-- declaration  : instance name (OBUFDS_inst) and/or the port declarations
--    code      : after the "=&gt;" assignment maybe changed to properly
--              : connect this function to the design. All inputs must be
--              : connected.

--   Library    : In addition to adding the instance declaration, a use
-- declaration  : statement for the UNISIM.vcomponents library needs to be
--     for      : added before the entity declaration.  This library
--   Xilinx     : contains the component declarations for all Xilinx
--  primitives  : primitives and points to the models that will be used
--              : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFDS: Differential Output Buffer
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUFDS_inst : OBUFDS
   generic map (
      IOSTANDARD =&gt; "DEFAULT", -- Specify the output I/O standard
      SLEW =&gt; "SLOW")          -- Specify the output slew rate
   port map (
      O =&gt; O,     -- Diff_p output (connect directly to top-level port)
      OB =&gt; OB,   -- Diff_n output (connect directly to top-level port)
      I =&gt; I      -- Buffer input 
   );
  
   -- End of OBUFDS_inst instantiation

					</Template>
					<Template label="Differential 3-state Buffer (OBUFTDS)" treetype="template">

--   OBUFTDS   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (OBUFTDS_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFTDS: Differential 3-state Output Buffer
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUFTDS_inst : OBUFTDS
   generic map (
      IOSTANDARD =&gt; "DEFAULT")
   port map (
      O =&gt; O,     -- Diff_p output (connect directly to top-level port)
      OB =&gt; OB,   -- Diff_n output (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input
   );
  
   -- End of OBUFTDS_inst instantiation

					</Template>
					<Template label="Single-ended Buffer (OBUF)" treetype="template">

--    OBUF     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (OBUF_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUF: Single-ended Output Buffer
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUF_inst : OBUF
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output (connect directly to top-level port)
      I =&gt; I      -- Buffer input 
   );
  
   -- End of OBUF_inst instantiation

					</Template>
					<Template label="Single-ended 3-state Buffer (OBUFT)" treetype="template">

--    OBUFT    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (OBUFT_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- OBUFT: Single-ended 3-state Output Buffer
   --        Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   OBUFT_inst : OBUFT
   generic map (
      DRIVE =&gt; 12,
      IOSTANDARD =&gt; "DEFAULT",
      SLEW =&gt; "SLOW")
   port map (
      O =&gt; O,     -- Buffer output (connect directly to top-level port)
      I =&gt; I,     -- Buffer input
      T =&gt; T      -- 3-state enable input 
   );
  
   -- End of OBUFT_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Weak drivers" treetype="folder">
					<Template label="KEEPER" treetype="template">

--   KEEPER    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (KEEPER_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design.  

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- KEEPER: I/O Buffer Weak Keeper
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   KEEPER_inst : KEEPER
   port map (
      O =&gt; O     -- Keeper output (connect directly to top-level port)
   );
  
   -- End of KEEPER_inst instantiation


					</Template>
					<Template label="PULLDOWN" treetype="template">

--  PULLDOWN   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (PULLDOWN_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design.  

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLDOWN: I/O Buffer Weak Pull-down
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   PULLDOWN_inst : PULLDOWN
   port map (
      O =&gt; O     -- Pulldown output (connect directly to top-level port)
   );
  
   -- End of PULLDOWN_inst instantiation

					</Template>
					<Template label="PULLUP" treetype="template">

--   PULLUP    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (PULLUP_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- PULLUP: I/O Buffer Weak Pull-up
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   PULLUP_inst : PULLUP
   port map (
      O =&gt; O     -- Pullup output (connect directly to top-level port)
   );
  
   -- End of PULLUP_inst instantiation

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="RAM/ROM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E1)" treetype="template">
--  RAMB18E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB18E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB18E1: 18K-bit Configurable Synchronous Block RAM
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAMB18E1_inst : RAMB18E1
   generic map (
      -- Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      RDADDR_COLLISION_HWCONFIG =&gt; "DELAYED_WRITE",
      -- Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0 or 1)
      DOA_REG =&gt; 0,
      DOB_REG =&gt; 0,
      -- INITP_00 to INITP_07: Initial contents of parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_3F: Initial contents of data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"00000",
      INIT_B =&gt; X"00000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- RAM Mode: "SDP" or "TDP" 
      RAM_MODE =&gt; "TDP",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-72
      READ_WIDTH_B =&gt; 0,                                                               -- 0-18
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-18
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-72
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"00000",
      SRVAL_B =&gt; X"00000",
      -- Simulation Device: Must be set to "7SERIES" for simulation behavior
      SIM_DEVICE =&gt; "7SERIES",
      -- WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      WRITE_MODE_A =&gt; "WRITE_FIRST",
      WRITE_MODE_B =&gt; "WRITE_FIRST" 
   )
   port map (
      -- Port A Data: 16-bit (each) output: Port A data
      DOADO =&gt; DOADO,                 -- 16-bit output: A port data/LSB data
      DOPADOP =&gt; DOPADOP,             -- 2-bit output: A port parity/LSB parity
      -- Port B Data: 16-bit (each) output: Port B data
      DOBDO =&gt; DOBDO,                 -- 16-bit output: B port data/MSB data
      DOPBDOP =&gt; DOPBDOP,             -- 2-bit output: B port parity/MSB parity
      -- Port A Address/Control Signals: 14-bit (each) input: Port A address and control signals (read port
      -- when RAM_MODE="SDP")
      ADDRARDADDR =&gt; ADDRARDADDR,     -- 14-bit input: A port address/Read address
      CLKARDCLK =&gt; CLKARDCLK,         -- 1-bit input: A port clock/Read clock
      ENARDEN =&gt; ENARDEN,             -- 1-bit input: A port enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,     -- 1-bit input: A port register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM, -- 1-bit input: A port set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG, -- 1-bit input: A port register set/reset
      WEA =&gt; WEA,                     -- 2-bit input: A port write enable
      -- Port A Data: 16-bit (each) input: Port A data
      DIADI =&gt; DIADI,                 -- 16-bit input: A port data/LSB data
      DIPADIP =&gt; DIPADIP,             -- 2-bit input: A port parity/LSB parity
      -- Port B Address/Control Signals: 14-bit (each) input: Port B address and control signals (write port
      -- when RAM_MODE="SDP")
      ADDRBWRADDR =&gt; ADDRBWRADDR,     -- 14-bit input: B port address/Write address
      CLKBWRCLK =&gt; CLKBWRCLK,         -- 1-bit input: B port clock/Write clock
      ENBWREN =&gt; ENBWREN,             -- 1-bit input: B port enable/Write enable
      REGCEB =&gt; REGCEB,               -- 1-bit input: B port register enable
      RSTRAMB =&gt; RSTRAMB,             -- 1-bit input: B port set/reset
      RSTREGB =&gt; RSTREGB,             -- 1-bit input: B port register set/reset
      WEBWE =&gt; WEBWE,                 -- 4-bit input: B port write enable/Write enable
      -- Port B Data: 16-bit (each) input: Port B data
      DIBDI =&gt; DIBDI,                 -- 16-bit input: B port data/MSB data
      DIPBDIP =&gt; DIPBDIP              -- 2-bit input: B port parity/MSB parity
   );

   -- End of RAMB18E1_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E1)" treetype="template">
--  RAMB36E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (RAMB36E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAMB36E1: 36K-bit Configurable Synchronous Block RAM
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAMB36E1_inst : RAMB36E1
   generic map (
      -- Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      RDADDR_COLLISION_HWCONFIG =&gt; "DELAYED_WRITE",
      -- Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      SIM_COLLISION_CHECK =&gt; "ALL",
      -- DOA_REG, DOB_REG: Optional output register (0 or 1)
      DOA_REG =&gt; 0,
      DOB_REG =&gt; 0,
      EN_ECC_READ =&gt; FALSE,                                                            -- Enable ECC decoder,
                                                                                       -- FALSE, TRUE
      EN_ECC_WRITE =&gt; FALSE,                                                           -- Enable ECC encoder,
                                                                                       -- FALSE, TRUE
      -- INITP_00 to INITP_0F: Initial contents of the parity memory array
      INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INITP_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_00 to INIT_7F: Initial contents of the data memory array
      INIT_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_01 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_02 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_03 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_04 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_05 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_06 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_07 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_08 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_09 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_0F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_10 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_11 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_12 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_13 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_14 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_15 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_16 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_17 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_18 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_19 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_1F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_20 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_21 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_22 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_23 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_24 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_25 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_26 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_27 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_28 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_29 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_2F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_30 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_31 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_32 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_33 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_34 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_35 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_36 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_37 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_38 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_39 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_40 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_41 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_42 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_43 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_44 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_45 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_46 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_47 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_48 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_49 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_4F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_50 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_51 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_52 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_53 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_54 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_55 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_56 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_57 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_58 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_59 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_5F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_60 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_61 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_62 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_63 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_64 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_65 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_66 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_67 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_68 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_69 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_6F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_70 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_71 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_72 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_73 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_74 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_75 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_76 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_77 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_78 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_79 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7A =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7B =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7C =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7D =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7E =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      INIT_7F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
      -- INIT_A, INIT_B: Initial values on output ports
      INIT_A =&gt; X"000000000",
      INIT_B =&gt; X"000000000",
      -- Initialization File: RAM initialization file
      INIT_FILE =&gt; "NONE",
      -- RAM Mode: "SDP" or "TDP" 
      RAM_MODE =&gt; "TDP",
      -- RAM_EXTENSION_A, RAM_EXTENSION_B: Selects cascade mode ("UPPER", "LOWER", or "NONE")
      RAM_EXTENSION_A =&gt; "NONE",
      RAM_EXTENSION_B =&gt; "NONE",
      -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      READ_WIDTH_A =&gt; 0,                                                               -- 0-72
      READ_WIDTH_B =&gt; 0,                                                               -- 0-36
      WRITE_WIDTH_A =&gt; 0,                                                              -- 0-36
      WRITE_WIDTH_B =&gt; 0,                                                              -- 0-72
      -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      RSTREG_PRIORITY_A =&gt; "RSTREG",
      RSTREG_PRIORITY_B =&gt; "RSTREG",
      -- SRVAL_A, SRVAL_B: Set/reset value for output
      SRVAL_A =&gt; X"000000000",
      SRVAL_B =&gt; X"000000000",
      -- Simulation Device: Must be set to "7SERIES" for simulation behavior
      SIM_DEVICE =&gt; "7SERIES",
      -- WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      WRITE_MODE_A =&gt; "WRITE_FIRST",
      WRITE_MODE_B =&gt; "WRITE_FIRST" 
   )
   port map (
      -- Cascade Signals: 1-bit (each) output: BRAM cascade ports (to create 64kx1)
      CASCADEOUTA =&gt; CASCADEOUTA,     -- 1-bit output: A port cascade
      CASCADEOUTB =&gt; CASCADEOUTB,     -- 1-bit output: B port cascade
      -- ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      RDADDRECC =&gt; RDADDRECC,         -- 9-bit output: ECC read address
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Port A Data: 32-bit (each) output: Port A data
      DOADO =&gt; DOADO,                 -- 32-bit output: A port data/LSB data
      DOPADOP =&gt; DOPADOP,             -- 4-bit output: A port parity/LSB parity
      -- Port B Data: 32-bit (each) output: Port B data
      DOBDO =&gt; DOBDO,                 -- 32-bit output: B port data/MSB data
      DOPBDOP =&gt; DOPBDOP,             -- 4-bit output: B port parity/MSB parity
      -- Cascade Signals: 1-bit (each) input: BRAM cascade ports (to create 64kx1)
      CASCADEINA =&gt; CASCADEINA,       -- 1-bit input: A port cascade
      CASCADEINB =&gt; CASCADEINB,       -- 1-bit input: B port cascade
      -- ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error
      INJECTSBITERR =&gt; INJECTSBITERR, -- 1-bit input: Inject a single bit error
      -- Port A Address/Control Signals: 16-bit (each) input: Port A address and control signals (read port
      -- when RAM_MODE="SDP")
      ADDRARDADDR =&gt; ADDRARDADDR,     -- 16-bit input: A port address/Read address
      CLKARDCLK =&gt; CLKARDCLK,         -- 1-bit input: A port clock/Read clock
      ENARDEN =&gt; ENARDEN,             -- 1-bit input: A port enable/Read enable
      REGCEAREGCE =&gt; REGCEAREGCE,     -- 1-bit input: A port register enable/Register enable
      RSTRAMARSTRAM =&gt; RSTRAMARSTRAM, -- 1-bit input: A port set/reset
      RSTREGARSTREG =&gt; RSTREGARSTREG, -- 1-bit input: A port register set/reset
      WEA =&gt; WEA,                     -- 4-bit input: A port write enable
      -- Port A Data: 32-bit (each) input: Port A data
      DIADI =&gt; DIADI,                 -- 32-bit input: A port data/LSB data
      DIPADIP =&gt; DIPADIP,             -- 4-bit input: A port parity/LSB parity
      -- Port B Address/Control Signals: 16-bit (each) input: Port B address and control signals (write port
      -- when RAM_MODE="SDP")
      ADDRBWRADDR =&gt; ADDRBWRADDR,     -- 16-bit input: B port address/Write address
      CLKBWRCLK =&gt; CLKBWRCLK,         -- 1-bit input: B port clock/Write clock
      ENBWREN =&gt; ENBWREN,             -- 1-bit input: B port enable/Write enable
      REGCEB =&gt; REGCEB,               -- 1-bit input: B port register enable
      RSTRAMB =&gt; RSTRAMB,             -- 1-bit input: B port set/reset
      RSTREGB =&gt; RSTREGB,             -- 1-bit input: B port register set/reset
      WEBWE =&gt; WEBWE,                 -- 8-bit input: B port write enable/Write enable
      -- Port B Data: 32-bit (each) input: Port B data
      DIBDI =&gt; DIBDI,                 -- 32-bit input: B port data/MSB data
      DIPBDIP =&gt; DIPBDIP              -- 4-bit input: B port parity/MSB parity
   );

   -- End of RAMB36E1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Distributed RAM" treetype="folder">
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 x 1 negedge write (RAM32X1D_1)" treetype="template">

-- RAM32X1D_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_1_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D_1: 32 x 1 negative edge write, asynchronous read 
   --             dual-port distributed RAM (Mapped to SliceM LUT6)
   --             Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1_inst : RAM32X1D_1
   generic map (
      INIT =&gt; X"00000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_1_inst instantiation

						</Template>
						<Template label="32 x 1 posedge write (RAM32X1D)" treetype="template">

--   RAM32X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1D: 32 x 1 positive edge write, asynchronous read 
   --              dual-port distributed RAM (Mapped to SliceM LUT6)
   --              Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1D_inst : RAM32X1D
   generic map (
      INIT =&gt; X"00000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM32X1D_inst instantiation

						</Template>
						<Template label="64 x 1 negedge write (RAM64X1D_1)" treetype="template">

-- RAM64X1D_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1D: 64 x 1 negative edge write, asynchronous read 
   --           dual-port distributed RAM (Mapped to SliceM LUT6)
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1D_1_inst : RAM64X1D_1
   generic map (
      INIT =&gt; X"0000000000000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      A5 =&gt; A5,       -- R/W address[5] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      DPRA5 =&gt; DPRA5, -- Read-only address[5] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM64X1D_1_inst instantiation

						</Template>
						<Template label="64 x 1 posedge write (RAM64X1D)" treetype="template">

--   RAM64X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1D: 64 x 1 positive edge write, asynchronous read 
   --           dual-port distributed RAM (Mapped to SliceM LUT6)
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1D_inst : RAM64X1D
   generic map (
      INIT =&gt; X"0000000000000000") -- Initial contents of RAM
   port map (
      DPO =&gt; DPO,     -- Read-only 1-bit data output
      SPO =&gt; SPO,     -- R/W 1-bit data output
      A0 =&gt; A0,       -- R/W address[0] input bit
      A1 =&gt; A1,       -- R/W address[1] input bit
      A2 =&gt; A2,       -- R/W address[2] input bit
      A3 =&gt; A3,       -- R/W address[3] input bit
      A4 =&gt; A4,       -- R/W address[4] input bit
      A5 =&gt; A5,       -- R/W address[5] input bit
      D =&gt; D,         -- Write 1-bit data input
      DPRA0 =&gt; DPRA0, -- Read-only address[0] input bit
      DPRA1 =&gt; DPRA1, -- Read-only address[1] input bit
      DPRA2 =&gt; DPRA2, -- Read-only address[2] input bit
      DPRA3 =&gt; DPRA3, -- Read-only address[3] input bit
      DPRA4 =&gt; DPRA4, -- Read-only address[4] input bit
      DPRA5 =&gt; DPRA5, -- Read-only address[5] input bit
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- Write enable input
   );
   
   -- End of RAM64X1D_inst instantiation

						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">

--  RAM128X1D  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1D_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read 
   --            dual-port distributed LUT RAM (Mapped to two SliceM LUT6s)
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1D_inst : RAM128X1D
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      DPO =&gt; DPO,     -- Read/Write port 1-bit ouput
      SPO =&gt; SPO,     -- Read port 1-bit output
      A =&gt; A,         -- Read/Write port 7-bit address input
      D =&gt; D,         -- RAM data input
      DPRA =&gt; DPRA,   -- Read port 7-bit address input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1D_inst instantiation

						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">

--   RAM32M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM32M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32M: 32-deep by 8-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s)
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32M_inst : RAM32M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000")   -- Initial contents of D port
   port map (
      DOA =&gt; DOA, -- Read port A 2-bit output
      DOB =&gt; DOB, -- Read port B 2-bit output
      DOC =&gt; DOC, -- Read port C 2-bit output
      DOD =&gt; DOD, -- Read/Write port D 2-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 5-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 5-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 5-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 5-bit address input
      DIA =&gt; DIA, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 2-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM32M_inst instantiation

						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">

--   RAM64M    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM64M_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64M: 64-deep by 4-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s) 
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64M_inst : RAM64M
   generic map (
      INIT_A =&gt; X"0000000000000000",   -- Initial contents of A port
      INIT_B =&gt; X"0000000000000000",   -- Initial contents of B port
      INIT_C =&gt; X"0000000000000000",   -- Initial contents of C port
      INIT_D =&gt; X"0000000000000000")   -- Initial contents of D port
   port map (
      DOA =&gt; DOA, -- Read port A 1-bit output
      DOB =&gt; DOB, -- Read port B 1-bit output
      DOC =&gt; DOC, -- Read port C 1-bit output
      DOD =&gt; DOD, -- Read/Write port D 1-bit output
      ADDRA =&gt; ADDRA,   -- Read port A 6-bit address input
      ADDRB =&gt; ADDRB,   -- Read port B 6-bit address input
      ADDRC =&gt; ADDRC,   -- Read port C 6-bit address input
      ADDRD =&gt; ADDRD,   -- Read/Write port D 6-bit address input
      DIA =&gt; DIA, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRA
      DIB =&gt; DIB, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRB
      DIC =&gt; DIC, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRC
      DID =&gt; DID, -- RAM 1-bit data write input addressed by ADDRD,
                  -- read addressed by ADDRD
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );
   -- End of RAM64M_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<SubFolder label="32 Deep (5-bit address)" treetype="folder">
							<Template label="32 x 1 negedge write (RAM32X1S_1)" treetype="template">

-- RAM32X1S_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1S_1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1S_1: 32 x 1 negedge write distributed (LUT) RAM (Mapped to SliceM LUT6)
   --             Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1S_1_inst : RAM32X1S_1
   generic map (
      INIT =&gt; X"00000000")
   port map (
      O =&gt; O,       -- RAM output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D =&gt; D,       -- RAM data input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X1S_1_inst instantiation
							</Template>
							<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">

--  RAM32X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM32X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM (Mapped to SliceM LUT6)
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X1S_inst : RAM32X1S
   generic map (
      INIT =&gt; X"00000000")
   port map (
      O =&gt; O,       -- RAM output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D =&gt; D,       -- RAM data input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X1S_inst instantiation
							</Template>
							<Template label="32 x 2 posedge write (RAM32X2S)" treetype="template">

--  RAM32X2S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM16X2S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM32X2S: 32 x 2 posedge write distributed (LUT) RAM (Mapped to SliceM LUT6)
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM32X2S_inst : RAM32X2S
   generic map (
      INIT_00 =&gt; X"00000000", --  INIT for bit 0 of RAM
      INIT_01 =&gt; X"00000000") --  INIT for bit 1 of RAM
   port map (
      O0 =&gt; O0,     -- RAM data[0] output
      O1 =&gt; O1,     -- RAM data[1] output
      A0 =&gt; A0,     -- RAM address[0] input
      A1 =&gt; A1,     -- RAM address[1] input
      A2 =&gt; A2,     -- RAM address[2] input
      A3 =&gt; A3,     -- RAM address[3] input
      A4 =&gt; A4,     -- RAM address[4] input
      D0 =&gt; D0,     -- RAM data[0] input
      D1 =&gt; D1,     -- RAM data[1] input
      WCLK =&gt; WCLK, -- Write clock input
      WE =&gt; WE      -- Write enable input
   );

   -- End of RAM32X2S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="64 Deep (6-bit address)" treetype="folder">
							<Template label="64 X 1 negedge write (RAM64X1S_1)" treetype="template">

--  RAM64X1S_1 : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1S_1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1S_1: 64 x 1 negative edge write, asynchronous read single-port distributed RAM (Mapped to SliceM LUT6)
   --             Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1S_1_inst : RAM64X1S_1
   generic map (
      INIT =&gt; X"0000000000000000")
   port map (
      O =&gt; O,        -- 1-bit data output
      A0 =&gt; A0,      -- Address[0] input bit
      A1 =&gt; A1,      -- Address[1] input bit
      A2 =&gt; A2,      -- Address[2] input bit
      A3 =&gt; A3,      -- Address[3] input bit
      A4 =&gt; A4,      -- Address[4] input bit
      A5 =&gt; A5,      -- Address[5] input bit
      D =&gt; D,        -- 1-bit data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64X1S_1_inst instantiation

							</Template>
							<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">

--  RAM64X1S   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (RAM64X1S_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port distributed RAM (Mapped to SliceM LUT6)
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM64X1S_inst : RAM64X1S
   generic map (
      INIT =&gt; X"0000000000000000")
   port map (
      O =&gt; O,        -- 1-bit data output
      A0 =&gt; A0,      -- Address[0] input bit
      A1 =&gt; A1,      -- Address[1] input bit
      A2 =&gt; A2,      -- Address[2] input bit
      A3 =&gt; A3,      -- Address[3] input bit
      A4 =&gt; A4,      -- Address[4] input bit
      A5 =&gt; A5,      -- Address[5] input bit
      D =&gt; D,        -- 1-bit data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE       -- Write enable input
   );

   -- End of RAM64X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="128 Deep (7-bit address)" treetype="folder">
							<Template label="128 x 1 negedge write (RAM128X1S_1)" treetype="template">

--RAM128X1S_1  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S_1: 128-deep x 1 negative edge write, asynchronous read 
   --              single-port distributed RAM (Mapped to SliceM LUT6)
   --              Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation

							</Template>
							<Template label="128 x 1 posedge write (RAM128X1S)" treetype="template">

--  RAM128X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM128X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM128X1S: 128-deep x 1 positive edge write, asynchronous read 
   --            single-port distributed RAM (Mapped to SliceM LUT6)
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM128X1S_inst : RAM128X1S
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      O =&gt; O,     -- 1-bit data output
      A0 =&gt; A0,   -- Address[0] input bit
      A1 =&gt; A1,   -- Address[1] input bit
      A2 =&gt; A2,   -- Address[2] input bit
      A3 =&gt; A3,   -- Address[3] input bit
      A4 =&gt; A4,   -- Address[4] input bit
      A5 =&gt; A5,   -- Address[5] input bit
      A6 =&gt; A6,   -- Address[6] input bit
      D =&gt; D,         -- 1-bit data input
      WCLK =&gt; WCLK,   -- Write clock input
      WE =&gt; WE        -- RAM data input
   );

   -- End of RAM128X1S_inst instantiation

							</Template>
						</SubFolder>
						<SubFolder label="256 Deep (8-bit address)" treetype="folder">
							<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">

--  RAM256X1S  : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--   instance  : in the architecture body of the design code.  The
-- declaration : instance name (RAM256X1S_inst) and/or the port declarations
--     code    : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read 
   --            single-port distributed LUT RAM (Mapped to four SliceM LUT6s)
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   RAM256X1S_inst : RAM256X1S
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      O =&gt; O,  -- Read/Write port 1-bit ouput
      A =&gt; A,  -- Read/Write port 8-bit address input
      D =&gt; D,  -- RAM data input
      WCLK =&gt; WCLK,  -- Write clock input
      WE =&gt; WE -- Write enable input
   );

   -- End of RAM256X1S_inst instantiation

							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Distributed ROM" treetype="folder">
					<Template label="32 X 1 (ROM32X1)" treetype="template">

--   ROM32X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM32X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM32X1: 32 x 1 Asynchronous Distributed (LUT) ROM
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM32X1_inst : ROM32X1
   generic map (
      INIT =&gt; X"00000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4  -- ROM address[4]
   );
   -- End of ROM32X1_inst instantiation
					</Template>
					<Template label="64 X 1 (ROM64X1)" treetype="template">

--   ROM64X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM64X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM64X1: 64 x 1 Asynchronous Distributed (LUT) ROM
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM64X1_inst : ROM64X1
   generic map (
      INIT =&gt; X"0000000000000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4, -- ROM address[4]
      A5 =&gt; A5  -- ROM address[5]
   );

   -- End of ROM64X1_inst instantiation
					</Template>
					<Template label="128 X 1 (ROM128X1)" treetype="template">

--  ROM128X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM128X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM128X1: 128 x 1 Asynchronous Distributed (LUT) ROM
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM128X1_inst : ROM128X1
   generic map (
      INIT =&gt; X"00000000000000000000000000000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4, -- ROM address[4]
      A5 =&gt; A5, -- ROM address[5]
      A6 =&gt; A6  -- ROM address[6]
   );

   -- End of ROM128X1_inst instantiation
					</Template>
					<Template label="256 X 1 (ROM256X1)" treetype="template">

--   ROM256X1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (ROM256X1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ROM256X1: 256 x 1 Asynchronous Distributed (LUT) ROM
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   ROM256X1_inst : ROM256X1
   generic map (
      INIT =&gt; X"0000000000000000000000000000000000000000000000000000000000000000")
   port map (
      O =&gt; O,   -- ROM output
      A0 =&gt; A0, -- ROM address[0]
      A1 =&gt; A1, -- ROM address[1]
      A2 =&gt; A2, -- ROM address[2]
      A3 =&gt; A3, -- ROM address[3]
      A4 =&gt; A4, -- ROM address[4]
      A5 =&gt; A5, -- ROM address[5]
      A6 =&gt; A6,  -- ROM address[6]
      A7 =&gt; A7  -- ROM address[7]
   );

   -- End of ROM256X1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E1)" treetype="template">
--  FIFO18E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO18E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO18E1: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   FIFO18E1_inst : FIFO18E1
   generic map (
      ALMOST_EMPTY_OFFSET =&gt; X"0080",   -- Sets the almost empty threshold
      ALMOST_FULL_OFFSET =&gt; X"0080",    -- Sets almost full threshold
      DATA_WIDTH =&gt; 4,                  -- Sets data width to 4-36
      DO_REG =&gt; 1,                      -- Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      EN_SYN =&gt; FALSE,                  -- Specifies FIFO as dual-clock (FALSE) or Synchronous (TRUE)
      FIFO_MODE =&gt; "FIFO18",            -- Sets mode to FIFO18 or FIFO18_36
      FIRST_WORD_FALL_THROUGH =&gt; FALSE, -- Sets the FIFO FWFT to FALSE, TRUE
      INIT =&gt; X"000000000",             -- Initial values on output port
      SIM_DEVICE =&gt; "7SERIES",          -- Must be set to "7SERIES" for simulation behavior
      SRVAL =&gt; X"000000000"             -- Set/Reset value for output port
   )
   port map (
      -- Read Data: 32-bit (each) output: Read output data
      DO =&gt; DO,                   -- 32-bit output: Data output
      DOP =&gt; DOP,                 -- 4-bit output: Parity data output
      -- Status: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY, -- 1-bit output: Almost empty flag
      ALMOSTFULL =&gt; ALMOSTFULL,   -- 1-bit output: Almost full flag
      EMPTY =&gt; EMPTY,             -- 1-bit output: Empty flag
      FULL =&gt; FULL,               -- 1-bit output: Full flag
      RDCOUNT =&gt; RDCOUNT,         -- 12-bit output: Read count
      RDERR =&gt; RDERR,             -- 1-bit output: Read error
      WRCOUNT =&gt; WRCOUNT,         -- 12-bit output: Write count
      WRERR =&gt; WRERR,             -- 1-bit output: Write error
      -- Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,             -- 1-bit input: Read clock
      RDEN =&gt; RDEN,               -- 1-bit input: Read enable
      REGCE =&gt; REGCE,             -- 1-bit input: Clock enable
      RST =&gt; RST,                 -- 1-bit input: Asynchronous Reset
      RSTREG =&gt; RSTREG,           -- 1-bit input: Output register set/reset
      -- Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      WRCLK =&gt; WRCLK,             -- 1-bit input: Write clock
      WREN =&gt; WREN,               -- 1-bit input: Write enable
      -- Write Data: 32-bit (each) input: Write input data
      DI =&gt; DI,                   -- 32-bit input: Data input
      DIP =&gt; DIP                  -- 4-bit input: Parity input
   );

   -- End of FIFO18E1_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E1)" treetype="template">
--  FIFO36E1   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the body of the design code.  The instance name
-- declaration : (FIFO36E1_inst) and/or the port declarations after the
--    code     : "=&gt;" declaration maybe changed to properly reference and
--             : connect this function to the design.  All inputs and outputs
--             : must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
-- primitives  : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

-- &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FIFO36E1: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   --           Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   FIFO36E1_inst : FIFO36E1
   generic map (
      ALMOST_EMPTY_OFFSET =&gt; X"0080",   -- Sets the almost empty threshold
      ALMOST_FULL_OFFSET =&gt; X"0080",    -- Sets almost full threshold
      DATA_WIDTH =&gt; 4,                  -- Sets data width to 4-72
      DO_REG =&gt; 1,                      -- Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      EN_ECC_READ =&gt; FALSE,             -- Enable ECC decoder, FALSE, TRUE
      EN_ECC_WRITE =&gt; FALSE,            -- Enable ECC encoder, FALSE, TRUE
      EN_SYN =&gt; FALSE,                  -- Specifies FIFO as Asynchronous (FALSE) or Synchronous (TRUE)
      FIFO_MODE =&gt; "FIFO36",            -- Sets mode to "FIFO36" or "FIFO36_72" 
      FIRST_WORD_FALL_THROUGH =&gt; FALSE, -- Sets the FIFO FWFT to FALSE, TRUE
      INIT =&gt; X"000000000000000000",    -- Initial values on output port
      SIM_DEVICE =&gt; "7SERIES",          -- Must be set to "7SERIES" for simulation behavior
      SRVAL =&gt; X"000000000000000000"    -- Set/Reset value for output port
   )
   port map (
      -- ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      DBITERR =&gt; DBITERR,             -- 1-bit output: Double bit error status
      ECCPARITY =&gt; ECCPARITY,         -- 8-bit output: Generated error correction parity
      SBITERR =&gt; SBITERR,             -- 1-bit output: Single bit error status
      -- Read Data: 64-bit (each) output: Read output data
      DO =&gt; DO,                       -- 64-bit output: Data output
      DOP =&gt; DOP,                     -- 8-bit output: Parity data output
      -- Status: 1-bit (each) output: Flags and other FIFO status outputs
      ALMOSTEMPTY =&gt; ALMOSTEMPTY,     -- 1-bit output: Almost empty flag
      ALMOSTFULL =&gt; ALMOSTFULL,       -- 1-bit output: Almost full flag
      EMPTY =&gt; EMPTY,                 -- 1-bit output: Empty flag
      FULL =&gt; FULL,                   -- 1-bit output: Full flag
      RDCOUNT =&gt; RDCOUNT,             -- 13-bit output: Read count
      RDERR =&gt; RDERR,                 -- 1-bit output: Read error
      WRCOUNT =&gt; WRCOUNT,             -- 13-bit output: Write count
      WRERR =&gt; WRERR,                 -- 1-bit output: Write error
      -- ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      INJECTDBITERR =&gt; INJECTDBITERR, -- 1-bit input: Inject a double bit error input
      INJECTSBITERR =&gt; INJECTSBITERR,
      -- Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      RDCLK =&gt; RDCLK,                 -- 1-bit input: Read clock
      RDEN =&gt; RDEN,                   -- 1-bit input: Read enable
      REGCE =&gt; REGCE,                 -- 1-bit input: Clock enable
      RST =&gt; RST,                     -- 1-bit input: Reset
      RSTREG =&gt; RSTREG,               -- 1-bit input: Output register set/reset
      -- Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      WRCLK =&gt; WRCLK,                 -- 1-bit input: Rising edge write clock.
      WREN =&gt; WREN,                   -- 1-bit input: Write enable
      -- Write Data: 64-bit (each) input: Write input data
      DI =&gt; DI,                       -- 64-bit input: Data input
      DIP =&gt; DIP                      -- 8-bit input: Parity input
   );

   -- End of FIFO36E1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Registers &amp; Latches" treetype="folder">
				<SubFolder label="Double Data Rate" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
--    IDDR_2CLK  : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The
--   declaration : instance name (IDDR_2CLK_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design.  All inputs must be 
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   --            Set, Reset and Clock Enable.
   --            Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK_inst : IDDR_2CLK 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit primary clock input
      CB =&gt; CB, -- 1-bit secondary clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_2CLK_inst instantiation

					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
--      IDDR     : In order to incorporate this function into the design,
--      VHDL     : the following instance declaration needs to be placed
--    instance   : in the architecture body of the design code.  The 
--   declaration : instance name (IDDR_inst) and/or the port declarations
--      code     : after the "=&gt;" assignment maybe changed to properly
--               : connect this function to the design. All inputs must be
--               : connected.

--    Library    : In addition to adding the instance declaration, a use
--  declaration  : statement for the UNISIM.vcomponents library needs to be
--      for      : added before the entity declaration.  This library
--    Xilinx     : contains the component declarations for all Xilinx
--   primitives  : primitives and points to the models that will be used
--               : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- IDDR: Double Data Rate Input Register with Set, Reset
   --       and Clock Enable. 
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   IDDR_inst : IDDR 
   generic map (
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE", "SAME_EDGE" 
                                       -- or "SAME_EDGE_PIPELINED" 
      INIT_Q1 =&gt; '0', -- Initial value of Q1: '0' or '1'
      INIT_Q2 =&gt; '0', -- Initial value of Q2: '0' or '1'
      SRTYPE =&gt; "SYNC") -- Set/Reset type: "SYNC" or "ASYNC" 
   port map (
      Q1 =&gt; Q1, -- 1-bit output for positive edge of clock 
      Q2 =&gt; Q2, -- 1-bit output for negative edge of clock
      C =&gt; C,   -- 1-bit clock input
      CE =&gt; CE, -- 1-bit clock enable input
      D =&gt; D,   -- 1-bit DDR data input
      R =&gt; R,   -- 1-bit reset
      S =&gt; S    -- 1-bit set
      );

   -- End of IDDR_inst instantiation

					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
--      ODDR       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the architecture body of the design code.  The
--   declaration   : instance name (ODDR_inst) and/or the port declarations
--      code       : after the "=&gt;" assignment maybe changed to properly
--                 : connect this function to the design. All inputs  
--                 : and outputs must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- ODDR: Output Double Data Rate Output Register with Set, Reset
   --       and Clock Enable. 
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   ODDR_inst : ODDR
   generic map(
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE" or "SAME_EDGE" 
      INIT =&gt; '0',   -- Initial value for Q port ('1' or '0')
      SRTYPE =&gt; "SYNC") -- Reset Type ("ASYNC" or "SYNC")
   port map (
      Q =&gt; Q,   -- 1-bit DDR output
      C =&gt; C,    -- 1-bit clock input
      CE =&gt; CE,  -- 1-bit clock enable input
      D1 =&gt; D1,  -- 1-bit data input (positive edge)
      D2 =&gt; D2,  -- 1-bit data input (negative edge)
      R =&gt; R,    -- 1-bit reset input
      S =&gt; S     -- 1-bit set input
   );
  
   -- End of ODDR_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Single Data Rate" treetype="folder">
					<Template label="Posedge D-FF /w Async Clear, and CE (FDCE)" treetype="template">

--    FDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDCE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and
   --       Clock Enable (posedge clk).  
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDCE_inst : FDCE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      CLR =&gt; CLR,  -- Asynchronous clear input
      D =&gt; D       -- Data input
   );
  
   -- End of FDCE_inst instantiation
					</Template>
					<Template label="Posedge D-FF /w Async Preset, and CE (FDPE)" treetype="template">

--    FDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDPE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDPE: Single Data Rate D Flip-Flop with Asynchronous Preset and
   --       Clock Enable (posedge clk).  
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDPE_inst : FDPE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      PRE =&gt; PRE,  -- Asynchronous preset input
      D =&gt; D       -- Data input
   );
  
   -- End of FDPE_inst instantiation
					</Template>
					<Template label="Posedge D-FF /w Sync Reset, and CE (FDRE)" treetype="template">

--    FDRE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDRE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
   --       Clock Enable (posedge clk).  
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDRE_inst : FDRE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      R =&gt; R,      -- Synchronous reset input
      D =&gt; D       -- Data input
   );
  
   -- End of FDRE_inst instantiation

					</Template>
					<Template label="Posedge D-FF /w Sync Set, and CE (FDSE)" treetype="template">

--    FDSE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (FDSE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- FDSE: Single Data Rate D Flip-Flop with Synchronous Set and
   --       Clock Enable (posedge clk).  
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   FDSE_inst : FDSE
   generic map (
      INIT =&gt; '0') -- Initial value of register ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      C =&gt; C,      -- Clock input
      CE =&gt; CE,    -- Clock enable input
      S =&gt; S,      -- Synchronous Set input
      D =&gt; D       -- Data input
   );
  
   -- End of FDSE_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Transparent Latch" treetype="folder">
					<Template label="Latch with Async Reset and Gate Enable (LDCE)" treetype="template">

--    LDCE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LDCE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDCE: Transparent latch with Asynchronous Reset and
   --        Gate Enable.
   --        Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LDCE_inst : LDCE
   generic map (
      INIT =&gt; '0') -- Initial value of latch ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      CLR =&gt; CLR,  -- Asynchronous clear/reset input
      D =&gt; D,      -- Data input
      G =&gt; G,      -- Gate input
      GE =&gt; GE     -- Gate enable input
   );

   -- End of LDCE_inst instantiation

					</Template>
					<Template label="Latch with Async Set and Gate Enable (LDPE)" treetype="template">

--    LDPE     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LDPE_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : connect this function to the design. All inputs must be
--             : connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LDPE:  Transparent latch with Asynchronous Set and
   --        Gate Enable.
   --        Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LDPE_inst : LDPE
   generic map (
      INIT =&gt; '0') -- Initial value of latch ('0' or '1')  
   port map (
      Q =&gt; Q,      -- Data output
      CLR =&gt; CLR,  -- Asynchronous preset/set input
      D =&gt; D,      -- Data input
      G =&gt; G,      -- Gate input
      GE =&gt; GE     -- Gate enable input
   );

   -- End of LDPE_inst instantiation

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Slice/CLB Primitives" treetype="folder">
				<Template label="Carry (CARRY4)" treetype="template">
--    CARRY4       : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (CARRY4_inst) and/or the port declarations after the
--      code       : "=&gt;" assignment maybe changed to properly reference and
--                 : connect this function to the design.  All inputs and 
--                 : outputs of this primitive must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CARRY4: Fast Carry Logic Component
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   CARRY4_inst : CARRY4
   port map (
      CO =&gt; CO,         -- 4-bit carry out
      O =&gt; O,           -- 4-bit carry chain XOR data out
      CI =&gt; CI,         -- 1-bit carry cascade input
      CYINIT =&gt; CYINIT, -- 1-bit carry initialization
      DI =&gt; DI,         -- 4-bit carry-MUX data in
      S =&gt; S            -- 4-bit carry-MUX select input
   );

   -- End of CARRY4_inst instantiation

				</Template>
				<SubFolder label="LUTs" treetype="folder">
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
-- The INIT constant for the FPGA LUT primitive is what gives the LUT its 
-- logical value. By default this value is zero thus driving the output to a  
-- zero regardless of the input values (acting as a ground) however in most 
-- cases an new INIT value must be determined in order to specify the logic 
-- function for the LUT primitive.  There are a few methods in which the LUT 
-- value can be determined and two of those methods will be discussed here.
--
-- The Truth Table Method
-- ----------------------
--
--  A common method to determine the desired INIT value for a LUT is using a 
-- truth table.  To do so, simply create a binary truth table of all possible 
-- inputs, specify the desired logic value of the output and then create the 
-- INIT string from those output values.  An example is shown below:
--
-- Example of determining an XOR INIT equation for a LUT4:
--
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | 0 |\
--     |  0  0  0  1 | 1 | \ = 0110 = 6 -----------+
--     |  0  0  1  0 | 1 | /                       |
--     |  0  0  1  1 | 0 |/                        |
--     |-------------|---|                         |
--     |  0  1  0  0 | 1 |\                        |
--     |  0  1  0  1 | 0 | \ = 1001 = 9            |
--     |  0  1  1  0 | 0 | /                       |
--     |  0  1  1  1 | 1 |/                        |                     
--     |-------------|---|               INIT = 6996
--     |  1  0  0  0 | 1 |\                     |
--     |  1  0  0  1 | 0 | \ = 0110 = 9         |
--     |  1  0  1  0 | 0 | /                    |
--     |  1  0  1  1 | 1 |/                     |
--     |-------------|---|                      |
--     |  1  1  0  0 | 0 |\                     |
--     |  1  1  0  1 | 1 | \ = 1001 = 6---------+
--     |  1  1  1  0 | 1 | /
--     |  1  1  1  1 | 0 |/
--     -------------------
--
-- Example of determining a 3-input AND gate:
--
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | 0 |\
--     |  0  0  1 | 0 | \ = 0000 = 0 -----------+
--     |  0  1  0 | 0 | /                       |
--     |  0  1  1 | 0 |/                        |
--     |----------|---|                 INIT = 80 
--     |  1  0  0 | 0 |\                       |
--     |  1  0  1 | 0 | \ = 1000 = 8-----------+
--     |  1  1  0 | 0 | / 
--     |  1  1  1 | 1 |/                      
--     ----------------
--
-- The Equation Method
-- -------------------
--
-- Another method to determine the LUT value is to define constants for each 
-- input to the LUT that correspond to their listed truth value and use those to
-- build the logic equation you are after.  This method is easier to understand 
-- once you have grasped the concept and more self-documenting that the above 
-- method however does require the code to first specify the appropriate 
-- constants.  See the example below.
--
-- Example of specifying the equation (A and B) or (C and D) for a LUT4:
--
   -- The following constants are defined to allow for
   --   equation-based INIT specification.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00"; 


   -- LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; (I3 and I2) or (I1 and I0))
   port map (
      O =&gt; O_LUT,   -- LUT general output
      I0 =&gt; A, -- LUT input
      I1 =&gt; B, -- LUT input
      I2 =&gt; C, -- LUT input
      I3 =&gt; D  -- LUT input
   );
   -- End of LUT4_inst instantiation

-- With the constants specifying all possible cases for the truth table, a 
-- VHDL equation can be written to determine the end INIT value.

						</Template>
						<SubFolder label="INIT Constants" treetype="folder">
							<Template label="LUT1" treetype="template">
   -- The following constant is defined to allow for
   --   equation-based INIT specification for a LUT1.
   constant I0 : BIT_VECTOR(1 downto 0) := "10";
   -- The following constant is defined to allow for
   --   equation-based INIT specification for a LUT1.
   constant I0 : BIT_VECTOR(1 downto 0) := "10";
							</Template>
							<Template label="LUT2" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT2.
   constant I0 : BIT_VECTOR(3 downto 0) := X"A";
   constant I1 : BIT_VECTOR(3 downto 0) := X"C";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT2.
   constant I0 : BIT_VECTOR(3 downto 0) := X"A";
   constant I1 : BIT_VECTOR(3 downto 0) := X"C";
							</Template>
							<Template label="LUT3" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT3.
   constant I0 : BIT_VECTOR(7 downto 0) := X"AA";
   constant I1 : BIT_VECTOR(7 downto 0) := X"CC";
   constant I2 : BIT_VECTOR(7 downto 0) := X"F0";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT3.
   constant I0 : BIT_VECTOR(7 downto 0) := X"AA";
   constant I1 : BIT_VECTOR(7 downto 0) := X"CC";
   constant I2 : BIT_VECTOR(7 downto 0) := X"F0";
							</Template>
							<Template label="LUT4" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT4.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT4.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00";
							</Template>
							<Template label="LUT5" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT5.
   constant I0 : BIT_VECTOR(31 downto 0) := X"AAAAAAAA";
   constant I1 : BIT_VECTOR(31 downto 0) := X"CCCCCCCC";
   constant I2 : BIT_VECTOR(31 downto 0) := X"F0F0F0F0";
   constant I3 : BIT_VECTOR(31 downto 0) := X"FF00FF00";
   constant I4 : BIT_VECTOR(31 downto 0) := X"FFFF0000";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT5.
   constant I0 : BIT_VECTOR(31 downto 0) := X"AAAAAAAA";
   constant I1 : BIT_VECTOR(31 downto 0) := X"CCCCCCCC";
   constant I2 : BIT_VECTOR(31 downto 0) := X"F0F0F0F0";
   constant I3 : BIT_VECTOR(31 downto 0) := X"FF00FF00";
   constant I4 : BIT_VECTOR(31 downto 0) := X"FFFF0000";
							</Template>
							<Template label="LUT6" treetype="template">
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT6.
   constant I0 : BIT_VECTOR(63 downto 0) := X"AAAAAAAAAAAAAAAA";
   constant I1 : BIT_VECTOR(63 downto 0) := X"CCCCCCCCCCCCCCCC";
   constant I2 : BIT_VECTOR(63 downto 0) := X"F0F0F0F0F0F0F0F0";
   constant I3 : BIT_VECTOR(63 downto 0) := X"FF00FF00FF00FF00";
   constant I4 : BIT_VECTOR(63 downto 0) := X"FFFF0000FFFF0000";
   constant I5 : BIT_VECTOR(63 downto 0) := X"FFFFFFFF00000000";
   -- The following constants are defined to allow for
   --   equation-based INIT specification for a LUT6.
   constant I0 : BIT_VECTOR(63 downto 0) := X"AAAAAAAAAAAAAAAA";
   constant I1 : BIT_VECTOR(63 downto 0) := X"CCCCCCCCCCCCCCCC";
   constant I2 : BIT_VECTOR(63 downto 0) := X"F0F0F0F0F0F0F0F0";
   constant I3 : BIT_VECTOR(63 downto 0) := X"FF00FF00FF00FF00";
   constant I4 : BIT_VECTOR(63 downto 0) := X"FFFF0000FFFF0000";
   constant I5 : BIT_VECTOR(63 downto 0) := X"FFFFFFFF00000000";
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
--  Truth Table to determine INIT value for a LUT1
--      ________
--     | I0 | O |
--     |--------|
--     |  0 | ? |\
--     |  1 | ? |/ = 2'b??
--     ----------
--  Truth Table to determine INIT value for a LUT1
--      ________
--     | I0 | O |
--     |--------|
--     |  0 | ? |\
--     |  1 | ? |/ = 2'b??
--     ----------
							</Template>
							<Template label="LUT2" treetype="template">
--  Truth Table to determine INIT value for a LUT2
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
--     |  0  1  0 | ? | /
--     |  0  1  1 | ? |/ 
--      ---------- --- 
--  Truth Table to determine INIT value for a LUT2
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
--     |  0  1  0 | ? | /
--     |  0  1  1 | ? |/ 
--      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
--  Truth Table to determine INIT value for a LUT3
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
--     |  0  1  0 | ? | /                                |
--     |  0  1  1 | ? |/                                 |
--     |----------|---|                       INIT = 8'h?? 
--     |  1  0  0 | ? |\                                |
--     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
--     |  1  1  0 | ? | / 
--     |  1  1  1 | ? |/                      
--     ----------------
--  Truth Table to determine INIT value for a LUT3
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | ? |\
--     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
--     |  0  1  0 | ? | /                                |
--     |  0  1  1 | ? |/                                 |
--     |----------|---|                       INIT = 8'h?? 
--     |  1  0  0 | ? |\                                |
--     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
--     |  1  1  0 | ? | / 
--     |  1  1  1 | ? |/                      
--     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
--  Truth Table to determine INIT value for a LUT4
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | ? |\
--     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
--     |  0  0  1  0 | ? | /                                 |
--     |  0  0  1  1 | ? |/                                  |
--     |-------------|---|                                   |
--     |  0  1  0  0 | ? |\                                  |
--     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
--     |  0  1  1  0 | ? | /                                 |
--     |  0  1  1  1 | ? |/                                  |                     
--     |-------------|---|                     INIT = 16'h????
--     |  1  0  0  0 | ? |\                               |
--     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  0 | ? | /                              |
--     |  1  0  1  1 | ? |/                               |
--     |-------------|---|                                |
--     |  1  1  0  0 | ? |\                               |
--     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  0 | ? | /
--     |  1  1  1  1 | ? |/
--     -------------------
--  Truth Table to determine INIT value for a LUT4
--      _________________
--     | I3 I2 I1 I0 | O |
--     |-----------------|
--     |  0  0  0  0 | ? |\
--     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
--     |  0  0  1  0 | ? | /                                 |
--     |  0  0  1  1 | ? |/                                  |
--     |-------------|---|                                   |
--     |  0  1  0  0 | ? |\                                  |
--     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
--     |  0  1  1  0 | ? | /                                 |
--     |  0  1  1  1 | ? |/                                  |                     
--     |-------------|---|                     INIT = 16'h????
--     |  1  0  0  0 | ? |\                               |
--     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  0 | ? | /                              |
--     |  1  0  1  1 | ? |/                               |
--     |-------------|---|                                |
--     |  1  1  0  0 | ? |\                               |
--     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  0 | ? | /
--     |  1  1  1  1 | ? |/
--     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
--  Truth Table to determine INIT value for a LUT5
--      ____________________
--     | I4 I3 I2 I1 I0 | O |
--     |--------------------|
--     |  0  0  0  0  0 | ? |\
--     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  0  1  0  0 | ? |\                                      |
--     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1 | ? |/                                      |                     
--     |----------------|---|                                       |
--     |  0  1  0  0  0 | ? |\                                      |
--     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  0 | ? | /                                     |
--     |  0  1  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  1  0  0 | ? |\                                      |
--     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1 | ? |/                                      |
--     ----------------------                     INIT = 32'h????????
--     |  1  0  0  0  0 | ? |\                               |
--     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  0  1  0 | ? | /                              |
--     |  1  0  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  0  1  0  0 | ? |\                               |
--     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  1  0 | ? | /                              |
--     |  1  0  1  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  0  0  0 | ? |\                               |
--     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  1  0  1  0 | ? | /                              |
--     |  1  1  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  1  0  0 | ? |\                               |
--     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1 | ? |/
--     ----------------------
--  Truth Table to determine INIT value for a LUT5
--      ____________________
--     | I4 I3 I2 I1 I0 | O |
--     |--------------------|
--     |  0  0  0  0  0 | ? |\
--     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  0  1  0  0 | ? |\                                      |
--     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1 | ? |/                                      |                     
--     |----------------|---|                                       |
--     |  0  1  0  0  0 | ? |\                                      |
--     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  0 | ? | /                                     |
--     |  0  1  0  1  1 | ? |/                                      |
--     |----------------|---|                                       |
--     |  0  1  1  0  0 | ? |\                                      |
--     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1 | ? |/                                      |
--     ----------------------                     INIT = 32'h????????
--     |  1  0  0  0  0 | ? |\                               |
--     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  0  1  0 | ? | /                              |
--     |  1  0  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  0  1  0  0 | ? |\                               |
--     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  0  1  1  0 | ? | /                              |
--     |  1  0  1  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  0  0  0 | ? |\                               |
--     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
--     |  1  1  0  1  0 | ? | /                              |
--     |  1  1  0  1  1 | ? |/                               |
--     |----------------|---|                                |
--     |  1  1  1  0  0 | ? |\                               |
--     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
--     |  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1 | ? |/
--     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
--  Truth Table to determine INIT value for a LUT6
--      _______________________
--     | I5 I4 I3 I2 I1 I0 | O |
--     |-----------------------|
--     |  0  0  0  0  0  0 | ? |\
--     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  0  1  0  0 | ? |\                                      |
--     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  0  1  1  0 | ? | /                                     |
--     |  0  0  0  1  1  1 | ? |/                                      |                     
--     |-------------------|---|                                       |
--     |  0  0  1  0  0  0 | ? |\                                      |
--     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  0  1  0 | ? | /                                     |
--     |  0  0  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  1  0  0 | ? |\                                      |
--     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1  1 | ? |/                                      |
--     -------------------------                                       |
--     |  0  1  0  0  0  0 | ? |\                                      |
--     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  0  1  0 | ? | /                                     |
--     |  0  1  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  0  1  0  0 | ? |\                                      |
--     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  1  0 | ? | /                                     |
--     |  0  1  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  0  0  0 | ? |\                                      |
--     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  0  1  0 | ? | /                                     |
--     |  0  1  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  1  0  0 | ? |\                                      |
--     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1  1 | ? |/                                      |
--     ------------------------              INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     ------------------------




--  Truth Table to determine INIT value for a LUT6
--      _______________________
--     | I5 I4 I3 I2 I1 I0 | O |
--     |-----------------------|
--     |  0  0  0  0  0  0 | ? |\
--     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
--     |  0  0  0  0  1  0 | ? | /                                     |
--     |  0  0  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  0  1  0  0 | ? |\                                      |
--     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  0  1  1  0 | ? | /                                     |
--     |  0  0  0  1  1  1 | ? |/                                      |                     
--     |-------------------|---|                                       |
--     |  0  0  1  0  0  0 | ? |\                                      |
--     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  0  1  0 | ? | /                                     |
--     |  0  0  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  0  1  1  0  0 | ? |\                                      |
--     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  0  1  1  1  0 | ? | /                                     |
--     |  0  0  1  1  1  1 | ? |/                                      |
--     -------------------------                                       |
--     |  0  1  0  0  0  0 | ? |\                                      |
--     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  0  1  0 | ? | /                                     |
--     |  0  1  0  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  0  1  0  0 | ? |\                                      |
--     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  0  1  1  0 | ? | /                                     |
--     |  0  1  0  1  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  0  0  0 | ? |\                                      |
--     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  0  1  0 | ? | /                                     |
--     |  0  1  1  0  1  1 | ? |/                                      |
--     |-------------------|---|                                       |
--     |  0  1  1  1  0  0 | ? |\                                      |
--     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
--     |  0  1  1  1  1  0 | ? | /                                     |
--     |  0  1  1  1  1  1 | ? |/                                      |
--     ------------------------              INIT = 64'h????????????????
--     |  1  0  0  0  0  0 | ? |\                       |
--     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  0  1  0 | ? | /                      |
--     |  1  0  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  0  1  0  0 | ? |\                       |
--     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  0  1  1  0 | ? | /                      |
--     |  1  0  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  0  1  0  0  0 | ? |\                       |
--     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  0  1  0 | ? | /                      |
--     |  1  0  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  0  1  1  0  0 | ? |\                       |
--     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  0  1  1  1  0 | ? | /                      |
--     |  1  0  1  1  1  1 | ? |/                       |
--     -------------------------                        |
--     |  1  1  0  0  0  0 | ? |\                       |
--     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  0  1  0 | ? | /                      |
--     |  1  1  0  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  0  1  0  0 | ? |\                       |
--     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  0  1  1  0 | ? | /                      |
--     |  1  1  0  1  1  1 | ? |/                       |                     
--     |-------------------|---|                        |
--     |  1  1  1  0  0  0 | ? |\                       |
--     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
--     |  1  1  1  0  1  0 | ? | /                      |
--     |  1  1  1  0  1  1 | ? |/                       |
--     |-------------------|---|                        |
--     |  1  1  1  1  0  0 | ? |\                       |
--     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
--     |  1  1  1  1  1  0 | ? | /
--     |  1  1  1  1  1  1 | ? |/
--     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT1" treetype="template">

--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; "00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_inst instantiation


--    LUT1     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1: 1-input Look-Up Table with general output
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_inst : LUT1
   generic map (
      INIT =&gt; "00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_inst instantiation

					</Template>
					<Template label="LUT1_D" treetype="template">

--   LUT1_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_D: 1-input Look-Up Table with general and local outputs
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_D_inst : LUT1_D
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_D_inst instantiation

--     -------------------
--
-- Example of determining a 3-input AND gate:
--
--      ______________
--     | I2 I1 I0 | O |
--     |--------------|
--     |  0  0  0 | 0 |\
--     |  0  0  1 | 0 | \ = 0000 = 0 -----------+
--     |  0  1  0 | 0 | /                       |
--     |  0  1  1 | 0 |/                        |
--     |----------|---|                 INIT = 80 
--     |  1  0  0 | 0 |\                       |
--     |  1  0  1 | 0 | \ = 1000 = 8-----------+
--     |  1  1  0 | 0 | / 
--     |  1  1  1 | 1 |/                      
--     ----------------
--
-- The Equation Method
-- -------------------
--
-- Another method to determine the LUT value is to define constants for each 
-- input to the LUT that correspond to their listed truth value and use those to
-- build the logic equation you are after.  This method is easier to understand 
-- once you have grasped the concept and more self-documenting that the above 
-- method however does require the code to first specify the appropriate 
-- constants.  See the example below.
--
-- Example of specifying the equation (A and B) or (C and D) for a LUT4:
--
   -- The following constants are defined to allow for
   --   equation-based INIT specification.
   constant I0 : BIT_VECTOR(15 downto 0) := X"AAAA";
   constant I1 : BIT_VECTOR(15 downto 0) := X"CCCC";
   constant I2 : BIT_VECTOR(15 downto 0) := X"F0F0";
   constant I3 : BIT_VECTOR(15 downto 0) := X"FF00"; 


   -- LUT4: 4-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; (I3 and I2) or (I1 and I0))
   port map (
      O =&gt; O_LUT,   -- LUT general output
      I0 =&gt; A, -- LUT input
      I1 =&gt; B, -- LUT input
      I2 =&gt; C, -- LUT input
      I3 =&gt; D  -- LUT input
   );
   -- End of LUT4_inst instantiation

-- With the constants specifying all possible cases for the truth table, a 
-- VHDL equation can be written to determine the end INIT value.


--   LUT1_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_D: 1-input Look-Up Table with general and local outputs
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_D_inst : LUT1_D
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_D_inst instantiation

					</Template>
					<Template label="LUT1_L" treetype="template">

--   LUT1_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_L: 1-input Look-Up Table with local output
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_L_inst : LUT1_L
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_L_inst instantiation


--   LUT1_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT1_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT1_L: 1-input Look-Up Table with local output
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT1_L_inst : LUT1_L
   generic map (
      INIT =&gt; "00")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0  -- LUT input
   );

   -- End of LUT1_L_inst instantiation

					</Template>
					<Template label="LUT2" treetype="template">

--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_inst instantiation


--    LUT2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2: 2-input Look-Up Table with general output
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_inst : LUT2
   generic map (
      INIT =&gt; X"0")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_inst instantiation

					</Template>
					<Template label="LUT2_D" treetype="template">

--   LUT2_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_D: 2-input Look-Up Table with general and local outputs
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_D_inst : LUT2_D
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_D_inst instantiation


--   LUT2_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_D: 2-input Look-Up Table with general and local outputs
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_D_inst : LUT2_D
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_D_inst instantiation

					</Template>
					<Template label="LUT2_L" treetype="template">

--   LUT2_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_L: 2-input Look-Up Table with local output
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_L_inst : LUT2_L
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_L_inst instantiation


--   LUT2_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT2_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT2_L: 2-input Look-Up Table with local output
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT2_L_inst : LUT2_L
   generic map (
      INIT =&gt; X"0")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1  -- LUT input
   );

   -- End of LUT2_L_inst instantiation

					</Template>
					<Template label="LUT3" treetype="template">

--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-input Look-Up Table with general output
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2  -- LUT input
   );

   -- End of LUT3_inst instantiation


--    LUT3     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3: 3-input Look-Up Table with general output (Mapped to a LUT6)
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_inst : LUT3
   generic map (
      INIT =&gt; X"00")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2  -- LUT input
   );

   -- End of LUT3_inst instantiation

					</Template>
					<Template label="LUT3_D" treetype="template">

--   LUT3_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_D: 3-input Look-Up Table with general and local outputs
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_D_inst : LUT3_D
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,  -- LUT local output
      O =&gt; O,    -- LUT general output
      I0 =&gt; I0,  -- LUT input
      I1 =&gt; I1,  -- LUT input
      I2 =&gt; I2   -- LUT input
   );

   -- End of LUT3_D_inst instantiation


--   LUT3_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_D: 3-input Look-Up Table with general and local outputs
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_D_inst : LUT3_D
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,  -- LUT local output
      O =&gt; O,    -- LUT general output
      I0 =&gt; I0,  -- LUT input
      I1 =&gt; I1,  -- LUT input
      I2 =&gt; I2   -- LUT input
   );

   -- End of LUT3_D_inst instantiation

					</Template>
					<Template label="LUT3_L" treetype="template">

--   LUT3_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_L: 3-input Look-Up Table with local output
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_L_inst : LUT3_L
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,   -- LUT local output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2    -- LUT input
   );

   -- End of LUT3_L_inst instantiation


--   LUT3_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT3_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT3_L: 3-input Look-Up Table with local output
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT3_L_inst : LUT3_L
   generic map (
      INIT =&gt; X"00")
   port map (
      LO =&gt; LO,   -- LUT local output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2    -- LUT input
   );

   -- End of LUT3_L_inst instantiation

					</Template>
					<Template label="LUT4" treetype="template">

--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_inst instantiation


--    LUT4     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4: 4-input Look-Up Table with general output
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_inst : LUT4
   generic map (
      INIT =&gt; X"0000")
   port map (
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_inst instantiation

					</Template>
					<Template label="LUT4_D" treetype="template">

--   LUT4_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_D: 4-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_D_inst : LUT4_D
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_D_inst instantiation


--   LUT4_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_D: 4-input Look-Up Table with general and local outputs
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_D_inst : LUT4_D
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_D_inst instantiation
					</Template>
					<Template label="LUT4_L" treetype="template">

--   LUT4_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_L: 4-input Look-Up Table with local output (Mapped to a LUT6)
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_L_inst : LUT4_L
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_L_inst instantiation


--   LUT4_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT4_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT4_L: 4-input Look-Up Table with local output
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT4_L_inst : LUT4_L
   generic map (
      INIT =&gt; X"0000")
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3  -- LUT input
   );

   -- End of LUT4_L_inst instantiation

					</Template>
					<Template label="LUT5" treetype="template">

--    LUT5     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT5_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5: 5-input Look-Up Table with general output (Mapped to SliceM LUT6)
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_inst : LUT5
   generic map (
      INIT =&gt; X"00000000") -- Specify LUT Contents
   port map (
      O =&gt; O,  -- LUT general output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2,   -- LUT input
      I3 =&gt; I3,   -- LUT input
      I4 =&gt; I4    -- LUT input 
   );

   -- End of LUT5_inst instantiation

					</Template>
					<Template label="LUT5_D" treetype="template">

--   LUT5_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT5_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5_D: 5-input Look-Up Table with general and local outputs (Mapped to SliceM LUT6)
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_D_inst : LUT5_D
   generic map (
      INIT =&gt; X"00000000") -- Specify LUT contents
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4  -- LUT input
   );

   -- End of LUT5_D_inst instantiation

					</Template>
					<Template label="LUT5_L" treetype="template">

--   LUT5_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT5_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT5_L: 5-input Look-Up Table with local output (Mapped to SliceM LUT6)
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT5_L_inst : LUT5_L
   generic map (
      INIT =&gt; X"00000000") -- Specify LUT Contents
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4  -- LUT input
   );

   -- End of LUT5_L_inst instantiation

					</Template>
					<Template label="LUT6" treetype="template">

--    LUT6     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6: 6-input Look-Up Table with general output
   --       Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_inst : LUT6
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      O =&gt; O,  -- LUT general output
      I0 =&gt; I0,   -- LUT input
      I1 =&gt; I1,   -- LUT input
      I2 =&gt; I2,   -- LUT input
      I3 =&gt; I3,   -- LUT input
      I4 =&gt; I4,   -- LUT input
      I5 =&gt; I5    -- LUT input 
   );

   -- End of LUT6_inst instantiation

					</Template>
					<Template label="LUT6_D" treetype="template">

--   LUT6_D    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_D: 6-input Look-Up Table with general and local outputs
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_D_inst : LUT6_D
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT contents
   port map (
      LO =&gt; LO, -- LUT local output
      O =&gt; O,   -- LUT general output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4, -- LUT input
      I5 =&gt; I5 -- LUT input
   );

   -- End of LUT6_D_inst instantiation
					</Template>
					<Template label="LUT6_L" treetype="template">

--   LUT6_L    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_L: 6-input Look-Up Table with local output
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_L_inst : LUT6_L
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      LO =&gt; LO, -- LUT local output
      I0 =&gt; I0, -- LUT input
      I1 =&gt; I1, -- LUT input
      I2 =&gt; I2, -- LUT input
      I3 =&gt; I3, -- LUT input
      I4 =&gt; I4, -- LUT input
      I5 =&gt; I5  -- LUT input
   );

   -- End of LUT6_L_inst instantiation

					</Template>
					<Template label="LUT6_2" treetype="template">

--   LUT6_2     : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (LUT6_2_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- LUT6_2: 6-input  2 output Look-Up Table
   --         Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   LUT6_2_inst : LUT6_2
   generic map (
      INIT =&gt; X"0000000000000000") -- Specify LUT Contents
   port map (
      O6 =&gt; O6,  -- 6/5-LUT output (1-bit)
      O5 =&gt; O5,  -- 5-LUT output (1-bit)
      I0 =&gt; I0,   -- LUT input (1-bit)
      I1 =&gt; I1,   -- LUT input (1-bit)
      I2 =&gt; I2,   -- LUT input (1-bit)
      I3 =&gt; I3,   -- LUT input (1-bit)
      I4 =&gt; I4,   -- LUT input (1-bit)
      I5 =&gt; I5    -- LUT input (1-bit)
   );

   -- End of LUT6_2_inst instantiation

					</Template>
					<Template label="Reconfigurable LUT (CFGLUT5)" treetype="template">
--     CFGLUT5     : In order to incorporate this function into the design,
--      VHDL       : the following instance declaration needs to be placed
--    instance     : in the body of the design code.  The instance name
--   declaration   : (CFGLUT5_inst) and/or the port declarations after the
--      code       : "=&gt;" assignment maybe changed to properly reference and
--                 : connect this function to the design.  All inputs
--                 : and outputs must be connected.

--     Library     : In addition to adding the instance declaration, a use
--   declaration   : statement for the UNISIM.vcomponents library needs to be
--       for       : added before the entity declaration.  This library
--     Xilinx      : contains the component declarations for all Xilinx
--    primitives   : primitives and points to the models that will be used
--                 : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- CFGLUT5: Reconfigurable 5-input LUT (Mapped to SliceM LUT6) 
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   CFGLUT5_inst : CFGLUT5
   generic map (
      INT =&gt; X"00000000")
   port map (
      CDO =&gt; CDO, -- Reconfiguration cascade output
      O5 =&gt; O5,   -- 4-LUT output
      O6 =&gt; O6,   -- 5-LUT output
      CDI =&gt; CDI, -- Reconfiguration data input
      CE =&gt; CE,   -- Reconfiguration enable input
      CLK =&gt; CLK, -- Clock input
      I0 =&gt; I0,   -- Logic data input
      I1 =&gt; I1,   -- Logic data input
      I2 =&gt; I2,   -- Logic data input
      I3 =&gt; I3,   -- Logic data input
      I4 =&gt; I4    -- Logic data input
   );

   -- End of CFGLUT5_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUXFx" treetype="folder">
					<Template label="MUXF7" treetype="template">

--    MUXF7    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF7_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7: CLB MUX to tie two LUT6's together with general output
   --        Virtex-7 
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_inst : MUXF7
   port map (
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to LUT6 O6 pin)
      I1 =&gt; I1,  -- Input (tie to LUT6 O6 pin)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF7_inst instantiation

					</Template>
					<Template label="MUXF7_D" treetype="template">

--   MUXF7_D   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF7_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7_D: CLB MUX to tie two LUT6's together with general and local outputs
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_D_inst : MUXF7_D
   port map (
      LO =&gt; LO,  -- Ouptut of MUX to local routing
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to LUT6 O6 pin)
      I1 =&gt; I1,  -- Input (tie to LUT6 O6 pin)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF7_D_inst instantiation

					</Template>
					<Template label="MUXF7_L" treetype="template">

--   MUXF7_L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF7_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF7_L: CLB MUX to tie two LUT6's together with local output
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF7_L_inst : MUXF7_L
   port map (
      LO =&gt; LO,  -- Output of MUX to local routing
      I0 =&gt; I0,  -- Input (tie to LUT6 O6 pin)
      I1 =&gt; I1,  -- Input (tie to LUT6 O6 pin)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF7_L_inst instantiation

					</Template>
					<Template label="MUXF8" treetype="template">

--    MUXF8    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF8_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8: CLB MUX to tie two MUXF7's together with general output
   --        Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_inst : MUXF8
   port map (
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to MUXF7 L/LO out)
      I1 =&gt; I1,  -- Input (tie to MUXF7 L/LO out)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF8_inst instantiation

					</Template>
					<Template label="MUXF8_D" treetype="template">

--   MUXF8_D   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF8_D_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8_D: CLB MUX to tie two MUXF7's together with general and local outputs
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_D_inst : MUXF8_D
   port map (
      LO =&gt; LO,  -- Ouptut of MUX to local routing
      O =&gt; O,    -- Output of MUX to general routing
      I0 =&gt; I0,  -- Input (tie to MUXF7 L/LO out)
      I1 =&gt; I1,  -- Input (tie to MUXF7 L/LO out)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF8_D_inst instantiation

					</Template>
					<Template label="MUXF8_L" treetype="template">

--   MUXF8_L   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (MUXF8_L_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- MUXF8_L: CLB MUX to tie two MUXF7's together with local output
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4

   MUXF8_L_inst : MUXF8_L
   port map (
      LO =&gt; LO,  -- Output of MUX to local routing
      I0 =&gt; I0,  -- Input (tie to MUXF7 L/LO out)
      I1 =&gt; I1,  -- Input (tie to MUXF7 L/LO out)
      S =&gt; S     -- Input select to MUX
   );

   -- End of MUXF8_L_inst instantiation

					</Template>
				</SubFolder>
				<SubFolder label="Shift Register LUT" treetype="folder">
					<Template label="16-bit /w CE posedge SR (SRL16E)" treetype="template">

--   SRL16E    : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (SRL16E_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRL16E: 16-bit shift register LUT with clock enable operating on posedge of clock (Mapped to SliceM LUT6)
   --        Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   SRL16E_inst : SRL16E
   generic map (
      INIT =&gt; X"0000")
   port map (
      Q =&gt; Q,       -- SRL data output
      A0 =&gt; A0,     -- Select[0] input
      A1 =&gt; A1,     -- Select[1] input
      A2 =&gt; A2,     -- Select[2] input
      A3 =&gt; A3,     -- Select[3] input
      CE =&gt; CE,     -- Clock enable input
      CLK =&gt; CLK,   -- Clock input
      D =&gt; D        -- SRL data input
   );

   -- End of SRL16E_inst instantiation

					</Template>
					<Template label="32-bit /w CE posedge SR (SRLC32E)" treetype="template">

--   SRLC32E   : In order to incorporate this function into the design,
--    VHDL     : the following instance declaration needs to be placed
--  instance   : in the architecture body of the design code.  The
-- declaration : instance name (SRLC32E_inst) and/or the port declarations
--    code     : after the "=&gt;" assignment maybe changed to properly
--             : reference and connect this function to the design.
--             : All inputs and outputs must be connected.

--   Library   : In addition to adding the instance declaration, a use
-- declaration : statement for the UNISIM.vcomponents library needs to be
--     for     : added before the entity declaration.  This library
--   Xilinx    : contains the component declarations for all Xilinx
--  primitives : primitives and points to the models that will be used
--             : for simulation.

--  Copy the following two statements and paste them before the
--  Entity declaration, unless they already exist.

Library UNISIM;
use UNISIM.vcomponents.all;

--  &lt;-----Cut code below this line and paste into the architecture body----&gt;

   -- SRLC32E: 32-bit variable length shift register LUT
   --          with clock enable (Mapped to a SliceM LUT6)
   --          Virtex-7
   -- Xilinx HDL Language Template, version 2016.4
   
   SRLC32E_inst : SRLC32E
   generic map (
      INIT =&gt; X"00000000")
   port map (
      Q =&gt; Q,        -- SRL data output
      Q31 =&gt; Q31,    -- SRL cascade output pin
      A =&gt; A,        -- 5-bit shift depth select input
      CE =&gt; CE,      -- Clock enable input
      CLK =&gt; CLK,    -- Clock input
      D =&gt; D         -- SRL data input
   );

   -- End of SRLC32E_inst instantiation

					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
	</Folder>
	<Folder label="IP Integrator HDL" treetype="folder">
		<SubFolder label="Advanced Interfaces" treetype="folder">
			<Template label="10-Gigabit Ethernet Media Independent Interface" treetype="template">
-- xgmii - 10-Gigabit Ethernet Media Independent Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_txd&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Ethernet Transmit Data (required)
  &lt;s_txc&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Ethernet Transmit Control (required)
  &lt;s_rxd&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Ethernet Receive Data (required)
  &lt;s_rxc&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Ethernet Receive Control (required)
  &lt;s_tx_clk&gt; : in std_logic; -- Ethernet Transmit Clock (optional)
  &lt;s_rx_clk&gt; : out std_logic; -- Ethernet Receive Clock (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txd&gt;: SIGNAL is "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; TXD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txc&gt;: SIGNAL is "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; TXC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxd&gt;: SIGNAL is "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; RXD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxc&gt;: SIGNAL is "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; RXC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_clk&gt;: SIGNAL is "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; TX_CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_clk&gt;: SIGNAL is "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; RX_CLK";

begin
--  user logic here

end arch_impl;
			</Template>
			<SubFolder label="acc" treetype="folder">
				<Template label="Accelerator Handshake Interface" treetype="template">
-- acc_handshake - Accelerator Handshake Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_start&gt; : in std_logic; -- Accelerator Start (required)
  &lt;s_ready&gt; : out std_logic; -- Accelerator Ready (required)
  &lt;s_done&gt; : out std_logic; -- Accelerator Done (required)
  &lt;s_continue&gt; : in std_logic; -- Accelerator Continue (optional)
  &lt;s_idle&gt; : out std_logic; -- Accelerator Idle (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_start&gt;: SIGNAL is "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; start";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ready&gt;: SIGNAL is "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; ready";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_done&gt;: SIGNAL is "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_continue&gt;: SIGNAL is "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; continue";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_idle&gt;: SIGNAL is "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; idle";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Acc_fifo_read" treetype="template">
-- acc_fifo_read -  (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_rd_data&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- FIFO Read Data (required)
  &lt;s_rd_en&gt; : in std_logic; -- FIFO Read Enable (required)
  &lt;s_empty_n&gt; : out std_logic; -- FIFO Empty flag (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rd_data&gt;: SIGNAL is "xilinx.com:interface:acc_fifo_read:1.0 &lt;interface_name&gt; RD_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rd_en&gt;: SIGNAL is "xilinx.com:interface:acc_fifo_read:1.0 &lt;interface_name&gt; RD_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_empty_n&gt;: SIGNAL is "xilinx.com:interface:acc_fifo_read:1.0 &lt;interface_name&gt; EMPTY_N";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Acc_fifo_write" treetype="template">
-- acc_fifo_write -  (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_wr_data&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- FIFO Write Data (required)
  &lt;s_wr_en&gt; : in std_logic; -- FIFO Write Enable (required)
  &lt;s_full_n&gt; : out std_logic; -- FIFO Full flag (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wr_data&gt;: SIGNAL is "xilinx.com:interface:acc_fifo_write:1.0 &lt;interface_name&gt; WR_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wr_en&gt;: SIGNAL is "xilinx.com:interface:acc_fifo_write:1.0 &lt;interface_name&gt; WR_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_full_n&gt;: SIGNAL is "xilinx.com:interface:acc_fifo_write:1.0 &lt;interface_name&gt; FULL_N";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<Template label="AMBA ACE Interface" treetype="template">
-- acemm - AMBA ACE Interface (slave directions)
-- 
-- Allowed parameters:
--  MAX_BURST_LENGTH          - Max Burst Length          (long) 
--  NUM_WRITE_OUTSTANDING     - Num Write Outstanding     (long) 
--  NUM_READ_OUTSTANDING      - Num Read Outstanding      (long) 
--  SUPPORTS_NARROW_BURST     - Supports Narrow Burst     (long) 
--  READ_WRITE_MODE           - Read Write Mode           (string default: READ_WRITE) 
--  BUSER_WIDTH               - Buser Width               (long) 
--  RUSER_WIDTH               - Ruser Width               (long) 
--  WUSER_WIDTH               - Wuser Width               (long) 
--  ARUSER_WIDTH              - Aruser Width              (long) 
--  AWUSER_WIDTH              - Awuser Width              (long) 
--  ADDR_WIDTH                - Addr Width                (long) 
--  ID_WIDTH                  - Id Width                  (long) 
--  FREQ_HZ                   - Frequency                 (float default: 100000000) 
--  PROTOCOL                  - Protocol                  (string default: &lt;blank&gt;) 
--  DATA_WIDTH                - Data Width                (long) 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_awid&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write address ID (optional)
  &lt;s_awaddr&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write address (optional)
  &lt;s_awlen&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Burst length (optional)
  &lt;s_awsize&gt; : in std_logic_vector(2 downto 0); -- Burst size (optional)
  &lt;s_awburst&gt; : in std_logic_vector(1 downto 0); -- Burst type (optional)
  &lt;s_awlock&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Lock type (optional)
  &lt;s_awcache&gt; : in std_logic_vector(3 downto 0); -- Cache type (optional)
  &lt;s_awprot&gt; : in std_logic_vector(2 downto 0); -- Protection type (optional)
  &lt;s_awregion&gt; : in std_logic_vector(3 downto 0); -- Write address slave region (optional)
  &lt;s_awqos&gt; : in std_logic_vector(3 downto 0); -- Transaction Quality of Service token (optional)
  &lt;s_awuser&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write address user sideband (optional)
  &lt;s_awvalid&gt; : in std_logic; -- Write address valid (optional)
  &lt;s_awready&gt; : out std_logic; -- Write address ready (optional)
  &lt;s_awdomain&gt; : in std_logic_vector(1 downto 0); -- Write address domain (optional)
  &lt;s_awsnoop&gt; : in std_logic_vector(2 downto 0); -- Write address snoop (optional)
  &lt;s_awbar&gt; : in std_logic_vector(1 downto 0); -- Write address barrier (optional)
  &lt;s_wid&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write ID tag (optional)
  &lt;s_wdata&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write data (optional)
  &lt;s_wstrb&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write strobes (optional)
  &lt;s_wlast&gt; : in std_logic; -- Write last beat (optional)
  &lt;s_wuser&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write data user sideband (optional)
  &lt;s_wvalid&gt; : in std_logic; -- Write valid (optional)
  &lt;s_wready&gt; : out std_logic; -- Write ready (optional)
  &lt;s_bid&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Response ID (optional)
  &lt;s_bresp&gt; : out std_logic_vector(1 downto 0); -- Write response (optional)
  &lt;s_buser&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Write response user sideband (optional)
  &lt;s_bvalid&gt; : out std_logic; -- Write response valid (optional)
  &lt;s_bready&gt; : in std_logic; -- Write response ready (optional)
  &lt;s_wack&gt; : in std_logic; -- Write response acknowledge (optional)
  &lt;s_arid&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Read address ID (optional)
  &lt;s_araddr&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Read address (optional)
  &lt;s_arlen&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Burst length (optional)
  &lt;s_arsize&gt; : in std_logic_vector(2 downto 0); -- Burst size (optional)
  &lt;s_arburst&gt; : in std_logic_vector(1 downto 0); -- Burst type (optional)
  &lt;s_arlock&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Lock type (optional)
  &lt;s_arcache&gt; : in std_logic_vector(3 downto 0); -- Cache type (optional)
  &lt;s_arprot&gt; : in std_logic_vector(2 downto 0); -- Protection type (optional)
  &lt;s_arregion&gt; : in std_logic_vector(3 downto 0); -- Read address slave region (optional)
  &lt;s_arqos&gt; : in std_logic_vector(3 downto 0); -- Quality of service token (optional)
  &lt;s_aruser&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Read address user sideband (optional)
  &lt;s_arvalid&gt; : in std_logic; -- Read address valid (optional)
  &lt;s_arready&gt; : out std_logic; -- Read address ready (optional)
  &lt;s_ardomain&gt; : in std_logic_vector(1 downto 0); -- Read address domain (optional)
  &lt;s_arsnoop&gt; : in std_logic_vector(3 downto 0); -- Read address snoop (optional)
  &lt;s_arbar&gt; : in std_logic_vector(1 downto 0); -- Read address barrier (optional)
  &lt;s_rid&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Read ID tag (optional)
  &lt;s_rdata&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Read data (optional)
  &lt;s_rresp&gt; : out std_logic_vector(3 downto 0); -- Read response (optional)
  &lt;s_rlast&gt; : out std_logic; -- Read last beat (optional)
  &lt;s_ruser&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Read data user sideband (optional)
  &lt;s_rvalid&gt; : out std_logic; -- Read valid (optional)
  &lt;s_rready&gt; : in std_logic; -- Read ready (optional)
  &lt;s_rack&gt; : in std_logic; -- Read response acknowledge (optional)
  &lt;s_acvalid&gt; : out std_logic; -- Snoop address valid (optional)
  &lt;s_acaddr&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Snoop address (optional)
  &lt;s_acsnoop&gt; : out std_logic_vector(3 downto 0); -- Snoop address snoop (optional)
  &lt;s_acprot&gt; : out std_logic_vector(2 downto 0); -- Snoop address protection type (optional)
  &lt;s_acready&gt; : in std_logic; -- Snoop address ready (optional)
  &lt;s_crready&gt; : out std_logic; -- Snoop response ready (optional)
  &lt;s_crvalid&gt; : in std_logic; -- Snoop response valid (optional)
  &lt;s_crresp&gt; : in std_logic_vector(4 downto 0); -- Snoop response (optional)
  &lt;s_cdvalid&gt; : in std_logic; -- Snoop data valid (optional)
  &lt;s_cdready&gt; : out std_logic; -- Snoop data ready (optional)
  &lt;s_cddata&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Snoop data (optional)
  &lt;s_cdlast&gt; : in std_logic; -- Snoop data last beat (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awaddr&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awlen&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWLEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awsize&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWSIZE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awburst&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWBURST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awlock&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWLOCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awcache&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWCACHE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awprot&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWPROT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awregion&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWREGION";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awqos&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWQOS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awuser&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awvalid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awready&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awdomain&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWDOMAIN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awsnoop&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWSNOOP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awbar&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWBAR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wdata&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wstrb&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WSTRB";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wlast&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WLAST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wuser&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wvalid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wready&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bresp&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BRESP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_buser&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bvalid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bready&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wack&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WACK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_araddr&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arlen&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARLEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arsize&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARSIZE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arburst&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARBURST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arlock&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARLOCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arcache&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARCACHE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arprot&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARPROT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arregion&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARREGION";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arqos&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARQOS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aruser&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arvalid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arready&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ardomain&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARDOMAIN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arsnoop&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARSNOOP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arbar&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARBAR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rdata&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rresp&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RRESP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rlast&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RLAST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ruser&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rvalid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rready&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rack&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RACK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_acvalid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_acaddr&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_acsnoop&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACSNOOP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_acprot&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACPROT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_acready&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_crready&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CRREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_crvalid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CRVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_crresp&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CRRESP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cdvalid&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CDVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cdready&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CDREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cddata&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CDDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cdlast&gt;: SIGNAL is "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CDLAST";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "MAX_BURST_LENGTH &lt;value&gt;,NUM_WRITE_OUTSTANDING &lt;value&gt;,NUM_READ_OUTSTANDING &lt;value&gt;,SUPPORTS_NARROW_BURST &lt;value&gt;,READ_WRITE_MODE &lt;value&gt;,BUSER_WIDTH &lt;value&gt;,RUSER_WIDTH &lt;value&gt;,WUSER_WIDTH &lt;value&gt;,ARUSER_WIDTH &lt;value&gt;,AWUSER_WIDTH &lt;value&gt;,ADDR_WIDTH &lt;value&gt;,ID_WIDTH &lt;value&gt;,FREQ_HZ &lt;value&gt;,PROTOCOL &lt;value&gt;,DATA_WIDTH &lt;value&gt;";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="AMBA AHB Lite interface" treetype="template">
-- ahblite - AMBA AHB Lite interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_sel&gt; : in std_logic; -- Slave select (required)
  &lt;s_haddr&gt; : in std_logic_vector(31 downto 0); -- Address bus (required)
  &lt;s_hprot&gt; : in std_logic_vector(3 downto 0); -- Protenction type (required)
  &lt;s_htrans&gt; : in std_logic_vector(1 downto 0); -- Transfer type (required)
  &lt;s_hsize&gt; : in std_logic_vector(2 downto 0); -- Transfer size (required)
  &lt;s_hwrite&gt; : in std_logic; -- Write / Read transfer (required)
  &lt;s_hburst&gt; : in std_logic_vector(2 downto 0); -- Burst type (required)
  &lt;s_hwdata&gt; : in std_logic_vector(31 downto 0); -- Write data (required)
  &lt;s_hrdata&gt; : out std_logic_vector(31 downto 0); -- Read data (required)
  &lt;s_hresp&gt; : out std_logic; -- Status of the transfer (required)
  &lt;s_hmastlock&gt; : in std_logic; -- This signal indicates that the current transfer is part of a locked sequence (optional)
  &lt;s_hready&gt; : out std_logic; -- This signal indicates that the previous transfer is complete. (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sel&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; SEL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_haddr&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hprot&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HPROT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_htrans&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HTRANS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hsize&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HSIZE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hwrite&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HWRITE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hburst&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HBURST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hwdata&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HWDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hrdata&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HRDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hresp&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HRESP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hmastlock&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HMASTLOCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hready&gt;: SIGNAL is "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HREADY";

begin
--  user logic here

end arch_impl;
-- ahblite - AMBA AHB Lite interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_sel&gt; : in std_logic; -- Slave select (required)
  &lt;s_haddr&gt; : in std_logic_vector(31 downto 0); -- Address bus (required)
  &lt;s_hprot&gt; : in std_logic_vector(3 downto 0); -- Protection type (required)
  &lt;s_htrans&gt; : in std_logic_vector(1 downto 0); -- Transfer type (required)
  &lt;s_hsize&gt; : in std_logic_vector(2 downto 0); -- Transfer size (required)
  &lt;s_hwrite&gt; : in std_logic; -- Write / Read transfer (required)
  &lt;s_hburst&gt; : in std_logic_vector(2 downto 0); -- Burst type (required)
  &lt;s_hwdata&gt; : in std_logic_vector(31 downto 0); -- Write data (required)
  &lt;s_hrdata&gt; : out std_logic_vector(31 downto 0); -- Read data (required)
  &lt;s_hresp&gt; : out std_logic; -- Status of the transfer (required)
  &lt;s_hmastlock&gt; : in std_logic; -- This signal indicates that the current transfer is part of a locked sequence (optional)
  &lt;s_hready_in&gt; : in std_logic; -- This signal indicates that the previous transfer is complete. (required)
  &lt;s_hready_out&gt; : out std_logic; -- This signal indicates that the transfer is complete. (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sel&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; SEL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_haddr&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hprot&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HPROT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_htrans&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HTRANS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hsize&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HSIZE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hwrite&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HWRITE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hburst&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HBURST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hwdata&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HWDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hrdata&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HRDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hresp&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HRESP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hmastlock&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HMASTLOCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hready_in&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HREADY_IN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hready_out&gt;: SIGNAL is "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HREADY_OUT";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Apb" treetype="template">
-- apb -  (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_paddr&gt; : in std_logic_vector(31 downto 0); -- Address (required)
  &lt;s_pprot&gt; : in std_logic_vector(2 downto 0); -- Protection (optional)
  &lt;s_psel&gt; : in std_logic; -- Slave Select (required)
  &lt;s_penable&gt; : in std_logic; -- Enable (required)
  &lt;s_pwrite&gt; : in std_logic; -- Write Control (required)
  &lt;s_pwdata&gt; : in std_logic_vector(31 downto 0); -- Write Data (required)
  &lt;s_pstrb&gt; : in std_logic_vector(3 downto 0); -- Write data strobe (optional)
  &lt;s_pready&gt; : out std_logic; -- Slave Ready (required)
  &lt;s_prdata&gt; : out std_logic_vector(31 downto 0); -- Read Data (required)
  &lt;s_pslverr&gt; : out std_logic; -- Slave Error Response (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_paddr&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pprot&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PPROT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_psel&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PSEL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_penable&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pwrite&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PWRITE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pwdata&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PWDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pstrb&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PSTRB";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pready&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_prdata&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PRDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pslverr&gt;: SIGNAL is "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PSLVERR";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Avalon" treetype="template">
-- avalon - Avalon interface (slave directions)
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_address&gt; : in std_logic_vector(&lt;leftbound&gt; downto 0); -- Read Write Address (required)
  &lt;s_readdata&gt; : out std_logic_vector(&lt;leftbound&gt; downto 0); -- Read Data (optional)
  &lt;s_readdatavalid&gt; : out std_logic; -- Read Datavalid (optional)
  &lt;s_waitrequest&gt; :  out std_logic; -- Wait Request (optional)
  &lt;s_byteenable&gt; : in std_logic_vector(&lt;leftbound&gt; downto 0); -- Byte Enable (optional)
  &lt;s_read&gt; : in std_logic; -- Read transfer (optional)
  &lt;s_response&gt; : out std_logic_vector(1 downto 0); -- Read Write Response (optional)
  &lt;s_write&gt; : in std_logic; -- Write Transfer (optional)
  &lt;s_writedata&gt; : in std_logic_vector(&lt;leftbound&gt; downto 0); -- Write Data (optional)
  &lt;s_lock&gt; : in std_logic; -- Lock (optional)
  &lt;s_writeresponsevalid&gt; : out std_logic; -- Write Response Valid (optional)
  &lt;s_burstcount&gt; : in std_logic_vector(&lt;leftbound&gt; downto 0); -- Burst Count (optional)
  &lt;s_beginbursttransfer&gt; : in std_logic; -- Begin Burst Transfer (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_address&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; ADDRESS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_readdata&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; READDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_readdatavalid&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; READDATAVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_waitrequest&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; WAITREQUEST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_byteenable&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; BYTEENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; READ";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_response&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; RESPONSE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_write&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; WRITE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_writedata&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; WRITEDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_lock&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; LOCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_writeresponsevalid&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; WRITERESPONSEVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_burstcount&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; BURSTCOUNT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_beginbursttransfer&gt;: SIGNAL is "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; BEGINBURSTTRANSFER";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="AXI SmartConnect Interface" treetype="template">
-- sc - AXI SmartConnect Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_recv&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Response Handshake (optional)
  &lt;s_send&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Forward Handshake (optional)
  &lt;s_req&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Arbitration Request (optional)
  &lt;s_sel&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Arbitration Response (optional)
  &lt;s_payld&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Transfer Payload (optional)
  &lt;s_info&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Additional Transfer Attributes (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_recv&gt;: SIGNAL is "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; RECV";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_send&gt;: SIGNAL is "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; SEND";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_req&gt;: SIGNAL is "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; REQ";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sel&gt;: SIGNAL is "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; SEL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_payld&gt;: SIGNAL is "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; PAYLD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_info&gt;: SIGNAL is "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; INFO";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Block RAM interface" treetype="template">
-- bram - Xilinx Block RAM interface (slave directions)
-- 
-- Allowed parameters:
--  MASTER_TYPE               - Master Type               (string default: &lt;blank&gt;) 
--  MEM_ECC                   - Mem Ecc                   (string default: &lt;blank&gt;) 
--  MEM_WIDTH                 - Mem Width                 (long) 
--  MEM_SIZE                  - Mem Size                  (long) 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_en&gt; : in std_logic; -- Chip Enable Signal (optional)
  &lt;s_dout&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Data Out Bus (optional)
  &lt;s_din&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Data In Bus (optional)
  &lt;s_we&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Byte Enables (optional)
  &lt;s_addr&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Address Signal (required)
  &lt;s_clk&gt; : in std_logic; -- Clock Signal (required)
  &lt;s_rst&gt; : in std_logic; -- Reset Signal (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_en&gt;: SIGNAL is "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dout&gt;: SIGNAL is "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; DOUT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_din&gt;: SIGNAL is "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; DIN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_we&gt;: SIGNAL is "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; WE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_addr&gt;: SIGNAL is "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; ADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk&gt;: SIGNAL is "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst&gt;: SIGNAL is "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; RST";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "MASTER_TYPE &lt;value&gt;,MEM_ECC &lt;value&gt;,MEM_WIDTH &lt;value&gt;,MEM_SIZE &lt;value&gt;";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Boundary Scan (BSCAN) Bus Definition" treetype="template">
-- bscan - Boundary Scan (BSCAN) Bus Definition (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_drck&gt; : in std_logic; -- Data register clock (required)
  &lt;s_reset&gt; : in std_logic; -- Reset (optional)
  &lt;s_sel&gt; : in std_logic; -- Select (required)
  &lt;s_capture&gt; : in std_logic; -- Capture (required)
  &lt;s_shift&gt; : in std_logic; -- Shift (required)
  &lt;s_update&gt; : in std_logic; -- Update (required)
  &lt;s_tdi&gt; : in std_logic; -- Test data in (required)
  &lt;s_tdo&gt; : out std_logic; -- Test data out (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_drck&gt;: SIGNAL is "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; DRCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_reset&gt;: SIGNAL is "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; RESET";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sel&gt;: SIGNAL is "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; SEL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_capture&gt;: SIGNAL is "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; CAPTURE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_shift&gt;: SIGNAL is "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; SHIFT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_update&gt;: SIGNAL is "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; UPDATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tdi&gt;: SIGNAL is "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; TDI";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tdo&gt;: SIGNAL is "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; TDO";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="bus definition for DDR4" treetype="template">
-- ddr4 - bus definition for DDR4 (master directions)
-- 
-- Allowed parameters:
--  TIMEPERIOD_PS             - Timeperiod Ps             (string default: &lt;blank&gt;) 
--  MEMORY_TYPE               - Memory Type               (string default: Components) {Components,UDIMMs,SODIMMs,RDIMMs}
--  MEMORY_PART               - Memory Part               (string default: &lt;blank&gt;) 
--  CUSTOM_PARTS              - Custom Parts              (string default: &lt;blank&gt;) 
--  DATA_WIDTH                - Data Width                (string default: &lt;blank&gt;) 
--  SLOT                      - Slot                      (string default: Single) {Single,Dual}
--  CS_ENABLED                - Enable Chip Select Pin    (bool default: true) 
--  DATA_MASK_ENABLED         - Data Mask                 (string default: NONE) 
--  MEM_ADDR_MAP              - Memory Address Map        (string default: ROW_BANK_COLUMN) {ROW_BANK_COLUMN,BANK_ROW_COLUMN,ROW_COLUMN_BANK,ROW_COLUMN_BANK_INTLV}
--  BURST_LENGTH              - Burst Length              (long default: 8) 
--  AXI_ARBITRATION_SCHEME    - Arbitration Scheme        (string default: TDM) {TDM,ROUND_ROBIN,RD_PRI_REG,RD_PRI_REG_STARVE_LIMIT,WRITE_PRIORITY_REG,WRITE_PRIORITY}
--  CAS_LATENCY               - Cas Latency               (long default: 13) 
--  CAS_WRITE_LATENCY         - Cas Write Latency         (long default: 9) 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_dq&gt; : inout std_logic_vector(63 downto 0); -- Data (required)
  &lt;m_dqs_t&gt; : inout std_logic_vector(7 downto 0); -- Data Strobe (required)
  &lt;m_dqs_c&gt; : inout std_logic_vector(7 downto 0); -- Data Strobe (required)
  &lt;m_adr&gt; : out std_logic_vector(12 downto 0); -- Address (required)
  &lt;m_ba&gt; : out std_logic_vector(2 downto 0); -- Bank Address (required)
  &lt;m_bg&gt; : out std_logic; -- Bank Group Bits (required)
  &lt;m_act_n&gt; : out std_logic; -- write enable (required)
  &lt;m_reset_n&gt; : out std_logic; -- reset to memory device (optional)
  &lt;m_ck_t&gt; : out std_logic; -- clock to memory device (required)
  &lt;m_ck_c&gt; : out std_logic; -- clock to memory device (required)
  &lt;m_cke&gt; : out std_logic; -- clock enable (required)
  &lt;m_cs_n&gt; : out std_logic; -- chip select (required)
  &lt;m_dm_n&gt; : inout std_logic_vector(7 downto 0); -- data mask (required)
  &lt;m_odt&gt; : out std_logic; -- on die termination (required)
  &lt;m_par&gt; : out std_logic; -- parity bit (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dq&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; DQ";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dqs_t&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; DQS_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dqs_c&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; DQS_C";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_adr&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; ADR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ba&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; BA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_bg&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; BG";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_act_n&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; ACT_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_reset_n&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; RESET_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ck_t&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; CK_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ck_c&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; CK_C";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_cke&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; CKE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_cs_n&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; CS_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dm_n&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; DM_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_odt&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; ODT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_par&gt;: SIGNAL is "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; PAR";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "TIMEPERIOD_PS &lt;value&gt;,MEMORY_TYPE &lt;value&gt;,MEMORY_PART &lt;value&gt;,CUSTOM_PARTS &lt;value&gt;,DATA_WIDTH &lt;value&gt;,SLOT &lt;value&gt;,CS_ENABLED &lt;value&gt;,DATA_MASK_ENABLED &lt;value&gt;,MEM_ADDR_MAP &lt;value&gt;,BURST_LENGTH &lt;value&gt;,AXI_ARBITRATION_SCHEME &lt;value&gt;,CAS_LATENCY &lt;value&gt;,CAS_WRITE_LATENCY &lt;value&gt;";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Can" treetype="template">
-- can -  (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_clk&gt; : in std_logic; -- CAN Clock (optional)
  &lt;m_tx&gt; : out std_logic; -- Trasnmit Line (required)
  &lt;m_rx&gt; : in std_logic; -- Receive Line (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_clk&gt;: SIGNAL is "xilinx.com:interface:can:1.0 &lt;interface_name&gt; CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_tx&gt;: SIGNAL is "xilinx.com:interface:can:1.0 &lt;interface_name&gt; TX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rx&gt;: SIGNAL is "xilinx.com:interface:can:1.0 &lt;interface_name&gt; RX";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Configuration Access Port arbitration interface" treetype="template">
-- cap - Configuration Access Port arbitration interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_req&gt; : in std_logic; -- Request output signal. Used by the IP to Request access to the configuration engine (required)
  &lt;s_gnt&gt; : out std_logic; -- Grant input signal. Default drive_value 1. Used by an arbiter to Grant access of the configuration engine to an IP or endpoint (required)
  &lt;s_rel&gt; : out std_logic; -- Request for Release input signal. Default_drive_value 0. Used by an arbiter to Request that an IP or endpoint give up control of the configuration engine (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_req&gt;: SIGNAL is "xilinx.com:interface:cap:1.0 &lt;interface_name&gt; REQ";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gnt&gt;: SIGNAL is "xilinx.com:interface:cap:1.0 &lt;interface_name&gt; GNT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rel&gt;: SIGNAL is "xilinx.com:interface:cap:1.0 &lt;interface_name&gt; REL";

begin
--  user logic here

end arch_impl;
			</Template>
			<SubFolder label="cpri" treetype="folder">
				<Template label="Cpri_hdlc" treetype="template">
-- cpri_hdlc - High Level Data Link Control Interface for CPRI (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_tx_data&gt; : out std_logic; -- HDLC Transmit Serial Data (required)
  &lt;s_rx_data&gt; : in std_logic; -- HDLC Receive Serial Data (required)
  &lt;s_tx_enable&gt; : in std_logic; -- HDLC Enable (optional)
  &lt;s_rx_data_valid&gt; : in std_logic; -- HDLC Data Valid (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data&gt;: SIGNAL is "xilinx.com:interface:cpri_hdlc:1.0 &lt;interface_name&gt; TX_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data&gt;: SIGNAL is "xilinx.com:interface:cpri_hdlc:1.0 &lt;interface_name&gt; RX_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_enable&gt;: SIGNAL is "xilinx.com:interface:cpri_hdlc:1.0 &lt;interface_name&gt; TX_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data_valid&gt;: SIGNAL is "xilinx.com:interface:cpri_hdlc:1.0 &lt;interface_name&gt; RX_DATA_VALID";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Cpri_iq" treetype="template">
-- cpri_iq - CPRI I/Q Interface for sending and receiving sample data and synchronization information (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_data&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- I/Q Data (required)
  &lt;s_enable&gt; : out std_logic; -- I/Q Enable (optional)
  &lt;s_bffw&gt; : in std_logic; -- I/Q Basic Frame First Word (optional)
  &lt;s_strobe&gt; : in std_logic; -- Frame Strobe (optional)
  &lt;s_strobe_bfn&gt; : in std_logic_vector(11 downto 0); -- Node B Frame Number (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data&gt;: SIGNAL is "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_enable&gt;: SIGNAL is "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bffw&gt;: SIGNAL is "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; BFFW";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_strobe&gt;: SIGNAL is "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; STROBE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_strobe_bfn&gt;: SIGNAL is "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; STROBE_BFN";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="CPRI Vendor Specific Interface" treetype="template">
-- cpri_vendor - CPRI Vendor Specific Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_data&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Vendor Specific Word (required)
  &lt;s_tx_xs&gt; : out std_logic_vector(1 downto 0); -- Transmit Control Word Index (optional)
  &lt;s_tx_ns&gt; : out std_logic_vector(5 downto 0); -- Transmit Subchannel Index (optional)
  &lt;s_rx_xs&gt; : in std_logic_vector(1 downto 0); -- Receive Control Word Index (optional)
  &lt;s_rx_ns&gt; : in std_logic_vector(5 downto 0); -- Receive Subchannel Index (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data&gt;: SIGNAL is "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_xs&gt;: SIGNAL is "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; TX_XS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_ns&gt;: SIGNAL is "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; TX_NS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_xs&gt;: SIGNAL is "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; RX_XS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_ns&gt;: SIGNAL is "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; RX_NS";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<Template label="Ddrx" treetype="template">
-- ddrx - Common bus definition for DDR2/DDR3/LPDDR etc (master directions)
-- 
-- Allowed parameters:
--  TIMEPERIOD_PS             - Timeperiod Ps             (string default: &lt;blank&gt;) 
--  CUSTOM_PARTS              - Custom Parts              (string default: &lt;blank&gt;) 
--  MEMORY_TYPE               - Memory Type               (string default: Components) {Components,UDIMMs,SODIMMs,RDIMMs}
--  MEMORY_PART               - Memory Part               (string default: &lt;blank&gt;) 
--  DATA_WIDTH                - Data Width                (string default: &lt;blank&gt;) 
--  SLOT                      - Slot                      (string default: Single) {Single,Dual}
--  CS_ENABLED                - Enable Chip Select Pin    (bool default: true) 
--  DATA_MASK_ENABLED         - Data Mask                 (bool default: true) 
--  MEM_ADDR_MAP              - Memory Address Map        (string default: ROW_BANK_COLUMN) {ROW_BANK_COLUMN,BANK_ROW_COLUMN,ROW_COLUMN_BANK,ROW_COLUMN_BANK_INTLV}
--  BURST_LENGTH              - Burst Length              (long default: 8) 
--  AXI_ARBITRATION_SCHEME    - Arbitration Scheme        (string default: TDM) {TDM,ROUND_ROBIN,RD_PRI_REG,RD_PRI_REG_STARVE_LIMIT,WRITE_PRIORITY_REG,WRITE_PRIORITY}
--  CAS_LATENCY               - Cas Latency               (long default: 13) 
--  CAS_WRITE_LATENCY         - Cas Write Latency         (long default: 9) 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_dq&gt; : inout std_logic_vector(63 downto 0); -- Data (required)
  &lt;m_dqs_p&gt; : inout std_logic_vector(7 downto 0); -- Data Strobe (required)
  &lt;m_dqs_n&gt; : inout std_logic_vector(7 downto 0); -- Data Strobe (required)
  &lt;m_addr&gt; : out std_logic_vector(12 downto 0); -- Address (required)
  &lt;m_ba&gt; : out std_logic_vector(2 downto 0); -- Bank Address (optional)
  &lt;m_ras_n&gt; : out std_logic; -- row address strobe (optional)
  &lt;m_cas_n&gt; : out std_logic; -- column address strobe (optional)
  &lt;m_we_n&gt; : out std_logic; -- write enable (optional)
  &lt;m_reset_n&gt; : out std_logic; -- reset to memory device (optional)
  &lt;m_ck_p&gt; : out std_logic; -- clock to memory device (required)
  &lt;m_ck_n&gt; : out std_logic; -- clock to memory device (required)
  &lt;m_cke&gt; : out std_logic; -- clock enable (required)
  &lt;m_cs_n&gt; : out std_logic; -- chip select (optional)
  &lt;m_dm&gt; : out std_logic_vector(7 downto 0); -- data mask (optional)
  &lt;m_odt&gt; : out std_logic; -- on die termination (optional)
  &lt;m_parity&gt; : out std_logic; -- parity bit (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dq&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; DQ";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dqs_p&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; DQS_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dqs_n&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; DQS_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_addr&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; ADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ba&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; BA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ras_n&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; RAS_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_cas_n&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CAS_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_we_n&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; WE_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_reset_n&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; RESET_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ck_p&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CK_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ck_n&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CK_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_cke&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CKE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_cs_n&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CS_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dm&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; DM";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_odt&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; ODT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_parity&gt;: SIGNAL is "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; PARITY";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "TIMEPERIOD_PS &lt;value&gt;,CUSTOM_PARTS &lt;value&gt;,MEMORY_TYPE &lt;value&gt;,MEMORY_PART &lt;value&gt;,DATA_WIDTH &lt;value&gt;,SLOT &lt;value&gt;,CS_ENABLED &lt;value&gt;,DATA_MASK_ENABLED &lt;value&gt;,MEM_ADDR_MAP &lt;value&gt;,BURST_LENGTH &lt;value&gt;,AXI_ARBITRATION_SCHEME &lt;value&gt;,CAS_LATENCY &lt;value&gt;,CAS_WRITE_LATENCY &lt;value&gt;";

begin
--  user logic here

end arch_impl;
			</Template>
			<SubFolder label="diff" treetype="folder">
				<Template label="Diff_analog_io" treetype="template">
-- diff_analog_io - Differential Analog IO interface for VP/VN and VAUXP[15:0]/VAUXN[15:0] (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_v_p&gt; : in std_logic; -- Analog Volt P (optional)
  &lt;s_v_n&gt; : in std_logic; -- Analog Volt N (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_v_p&gt;: SIGNAL is "xilinx.com:interface:diff_analog_io:1.0 &lt;interface_name&gt; V_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_v_n&gt;: SIGNAL is "xilinx.com:interface:diff_analog_io:1.0 &lt;interface_name&gt; V_N";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Differential Clock Interface" treetype="template">
-- diff_clock - Differential Clock Interface (slave directions)
-- 
-- Allowed parameters:
--  FREQ_HZ                   - Frequency                 (float default: 100000000) 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_clk_p&gt; : in std_logic; -- ClockP (optional)
  &lt;s_clk_n&gt; : in std_logic; -- ClockN (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk_p&gt;: SIGNAL is "xilinx.com:interface:diff_clock:1.0 &lt;interface_name&gt; CLK_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk_n&gt;: SIGNAL is "xilinx.com:interface:diff_clock:1.0 &lt;interface_name&gt; CLK_N";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "FREQ_HZ &lt;value&gt;";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<SubFolder label="dp" treetype="folder">
				<Template label="Dp_aux" treetype="template">
-- dp_aux - Auxiliary interface is to access video register data (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_aux_tx_channel_out_p&gt; : in std_logic; -- Aux. Channel out differential p (required)
  &lt;s_aux_tx_channel_out_n&gt; : in std_logic; -- Aux. Channel out differential n (required)
  &lt;s_aux_tx_channel_in_p&gt; : out std_logic; -- Aux. Channel in differential p (required)
  &lt;s_aux_tx_channel_in_n&gt; : out std_logic; -- Aux. Channel in differential n (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aux_tx_channel_out_p&gt;: SIGNAL is "xilinx.com:interface:dp_aux:1.0 &lt;interface_name&gt; AUX_TX_CHANNEL_OUT_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aux_tx_channel_out_n&gt;: SIGNAL is "xilinx.com:interface:dp_aux:1.0 &lt;interface_name&gt; AUX_TX_CHANNEL_OUT_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aux_tx_channel_in_p&gt;: SIGNAL is "xilinx.com:interface:dp_aux:1.0 &lt;interface_name&gt; AUX_TX_CHANNEL_IN_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aux_tx_channel_in_n&gt;: SIGNAL is "xilinx.com:interface:dp_aux:1.0 &lt;interface_name&gt; AUX_TX_CHANNEL_IN_N";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Dp_main_lnk" treetype="template">
-- dp_main_lnk - To move video stream through these high speed I/O from source to sink core (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_lnk_clk_p&gt; : in std_logic; -- Differential clock input(Positive) (required)
  &lt;m_lnk_clk_n&gt; : in std_logic; -- Differential clock input(Negative) (required)
  &lt;m_lnk_clk&gt; : out std_logic; -- Reference clock for FPGA fabric (required)
  &lt;m_lnk_tx_lane_p&gt; : out std_logic_vector(3 downto 0); -- High-speed lane serial data(Positive) (required)
  &lt;m_lnk_tx_lane_n&gt; : out std_logic_vector(3 downto 0); -- High-speed lane serial data(Negative) (required)
  &lt;m_lnk_m_vid&gt; : out std_logic_vector(23 downto 0); -- M-value for clock generation (optional)
  &lt;m_lnk_n_vid&gt; : out std_logic_vector(23 downto 0); -- N-value for clock generation (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_lnk_clk_p&gt;: SIGNAL is "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_CLK_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_lnk_clk_n&gt;: SIGNAL is "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_CLK_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_lnk_clk&gt;: SIGNAL is "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_lnk_tx_lane_p&gt;: SIGNAL is "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_TX_LANE_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_lnk_tx_lane_n&gt;: SIGNAL is "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_TX_LANE_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_lnk_m_vid&gt;: SIGNAL is "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_M_VID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_lnk_n_vid&gt;: SIGNAL is "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_N_VID";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Dp_vid" treetype="template">
-- dp_vid - Video interface is to access pixel data (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_tx_vid_clk&gt; : in std_logic; -- Video clock (required)
  &lt;s_tx_vid_rst&gt; : in std_logic; -- Video reset (required)
  &lt;s_tx_vid_vsync&gt; : in std_logic; -- Vertical sync (required)
  &lt;s_tx_vid_hsync&gt; : in std_logic; -- Horizontal sync (required)
  &lt;s_tx_vid_oddeven&gt; : in std_logic; -- Video odd/even pixel (required)
  &lt;s_tx_vid_enable&gt; : in std_logic; -- Video enable (required)
  &lt;s_tx_vid_pixel0&gt; : in std_logic; -- Video pixel 0 (required)
  &lt;s_tx_vid_pixel1&gt; : in std_logic; -- Video pixel 1 (required)
  &lt;s_tx_vid_pixel2&gt; : in std_logic; -- Vdeo pixel 2 (required)
  &lt;s_tx_vid_pixel3&gt; : in std_logic; -- Video pixel 3 (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_clk&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_rst&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_RST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_vsync&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_VSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_hsync&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_HSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_oddeven&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_ODDEVEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_enable&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_pixel0&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_PIXEL0";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_pixel1&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_PIXEL1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_pixel2&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_PIXEL2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_vid_pixel3&gt;: SIGNAL is "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_PIXEL3";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<Template label="Dvi" treetype="template">
-- dvi - DVI interface used for AXI TFT controller (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_clk_p&gt; : out std_logic; -- DVI Clock positive signal (required)
  &lt;m_clk_n&gt; : out std_logic; -- DVI Clock negative signal (optional)
  &lt;m_data&gt; : out std_logic_vector(11 downto 0); -- DVI Data (required)
  &lt;m_hsync&gt; : out std_logic; -- Horizantal sync signal (required)
  &lt;m_vsync&gt; : out std_logic; -- Vertical sync signal (required)
  &lt;m_de&gt; : out std_logic; -- Display enable signal (required)
  &lt;m_dps&gt; : out std_logic; -- Display scan signal (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_clk_p&gt;: SIGNAL is "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; CLK_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_clk_n&gt;: SIGNAL is "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; CLK_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_data&gt;: SIGNAL is "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_hsync&gt;: SIGNAL is "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; HSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_vsync&gt;: SIGNAL is "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; VSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_de&gt;: SIGNAL is "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; DE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dps&gt;: SIGNAL is "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; DPS";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Dynamic Reconfiguration Port (DRP)" treetype="template">
-- drp - Dynamic Reconfiguration Port (DRP) (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_den&gt; : in std_logic; -- Enable (required)
  &lt;s_daddr&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Address (required)
  &lt;s_di&gt; : in std_logic; -- Data In (required)
  &lt;s_do&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (required)
  &lt;s_drdy&gt; : out std_logic; --  (required)
  &lt;s_dwe&gt; : in std_logic; --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_den&gt;: SIGNAL is "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_daddr&gt;: SIGNAL is "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_di&gt;: SIGNAL is "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DI";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_do&gt;: SIGNAL is "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DO";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_drdy&gt;: SIGNAL is "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DRDY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dwe&gt;: SIGNAL is "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DWE";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Emc" treetype="template">
-- emc - external memory controller interface definition, used to define interfaces like EMC and memories. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_dq_i&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Data signal from external memory (required)
  &lt;s_dq_o&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Data signal from external memory (required)
  &lt;s_dq_t&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Data signal from external memory (required)
  &lt;s_dq_parity_i&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Data parity input from memory (optional)
  &lt;s_dq_parity_o&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Data parity output to memory (optional)
  &lt;s_dq_parity_t&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Data parity enable signal (optional)
  &lt;s_addr&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- external memory address signal (required)
  &lt;s_ce&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Active high chip enable signal (optional)
  &lt;s_ce_n&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Active low chip enable signal (optional)
  &lt;s_oen&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Outut enable signals (optional)
  &lt;s_wen&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write enable signal (optional)
  &lt;s_ben&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- byte enable signal (optional)
  &lt;s_qwen&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Quad word enable signal (optional)
  &lt;s_rpn&gt; : in std_logic; -- Reset or power down signal (optional)
  &lt;s_adv_ldn&gt; : in std_logic; -- Active low address valid signal (optional)
  &lt;s_lbon&gt; : in std_logic; -- interleaved burst ordering (optional)
  &lt;s_clken&gt; : in std_logic; -- clock enable signal (optional)
  &lt;s_rnw&gt; : in std_logic; -- Read or write signal (optional)
  &lt;s_cre&gt; : in std_logic; -- command sequence configuration of RSRAM (optional)
  &lt;s_wait&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- wait signal from memory (optional)
  &lt;s_rd_clk&gt; : in std_logic; -- Read Clock Signal (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dq_i&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dq_o&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dq_t&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dq_parity_i&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_PARITY_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dq_parity_o&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_PARITY_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dq_parity_t&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_PARITY_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_addr&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; ADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ce&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; CE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ce_n&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; CE_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_oen&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; OEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wen&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; WEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ben&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; BEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qwen&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; QWEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rpn&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; RPN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_adv_ldn&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; ADV_LDN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_lbon&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; LBON";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clken&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; CLKEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rnw&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; RNW";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cre&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; CRE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wait&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; WAIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rd_clk&gt;: SIGNAL is "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; RD_CLK";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Evntbus" treetype="template">
-- evntbus - The event bus in ARM processors provide a low-latency and direct mechanism to transfer status and implement a wake mechanism for the Application processing unit (APU) (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_evento&gt; : in std_logic; -- Toggle Output (optional)
  &lt;s_eventi&gt; : out std_logic; -- Toggle Input (optional)
  &lt;s_standbywfe&gt; : in std_logic_vector(1 downto 0); -- Indicates CPU State Following the Execution of the WFE (wait for event) Instruction (optional)
  &lt;s_standbywfi&gt; : in std_logic_vector(1 downto 0); -- Indicates CPU State Following the Execution of the WFI (wait for interrupt) Instruction (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_evento&gt;: SIGNAL is "xilinx.com:interface:evntbus:1.0 &lt;interface_name&gt; EVENTO";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_eventi&gt;: SIGNAL is "xilinx.com:interface:evntbus:1.0 &lt;interface_name&gt; EVENTI";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_standbywfe&gt;: SIGNAL is "xilinx.com:interface:evntbus:1.0 &lt;interface_name&gt; STANDBYWFE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_standbywfi&gt;: SIGNAL is "xilinx.com:interface:evntbus:1.0 &lt;interface_name&gt; STANDBYWFI";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="external peripheral controller interface definition" treetype="template">
-- epc - external peripheral controller interface definition (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_cs_n&gt; : in std_logic; -- Chip Enable Signal (optional)
  &lt;s_addr&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Address signal (required)
  &lt;s_ads&gt; : in std_logic; -- Address Strobe Signal (optional)
  &lt;s_be&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Byte enables (required)
  &lt;s_rnw&gt; : in std_logic; -- Active high read and active low write signal (optional)
  &lt;s_rd_n&gt; : in std_logic; -- Active low read signal (optional)
  &lt;s_wr_n&gt; : in std_logic; -- Active low write signal (optional)
  &lt;s_burst&gt; : in std_logic; -- Burst operation  (optional)
  &lt;s_rdy&gt; : out std_logic; -- Ready signal (required)
  &lt;s_data_i&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Input signal from the tristate data bus (required)
  &lt;s_data_o&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- output signal from the tristate data bus (required)
  &lt;s_data_t&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Output enable signal from the tristate data bus (required)
  &lt;s_clk&gt; : in std_logic; -- Peripheral clock signal (optional)
  &lt;s_rst&gt; : in std_logic; -- Peripheral Reset (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cs_n&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; CS_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_addr&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; ADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ads&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; ADS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_be&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; BE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rnw&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; RNW";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rd_n&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; RD_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wr_n&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; WR_N";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_burst&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; BURST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rdy&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; RDY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_i&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; DATA_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_o&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; DATA_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_t&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; DATA_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst&gt;: SIGNAL is "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; RST";

begin
--  user logic here

end arch_impl;
			</Template>
			<SubFolder label="fifo" treetype="folder">
				<Template label="FIFO read interface" treetype="template">
-- fifo_read - FIFO read interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_rd_data&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- FIFO Read Data (required)
  &lt;s_rd_en&gt; : in std_logic; -- FIFO Read Enable (required)
  &lt;s_empty&gt; : out std_logic; -- FIFO Empty flag (optional)
  &lt;s_almost_empty&gt; : out std_logic; -- FIFO Almost Empty flag (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rd_data&gt;: SIGNAL is "xilinx.com:interface:fifo_read:1.0 &lt;interface_name&gt; RD_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rd_en&gt;: SIGNAL is "xilinx.com:interface:fifo_read:1.0 &lt;interface_name&gt; RD_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_empty&gt;: SIGNAL is "xilinx.com:interface:fifo_read:1.0 &lt;interface_name&gt; EMPTY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_almost_empty&gt;: SIGNAL is "xilinx.com:interface:fifo_read:1.0 &lt;interface_name&gt; ALMOST_EMPTY";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Fifo_write" treetype="template">
-- fifo_write -  (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_wr_data&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- FIFO Write Data (required)
  &lt;s_wr_en&gt; : in std_logic; -- FIFO Write Enable (required)
  &lt;s_full&gt; : out std_logic; -- FIFO Full flag (optional)
  &lt;s_almost_full&gt; : out std_logic; -- FIFO Almost full flag (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wr_data&gt;: SIGNAL is "xilinx.com:interface:fifo_write:1.0 &lt;interface_name&gt; WR_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wr_en&gt;: SIGNAL is "xilinx.com:interface:fifo_write:1.0 &lt;interface_name&gt; WR_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_full&gt;: SIGNAL is "xilinx.com:interface:fifo_write:1.0 &lt;interface_name&gt; FULL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_almost_full&gt;: SIGNAL is "xilinx.com:interface:fifo_write:1.0 &lt;interface_name&gt; ALMOST_FULL";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<Template label="General purpose input output interface" treetype="template">
-- gpio - General purpose input output interface (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_tri_t&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Tristate output enable signal (optional)
  &lt;m_tri_o&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Tristate output signal (optional)
  &lt;m_tri_i&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Tristate input signal (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_tri_t&gt;: SIGNAL is "xilinx.com:interface:gpio:1.0 &lt;interface_name&gt; TRI_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_tri_o&gt;: SIGNAL is "xilinx.com:interface:gpio:1.0 &lt;interface_name&gt; TRI_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_tri_i&gt;: SIGNAL is "xilinx.com:interface:gpio:1.0 &lt;interface_name&gt; TRI_I";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Gigabit Media Independent Interface" treetype="template">
-- gmii - Gigabit Media Independent Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_txd&gt; : in std_logic_vector(7 downto 0); -- Ethernet transmit data. (required)
  &lt;s_tx_en&gt; : in std_logic; -- Ethernet transmit enable. (required)
  &lt;s_tx_er&gt; : in std_logic; -- Ethernet transmit error. (optional)
  &lt;s_rxd&gt; : out std_logic_vector(7 downto 0); -- Ethernet receive data.  (required)
  &lt;s_rx_dv&gt; : out std_logic; -- Ethernet receive data valid. (required)
  &lt;s_rx_er&gt; : out std_logic; -- Ethernet receive error. (required)
  &lt;s_crs&gt; : out std_logic; -- Ethernet carrier sense. (optional)
  &lt;s_col&gt; : out std_logic; -- Ethernet collision. (optional)
  &lt;s_tx_clk&gt; : out std_logic; -- Ethernet transmit clock for 10/100Mb/s Ethernet speeds (optional)
  &lt;s_gtx_clk&gt; : in std_logic; -- Ethernet transmit clock for 1Gb/s Ethernet (optional)
  &lt;s_rx_clk&gt; : out std_logic; -- Ethernet receive clock (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txd&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; TXD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_en&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; TX_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_er&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; TX_ER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxd&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; RXD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_dv&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; RX_DV";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_er&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; RX_ER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_crs&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; CRS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_col&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; COL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_clk&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; TX_CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gtx_clk&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; GTX_CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_clk&gt;: SIGNAL is "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; RX_CLK";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="GT interface" treetype="template">
-- gt - GT interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_gtx_p&gt; : in std_logic; --  (optional)
  &lt;s_gtx_n&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gtx_p&gt;: SIGNAL is "xilinx.com:interface:gt:1.0 &lt;interface_name&gt; GTX_P";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gtx_n&gt;: SIGNAL is "xilinx.com:interface:gt:1.0 &lt;interface_name&gt; GTX_N";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="HDMI Interface" treetype="template">
-- hdmi - HDMI Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_data&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- HDMI Data (required)
  &lt;s_hsync&gt; : in std_logic; -- HDMI Horizontal sync (optional)
  &lt;s_vsync&gt; : in std_logic; -- HDMI Vertical sync (optional)
  &lt;s_de&gt; : in std_logic; -- HDMI Active Video (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data&gt;: SIGNAL is "xilinx.com:interface:hdmi:1.0 &lt;interface_name&gt; DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hsync&gt;: SIGNAL is "xilinx.com:interface:hdmi:1.0 &lt;interface_name&gt; HSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vsync&gt;: SIGNAL is "xilinx.com:interface:hdmi:1.0 &lt;interface_name&gt; VSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_de&gt;: SIGNAL is "xilinx.com:interface:hdmi:1.0 &lt;interface_name&gt; DE";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Hsic" treetype="template">
-- hsic - HSIC interface for USB HSIC capable PHY's (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_data&gt; : inout std_logic; -- HSIC Data line (required)
  &lt;m_strobe&gt; : inout std_logic; -- HSIC Strobe line (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_data&gt;: SIGNAL is "xilinx.com:interface:hsic:1.0 &lt;interface_name&gt; DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_strobe&gt;: SIGNAL is "xilinx.com:interface:hsic:1.0 &lt;interface_name&gt; STROBE";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="ICAP interface" treetype="template">
-- icap - ICAP interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_csib&gt; : in std_logic; --  (required)
  &lt;s_rdwrb&gt; : in std_logic; --  (required)
  &lt;s_i&gt; : in std_logic_vector(31 downto 0); --  (required)
  &lt;s_o&gt; : out std_logic_vector(31 downto 0); --  (required)
  &lt;s_clk&gt; : in std_logic; --  (optional)
  &lt;s_avail&gt; : out std_logic; --  (optional)
  &lt;s_prdone&gt; : out std_logic; --  (optional)
  &lt;s_prerror&gt; : out std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_csib&gt;: SIGNAL is "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; csib";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rdwrb&gt;: SIGNAL is "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; rdwrb";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_i&gt;: SIGNAL is "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; i";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_o&gt;: SIGNAL is "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; o";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk&gt;: SIGNAL is "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; clk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_avail&gt;: SIGNAL is "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; avail";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_prdone&gt;: SIGNAL is "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; prdone";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_prerror&gt;: SIGNAL is "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; prerror";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="IIC Interface" treetype="template">
-- iic - IIC Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_scl_i&gt; : out std_logic; -- IIC Serial Clock Input from 3-state buffer (required)
  &lt;s_scl_o&gt; : in std_logic; -- IIC Serial Clock Output to 3-state buffer (required)
  &lt;s_scl_t&gt; : in std_logic; -- IIC Serial Clock Output Enable to 3-state buffer (required)
  &lt;s_sda_i&gt; : out std_logic; -- IIC Serial Data Input from 3-state buffer (required)
  &lt;s_sda_o&gt; : in std_logic; -- IIC Serial Data Output to 3-state buffer (required)
  &lt;s_sda_t&gt; : in std_logic; -- IIC Serial Data Output Enable to 3-state buffer (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_scl_i&gt;: SIGNAL is "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SCL_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_scl_o&gt;: SIGNAL is "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SCL_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_scl_t&gt;: SIGNAL is "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SCL_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sda_i&gt;: SIGNAL is "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SDA_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sda_o&gt;: SIGNAL is "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SDA_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sda_t&gt;: SIGNAL is "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SDA_T";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="_Info" treetype="template">
-- 
-- VHDL Attributes are used to declare interfaces and set parameters on them.
-- Due to the language, the attributes need to be placed into the architecture declaration section.
-- The attributes need to be declared and then attached to a declared port.
-- When mapping logical names from the interface to a port in your hdl, there will be a seperate
-- attribute attached for each port.
-- When adding one or more parameters for an interface, a single attribute with multiple
-- key value pairs should be added to one of the ports that was mapped into the interface.
-- Generally, the form of the attributes are:
--   ATTRIBUTE X_INTERFACE_INFO : STRING;
--   ATTRIBUTE X_INTERFACE_INFO of &lt;port_name&gt;: SIGNAL is "&lt;interface vlnv&gt; &lt;interface_name&gt; &lt;logical_port_name&gt;";
--   ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
--   ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "&lt;parameter_name1&gt; &lt;parameter_value1&gt;, &lt;parameter_name2&gt; &lt;parameter_value2&gt;"; 
			</Template>
			<Template label="Jtag" treetype="template">
-- jtag - Provides debug access via a standard JTAG debug interface (slave directions)
-- 
-- Allowed parameters:
--  BUFFER_TYPE               - Buffer Type               (string default: NONE) {AUTO,NONE}

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_tck&gt; : in std_logic; --  (required)
  &lt;s_tms&gt; : in std_logic; --  (required)
  &lt;s_td_i&gt; : in std_logic; --  (required)
  &lt;s_td_o&gt; : out std_logic; --  (required)
  &lt;s_td_t&gt; : out std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tck&gt;: SIGNAL is "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tms&gt;: SIGNAL is "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TMS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_td_i&gt;: SIGNAL is "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TD_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_td_o&gt;: SIGNAL is "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TD_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_td_t&gt;: SIGNAL is "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TD_T";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "BUFFER_TYPE &lt;value&gt;";

begin
--  user logic here

end arch_impl;
-- jtag - Provides debug access via a standard JTAG debug interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_tck&gt; : in std_logic; --  (required)
  &lt;s_tms&gt; : in std_logic; --  (required)
  &lt;s_tdi&gt; : in std_logic; --  (required)
  &lt;s_tdo&gt; : out std_logic; --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tck&gt;: SIGNAL is "xilinx.com:interface:jtag:2.0 &lt;interface_name&gt; TCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tms&gt;: SIGNAL is "xilinx.com:interface:jtag:2.0 &lt;interface_name&gt; TMS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tdi&gt;: SIGNAL is "xilinx.com:interface:jtag:2.0 &lt;interface_name&gt; TDI";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tdo&gt;: SIGNAL is "xilinx.com:interface:jtag:2.0 &lt;interface_name&gt; TDO";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Local Memory Bus (LMB) Definition" treetype="template">
-- lmb - Local Memory Bus (LMB) Definition (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_rst&gt; : in std_logic; -- Reset (optional)
  &lt;s_abus&gt; : in std_logic_vector(31 downto 0); -- Address bus (required)
  &lt;s_readstrobe&gt; : in std_logic; -- Read strobe (required)
  &lt;s_writestrobe&gt; : in std_logic; -- Write strobe (optional)
  &lt;s_addrstrobe&gt; : in std_logic; -- Address strobe (required)
  &lt;s_writedbus&gt; : in std_logic_vector(31 downto 0); -- Write data bus (optional)
  &lt;s_be&gt; : in std_logic_vector(3 downto 0); -- Byte enable (optional)
  &lt;s_ready&gt; : out std_logic; -- Ready (required)
  &lt;s_wait&gt; : out std_logic; -- Wait (optional)
  &lt;s_ce&gt; : out std_logic; -- Correctable error (optional)
  &lt;s_ue&gt; : out std_logic; -- Uncorrectable error (optional)
  &lt;s_readdbus&gt; : out std_logic_vector(31 downto 0); -- Read data bus (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; RST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_abus&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; ABUS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_readstrobe&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; READSTROBE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_writestrobe&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; WRITESTROBE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_addrstrobe&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; ADDRSTROBE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_writedbus&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; WRITEDBUS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_be&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; BE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ready&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; READY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wait&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; WAIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ce&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; CE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ue&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; UE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_readdbus&gt;: SIGNAL is "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; READDBUS";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Management Data IO interface" treetype="template">
-- mdio - Management Data IO interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_mdc&gt; : in std_logic; -- Ethernet to PHY MII Management clock (required)
  &lt;s_io&gt; : inout std_logic; --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mdc&gt;: SIGNAL is "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_io&gt;: SIGNAL is "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; IO";

begin
--  user logic here

end arch_impl;
-- mdio - Management Data IO interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_mdio_i&gt; : in std_logic; -- PHY MDIO data input from 3-state buffer (optional)
  &lt;s_mdio_o&gt; : out std_logic; -- PHY MDIO data output to 3-state buffer (optional)
  &lt;s_mdio_t&gt; : out std_logic; -- PHY MDIO data output enable to 3-state buffer (optional)
  &lt;s_mdc&gt; : in std_logic; -- Ethernet to PHY MII Management clock (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mdio_i&gt;: SIGNAL is "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDIO_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mdio_o&gt;: SIGNAL is "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDIO_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mdio_t&gt;: SIGNAL is "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDIO_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mdc&gt;: SIGNAL is "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDC";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="MicroBlaze Debug Bus Interface" treetype="template">
-- mbdebug - MicroBlaze Debug Bus Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_clk&gt; : in std_logic; -- Debug clock (required)
  &lt;s_tdi&gt; : in std_logic; -- Debug test data in (required)
  &lt;s_tdo&gt; : out std_logic; -- Debug test data out (required)
  &lt;s_reg_en&gt; : in std_logic_vector(7 downto 0); -- Debug register enable (required)
  &lt;s_shift&gt; : in std_logic; -- Debug shift (required)
  &lt;s_capture&gt; : in std_logic; -- Debug capture (required)
  &lt;s_update&gt; : in std_logic; -- Debug update (required)
  &lt;s_rst&gt; : in std_logic; -- Debug reset (required)
  &lt;s_trig_in&gt; : out std_logic_vector(7 downto 0); -- Trigger input (optional)
  &lt;s_trig_ack_in&gt; : in std_logic_vector(7 downto 0); -- Trigger Acknowledge input (optional)
  &lt;s_trig_out&gt; : in std_logic_vector(7 downto 0); -- Trigger output (optional)
  &lt;s_trig_ack_out&gt; : out std_logic_vector(7 downto 0); -- Trigger Acknowledge output (optional)
  &lt;s_trclk&gt; : in std_logic; -- Trace Clock (optional)
  &lt;s_trdata&gt; : out std_logic_vector(35 downto 0); -- Trace Data (optional)
  &lt;s_trready&gt; : in std_logic; -- Trace Ready (optional)
  &lt;s_trvalid&gt; : out std_logic; -- Trace Valid (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tdi&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TDI";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tdo&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TDO";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_reg_en&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; REG_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_shift&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; SHIFT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_capture&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; CAPTURE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_update&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; UPDATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; RST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trig_in&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRIG_IN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trig_ack_in&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRIG_ACK_IN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trig_out&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRIG_OUT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trig_ack_out&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRIG_ACK_OUT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trclk&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRCLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trdata&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trready&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trvalid&gt;: SIGNAL is "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRVALID";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="MicroBlaze Interrupt Bus Interface" treetype="template">
-- mbinterrupt - MicroBlaze Interrupt Bus Interface (slave directions)
-- 
-- Allowed parameters:
--  LOW_LATENCY               - Low Latency               (string default: &lt;blank&gt;) 
--  SENSITIVITY               - Sensitivity               (string default: LEVEL_HIGH) {LEVEL_HIGH,LEVEL_LOW,EDGE_RISING,EDGE_FALLING}

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_interrupt&gt; : in std_logic; -- Interrupt (required)
  &lt;s_address&gt; : in std_logic_vector(31 downto 0); -- Interrupt address (optional)
  &lt;s_ack&gt; : out std_logic_vector(1 downto 0); -- Interrupt acknowledge (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_interrupt&gt;: SIGNAL is "xilinx.com:interface:mbinterrupt:1.0 &lt;interface_name&gt; INTERRUPT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_address&gt;: SIGNAL is "xilinx.com:interface:mbinterrupt:1.0 &lt;interface_name&gt; ADDRESS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ack&gt;: SIGNAL is "xilinx.com:interface:mbinterrupt:1.0 &lt;interface_name&gt; ACK";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "LOW_LATENCY &lt;value&gt;,SENSITIVITY &lt;value&gt;";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="MicroBlaze MCS I/O Bus Definition" treetype="template">
-- mcsio_bus - MicroBlaze MCS I/O Bus Definition (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_addr_strobe&gt; : in std_logic; -- I/O address strobe (required)
  &lt;s_read_strobe&gt; : in std_logic; -- I/O read strobe (optional)
  &lt;s_write_strobe&gt; : in std_logic; -- I/O write strobe (optional)
  &lt;s_address&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- I/O address (optional)
  &lt;s_byte_enable&gt; : in std_logic_vector(3 downto 0); -- I/O byte enable (optional)
  &lt;s_write_data&gt; : in std_logic_vector(31 downto 0); -- I/O write data (optional)
  &lt;s_read_data&gt; : out std_logic_vector(31 downto 0); -- I/O read data (optional)
  &lt;s_ready&gt; : out std_logic; -- I/O ready (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_addr_strobe&gt;: SIGNAL is "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; ADDR_STROBE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read_strobe&gt;: SIGNAL is "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; READ_STROBE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_write_strobe&gt;: SIGNAL is "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; WRITE_STROBE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_address&gt;: SIGNAL is "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; ADDRESS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_byte_enable&gt;: SIGNAL is "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; BYTE_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_write_data&gt;: SIGNAL is "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; WRITE_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read_data&gt;: SIGNAL is "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; READ_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ready&gt;: SIGNAL is "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; READY";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="MicroBlaze Trace Bus Definition" treetype="template">
-- mbtrace - MicroBlaze Trace Bus Definition (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_instruction&gt; : in std_logic_vector(31 downto 0); -- Trace instruction (optional)
  &lt;s_valid_instr&gt; : in std_logic; -- Trace valid instruction (optional)
  &lt;s_pc&gt; : in std_logic_vector(31 downto 0); -- Trace program counter (optional)
  &lt;s_reg_write&gt; : in std_logic; -- Trace register write (optional)
  &lt;s_reg_addr&gt; : in std_logic_vector(4 downto 0); -- Trace register address (optional)
  &lt;s_msr_reg&gt; : in std_logic_vector(14 downto 0); -- Trace machine status register (optional)
  &lt;s_pid_reg&gt; : in std_logic_vector(7 downto 0); -- Trace process id register (optional)
  &lt;s_new_reg_value&gt; : in std_logic_vector(31 downto 0); -- Trace new register value (optional)
  &lt;s_exception_taken&gt; : in std_logic; -- Trace exception taken (optional)
  &lt;s_exception_kind&gt; : in std_logic_vector(4 downto 0); -- Trace exception kind (optional)
  &lt;s_jump_taken&gt; : in std_logic; -- Trace jump taken (optional)
  &lt;s_delay_slot&gt; : in std_logic; -- Trace delay slot (optional)
  &lt;s_data_address&gt; : in std_logic_vector(31 downto 0); -- Trace data address (optional)
  &lt;s_data_access&gt; : in std_logic; -- Trace data access (optional)
  &lt;s_data_read&gt; : in std_logic; -- Trace  data read (optional)
  &lt;s_data_write&gt; : in std_logic; -- Trace data write (optional)
  &lt;s_data_write_value&gt; : in std_logic_vector(31 downto 0); -- Trace data write value (optional)
  &lt;s_data_byte_enable&gt; : in std_logic_vector(3 downto 0); -- Trace data byte enable (optional)
  &lt;s_dcache_req&gt; : in std_logic; -- Trace data cache request (optional)
  &lt;s_dcache_hit&gt; : in std_logic; -- Trace data cache hit (optional)
  &lt;s_dcache_rdy&gt; : in std_logic; -- Trace data cache ready (optional)
  &lt;s_dcache_read&gt; : in std_logic; -- Trace data cache read (optional)
  &lt;s_icache_req&gt; : in std_logic; -- Trace instruction cache request (optional)
  &lt;s_icache_hit&gt; : in std_logic; -- Trace instruction cache hit (optional)
  &lt;s_icache_rdy&gt; : in std_logic; -- Trace instruction cache ready (optional)
  &lt;s_of_piperun&gt; : in std_logic; -- Trace OF pipe run (optional)
  &lt;s_ex_piperun&gt; : in std_logic; -- Trace EX pipe run (optional)
  &lt;s_mem_piperun&gt; : in std_logic; -- Trace MEM pipe run (optional)
  &lt;s_mb_halted&gt; : in std_logic; -- Trace MicroBlaze halted (optional)
  &lt;s_jump_hit&gt; : in std_logic; -- Trace jump hit (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_instruction&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; INSTRUCTION";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_valid_instr&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; VALID_INSTR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pc&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; PC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_reg_write&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; REG_WRITE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_reg_addr&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; REG_ADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_msr_reg&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; MSR_REG";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pid_reg&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; PID_REG";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_new_reg_value&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; NEW_REG_VALUE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_exception_taken&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; EXCEPTION_TAKEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_exception_kind&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; EXCEPTION_KIND";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_jump_taken&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; JUMP_TAKEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_delay_slot&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DELAY_SLOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_address&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_ADDRESS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_access&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_ACCESS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_read&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_READ";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_write&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_WRITE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_write_value&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_WRITE_VALUE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_byte_enable&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_BYTE_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dcache_req&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DCACHE_REQ";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dcache_hit&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DCACHE_HIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dcache_rdy&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DCACHE_RDY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dcache_read&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DCACHE_READ";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_icache_req&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; ICACHE_REQ";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_icache_hit&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; ICACHE_HIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_icache_rdy&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; ICACHE_RDY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_of_piperun&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; OF_PIPERUN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ex_piperun&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; EX_PIPERUN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mem_piperun&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; MEM_PIPERUN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mb_halted&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; MB_HALTED";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_jump_hit&gt;: SIGNAL is "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; JUMP_HIT";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Mii" treetype="template">
-- mii -  (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_txd&gt; : in std_logic_vector(3 downto 0); -- Ethernet transmit data (required)
  &lt;s_tx_en&gt; : in std_logic; -- Ethernet transmit enable (required)
  &lt;s_tx_er&gt; : in std_logic; -- Ethernet transmit error (optional)
  &lt;s_rxd&gt; : out std_logic_vector(3 downto 0); -- Ethernet receive data (required)
  &lt;s_rx_dv&gt; : out std_logic; -- Ethernet receive data valid (required)
  &lt;s_rx_er&gt; : out std_logic; -- Ethernet receive error (required)
  &lt;s_crs&gt; : out std_logic; -- Ethernet carrier sense (optional)
  &lt;s_col&gt; : out std_logic; -- Ethernet collision (optional)
  &lt;s_tx_clk&gt; : out std_logic; -- Ethernet transmit clock (required)
  &lt;s_rx_clk&gt; : out std_logic; -- Ethernet receive clock (required)
  &lt;s_rst_n&gt; : in std_logic; -- PHY reset, active low (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txd&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; TXD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_en&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; TX_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_er&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; TX_ER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxd&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RXD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_dv&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RX_DV";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_er&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RX_ER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_crs&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; CRS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_col&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; COL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_clk&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; TX_CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_clk&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RX_CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst_n&gt;: SIGNAL is "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RST_N";

begin
--  user logic here

end arch_impl;
			</Template>
			<SubFolder label="onsg" treetype="folder">
				<Template label="FEC Interface for Framer blocks" treetype="template">
-- onsg_fec - FEC Interface for Framer blocks (slave directions)
-- 
-- Allowed parameters:
--  OTN_RATE                  - OTN_RATE                  (string default: OTU1) {OTU1,OTU2,OTU3,OTU4}

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_fen_valid&gt; : in std_logic; --  (required)
  &lt;s_fen_fs&gt; : in std_logic; --  (required)
  &lt;s_fen_data&gt; : in std_logic; --  (required)
  &lt;s_fde_valid&gt; : in std_logic; --  (required)
  &lt;s_fde_fs&gt; : in std_logic; --  (required)
  &lt;s_fde_data&gt; : in std_logic; --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fen_valid&gt;: SIGNAL is "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FEN_Valid";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fen_fs&gt;: SIGNAL is "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FEN_FS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fen_data&gt;: SIGNAL is "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FEN_Data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fde_valid&gt;: SIGNAL is "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FDE_Valid";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fde_fs&gt;: SIGNAL is "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FDE_FS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fde_data&gt;: SIGNAL is "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FDE_Data";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "OTN_RATE &lt;value&gt;";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Onsg_proc" treetype="template">
-- onsg_proc - Processor interface for OTN IP Blocks (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_proc_cs&gt; : in std_logic; -- Chip select (required)
  &lt;s_proc_we&gt; : in std_logic; -- Write Enable (required)
  &lt;s_proc_addr&gt; : in std_logic_vector(31 downto 0); -- Access Address (required)
  &lt;s_proc_d_in&gt; : in std_logic_vector(31 downto 0); -- Access Write Data (required)
  &lt;s_proc_d_out&gt; : out std_logic_vector(31 downto 0); -- Access Read Data (required)
  &lt;s_proc_ack&gt; : out std_logic; -- Processor cycle acknowledge (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_proc_cs&gt;: SIGNAL is "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_CS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_proc_we&gt;: SIGNAL is "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_WE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_proc_addr&gt;: SIGNAL is "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_Addr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_proc_d_in&gt;: SIGNAL is "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_D_In";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_proc_d_out&gt;: SIGNAL is "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_D_Out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_proc_ack&gt;: SIGNAL is "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_Ack";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<SubFolder label="pcie" treetype="folder">
				<Template label="Pcie_cfg_fc" treetype="template">
-- pcie_cfg_fc - Configuration Flow Control for PCIE Gen2/3 Core. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_ph&gt; : in std_logic_vector(7 downto 0); -- Posted Header Flow Control Credit (optional)
  &lt;s_pd&gt; : in std_logic_vector(11 downto 0); -- Posted Data Flow Control Credit (optional)
  &lt;s_nph&gt; : in std_logic_vector(7 downto 0); -- Non-Posted Header Flow Control Credit (optional)
  &lt;s_npd&gt; : in std_logic_vector(11 downto 0); -- Non-Posted Data Flow Control Credit (optional)
  &lt;s_cplh&gt; : in std_logic_vector(7 downto 0); -- Completion Header Flow Control Credit (optional)
  &lt;s_cpld&gt; : in std_logic_vector(11 downto 0); -- Completion Data Flow Control Credit (optional)
  &lt;s_sel&gt; : out std_logic_vector(2 downto 0); -- Flow Control Information Select (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ph&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; PH";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pd&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; PD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_nph&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; NPH";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_npd&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; NPD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cplh&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; CPLH";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cpld&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; CPLD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sel&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; SEL";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie_cfg_mgmt" treetype="template">
-- pcie_cfg_mgmt - Configuration Management register for PCIE Gen2/3 is used to read and write to the Configuration Space registers (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_addr&gt; : in std_logic_vector(18 downto 0); --  (required)
  &lt;s_write_en&gt; : in std_logic; --  (required)
  &lt;s_write_data&gt; : in std_logic_vector(31 downto 0); --  (required)
  &lt;s_byte_en&gt; : in std_logic_vector(3 downto 0); --  (required)
  &lt;s_read_en&gt; : in std_logic; --  (required)
  &lt;s_read_data&gt; : out std_logic_vector(31 downto 0); --  (required)
  &lt;s_read_write_done&gt; : out std_logic; --  (required)
  &lt;s_type1_cfg_reg_access&gt; : in std_logic; --  (optional)
  &lt;s_readonly&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_addr&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; ADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_write_en&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; WRITE_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_write_data&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; WRITE_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_byte_en&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; BYTE_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read_en&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; READ_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read_data&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; READ_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read_write_done&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; READ_WRITE_DONE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_type1_cfg_reg_access&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; TYPE1_CFG_REG_ACCESS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_readonly&gt;: SIGNAL is "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; READONLY";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie_pipe_debug" treetype="template">
-- pcie_pipe_debug - Transceiver Debug Interfaces for PCIE Gen2/3 Core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_txprbssel&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_rxprbssel&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_txprbsforceerr&gt; : in std_logic; --  (optional)
  &lt;s_rxprbscntreset&gt; : in std_logic; --  (optional)
  &lt;s_loopback&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_rxprbserr&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_rst_fsm&gt; : out std_logic_vector(4 downto 0); --  (optional)
  &lt;s_qrst_fsm&gt; : out std_logic_vector(11 downto 0); --  (optional)
  &lt;s_rate_fsm&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_sync_fsm_tx&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_sync_fsm_rx&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_drp_fsm&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_rst_idle&gt; : out std_logic; --  (optional)
  &lt;s_qrst_idle&gt; : out std_logic; --  (optional)
  &lt;s_rate_idle&gt; : out std_logic; --  (optional)
  &lt;s_gt_ch_drp_rdy&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (required)
  &lt;s_debug_0&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (required)
  &lt;s_debug_1&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_2&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_3&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_4&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_5&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_6&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_7&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_8&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_9&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug&gt; : out std_logic_vector(31 downto 0); --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txprbssel&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; txprbssel";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxprbssel&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rxprbssel";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txprbsforceerr&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; txprbsforceerr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxprbscntreset&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rxprbscntreset";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_loopback&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; loopback";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxprbserr&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rxprbserr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst_fsm&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rst_fsm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qrst_fsm&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; qrst_fsm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rate_fsm&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rate_fsm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sync_fsm_tx&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; sync_fsm_tx";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sync_fsm_rx&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; sync_fsm_rx";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_drp_fsm&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; drp_fsm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst_idle&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rst_idle";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qrst_idle&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; qrst_idle";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rate_idle&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rate_idle";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gt_ch_drp_rdy&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; gt_ch_drp_rdy";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_0&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_0";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_1&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_2&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_3&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_3";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_4&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_4";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_5&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_5";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_6&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_6";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_7&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_7";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_8&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_8";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_9&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_9";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug&gt;: SIGNAL is "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie_qpll_drp" treetype="template">
-- pcie_qpll_drp - External GT Common Ports for Sharing for PCIE Gen2/3 Core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_crscode&gt; : in std_logic_vector(11 downto 0); --  (optional)
  &lt;s_fsm&gt; : in std_logic_vector(17 downto 0); --  (optional)
  &lt;s_done&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_reset&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_qplllock&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_qplloutclk&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_qplloutrefclk&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_qplld&gt; : out std_logic; --  (optional)
  &lt;s_qpllreset&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_clk&gt; : out std_logic; --  (required)
  &lt;s_rst_n&gt; : out std_logic; --  (required)
  &lt;s_ovrd&gt; : out std_logic; --  (optional)
  &lt;s_gen3&gt; : out std_logic; --  (optional)
  &lt;s_start&gt; : out std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_crscode&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; crscode";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fsm&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; fsm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_done&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_reset&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; reset";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qplllock&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qplllock";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qplloutclk&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qplloutclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qplloutrefclk&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qplloutrefclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qplld&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qplld";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qpllreset&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qpllreset";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; clk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst_n&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; rst_n";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ovrd&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; ovrd";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gen3&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; gen3";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_start&gt;: SIGNAL is "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; start";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="PCIe Serial Link Interface" treetype="template">
-- pcie_7x_mgt - PCIe Serial Link Interface (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_txn&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;m_rxn&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;m_txp&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;m_rxp&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_txn&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_mgt:1.0 &lt;interface_name&gt; txn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rxn&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_mgt:1.0 &lt;interface_name&gt; rxn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_txp&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_mgt:1.0 &lt;interface_name&gt; txp";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rxp&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_mgt:1.0 &lt;interface_name&gt; rxp";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie_sharedlogic_int_clk" treetype="template">
-- pcie_sharedlogic_int_clk - Shared Logic Internal Clock for PCIE Gen2/3 Core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_pclk_slave&gt; : in std_logic; --  (optional)
  &lt;s_pipe_rxusrclk&gt; : in std_logic; --  (optional)
  &lt;s_rxoutclk&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_dclk&gt; : in std_logic; --  (optional)
  &lt;s_usrclk1&gt; : in std_logic; --  (optional)
  &lt;s_usrclk2&gt; : in std_logic; --  (optional)
  &lt;s_oobclk&gt; : in std_logic; --  (optional)
  &lt;s_qplllock&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_qplloutclk&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_qplloutrefclk&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pclk_sel_slave&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (required)
  &lt;s_mmcm_lock&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pclk_slave&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; pclk_slave";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pipe_rxusrclk&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; pipe_rxusrclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxoutclk&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; rxoutclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dclk&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; dclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_usrclk1&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; usrclk1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_usrclk2&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; usrclk2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_oobclk&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; oobclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qplllock&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; qplllock";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qplloutclk&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; qplloutclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qplloutrefclk&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; qplloutrefclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pclk_sel_slave&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; pclk_sel_slave";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mmcm_lock&gt;: SIGNAL is "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; mmcm_lock";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="PCIE Side band signals" treetype="template">
-- pcie_7x_sideband - PCIE Side band signals (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_fc_cpld&gt; : out std_logic_vector(11 downto 0); --  (optional)
  &lt;s_fc_cplh&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_fc_npd&gt; : out std_logic_vector(11 downto 0); --  (optional)
  &lt;s_fc_nph&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_fc_pd&gt; : out std_logic_vector(11 downto 0); --  (optional)
  &lt;s_fc_ph&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_fc_sel&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_mgmt_do&gt; : out std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_mgmt_rd_wr_done&gt; : out std_logic; --  (optional)
  &lt;s_cfg_status&gt; : out std_logic_vector(15 downto 0); --  (optional)
  &lt;s_cfg_command&gt; : out std_logic_vector(15 downto 0); --  (optional)
  &lt;s_cfg_dstatus&gt; : out std_logic_vector(15 downto 0); --  (optional)
  &lt;s_cfg_dcommand&gt; : out std_logic_vector(15 downto 0); --  (optional)
  &lt;s_cfg_lstatus&gt; : out std_logic_vector(15 downto 0); --  (optional)
  &lt;s_cfg_lcommand&gt; : out std_logic_vector(15 downto 0); --  (optional)
  &lt;s_cfg_dcommand2&gt; : out std_logic_vector(15 downto 0); --  (optional)
  &lt;s_cfg_pcie_link_state&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_pmcsr_pme_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_pmcsr_powerstate&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_pmcsr_pme_status&gt; : out std_logic; --  (optional)
  &lt;s_cfg_received_func_lvl_rst&gt; : out std_logic; --  (optional)
  &lt;s_cfg_mgmt_di&gt; : in std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_mgmt_byte_en&gt; : in std_logic_vector(3 downto 0); --  (optional)
  &lt;s_cfg_mgmt_dwaddr&gt; : in std_logic_vector(9 downto 0); --  (optional)
  &lt;s_cfg_mgmt_wr_en&gt; : in std_logic; --  (optional)
  &lt;s_cfg_mgmt_rd_en&gt; : in std_logic; --  (optional)
  &lt;s_cfg_mgmt_wr_readonly&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_ecrc&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_ur&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_cpl_timeout&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_cpl_unexpect&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_cpl_abort&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_posted&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_cor&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_atomic_egress_blocked&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_internal_cor&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_malformed&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_mc_blocked&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_poisoned&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_norecovery&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_tlp_cpl_header&gt; : in std_logic_vector(47 downto 0); --  (optional)
  &lt;s_cfg_err_cpl_rdy&gt; : out std_logic; --  (optional)
  &lt;s_cfg_err_locked&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_acs&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_internal_uncor&gt; : in std_logic; --  (optional)
  &lt;s_cfg_trn_pending&gt; : in std_logic; --  (optional)
  &lt;s_cfg_pm_halt_aspm_l0s&gt; : in std_logic; --  (optional)
  &lt;s_cfg_pm_halt_aspm_l1&gt; : in std_logic; --  (optional)
  &lt;s_cfg_pm_force_state_en&gt; : in std_logic; --  (optional)
  &lt;s_cfg_pm_force_state&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_dsn&gt; : in std_logic_vector(63 downto 0); --  (optional)
  &lt;s_cfg_msg_received&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_data&gt; : out std_logic_vector(15 downto 0); --  (optional)
  &lt;s_cfg_interrupt&gt; : in std_logic; --  (optional)
  &lt;s_cfg_interrupt_rdy&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_assert&gt; : in std_logic; --  (optional)
  &lt;s_cfg_interrupt_di&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_interrupt_do&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_interrupt_mmenable&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msienable&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_msixenable&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_msixfm&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_stat&gt; : in std_logic; --  (optional)
  &lt;s_cfg_pciecap_interrupt_msgnum&gt; : in std_logic_vector(4 downto 0); --  (optional)
  &lt;s_cfg_to_turnoff&gt; : out std_logic; --  (optional)
  &lt;s_cfg_turnoff_ok&gt; : in std_logic; --  (optional)
  &lt;s_cfg_bus_number&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_device_number&gt; : out std_logic_vector(4 downto 0); --  (optional)
  &lt;s_cfg_function_number&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_pm_wake&gt; : in std_logic; --  (optional)
  &lt;s_cfg_msg_received_pm_as_nak&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_setslotpowerlimit&gt; : out std_logic; --  (optional)
  &lt;s_cfg_pm_send_pme_to&gt; : in std_logic; --  (optional)
  &lt;s_cfg_ds_bus_number&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_ds_device_number&gt; : in std_logic_vector(4 downto 0); --  (optional)
  &lt;s_cfg_ds_function_number&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_mgmt_wr_rw1c_as_rw&gt; : in std_logic; --  (optional)
  &lt;s_cfg_bridge_serr_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_slot_control_electromech_il_ctl_pulse&gt; : out std_logic; --  (optional)
  &lt;s_cfg_root_control_syserr_corr_err_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_root_control_syserr_non_fatal_err_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_root_control_syserr_fatal_err_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_root_control_pme_int_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_aer_rooterr_corr_err_reporting_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_aer_rooterr_non_fatal_err_reporting_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_aer_rooterr_fatal_err_reporting_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_aer_rooterr_corr_err_received&gt; : out std_logic; --  (optional)
  &lt;s_cfg_aer_rooterr_non_fatal_err_received&gt; : out std_logic; --  (optional)
  &lt;s_cfg_aer_rooterr_fatal_err_received&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_err_cor&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_err_non_fatal&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_err_fatal&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_pm_pme&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_pme_to_ack&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_assert_int_a&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_assert_int_b&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_assert_int_c&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_assert_int_d&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_deassert_int_a&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_deassert_int_b&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_deassert_int_c&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_deassert_int_d&gt; : out std_logic; --  (optional)
  &lt;s_cfg_err_aer_headerlog&gt; : in std_logic_vector(127 downto 0); --  (optional)
  &lt;s_cfg_aer_interrupt_msgnum&gt; : in std_logic_vector(4 downto 0); --  (optional)
  &lt;s_cfg_err_aer_headerlog_set&gt; : out std_logic; --  (optional)
  &lt;s_cfg_aer_ecrc_check_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_aer_ecrc_gen_en&gt; : out std_logic; --  (optional)
  &lt;s_cfg_vc_tcvc_map&gt; : out std_logic_vector(6 downto 0); --  (optional)
  &lt;s_tx_buf_av&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_tx_err_drop&gt; : out std_logic; --  (optional)
  &lt;s_tx_cfg_req&gt; : out std_logic; --  (optional)
  &lt;s_rx_np_ok&gt; : in std_logic; --  (optional)
  &lt;s_rx_np_req&gt; : in std_logic; --  (optional)
  &lt;s_tx_cfg_gnt&gt; : in std_logic; --  (optional)
  &lt;s_pl_directed_link_change&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pl_directed_link_width&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pl_directed_link_speed&gt; : in std_logic; --  (optional)
  &lt;s_pl_directed_link_auton&gt; : in std_logic; --  (optional)
  &lt;s_pl_upstream_prefer_deemph&gt; : in std_logic; --  (optional)
  &lt;s_pl_sel_lnk_rate&gt; : out std_logic; --  (optional)
  &lt;s_pl_sel_lnk_width&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pl_ltssm_state&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_pl_lane_reversal_mode&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pl_phy_lnk_up&gt; : out std_logic; --  (optional)
  &lt;s_pl_tx_pm_state&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_pl_rx_pm_state&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pl_link_upcfg_cap&gt; : out std_logic; --  (optional)
  &lt;s_pl_link_gen2_cap&gt; : out std_logic; --  (optional)
  &lt;s_pl_link_partner_gen2_supported&gt; : out std_logic; --  (optional)
  &lt;s_pl_initial_link_width&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_pl_directed_change_done&gt; : out std_logic; --  (optional)
  &lt;s_pl_received_hot_rst&gt; : out std_logic; --  (optional)
  &lt;s_pl_transmit_hot_rst&gt; : in std_logic; --  (optional)
  &lt;s_pl_downstream_deemph_source&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fc_cpld&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_cpld";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fc_cplh&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_cplh";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fc_npd&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_npd";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fc_nph&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_nph";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fc_pd&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_pd";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fc_ph&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_ph";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fc_sel&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_sel";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_do&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_do";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_rd_wr_done&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_rd_wr_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_status&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_command&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_command";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_dstatus&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_dstatus";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_dcommand&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_dcommand";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_lstatus&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_lstatus";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_lcommand&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_lcommand";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_dcommand2&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_dcommand2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pcie_link_state&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pcie_link_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pmcsr_pme_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pmcsr_pme_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pmcsr_powerstate&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pmcsr_powerstate";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pmcsr_pme_status&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pmcsr_pme_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_received_func_lvl_rst&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_received_func_lvl_rst";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_di&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_di";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_byte_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_byte_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_dwaddr&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_dwaddr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_wr_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_wr_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_rd_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_rd_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_wr_readonly&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_wr_readonly";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_ecrc&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_ecrc";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_ur&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_ur";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_cpl_timeout&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cpl_timeout";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_cpl_unexpect&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cpl_unexpect";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_cpl_abort&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cpl_abort";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_posted&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_posted";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_cor&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cor";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_atomic_egress_blocked&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_atomic_egress_blocked";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_internal_cor&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_internal_cor";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_malformed&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_malformed";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_mc_blocked&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_mc_blocked";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_poisoned&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_poisoned";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_norecovery&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_norecovery";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_tlp_cpl_header&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_tlp_cpl_header";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_cpl_rdy&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cpl_rdy";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_locked&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_locked";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_acs&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_acs";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_internal_uncor&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_internal_uncor";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_trn_pending&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_trn_pending";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pm_halt_aspm_l0s&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_halt_aspm_l0s";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pm_halt_aspm_l1&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_halt_aspm_l1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pm_force_state_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_force_state_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pm_force_state&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_force_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_dsn&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_dsn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_data&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_rdy&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_rdy";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_assert&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_assert";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_di&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_di";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_do&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_do";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_mmenable&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_mmenable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msienable&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msienable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msixenable&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msixenable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msixfm&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msixfm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_stat&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_stat";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pciecap_interrupt_msgnum&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pciecap_interrupt_msgnum";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_to_turnoff&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_to_turnoff";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_turnoff_ok&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_turnoff_ok";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_bus_number&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_bus_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_device_number&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_device_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pm_wake&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_wake";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_pm_as_nak&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_pm_as_nak";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_setslotpowerlimit&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_setslotpowerlimit";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pm_send_pme_to&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_send_pme_to";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ds_bus_number&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_bus_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ds_device_number&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_device_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ds_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_wr_rw1c_as_rw&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_wr_rw1c_as_rw";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_bridge_serr_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_bridge_serr_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_slot_control_electromech_il_ctl_pulse&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_slot_control_electromech_il_ctl_pulse";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_root_control_syserr_corr_err_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_root_control_syserr_corr_err_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_root_control_syserr_non_fatal_err_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_root_control_syserr_non_fatal_err_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_root_control_syserr_fatal_err_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_root_control_syserr_fatal_err_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_root_control_pme_int_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_root_control_pme_int_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_aer_rooterr_corr_err_reporting_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_corr_err_reporting_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_aer_rooterr_non_fatal_err_reporting_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_non_fatal_err_reporting_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_aer_rooterr_fatal_err_reporting_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_fatal_err_reporting_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_aer_rooterr_corr_err_received&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_corr_err_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_aer_rooterr_non_fatal_err_received&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_non_fatal_err_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_aer_rooterr_fatal_err_received&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_fatal_err_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_err_cor&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_err_cor";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_err_non_fatal&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_err_non_fatal";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_err_fatal&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_err_fatal";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_pm_pme&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_pm_pme";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_pme_to_ack&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_pme_to_ack";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_assert_int_a&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_assert_int_a";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_assert_int_b&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_assert_int_b";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_assert_int_c&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_assert_int_c";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_assert_int_d&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_assert_int_d";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_deassert_int_a&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_deassert_int_a";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_deassert_int_b&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_deassert_int_b";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_deassert_int_c&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_deassert_int_c";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_deassert_int_d&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_deassert_int_d";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_aer_headerlog&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_aer_headerlog";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_aer_interrupt_msgnum&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_interrupt_msgnum";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_aer_headerlog_set&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_aer_headerlog_set";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_aer_ecrc_check_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_ecrc_check_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_aer_ecrc_gen_en&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_ecrc_gen_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_vc_tcvc_map&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_vc_tcvc_map";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_buf_av&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; tx_buf_av";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_err_drop&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; tx_err_drop";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_cfg_req&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; tx_cfg_req";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_np_ok&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; rx_np_ok";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_np_req&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; rx_np_req";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_cfg_gnt&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; tx_cfg_gnt";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_directed_link_change&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_link_change";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_directed_link_width&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_link_width";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_directed_link_speed&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_link_speed";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_directed_link_auton&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_link_auton";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_upstream_prefer_deemph&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_upstream_prefer_deemph";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_sel_lnk_rate&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_sel_lnk_rate";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_sel_lnk_width&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_sel_lnk_width";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_ltssm_state&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_ltssm_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_lane_reversal_mode&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_lane_reversal_mode";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_phy_lnk_up&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_phy_lnk_up";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_tx_pm_state&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_tx_pm_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_rx_pm_state&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_rx_pm_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_link_upcfg_cap&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_link_upcfg_cap";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_link_gen2_cap&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_link_gen2_cap";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_link_partner_gen2_supported&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_link_partner_gen2_supported";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_initial_link_width&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_initial_link_width";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_directed_change_done&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_change_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_received_hot_rst&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_received_hot_rst";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_transmit_hot_rst&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_transmit_hot_rst";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_downstream_deemph_source&gt;: SIGNAL is "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_downstream_deemph_source";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<SubFolder label="pcie2" treetype="folder">
				<Template label="Pcie2_cfg_control" treetype="template">
-- pcie2_cfg_control - Configuration Control Interface for PCIE Gen2 Core allows a broad range of information exchange between the user application and the core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_tx_cfg_gnt&gt; : in std_logic; --  (optional)
  &lt;s_rx_np_ok&gt; : in std_logic; --  (optional)
  &lt;s_rx_np_req&gt; : in std_logic; --  (optional)
  &lt;s_trn_pending&gt; : in std_logic; --  (optional)
  &lt;s_pm_halt_aspm_l0s&gt; : in std_logic; --  (optional)
  &lt;s_pm_halt_aspm_l1&gt; : in std_logic; --  (optional)
  &lt;s_pm_force_state_en&gt; : in std_logic; --  (optional)
  &lt;s_pm_force_state&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_dsn&gt; : in std_logic_vector(63 downto 0); --  (required)
  &lt;s_turnoff_ok&gt; : in std_logic; --  (optional)
  &lt;s_pm_wake&gt; : in std_logic; --  (optional)
  &lt;s_pm_send_pme_to&gt; : in std_logic; --  (optional)
  &lt;s_ds_bus_number&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_ds_device_number&gt; : in std_logic_vector(4 downto 0); --  (optional)
  &lt;s_ds_function_number&gt; : in std_logic_vector(2 downto 0); --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_cfg_gnt&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; tx_cfg_gnt";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_np_ok&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; rx_np_ok";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_np_req&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; rx_np_req";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trn_pending&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; trn_pending";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pm_halt_aspm_l0s&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_halt_aspm_l0s";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pm_halt_aspm_l1&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_halt_aspm_l1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pm_force_state_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_force_state_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pm_force_state&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_force_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dsn&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; dsn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_turnoff_ok&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; turnoff_ok";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pm_wake&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_wake";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pm_send_pme_to&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_send_pme_to";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds_bus_number&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; ds_bus_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds_device_number&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; ds_device_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; ds_function_number";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie2_cfg_err" treetype="template">
-- pcie2_cfg_err - It is a user application error reporting interface for PCIE Gen2 Core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_ecrc&gt; : in std_logic; --  (optional)
  &lt;s_ur&gt; : in std_logic; --  (optional)
  &lt;s_cpl_timeout&gt; : in std_logic; --  (optional)
  &lt;s_cpl_unexpect&gt; : in std_logic; --  (optional)
  &lt;s_cpl_abort&gt; : in std_logic; --  (optional)
  &lt;s_posted&gt; : in std_logic; --  (optional)
  &lt;s_cor&gt; : in std_logic; --  (required)
  &lt;s_atomic_egress_blocked&gt; : in std_logic; --  (optional)
  &lt;s_internal_cor&gt; : in std_logic; --  (optional)
  &lt;s_mc_blocked&gt; : in std_logic; --  (optional)
  &lt;s_poisoned&gt; : in std_logic; --  (optional)
  &lt;s_norecovery&gt; : in std_logic; --  (optional)
  &lt;s_tlp_cpl_header&gt; : in std_logic_vector(47 downto 0); --  (optional)
  &lt;s_cpl_rdy&gt; : out std_logic; --  (optional)
  &lt;s_locked&gt; : in std_logic; --  (optional)
  &lt;s_acs&gt; : in std_logic; --  (optional)
  &lt;s_internal_uncor&gt; : in std_logic; --  (optional)
  &lt;s_err_aer_headerlog&gt; : in std_logic_vector(127 downto 0); --  (optional)
  &lt;s_aer_interrupt_msgnum&gt; : in std_logic_vector(4 downto 0); --  (optional)
  &lt;s_err_aer_headerlog_set&gt; : out std_logic; --  (optional)
  &lt;s_aer_ecrc_check_en&gt; : out std_logic; --  (optional)
  &lt;s_aer_ecrc_gen_en&gt; : out std_logic; --  (optional)
  &lt;s_malformed&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ecrc&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; ecrc";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ur&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; ur";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cpl_timeout&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cpl_timeout";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cpl_unexpect&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cpl_unexpect";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cpl_abort&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cpl_abort";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_posted&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; posted";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cor&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cor";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_atomic_egress_blocked&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; atomic_egress_blocked";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_internal_cor&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; internal_cor";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mc_blocked&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; mc_blocked";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_poisoned&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; poisoned";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_norecovery&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; norecovery";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tlp_cpl_header&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; tlp_cpl_header";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cpl_rdy&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cpl_rdy";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_locked&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; locked";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_acs&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; acs";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_internal_uncor&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; internal_uncor";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_aer_headerlog&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; err_aer_headerlog";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aer_interrupt_msgnum&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; aer_interrupt_msgnum";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_aer_headerlog_set&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; err_aer_headerlog_set";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aer_ecrc_check_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; aer_ecrc_check_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aer_ecrc_gen_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; aer_ecrc_gen_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_malformed&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; malformed";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie2_cfg_interrupt" treetype="template">
-- pcie2_cfg_interrupt - It defines the Interrupt Interface signals for PCIE Gen2 Core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_interrupt&gt; : in std_logic; --  (required)
  &lt;s_rdy&gt; : out std_logic; --  (optional)
  &lt;s_assert&gt; : in std_logic; --  (optional)
  &lt;s_write_data&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_read_data&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_mmenable&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_msienable&gt; : out std_logic; --  (optional)
  &lt;s_msixenable&gt; : out std_logic; --  (optional)
  &lt;s_msixfm&gt; : out std_logic; --  (optional)
  &lt;s_stat&gt; : in std_logic; --  (optional)
  &lt;s_pciecap_interrupt_msgnum&gt; : in std_logic_vector(4 downto 0); --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_interrupt&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; interrupt";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rdy&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; rdy";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_assert&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; assert";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_write_data&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; write_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read_data&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; read_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mmenable&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; mmenable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_msienable&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; msienable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_msixenable&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; msixenable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_msixfm&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; msixfm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_stat&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; stat";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pciecap_interrupt_msgnum&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; pciecap_interrupt_msgnum";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie2_cfg_msg_rcvd" treetype="template">
-- pcie2_cfg_msg_rcvd - Configuration Message Received Interface for PCIE Gen2 Core indicates to th elogic that a decodable message from the link, parameters associated with th edata and type of message received (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_received&gt; : in std_logic; --  (required)
  &lt;s_data&gt; : in std_logic_vector(15 downto 0); --  (required)
  &lt;s_err_cor&gt; : in std_logic; --  (optional)
  &lt;s_err_non_fatal&gt; : in std_logic; --  (optional)
  &lt;s_err_fatal&gt; : in std_logic; --  (optional)
  &lt;s_pm_pme&gt; : in std_logic; --  (optional)
  &lt;s_pme_to_ack&gt; : in std_logic; --  (optional)
  &lt;s_assert_int_a&gt; : in std_logic; --  (optional)
  &lt;s_assert_int_b&gt; : in std_logic; --  (optional)
  &lt;s_assert_int_c&gt; : in std_logic; --  (optional)
  &lt;s_assert_int_d&gt; : in std_logic; --  (optional)
  &lt;s_deassert_int_a&gt; : in std_logic; --  (optional)
  &lt;s_deassert_int_b&gt; : in std_logic; --  (optional)
  &lt;s_deassert_int_c&gt; : in std_logic; --  (optional)
  &lt;s_deassert_int_d&gt; : in std_logic; --  (optional)
  &lt;s_received_pm_as_nak&gt; : in std_logic; --  (optional)
  &lt;s_received_setslotpowerlimit&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_received&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_cor&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; err_cor";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_non_fatal&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; err_non_fatal";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_fatal&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; err_fatal";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pm_pme&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; pm_pme";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pme_to_ack&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; pme_to_ack";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_assert_int_a&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; assert_int_a";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_assert_int_b&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; assert_int_b";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_assert_int_c&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; assert_int_c";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_assert_int_d&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; assert_int_d";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_deassert_int_a&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; deassert_int_a";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_deassert_int_b&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; deassert_int_b";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_deassert_int_c&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; deassert_int_c";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_deassert_int_d&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; deassert_int_d";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_received_pm_as_nak&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; received_pm_as_nak";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_received_setslotpowerlimit&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; received_setslotpowerlimit";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie2_cfg_status" treetype="template">
-- pcie2_cfg_status - Configuration Status Interface provides information on how the PCIE Gen2 core is configured (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_status&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_command&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_dstatus&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_dcommand&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_lstatus&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_lcommand&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_dcommand2&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_pcie_link_state&gt; : in std_logic_vector(2 downto 0); --  (required)
  &lt;s_pmcsr_pme_en&gt; : in std_logic; --  (optional)
  &lt;s_pmcsr_powerstate&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pmcsr_pme_status&gt; : in std_logic; --  (optional)
  &lt;s_received_func_lvl_rst&gt; : in std_logic; --  (optional)
  &lt;s_turnoff&gt; : in std_logic; --  (optional)
  &lt;s_bus_number&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_device_number&gt; : in std_logic_vector(4 downto 0); --  (optional)
  &lt;s_function_number&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_bridge_serr_en&gt; : in std_logic; --  (optional)
  &lt;s_slot_control_electromech_il_ctl_pulse&gt; : in std_logic; --  (optional)
  &lt;s_root_control_syserr_corr_err_en&gt; : in std_logic; --  (optional)
  &lt;s_root_control_syserr_non_fatal_err_en&gt; : in std_logic; --  (optional)
  &lt;s_root_control_syserr_fatal_err_en&gt; : in std_logic; --  (optional)
  &lt;s_root_control_pme_int_en&gt; : in std_logic; --  (optional)
  &lt;s_aer_rooterr_corr_err_reporting_en&gt; : in std_logic; --  (optional)
  &lt;s_aer_rooterr_non_fatal_err_reporting_en&gt; : in std_logic; --  (optional)
  &lt;s_aer_rooterr_fatal_err_reporting_en&gt; : in std_logic; --  (optional)
  &lt;s_aer_rooterr_corr_err_received&gt; : in std_logic; --  (optional)
  &lt;s_aer_rooterr_non_fatal_err_received&gt; : in std_logic; --  (optional)
  &lt;s_aer_rooterr_fatal_err_received&gt; : in std_logic; --  (optional)
  &lt;s_vc_tcvc_map&gt; : in std_logic_vector(6 downto 0); --  (optional)
  &lt;s_tx_buf_av&gt; : in std_logic_vector(5 downto 0); --  (optional)
  &lt;s_tx_err_drop&gt; : in std_logic; --  (optional)
  &lt;s_tx_cfg_req&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_status&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_command&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; command";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dstatus&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; dstatus";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dcommand&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; dcommand";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_lstatus&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; lstatus";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_lcommand&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; lcommand";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dcommand2&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; dcommand2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pcie_link_state&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; pcie_link_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pmcsr_pme_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; pmcsr_pme_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pmcsr_powerstate&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; pmcsr_powerstate";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pmcsr_pme_status&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; pmcsr_pme_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_received_func_lvl_rst&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; received_func_lvl_rst";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_turnoff&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; turnoff";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bus_number&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; bus_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_device_number&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; device_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bridge_serr_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; bridge_serr_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_slot_control_electromech_il_ctl_pulse&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; slot_control_electromech_il_ctl_pulse";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_root_control_syserr_corr_err_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; root_control_syserr_corr_err_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_root_control_syserr_non_fatal_err_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; root_control_syserr_non_fatal_err_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_root_control_syserr_fatal_err_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; root_control_syserr_fatal_err_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_root_control_pme_int_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; root_control_pme_int_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aer_rooterr_corr_err_reporting_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_corr_err_reporting_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aer_rooterr_non_fatal_err_reporting_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_non_fatal_err_reporting_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aer_rooterr_fatal_err_reporting_en&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_fatal_err_reporting_en";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aer_rooterr_corr_err_received&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_corr_err_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aer_rooterr_non_fatal_err_received&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_non_fatal_err_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aer_rooterr_fatal_err_received&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_fatal_err_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vc_tcvc_map&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; vc_tcvc_map";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_buf_av&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; tx_buf_av";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_err_drop&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; tx_err_drop";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_cfg_req&gt;: SIGNAL is "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; tx_cfg_req";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie2_pl" treetype="template">
-- pcie2_pl - Physical Layer Interface for PCIE Gen2 Core enables the user design to inspect the status of the link and link partner and control the link state (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_directed_link_change&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_directed_link_width&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_directed_link_speed&gt; : in std_logic; --  (optional)
  &lt;s_directed_link_auton&gt; : in std_logic; --  (optional)
  &lt;s_upstream_prefer_deemph&gt; : in std_logic; --  (optional)
  &lt;s_sel_lnk_rate&gt; : out std_logic; --  (optional)
  &lt;s_sel_lnk_width&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_ltssm_state&gt; : out std_logic_vector(5 downto 0); --  (required)
  &lt;s_lane_reversal_mode&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_phy_lnk_up&gt; : out std_logic; --  (required)
  &lt;s_tx_pm_state&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_rx_pm_state&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_link_upcfg_cap&gt; : out std_logic; --  (optional)
  &lt;s_link_gen2_cap&gt; : out std_logic; --  (optional)
  &lt;s_link_partner_gen2_supported&gt; : out std_logic; --  (optional)
  &lt;s_initial_link_width&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_directed_change_done&gt; : out std_logic; --  (optional)
  &lt;s_received_hot_rst&gt; : out std_logic; --  (optional)
  &lt;s_transmit_hot_rst&gt; : in std_logic; --  (optional)
  &lt;s_downstream_deemph_source&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_directed_link_change&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_link_change";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_directed_link_width&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_link_width";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_directed_link_speed&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_link_speed";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_directed_link_auton&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_link_auton";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_upstream_prefer_deemph&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; upstream_prefer_deemph";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sel_lnk_rate&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; sel_lnk_rate";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sel_lnk_width&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; sel_lnk_width";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ltssm_state&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; ltssm_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_lane_reversal_mode&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; lane_reversal_mode";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_phy_lnk_up&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; phy_lnk_up";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_pm_state&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; tx_pm_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_pm_state&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; rx_pm_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_link_upcfg_cap&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; link_upcfg_cap";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_link_gen2_cap&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; link_gen2_cap";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_link_partner_gen2_supported&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; link_partner_gen2_supported";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_initial_link_width&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; initial_link_width";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_directed_change_done&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_change_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_received_hot_rst&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; received_hot_rst";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_transmit_hot_rst&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; transmit_hot_rst";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_downstream_deemph_source&gt;: SIGNAL is "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; downstream_deemph_source";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<SubFolder label="pcie3" treetype="folder">
				<Template label="PCIE Gen3 Sideband signal interface" treetype="template">
-- pcie3_7x_sideband - PCIE Gen3 Sideband signal interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_cfg_phy_link_down&gt; : out std_logic; --  (optional)
  &lt;s_cfg_phy_link_status&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_negotiated_width&gt; : out std_logic_vector(3 downto 0); --  (optional)
  &lt;s_cfg_current_speed&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_max_payload&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_max_read_req&gt; : out std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_function_status&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_function_power_state&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_vf_status&gt; : out std_logic_vector(11 downto 0); --  (optional)
  &lt;s_cfg_vf_power_state&gt; : out std_logic_vector(17 downto 0); --  (optional)
  &lt;s_cfg_link_power_state&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_mgmt_addr&gt; : in std_logic_vector(18 downto 0); --  (optional)
  &lt;s_cfg_mgmt_write&gt; : in std_logic; --  (optional)
  &lt;s_cfg_mgmt_write_data&gt; : in std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_mgmt_byte_enable&gt; : in std_logic_vector(3 downto 0); --  (optional)
  &lt;s_cfg_mgmt_read&gt; : in std_logic; --  (optional)
  &lt;s_cfg_mgmt_read_data&gt; : out std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_mgmt_read_write_done&gt; : out std_logic; --  (optional)
  &lt;s_cfg_mgmt_type1_cfg_reg_access&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_cor_out&gt; : out std_logic; --  (optional)
  &lt;s_cfg_err_nonfatal_out&gt; : out std_logic; --  (optional)
  &lt;s_cfg_err_fatal_out&gt; : out std_logic; --  (optional)
  &lt;s_cfg_ltr_enable&gt; : out std_logic; --  (optional)
  &lt;s_cfg_ltssm_state&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_rcb_status&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_dpa_substate_change&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_obff_enable&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_pl_status_change&gt; : out std_logic; --  (optional)
  &lt;s_cfg_tph_requester_enable&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_tph_st_mode&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_vf_tph_requester_enable&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_vf_tph_st_mode&gt; : out std_logic_vector(17 downto 0); --  (optional)
  &lt;s_cfg_msg_received&gt; : out std_logic; --  (optional)
  &lt;s_cfg_msg_received_data&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_msg_received_type&gt; : out std_logic_vector(4 downto 0); --  (optional)
  &lt;s_cfg_msg_transmit&gt; : in std_logic; --  (optional)
  &lt;s_cfg_msg_transmit_type&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_msg_transmit_data&gt; : in std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_msg_transmit_done&gt; : out std_logic; --  (optional)
  &lt;s_cfg_fc_ph&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_fc_pd&gt; : out std_logic_vector(11 downto 0); --  (optional)
  &lt;s_cfg_fc_nph&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_fc_npd&gt; : out std_logic_vector(11 downto 0); --  (optional)
  &lt;s_cfg_fc_cplh&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_fc_cpld&gt; : out std_logic_vector(11 downto 0); --  (optional)
  &lt;s_cfg_fc_sel&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_per_func_status_control&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_per_func_status_data&gt; : out std_logic_vector(15 downto 0); --  (optional)
  &lt;s_cfg_per_function_number&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_per_function_output_request&gt; : in std_logic; --  (optional)
  &lt;s_cfg_per_function_update_done&gt; : out std_logic; --  (optional)
  &lt;s_cfg_dsn&gt; : in std_logic_vector(63 downto 0); --  (optional)
  &lt;s_cfg_power_state_change_ack&gt; : in std_logic; --  (optional)
  &lt;s_cfg_power_state_change_interrupt&gt; : out std_logic; --  (optional)
  &lt;s_cfg_err_cor_in&gt; : in std_logic; --  (optional)
  &lt;s_cfg_err_uncor_in&gt; : in std_logic; --  (optional)
  &lt;s_cfg_flr_in_process&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_flr_done&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_vf_flr_in_process&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_vf_flr_done&gt; : in std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_link_training_enable&gt; : in std_logic; --  (optional)
  &lt;s_cfg_ext_read_received&gt; : out std_logic; --  (optional)
  &lt;s_cfg_ext_write_received&gt; : out std_logic; --  (optional)
  &lt;s_cfg_ext_register_number&gt; : out std_logic_vector(9 downto 0); --  (optional)
  &lt;s_cfg_ext_function_number&gt; : out std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_ext_write_data&gt; : out std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_ext_write_byte_enable&gt; : out std_logic_vector(3 downto 0); --  (optional)
  &lt;s_cfg_ext_read_data&gt; : in std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_ext_read_data_valid&gt; : in std_logic; --  (optional)
  &lt;s_cfg_ds_port_number&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_interrupt_int&gt; : in std_logic_vector(3 downto 0); --  (optional)
  &lt;s_cfg_interrupt_pending&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_interrupt_sent&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_msi_enable&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_vf_enable&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_mmenable&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_mask_update&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_msi_data&gt; : out std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_select&gt; : in std_logic_vector(3 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_int&gt; : in std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_pending_status&gt; : in std_logic_vector(63 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_sent&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_msi_fail&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_msix_enable&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msix_mask&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msix_vf_enable&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msix_vf_mask&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msix_data&gt; : in std_logic_vector(31 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msix_address&gt; : in std_logic_vector(63 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msix_int&gt; : in std_logic; --  (optional)
  &lt;s_cfg_interrupt_msix_sent&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_msix_fail&gt; : out std_logic; --  (optional)
  &lt;s_cfg_interrupt_msi_attr&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_tph_present&gt; : in std_logic; --  (optional)
  &lt;s_cfg_interrupt_msi_tph_type&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_tph_st_tag&gt; : in std_logic_vector(8 downto 0); --  (optional)
  &lt;s_cfg_interrupt_msi_function_number&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_cfg_hot_reset_out&gt; : out std_logic; --  (optional)
  &lt;s_cfg_config_space_enable&gt; : in std_logic; --  (optional)
  &lt;s_cfg_req_pm_transition_l23_ready&gt; : in std_logic; --  (optional)
  &lt;s_cfg_hot_reset_in&gt; : in std_logic; --  (optional)
  &lt;s_cfg_ds_bus_number&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_cfg_ds_device_number&gt; : in std_logic_vector(4 downto 0); --  (optional)
  &lt;s_cfg_ds_function_number&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_pcie_rq_seq_num&gt; : out std_logic_vector(3 downto 0); --  (optional)
  &lt;s_pcie_rq_seq_num_vld&gt; : out std_logic; --  (optional)
  &lt;s_pcie_rq_tag&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_pcie_rq_tag_vld&gt; : out std_logic; --  (optional)
  &lt;s_pcie_tfc_nph_av&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pcie_tfc_npd_av&gt; : out std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pcie_cq_np_req&gt; : in std_logic; --  (optional)
  &lt;s_pcie_cq_np_req_count&gt; : out std_logic_vector(5 downto 0); --  (optional)
  &lt;s_user_tph_stt_address&gt; : in std_logic_vector(4 downto 0); --  (optional)
  &lt;s_user_tph_function_num&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_user_tph_stt_read_data&gt; : out std_logic_vector(31 downto 0); --  (optional)
  &lt;s_user_tph_stt_read_data_valid&gt; : out std_logic; --  (optional)
  &lt;s_user_tph_stt_read_enable&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_phy_link_down&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_phy_link_down";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_phy_link_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_phy_link_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_negotiated_width&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_negotiated_width";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_current_speed&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_current_speed";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_max_payload&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_max_payload";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_max_read_req&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_max_read_req";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_function_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_function_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_function_power_state&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_function_power_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_vf_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_vf_power_state&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_power_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_link_power_state&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_link_power_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_addr&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_addr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_write&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_write";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_write_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_write_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_byte_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_byte_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_read&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_read";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_read_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_read_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_read_write_done&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_read_write_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_mgmt_type1_cfg_reg_access&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_type1_cfg_reg_access";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_cor_out&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cor_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_nonfatal_out&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_nonfatal_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_fatal_out&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_fatal_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ltr_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ltr_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ltssm_state&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ltssm_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_rcb_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_rcb_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_dpa_substate_change&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_dpa_substate_change";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_obff_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_obff_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_pl_status_change&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_pl_status_change";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_tph_requester_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_tph_requester_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_tph_st_mode&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_tph_st_mode";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_vf_tph_requester_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_tph_requester_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_vf_tph_st_mode&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_tph_st_mode";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_received_type&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_type";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_transmit&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_transmit";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_transmit_type&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_transmit_type";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_transmit_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_transmit_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_msg_transmit_done&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_transmit_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_fc_ph&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_ph";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_fc_pd&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_pd";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_fc_nph&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_nph";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_fc_npd&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_npd";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_fc_cplh&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_cplh";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_fc_cpld&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_cpld";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_fc_sel&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_sel";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_per_func_status_control&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_func_status_control";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_per_func_status_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_func_status_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_per_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_per_function_output_request&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_function_output_request";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_per_function_update_done&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_function_update_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_dsn&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_dsn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_power_state_change_ack&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_power_state_change_ack";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_power_state_change_interrupt&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_power_state_change_interrupt";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_cor_in&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cor_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_err_uncor_in&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_uncor_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_flr_in_process&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_flr_in_process";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_flr_done&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_flr_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_vf_flr_in_process&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_flr_in_process";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_vf_flr_done&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_flr_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_link_training_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_link_training_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ext_read_received&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_read_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ext_write_received&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_write_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ext_register_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_register_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ext_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ext_write_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_write_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ext_write_byte_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_write_byte_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ext_read_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_read_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ext_read_data_valid&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_read_data_valid";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ds_port_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_port_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_int&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_int";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_pending&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_pending";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_sent&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_sent";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_vf_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_vf_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_mmenable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_mmenable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_mask_update&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_mask_update";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_select&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_select";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_int&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_int";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_pending_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_pending_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_sent&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_sent";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_fail&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_fail";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msix_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msix_mask&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_mask";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msix_vf_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_vf_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msix_vf_mask&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_vf_mask";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msix_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msix_address&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_address";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msix_int&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_int";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msix_sent&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_sent";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msix_fail&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_fail";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_attr&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_attr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_tph_present&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_tph_present";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_tph_type&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_tph_type";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_tph_st_tag&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_tph_st_tag";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_interrupt_msi_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_hot_reset_out&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_hot_reset_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_config_space_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_config_space_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_req_pm_transition_l23_ready&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_req_pm_transition_l23_ready";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_hot_reset_in&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_hot_reset_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ds_bus_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_bus_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ds_device_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_device_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfg_ds_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pcie_rq_seq_num&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_rq_seq_num";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pcie_rq_seq_num_vld&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_rq_seq_num_vld";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pcie_rq_tag&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_rq_tag";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pcie_rq_tag_vld&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_rq_tag_vld";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pcie_tfc_nph_av&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_tfc_nph_av";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pcie_tfc_npd_av&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_tfc_npd_av";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pcie_cq_np_req&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_cq_np_req";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pcie_cq_np_req_count&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_cq_np_req_count";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_user_tph_stt_address&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_stt_address";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_user_tph_function_num&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_function_num";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_user_tph_stt_read_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_stt_read_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_user_tph_stt_read_data_valid&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_stt_read_data_valid";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_user_tph_stt_read_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_stt_read_enable";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_cfg_control" treetype="template">
-- pcie3_cfg_control - Configuration Control Interface for PCIE Gen3 core allows a broad range of information exchange between the user application and the core. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_hot_reset_in&gt; : in std_logic; --  (optional)
  &lt;s_hot_reset_out&gt; : out std_logic; --  (optional)
  &lt;s_config_space_enable&gt; : in std_logic; --  (optional)
  &lt;s_per_function_update_done&gt; : out std_logic; --  (optional)
  &lt;s_per_function_number&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_per_function_output_request&gt; : in std_logic; --  (optional)
  &lt;s_dsn&gt; : in std_logic_vector(63 downto 0); --  (optional)
  &lt;s_power_state_change_ack&gt; : in std_logic; --  (optional)
  &lt;s_power_state_change_interrupt&gt; : out std_logic; --  (optional)
  &lt;s_err_cor_in&gt; : in std_logic; --  (optional)
  &lt;s_err_uncor_in&gt; : in std_logic; --  (optional)
  &lt;s_flr_in_process&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_flr_done&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_vf_flr_in_process&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_vf_flr_done&gt; : in std_logic_vector(5 downto 0); --  (optional)
  &lt;s_link_training_enable&gt; : in std_logic; --  (optional)
  &lt;s_req_pm_transition_l23_ready&gt; : in std_logic; --  (optional)
  &lt;s_ds_port_number&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_ds_bus_number&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_ds_device_number&gt; : in std_logic_vector(4 downto 0); --  (optional)
  &lt;s_ds_function_number&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_subsys_vend_id&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_local_error&gt; : out std_logic; --  (optional)
  &lt;s_vend_id&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_dev_id&gt; : in std_logic_vector(15 downto 0); --  (optional)
  &lt;s_rev_id&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_subsys_id&gt; : in std_logic_vector(15 downto 0); --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hot_reset_in&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; hot_reset_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hot_reset_out&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; hot_reset_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_config_space_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; config_space_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_per_function_update_done&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; per_function_update_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_per_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; per_function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_per_function_output_request&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; per_function_output_request";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dsn&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; dsn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_power_state_change_ack&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; power_state_change_ack";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_power_state_change_interrupt&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; power_state_change_interrupt";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_cor_in&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; err_cor_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_uncor_in&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; err_uncor_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_flr_in_process&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; flr_in_process";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_flr_done&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; flr_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vf_flr_in_process&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; vf_flr_in_process";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vf_flr_done&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; vf_flr_done";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_link_training_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; link_training_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_req_pm_transition_l23_ready&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; req_pm_transition_l23_ready";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds_port_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; ds_port_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds_bus_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; ds_bus_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds_device_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; ds_device_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; ds_function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_subsys_vend_id&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; subsys_vend_id";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_local_error&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; local_error";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vend_id&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; vend_id";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dev_id&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; dev_id";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rev_id&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; rev_id";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_subsys_id&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; subsys_id";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_cfg_ext" treetype="template">
-- pcie3_cfg_ext - The Configuration Extend interface allows the PCIE Gen3 core to transfer configuration information with the user application when externally implemented configuration registers are implemented. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_read_received&gt; : in std_logic; --  (required)
  &lt;s_write_received&gt; : in std_logic; --  (required)
  &lt;s_register_number&gt; : in std_logic_vector(9 downto 0); --  (optional)
  &lt;s_function_number&gt; : in std_logic_vector(7 downto 0); --  (optional)
  &lt;s_write_data&gt; : in std_logic_vector(31 downto 0); --  (optional)
  &lt;s_write_byte_enable&gt; : in std_logic_vector(3 downto 0); --  (optional)
  &lt;s_read_data&gt; : out std_logic_vector(31 downto 0); --  (optional)
  &lt;s_read_data_valid&gt; : out std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read_received&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; read_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_write_received&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; write_received";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_register_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; register_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_write_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; write_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_write_byte_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; write_byte_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; read_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_read_data_valid&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; read_data_valid";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_cfg_interrupt" treetype="template">
-- pcie3_cfg_interrupt - Configuration Interrupt Control Interface fpr PCIE Gen3 Core allows the user application to set Legacy PCIE INterrupts (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_intx_vector&gt; : in std_logic_vector(3 downto 0); --  (required)
  &lt;s_sent&gt; : out std_logic; --  (optional)
  &lt;s_pending&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_intx_vector&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_interrupt:1.0 &lt;interface_name&gt; INTx_VECTOR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sent&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_interrupt:1.0 &lt;interface_name&gt; SENT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pending&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_interrupt:1.0 &lt;interface_name&gt; PENDING";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_cfg_mesg_tx" treetype="template">
-- pcie3_cfg_mesg_tx - The Configuration Transmit Message Interface is used by the user application to transmit messages to the PCIE Gen3 Core. The user application supplies the transmit message type and data information to the core, which responds with the DONE signal (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_transmit&gt; : out std_logic; -- Transmit Encoded message (required)
  &lt;s_transmit_type&gt; : out std_logic_vector(2 downto 0); --  (required)
  &lt;s_transmit_data&gt; : out std_logic_vector(31 downto 0); --  (required)
  &lt;s_transmit_done&gt; : in std_logic; --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_transmit&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_mesg_tx:1.0 &lt;interface_name&gt; TRANSMIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_transmit_type&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_mesg_tx:1.0 &lt;interface_name&gt; TRANSMIT_TYPE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_transmit_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_mesg_tx:1.0 &lt;interface_name&gt; TRANSMIT_DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_transmit_done&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_mesg_tx:1.0 &lt;interface_name&gt; TRANSMIT_DONE";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_cfg_msg_received" treetype="template">
-- pcie3_cfg_msg_received - Configuration Received message Interface for PCIE Gen3 core indicates the logic that a decodable message from the link, the parameters associated with the data and type of message have been received (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_recd&gt; : in std_logic; --  (required)
  &lt;s_recd_data&gt; : in std_logic_vector(7 downto 0); --  (required)
  &lt;s_recd_type&gt; : in std_logic_vector(4 downto 0); --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_recd&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msg_received:1.0 &lt;interface_name&gt; recd";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_recd_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msg_received:1.0 &lt;interface_name&gt; recd_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_recd_type&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msg_received:1.0 &lt;interface_name&gt; recd_type";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_cfg_msi" treetype="template">
-- pcie3_cfg_msi - Configuration MSI interface allows the user application to set MSI interrupts for the PCIE Gen3 Core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_enable&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (required)
  &lt;s_vf_enable&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_mmenable&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_mask_update&gt; : out std_logic; --  (optional)
  &lt;s_data&gt; : out std_logic_vector(31 downto 0); --  (optional)
  &lt;s_select&gt; : in std_logic_vector(3 downto 0); --  (optional)
  &lt;s_int_vector&gt; : in std_logic_vector(31 downto 0); --  (optional)
  &lt;s_pending_status&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_sent&gt; : out std_logic; --  (optional)
  &lt;s_fail&gt; : out std_logic; --  (optional)
  &lt;s_attr&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_tph_present&gt; : in std_logic; --  (optional)
  &lt;s_tph_type&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_tph_st_tag&gt; : in std_logic_vector(8 downto 0); --  (optional)
  &lt;s_function_number&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_pending_status_data_enable&gt; : in std_logic; --  (optional)
  &lt;s_pending_status_function_num&gt; : in std_logic_vector(3 downto 0); --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vf_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; vf_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mmenable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; mmenable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mask_update&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; mask_update";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_select&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; select";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_int_vector&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; int_vector";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pending_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; pending_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sent&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; sent";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fail&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; fail";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_attr&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; attr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tph_present&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; tph_present";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tph_type&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; tph_type";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tph_st_tag&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; tph_st_tag";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_function_number&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; function_number";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pending_status_data_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; pending_status_data_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pending_status_function_num&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; pending_status_function_num";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_cfg_msix" treetype="template">
-- pcie3_cfg_msix - Configuration MSIx interface allows the user application to set MSIx interrupts for the PCIE Gen3 Core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_enable&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (required)
  &lt;s_mask&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_vf_enable&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_vf_mask&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_data&gt; : in std_logic_vector(31 downto 0); --  (optional)
  &lt;s_address&gt; : in std_logic_vector(63 downto 0); --  (optional)
  &lt;s_int_vector&gt; : in std_logic; --  (optional)
  &lt;s_sent&gt; : out std_logic; --  (optional)
  &lt;s_fail&gt; : out std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mask&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; mask";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vf_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; vf_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vf_mask&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; vf_mask";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_address&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; address";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_int_vector&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; int_vector";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sent&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; sent";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fail&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; fail";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_cfg_status" treetype="template">
-- pcie3_cfg_status - Configuration Status Interface for PCIE Gen3 Core provides information on how the core is configured. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_phy_link_down&gt; : in std_logic; --  (optional)
  &lt;s_phy_link_status&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_negotiated_width&gt; : in std_logic_vector(3 downto 0); --  (optional)
  &lt;s_current_speed&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_max_payload&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_max_read_req&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_function_status&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_function_power_state&gt; : in std_logic_vector(5 downto 0); --  (optional)
  &lt;s_vf_status&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_vf_power_state&gt; : in std_logic_vector(17 downto 0); --  (optional)
  &lt;s_link_power_state&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_err_cor_out&gt; : in std_logic; --  (optional)
  &lt;s_err_nonfatal_out&gt; : in std_logic; --  (optional)
  &lt;s_err_fatal_out&gt; : in std_logic; --  (optional)
  &lt;s_ltr_enable&gt; : in std_logic; --  (optional)
  &lt;s_ltssm_state&gt; : in std_logic_vector(5 downto 0); --  (required)
  &lt;s_rcb_status&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_dpa_substate_change&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_obff_enable&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_pl_status_change&gt; : in std_logic; --  (optional)
  &lt;s_tph_requester_enable&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_tph_st_mode&gt; : in std_logic_vector(5 downto 0); --  (optional)
  &lt;s_vf_tph_requester_enable&gt; : in std_logic_vector(5 downto 0); --  (optional)
  &lt;s_vf_tph_st_mode&gt; : in std_logic_vector(17 downto 0); --  (optional)
  &lt;s_rq_seq_num&gt; : in std_logic_vector(3 downto 0); --  (optional)
  &lt;s_rq_seq_num_vld&gt; : in std_logic; --  (optional)
  &lt;s_rq_tag&gt; : in std_logic_vector(5 downto 0); --  (optional)
  &lt;s_rq_tag_vld&gt; : in std_logic; --  (optional)
  &lt;s_tfc_nph_av&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_tfc_npd_av&gt; : in std_logic_vector(1 downto 0); --  (optional)
  &lt;s_cq_np_req&gt; : out std_logic; --  (optional)
  &lt;s_cq_np_req_count&gt; : in std_logic_vector(5 downto 0); --  (optional)
  &lt;s_rq_tag_av&gt; : in std_logic_vector(1 downto 0); --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_phy_link_down&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; phy_link_down";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_phy_link_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; phy_link_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_negotiated_width&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; negotiated_width";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_current_speed&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; current_speed";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_max_payload&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; max_payload";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_max_read_req&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; max_read_req";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_function_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; function_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_function_power_state&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; function_power_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vf_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; vf_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vf_power_state&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; vf_power_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_link_power_state&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; link_power_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_cor_out&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; err_cor_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_nonfatal_out&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; err_nonfatal_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_err_fatal_out&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; err_fatal_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ltr_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; ltr_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ltssm_state&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; ltssm_state";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rcb_status&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rcb_status";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dpa_substate_change&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; dpa_substate_change";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_obff_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; obff_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pl_status_change&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; pl_status_change";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tph_requester_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; tph_requester_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tph_st_mode&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; tph_st_mode";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vf_tph_requester_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; vf_tph_requester_enable";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vf_tph_st_mode&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; vf_tph_st_mode";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rq_seq_num&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_seq_num";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rq_seq_num_vld&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_seq_num_vld";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rq_tag&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_tag";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rq_tag_vld&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_tag_vld";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tfc_nph_av&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; tfc_nph_av";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tfc_npd_av&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; tfc_npd_av";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cq_np_req&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; cq_np_req";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cq_np_req_count&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; cq_np_req_count";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rq_tag_av&gt;: SIGNAL is "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_tag_av";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_per_func_status" treetype="template">
-- pcie3_per_func_status - Per Function Status Interface for PCIE Gen3 Core provides status data as requested by the user application through the selected function (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_status_control&gt; : out std_logic_vector(2 downto 0); --  (required)
  &lt;s_status_data&gt; : in std_logic_vector(15 downto 0); --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_status_control&gt;: SIGNAL is "xilinx.com:interface:pcie3_per_func_status:1.0 &lt;interface_name&gt; STATUS_CONTROL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_status_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_per_func_status:1.0 &lt;interface_name&gt; STATUS_DATA";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_pipe_debug" treetype="template">
-- pcie3_pipe_debug - Transceiver Pipe Debug Interface for the PCIE Gen3 Core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_txprbssel&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_rxprbssel&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_txprbsforceerr&gt; : in std_logic; --  (optional)
  &lt;s_rxprbscntreset&gt; : in std_logic; --  (optional)
  &lt;s_loopback&gt; : in std_logic_vector(2 downto 0); --  (optional)
  &lt;s_rxprbserr&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_rst_fsm&gt; : out std_logic_vector(4 downto 0); --  (optional)
  &lt;s_qrst_fsm&gt; : out std_logic_vector(11 downto 0); --  (optional)
  &lt;s_rate_fsm&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_sync_fsm_tx&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_sync_fsm_rx&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_drp_fsm&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_rst_idle&gt; : out std_logic; --  (optional)
  &lt;s_qrst_idle&gt; : out std_logic; --  (optional)
  &lt;s_rate_idle&gt; : out std_logic; --  (optional)
  &lt;s_gt_ch_drp_rdy&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (required)
  &lt;s_debug_0&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (required)
  &lt;s_debug_1&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_2&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_3&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_4&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_5&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_6&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_7&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_8&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug_9&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_debug&gt; : out std_logic_vector(31 downto 0); --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txprbssel&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; txprbssel";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxprbssel&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rxprbssel";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txprbsforceerr&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; txprbsforceerr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxprbscntreset&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rxprbscntreset";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_loopback&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; loopback";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxprbserr&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rxprbserr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst_fsm&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rst_fsm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qrst_fsm&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; qrst_fsm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rate_fsm&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rate_fsm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sync_fsm_tx&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; sync_fsm_tx";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sync_fsm_rx&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; sync_fsm_rx";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_drp_fsm&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; drp_fsm";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst_idle&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rst_idle";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_qrst_idle&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; qrst_idle";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rate_idle&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rate_idle";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gt_ch_drp_rdy&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; gt_ch_drp_rdy";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_0&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_0";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_1&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_2&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_3&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_3";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_4&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_4";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_5&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_5";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_6&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_6";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_7&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_7";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_8&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_8";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug_9&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_9";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_debug&gt;: SIGNAL is "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_transmit_fc" treetype="template">
-- pcie3_transmit_fc - Transmit Flow Control Interface for PCIE Gen3 Core is used by the user application to request which flow Control information the core provides. This interface provides the Posted/Non-Posted Header Flow Control Credits, Posted/Non-Posted Data Flow Control Credits, the Completion Header Flow Control Credits and Completion Data Flow Control Credits to User application based upon the setting flow control select input to the core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_nph_av&gt; : in std_logic_vector(1 downto 0); --  (required)
  &lt;s_npd_av&gt; : in std_logic_vector(1 downto 0); --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_nph_av&gt;: SIGNAL is "xilinx.com:interface:pcie3_transmit_fc:1.0 &lt;interface_name&gt; nph_av";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_npd_av&gt;: SIGNAL is "xilinx.com:interface:pcie3_transmit_fc:1.0 &lt;interface_name&gt; npd_av";

begin
--  user logic here

end arch_impl;
				</Template>
				<Template label="Pcie3_user_tph" treetype="template">
-- pcie3_user_tph - Transaction Processing Hint (TPH) Interface for PCIE Gen3 Core (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_stt_address&gt; : out std_logic_vector(4 downto 0); --  (required)
  &lt;s_function_num&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (required)
  &lt;s_stt_read_data&gt; : in std_logic_vector(31 downto 0); --  (required)
  &lt;s_stt_read_data_valid&gt; : in std_logic; --  (required)
  &lt;s_stt_read_enable&gt; : out std_logic; --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_stt_address&gt;: SIGNAL is "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; stt_address";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_function_num&gt;: SIGNAL is "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; function_num";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_stt_read_data&gt;: SIGNAL is "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; stt_read_data";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_stt_read_data_valid&gt;: SIGNAL is "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; stt_read_data_valid";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_stt_read_enable&gt;: SIGNAL is "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; stt_read_enable";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<Template label="Pipe Clock Interface" treetype="template">
-- pipe_clock - Pipe Clock Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_pclk_in&gt; : in std_logic; --  (optional)
  &lt;s_rxusrclk_in&gt; : in std_logic; --  (optional)
  &lt;s_rxoutclk_in&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_dclk_in&gt; : in std_logic; --  (optional)
  &lt;s_userclk1_in&gt; : in std_logic; --  (optional)
  &lt;s_userclk2_in&gt; : in std_logic; --  (optional)
  &lt;s_oobclk_in&gt; : in std_logic; --  (optional)
  &lt;s_mmcm_lock_in&gt; : in std_logic; --  (optional)
  &lt;s_txoutclk_out&gt; : out std_logic; --  (optional)
  &lt;s_rxoutclk_out&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_pclk_sel_out&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); --  (optional)
  &lt;s_gen3_out&gt; : out std_logic; --  (optional)
  &lt;s_mmcm_rst_n&gt; : in std_logic; --  (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pclk_in&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; pclk_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxusrclk_in&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; rxusrclk_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxoutclk_in&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; rxoutclk_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dclk_in&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; dclk_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_userclk1_in&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; userclk1_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_userclk2_in&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; userclk2_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_oobclk_in&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; oobclk_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mmcm_lock_in&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; mmcm_lock_in";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txoutclk_out&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; txoutclk_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxoutclk_out&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; rxoutclk_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pclk_sel_out&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; pclk_sel_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gen3_out&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; gen3_out";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mmcm_rst_n&gt;: SIGNAL is "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; mmcm_rst_n";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Ptp" treetype="template">
-- ptp - The PTP interface connected to the Ethernet controller provide the capability to handle IEEE-1588 precision time protocol (PTP) signaling (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_sof_tx&gt; : in std_logic; --  Tx Start-of-Frame (optional)
  &lt;s_sof_rx&gt; : in std_logic; --  Rx Start-of-Frame (optional)
  &lt;s_delay_req_tx&gt; : in std_logic; -- Tx PTP  delay req frame detected (optional)
  &lt;s_pdelay_req_tx&gt; : in std_logic; -- Tx PTP  peer delay frame detected (optional)
  &lt;s_pdelay_resp_tx&gt; : in std_logic; -- Tx PTP peer delay response frame detected (optional)
  &lt;s_sync_frame_tx&gt; : in std_logic; -- Tx PTP sync frame detected (optional)
  &lt;s_delay_req_rx&gt; : in std_logic; -- Rx PTP  delay req frame detected (optional)
  &lt;s_pdelay_req_rx&gt; : in std_logic; -- Rx PTP  peer delay frame detected (optional)
  &lt;s_pdelay_resp_rx&gt; : in std_logic; -- Rx PTP peer delay response frame detected (optional)
  &lt;s_sync_frame_rx&gt; : in std_logic; -- Rx PTP sync frame detected (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sof_tx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; SOF_TX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sof_rx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; SOF_RX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_delay_req_tx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; DELAY_REQ_TX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pdelay_req_tx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; PDELAY_REQ_TX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pdelay_resp_tx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; PDELAY_RESP_TX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sync_frame_tx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; SYNC_FRAME_TX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_delay_req_rx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; DELAY_REQ_RX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pdelay_req_rx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; PDELAY_REQ_RX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pdelay_resp_rx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; PDELAY_RESP_RX";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sync_frame_rx&gt;: SIGNAL is "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; SYNC_FRAME_RX";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Raw_switchable" treetype="template">
-- raw_switchable - Raw data format for connecting as 4x80 or 10x32 bit data bus (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_tx_alt_data0&gt; : in std_logic_vector(15 downto 0); -- Top 16 bits of 80-bit data bus (required)
  &lt;s_tx_alt_data1&gt; : in std_logic_vector(15 downto 0); -- Top 16 bits of 80-bit data bus (required)
  &lt;s_tx_alt_data2&gt; : in std_logic_vector(15 downto 0); -- Top 16 bits of 80-bit data bus (required)
  &lt;s_tx_alt_data3&gt; : in std_logic_vector(15 downto 0); -- Top 16 bits of 80-bit data bus (required)
  &lt;s_tx_data0&gt; : in std_logic_vector(63 downto 0); -- Bottom 64 bits of 80-bit data bus (required)
  &lt;s_tx_data1&gt; : in std_logic_vector(63 downto 0); -- Bottom 64 bits of 80-bit data bus (required)
  &lt;s_tx_data2&gt; : in std_logic_vector(63 downto 0); -- Bottom 64 bits of 80-bit data bus (required)
  &lt;s_tx_data3&gt; : in std_logic_vector(63 downto 0); -- Bottom 64 bits of 80-bit data bus (required)
  &lt;s_tx_data4&gt; : in std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_tx_data5&gt; : in std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_tx_data6&gt; : in std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_tx_data7&gt; : in std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_tx_data8&gt; : in std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_tx_data9&gt; : in std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_rx_alt_data0&gt; : out std_logic_vector(15 downto 0); -- Top 16 bits of 80-bit data bus (required)
  &lt;s_rx_alt_data1&gt; : out std_logic_vector(15 downto 0); -- Top 16 bits of 80-bit data bus (required)
  &lt;s_rx_alt_data2&gt; : out std_logic_vector(15 downto 0); -- Top 16 bits of 80-bit data bus (required)
  &lt;s_rx_alt_data3&gt; : out std_logic_vector(15 downto 0); -- Top 16 bits of 80-bit data bus (required)
  &lt;s_rx_data0&gt; : out std_logic_vector(63 downto 0); -- Bottom 64 bits of 80-bit data bus (required)
  &lt;s_rx_data1&gt; : out std_logic_vector(63 downto 0); -- Bottom 64 bits of 80-bit data bus (required)
  &lt;s_rx_data2&gt; : out std_logic_vector(63 downto 0); -- Bottom 64 bits of 80-bit data bus (required)
  &lt;s_rx_data3&gt; : out std_logic_vector(63 downto 0); -- Bottom 64 bits of 80-bit data bus (required)
  &lt;s_rx_data4&gt; : out std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_rx_data5&gt; : out std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_rx_data6&gt; : out std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_rx_data7&gt; : out std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_rx_data8&gt; : out std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  &lt;s_rx_data9&gt; : out std_logic_vector(31 downto 0); -- 32-bit data bus (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_alt_data0&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_ALT_DATA0";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_alt_data1&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_ALT_DATA1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_alt_data2&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_ALT_DATA2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_alt_data3&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_ALT_DATA3";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data0&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA0";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data1&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data2&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data3&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA3";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data4&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA4";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data5&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA5";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data6&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA6";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data7&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA7";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data8&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA8";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_data9&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA9";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_alt_data0&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_ALT_DATA0";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_alt_data1&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_ALT_DATA1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_alt_data2&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_ALT_DATA2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_alt_data3&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_ALT_DATA3";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data0&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA0";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data1&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA1";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data2&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA2";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data3&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA3";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data4&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA4";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data5&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA5";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data6&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA6";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data7&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA7";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data8&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA8";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_data9&gt;: SIGNAL is "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA9";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Rgmii" treetype="template">
-- rgmii - DDR bus I/F between a 10/100/1000Mbps Ethernet MAC and a PHY (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_td&gt; : out std_logic_vector(3 downto 0); -- Ethernet transmit data (required)
  &lt;m_tx_ctl&gt; : out std_logic; -- Ethernet transmit control (required)
  &lt;m_txc&gt; : out std_logic; -- Ethernet transmit clock (required)
  &lt;m_rd&gt; : in std_logic_vector(3 downto 0); -- Ethernet receive data (required)
  &lt;m_rx_ctl&gt; : in std_logic; -- Ethernet receive control (required)
  &lt;m_rxc&gt; : in std_logic; -- Ethernet receive clock (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_td&gt;: SIGNAL is "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; TD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_tx_ctl&gt;: SIGNAL is "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; TX_CTL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_txc&gt;: SIGNAL is "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; TXC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rd&gt;: SIGNAL is "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; RD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rx_ctl&gt;: SIGNAL is "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; RX_CTL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rxc&gt;: SIGNAL is "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; RXC";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Rmii" treetype="template">
-- rmii - Reduced Media Independent Interface (RMII) is an interface used in ethernet designs to insulate Media Access (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_crs_dv&gt; : out std_logic; -- Carrier sence, Receive data valid (required)
  &lt;s_rxd&gt; : out std_logic_vector(1 downto 0); -- Receive data (required)
  &lt;s_tx_en&gt; : in std_logic; -- Transmit enable (required)
  &lt;s_txd&gt; : in std_logic_vector(1 downto 0); -- Transmit data (required)
  &lt;s_rx_er&gt; : out std_logic; -- Receive error (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_crs_dv&gt;: SIGNAL is "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; CRS_DV";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxd&gt;: SIGNAL is "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; RXD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_en&gt;: SIGNAL is "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; TX_EN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txd&gt;: SIGNAL is "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; TXD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_er&gt;: SIGNAL is "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; RX_ER";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Rx_mipi_ppi_if" treetype="template">
-- rx_mipi_ppi_if - MIPI PPI interface for rx clock lane and one (or) more rx data lane(s). This on-chip interface is used to connect to MIPI CSI IP from MIPI D-PHY IP in FPGA fabric. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_cl_enable&gt; : out std_logic; -- Enable Clock Lane Module (required)
  &lt;s_cl_stopstate&gt; : in std_logic; -- Clock Lane is in Stop state (required)
  &lt;s_cl_rxclkactivehs&gt; : in std_logic; -- Receiver Clock Active (optional)
  &lt;s_cl_ulpsactivenot&gt; : in std_logic; -- Clock Lane ULP State (not) Active (optional)
  &lt;s_cl_rxulpsclknot&gt; : in std_logic; -- Receive Ultra-Low Power State on Clock Lane (optional)
  &lt;s_dl0_stopstate&gt; : in std_logic; -- Data Lane 0 is in Stop state (optional)
  &lt;s_dl0_enable&gt; : out std_logic; -- Enable Data Lane 0 Module (required)
  &lt;s_dl0_rxactivehs&gt; : in std_logic; -- Data Lane 0 High-Speed Reception Active (required)
  &lt;s_dl0_rxsynchs&gt; : in std_logic; -- Data Lane 0 Receiver Synchronization Observed (required)
  &lt;s_dl0_rxvalidhs&gt; : in std_logic; -- Data Lane 0 High-Speed Receive Data Valid (required)
  &lt;s_dl0_rxdatahs&gt; : in std_logic_vector(7 downto 0); -- Data Lane 0 High-Speed Receive Data (required)
  &lt;s_dl0_forcerxmode&gt; : out std_logic; -- Force Data Lane 0 to Wait for Stop state (optional)
  &lt;s_dl0_rxclkesc&gt; : in std_logic; -- Data Lane 0 Escape Mode Receive Clock (optional)
  &lt;s_dl0_rxlpdtesc&gt; : in std_logic; -- Data Lane 0 Escape Low-Power Data Receive mode (optional)
  &lt;s_dl0_rxulpsesc&gt; : in std_logic; -- Data Lane 0 Escape Ultra-Low Power (Receive) mode (optional)
  &lt;s_dl0_rxdataesc&gt; : in std_logic_vector(7 downto 0); -- Data Lane 0 Escape mode Receive Data (optional)
  &lt;s_dl0_rxtriggeresc&gt; : in std_logic_vector(3 downto 0); -- Data Lane 0 Escape Mode Receive Trigger 0-3 (optional)
  &lt;s_dl0_rxvalidesc&gt; : in std_logic; -- Data Lane 0 Escape Mode Receive Data Valid (optional)
  &lt;s_dl0_ulpsactivenot&gt; : in std_logic; -- Data Lane 0 ULP State (not) Active (optional)
  &lt;s_dl0_errsoths&gt; : in std_logic; -- Data Lane 0 Start-of-Transmission (SoT) Error (optional)
  &lt;s_dl0_errsotsynchs&gt; : in std_logic; -- Data Lane 0 Start-of-Transmission Synchronization Error (optional)
  &lt;s_dl0_erresc&gt; : in std_logic; -- Data Lane 0 Escape Entry Error (optional)
  &lt;s_dl0_errsyncesc&gt; : in std_logic; -- Data Lane 0 Low-Power Data Transmission Synchronization Error (optional)
  &lt;s_dl0_errcontrol&gt; : in std_logic; -- Data Lane 0 Control Error (optional)
  &lt;s_dl1_stopstate&gt; : in std_logic; -- Data Lane 1 is in Stop state (optional)
  &lt;s_dl1_enable&gt; : out std_logic; -- Enable Data Lane 1 Module (optional)
  &lt;s_dl1_rxactivehs&gt; : in std_logic; -- Data Lane 1 High-Speed Reception Active (optional)
  &lt;s_dl1_rxsynchs&gt; : in std_logic; -- Data Lane 1 Receiver Synchronization Observed (optional)
  &lt;s_dl1_rxvalidhs&gt; : in std_logic; -- Data Lane 1 High-Speed Receive Data Valid (optional)
  &lt;s_dl1_rxdatahs&gt; : in std_logic_vector(7 downto 0); -- Data Lane 1 High-Speed Receive Data (optional)
  &lt;s_dl1_forcerxmode&gt; : out std_logic; -- Force Data Lane 1 to Wait for Stop state (optional)
  &lt;s_dl1_rxclkesc&gt; : in std_logic; -- Data Lane 1 Escape Mode Receive Clock (optional)
  &lt;s_dl1_rxlpdtesc&gt; : in std_logic; -- Data Lane 1 Escape Low-Power Data Receive mode (optional)
  &lt;s_dl1_rxulpsesc&gt; : in std_logic; -- Data Lane 1 Escape Ultra-Low Power (Receive) mode (optional)
  &lt;s_dl1_rxdataesc&gt; : in std_logic_vector(7 downto 0); -- Data Lane 1 Escape mode Receive Data (optional)
  &lt;s_dl1_rxtriggeresc&gt; : in std_logic_vector(3 downto 0); -- Data Lane 1 Escape Mode Receive Trigger 0-3 (optional)
  &lt;s_dl1_rxvalidesc&gt; : in std_logic; -- Data Lane 1 Escape Mode Receive Data Valid (optional)
  &lt;s_dl1_ulpsactivenot&gt; : in std_logic; -- Data Lane 1 ULP State (not) Active (optional)
  &lt;s_dl1_errsoths&gt; : in std_logic; -- Data Lane 1 Start-of-Transmission (SoT) Error (optional)
  &lt;s_dl1_errsotsynchs&gt; : in std_logic; -- Data Lane 1 Start-of-Transmission Synchronization Error (optional)
  &lt;s_dl1_erresc&gt; : in std_logic; -- Data Lane 1 Escape Entry Error (optional)
  &lt;s_dl1_errsyncesc&gt; : in std_logic; -- Data Lane 1 Low-Power Data Transmission Synchronization Error (optional)
  &lt;s_dl1_errcontrol&gt; : in std_logic; -- Data Lane 1 Control Error (optional)
  &lt;s_dl2_stopstate&gt; : in std_logic; -- Data Lane 2 is in Stop state (optional)
  &lt;s_dl2_enable&gt; : out std_logic; -- Enable Data Lane 2 Module (optional)
  &lt;s_dl2_rxactivehs&gt; : in std_logic; -- Data Lane 2 High-Speed Reception Active (optional)
  &lt;s_dl2_rxsynchs&gt; : in std_logic; -- Data Lane 2 Receiver Synchronization Observed (optional)
  &lt;s_dl2_rxvalidhs&gt; : in std_logic; -- Data Lane 2 High-Speed Receive Data Valid (optional)
  &lt;s_dl2_rxdatahs&gt; : in std_logic_vector(7 downto 0); -- Data Lane 2 High-Speed Receive Data (optional)
  &lt;s_dl2_forcerxmode&gt; : out std_logic; -- Force Data Lane 2 to Wait for Stop state (optional)
  &lt;s_dl2_rxclkesc&gt; : in std_logic; -- Data Lane 2 Escape Mode Receive Clock (optional)
  &lt;s_dl2_rxlpdtesc&gt; : in std_logic; -- Data Lane 2 Escape Low-Power Data Receive mode (optional)
  &lt;s_dl2_rxulpsesc&gt; : in std_logic; -- Data Lane 2 Escape Ultra-Low Power (Receive) mode (optional)
  &lt;s_dl2_rxdataesc&gt; : in std_logic_vector(7 downto 0); -- Data Lane 2 Escape mode Receive Data (optional)
  &lt;s_dl2_rxtriggeresc&gt; : in std_logic_vector(3 downto 0); -- Data Lane 2 Escape Mode Receive Trigger 0-3 (optional)
  &lt;s_dl2_rxvalidesc&gt; : in std_logic; -- Data Lane 2 Escape Mode Receive Data Valid (optional)
  &lt;s_dl2_ulpsactivenot&gt; : in std_logic; -- Data Lane 2 ULP State (not) Active (optional)
  &lt;s_dl2_errsoths&gt; : in std_logic; -- Data Lane 2 Start-of-Transmission (SoT) Error (optional)
  &lt;s_dl2_errsotsynchs&gt; : in std_logic; -- Data Lane 2 Start-of-Transmission Synchronization Error (optional)
  &lt;s_dl2_erresc&gt; : in std_logic; -- Data Lane 2 Escape Entry Error (optional)
  &lt;s_dl2_errsyncesc&gt; : in std_logic; -- Data Lane 2 Low-Power Data Transmission Synchronization Error (optional)
  &lt;s_dl2_errcontrol&gt; : in std_logic; -- Data Lane 2 Control Error (optional)
  &lt;s_dl3_stopstate&gt; : in std_logic; -- Data Lane 3 is in Stop state (optional)
  &lt;s_dl3_enable&gt; : out std_logic; -- Enable Data Lane 3 Module (optional)
  &lt;s_dl3_rxactivehs&gt; : in std_logic; -- Data Lane 3 High-Speed Reception Active (optional)
  &lt;s_dl3_rxsynchs&gt; : in std_logic; -- Data Lane 3 Receiver Synchronization Observed (optional)
  &lt;s_dl3_rxvalidhs&gt; : in std_logic; -- Data Lane 3 High-Speed Receive Data Valid (optional)
  &lt;s_dl3_rxdatahs&gt; : in std_logic_vector(7 downto 0); -- Data Lane 3 High-Speed Receive Data (optional)
  &lt;s_dl3_forcerxmode&gt; : out std_logic; -- Force Data Lane 3 to Wait for Stop state (optional)
  &lt;s_dl3_rxclkesc&gt; : in std_logic; -- Data Lane 3 Escape Mode Receive Clock (optional)
  &lt;s_dl3_rxlpdtesc&gt; : in std_logic; -- Data Lane 3 Escape Low-Power Data Receive mode (optional)
  &lt;s_dl3_rxulpsesc&gt; : in std_logic; -- Data Lane 3 Escape Ultra-Low Power (Receive) mode (optional)
  &lt;s_dl3_rxdataesc&gt; : in std_logic_vector(7 downto 0); -- Data Lane 3 Escape mode Receive Data (optional)
  &lt;s_dl3_rxtriggeresc&gt; : in std_logic_vector(3 downto 0); -- Data Lane 3 Escape Mode Receive Trigger 0-3 (optional)
  &lt;s_dl3_rxvalidesc&gt; : in std_logic; -- Data Lane 3 Escape Mode Receive Data Valid (optional)
  &lt;s_dl3_ulpsactivenot&gt; : in std_logic; -- Data Lane 3 ULP State (not) Active (optional)
  &lt;s_dl3_errsoths&gt; : in std_logic; -- Data Lane 3 Start-of-Transmission (SoT) Error (optional)
  &lt;s_dl3_errsotsynchs&gt; : in std_logic; -- Data Lane 3 Start-of-Transmission Synchronization Error (optional)
  &lt;s_dl3_erresc&gt; : in std_logic; -- Data Lane 3 Escape Entry Error (optional)
  &lt;s_dl3_errsyncesc&gt; : in std_logic; -- Data Lane 3 Low-Power Data Transmission Synchronization Error (optional)
  &lt;s_dl3_errcontrol&gt; : in std_logic; -- Data Lane 3 Control Error (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_enable&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_stopstate&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_rxclkactivehs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_RXCLKACTIVEHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_rxulpsclknot&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_RXULPSCLKNOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_stopstate&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_enable&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxactivehs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXACTIVEHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxsynchs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXSYNCHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxvalidhs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXVALIDHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxdatahs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXDATAHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_forcerxmode&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_FORCERXMODE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxclkesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXCLKESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxlpdtesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXLPDTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxulpsesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXULPSESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxdataesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXDATAESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxtriggeresc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXTRIGGERESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_rxvalidesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXVALIDESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_errsoths&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRSOTHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_errsotsynchs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRSOTSYNCHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_erresc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_errsyncesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRSYNCESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_errcontrol&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRCONTROL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_stopstate&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_enable&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxactivehs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXACTIVEHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxsynchs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXSYNCHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxvalidhs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXVALIDHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxdatahs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXDATAHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_forcerxmode&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_FORCERXMODE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxclkesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXCLKESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxlpdtesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXLPDTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxulpsesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXULPSESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxdataesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXDATAESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxtriggeresc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXTRIGGERESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_rxvalidesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXVALIDESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_errsoths&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRSOTHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_errsotsynchs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRSOTSYNCHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_erresc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_errsyncesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRSYNCESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_errcontrol&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRCONTROL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_stopstate&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_enable&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxactivehs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXACTIVEHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxsynchs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXSYNCHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxvalidhs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXVALIDHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxdatahs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXDATAHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_forcerxmode&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_FORCERXMODE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxclkesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXCLKESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxlpdtesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXLPDTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxulpsesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXULPSESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxdataesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXDATAESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxtriggeresc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXTRIGGERESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_rxvalidesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXVALIDESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_errsoths&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRSOTHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_errsotsynchs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRSOTSYNCHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_erresc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_errsyncesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRSYNCESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_errcontrol&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRCONTROL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_stopstate&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_enable&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxactivehs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXACTIVEHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxsynchs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXSYNCHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxvalidhs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXVALIDHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxdatahs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXDATAHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_forcerxmode&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_FORCERXMODE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxclkesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXCLKESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxlpdtesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXLPDTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxulpsesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXULPSESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxdataesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXDATAESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxtriggeresc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXTRIGGERESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_rxvalidesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXVALIDESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_errsoths&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRSOTHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_errsotsynchs&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRSOTSYNCHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_erresc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_errsyncesc&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRSYNCESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_errcontrol&gt;: SIGNAL is "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRCONTROL";

begin
--  user logic here

end arch_impl;
			</Template>
			<SubFolder label="sdi" treetype="folder">
				<Template label="Sdi_native" treetype="template">
-- sdi_native - bus definition for SDI that used between SDI with video block or Aux block (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_ds1a&gt; : in std_logic_vector(9 downto 0); -- data stream 1A or A_Y_IN (optional)
  &lt;s_ds2a&gt; : in std_logic_vector(9 downto 0); -- data stream 2A or A_C_IN (optional)
  &lt;s_ds1b&gt; : in std_logic_vector(9 downto 0); -- data stream 1B or B_Y_IN (optional)
  &lt;s_ds2b&gt; : in std_logic_vector(9 downto 0); -- data stream 2B or B_C_IN (optional)
  &lt;s_lvl_b_3g&gt; : in std_logic; -- used in 3g mode to determine module is configure for lvlA or lvl B (optional)
  &lt;s_d_rdy_3g&gt; : in std_logic; -- data ready signal used in 3G mode (optional)
  &lt;s_line_a&gt; : in std_logic_vector(10 downto 0); -- capture current line number (optional)
  &lt;s_line_b&gt; : in std_logic_vector(10 downto 0); -- capture current line number in 3G mode (optional)
  &lt;s_rx_eav&gt; : in std_logic; -- high when XYZ word of an EAV is present in the data (optional)
  &lt;s_rx_sav&gt; : in std_logic; -- high when XYZ word of an SAV is present in the data (optional)
  &lt;s_rx_trs&gt; : in std_logic; -- high for 4 consec sample times of all 4 words of an EAV and SAV (optional)
  &lt;s_ce&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- clock enable (optional)
  &lt;s_sdi_mode&gt; : in std_logic_vector(1 downto 0); -- indicate current sdi mode (optional)
  &lt;s_rx_mode_hd&gt; : in std_logic; -- indicator for matched SDI mode (optional)
  &lt;s_rx_mode_sd&gt; : in std_logic; -- indicator for matched SDI mode (optional)
  &lt;s_rx_mode_3g&gt; : in std_logic; -- indicator for matched SDI mode (optional)
  &lt;s_rx_mode_locked&gt; : in std_logic; -- indicate sdi mode has been locked (optional)
  &lt;s_rx_t_locked&gt; : in std_logic; -- indicate transpoprt format has been locked (optional)
  &lt;s_rx_t_family&gt; : in std_logic_vector(3 downto 0); -- indicate family of video signal (optional)
  &lt;s_rx_t_rate&gt; : in std_logic_vector(3 downto 0); -- indicate frame rate of transport (optional)
  &lt;s_rx_t_scan&gt; : in std_logic; -- indicate prog or interlaced (optional)
  &lt;s_rx_a_vpid&gt; : in std_logic_vector(31 downto 0); -- all four user data bytes of the ST 352 packet from data stream 1 (optional)
  &lt;s_rx_a_vpid_valid&gt; : in std_logic; -- indicate validity of vpid from a_vpid (optional)
  &lt;s_rx_b_vpid&gt; : in std_logic_vector(31 downto 0); -- all four user data bytes of the ST 352 packet from data stream 2 (optional)
  &lt;s_rx_b_vpid_valid&gt; : in std_logic; -- indicate validity of vpid from b_vpid (optional)
  &lt;s_rx_bit_rate&gt; : in std_logic; -- indicate bit rate in HD-SDI and 3G-SDI modes (optional)
  &lt;s_tx_bit_rate&gt; : in std_logic; -- selection control between 148.5 amd 148.35 ref clk (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds1a&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; DS1A";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds2a&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; DS2A";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds1b&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; DS1B";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ds2b&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; DS2B";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_lvl_b_3g&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; LVL_B_3G";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_d_rdy_3g&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; D_RDY_3G";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_line_a&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; LINE_A";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_line_b&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; LINE_B";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_eav&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_EAV";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_sav&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_SAV";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_trs&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_TRS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ce&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; CE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sdi_mode&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; SDI_MODE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_mode_hd&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_MODE_HD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_mode_sd&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_MODE_SD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_mode_3g&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_MODE_3G";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_mode_locked&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_MODE_LOCKED";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_t_locked&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_T_LOCKED";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_t_family&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_T_FAMILY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_t_rate&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_T_RATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_t_scan&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_T_SCAN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_a_vpid&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_A_VPID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_a_vpid_valid&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_A_VPID_VALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_b_vpid&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_B_VPID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_b_vpid_valid&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_B_VPID_VALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_bit_rate&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_BIT_RATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_bit_rate&gt;: SIGNAL is "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; TX_BIT_RATE";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<Template label="Sdio" treetype="template">
-- sdio - SDIO peripheral controller interface controls communication with SDIO devices, SD memory, and MMC cards (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_clk&gt; : in std_logic; -- Clock (required)
  &lt;s_clk_fb&gt; : out std_logic; -- Clock Feedback (optional)
  &lt;s_cmd_i&gt; : out std_logic; -- Command (optional)
  &lt;s_cmd_o&gt; : in std_logic; -- Command (optional)
  &lt;s_cmd_t&gt; : in std_logic; -- Command (optional)
  &lt;s_data_i&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Data Bus (optional)
  &lt;s_data_o&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Data Bus (optional)
  &lt;s_data_t&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Data Bus (optional)
  &lt;s_cdn&gt; : out std_logic; -- Card Detect (optional)
  &lt;s_wp&gt; : out std_logic; -- Write Protect (optional)
  &lt;s_led&gt; : in std_logic; -- LED Control (optional)
  &lt;s_buspow&gt; : in std_logic; -- Power Control (optional)
  &lt;s_busvolt&gt; : in std_logic; -- Bus Voltage (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk_fb&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CLK_FB";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cmd_i&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CMD_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cmd_o&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CMD_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cmd_t&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CMD_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_i&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; DATA_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_o&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; DATA_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_t&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; DATA_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cdn&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CDN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wp&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; WP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_led&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; LED";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_buspow&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; BUSPOW";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_busvolt&gt;: SIGNAL is "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; BUSVOLT";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Serial Peripheral Interface" treetype="template">
-- spi - Serial Peripheral Interface (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_spisel&gt; : in std_logic; -- SPISEL input to the core (optional)
  &lt;m_ss_i&gt; : in std_logic; -- Slave Select Input (optional)
  &lt;m_ss_o&gt; : out std_logic; -- Slave Select Output (required)
  &lt;m_ss_t&gt; : out std_logic; -- Slave Select Tri-State Control (required)
  &lt;m_sck_i&gt; : in std_logic; -- SPI Clock Input (required)
  &lt;m_sck_o&gt; : out std_logic; -- SPI Clock Output (required)
  &lt;m_sck_t&gt; : out std_logic; -- SPI Clock Tri-State Control (required)
  &lt;m_io0_i&gt; : in std_logic; -- IO0 Input Port (required)
  &lt;m_io0_o&gt; : out std_logic; -- IO0 Output Port (required)
  &lt;m_io0_t&gt; : out std_logic; -- IO0 Tri-State Control (required)
  &lt;m_io1_i&gt; : in std_logic; -- IO1 Input Port (required)
  &lt;m_io1_o&gt; : out std_logic; -- IO1 Output Port (required)
  &lt;m_io1_t&gt; : out std_logic; -- IO1 Tri-State Control (required)
  &lt;m_io2_i&gt; : in std_logic; -- IO2 Input Port (optional)
  &lt;m_io2_o&gt; : out std_logic; -- IO2 Output Port (optional)
  &lt;m_io2_t&gt; : out std_logic; -- IO2 Tri-State Control (optional)
  &lt;m_io3_i&gt; : in std_logic; -- IO3 Input Port (optional)
  &lt;m_io3_o&gt; : out std_logic; -- IO3 Output Port (optional)
  &lt;m_io3_t&gt; : out std_logic; -- IO3 Tri-State Control (optional)
  &lt;m_ss1_o&gt; : out std_logic; -- Slave Select 1 Output (optional)
  &lt;m_ss2_o&gt; : out std_logic; -- Slave Select 2 Output (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_spisel&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SPISEL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ss_i&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ss_o&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ss_t&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_sck_i&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SCK_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_sck_o&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SCK_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_sck_t&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SCK_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io0_i&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO0_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io0_o&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO0_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io0_t&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO0_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io1_i&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO1_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io1_o&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO1_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io1_t&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO1_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io2_i&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO2_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io2_o&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO2_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io2_t&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO2_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io3_i&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO3_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io3_o&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO3_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_io3_t&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO3_T";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ss1_o&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS1_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ss2_o&gt;: SIGNAL is "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS2_O";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Sfp" treetype="template">
-- sfp - Bus interface between a GT and a connected SFP (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_txn&gt; : in std_logic; -- Transmit Data N of differential pair (required)
  &lt;s_rxn&gt; : out std_logic; -- Receive Data N of differential pair (required)
  &lt;s_txp&gt; : in std_logic; -- Transmit Data P of differential pair (required)
  &lt;s_rxp&gt; : out std_logic; -- Receive Data P of differential pair (required)
  &lt;s_rx_los&gt; : out std_logic; -- Receiver Loss of Signal Indication (optional)
  &lt;s_mod_abs&gt; : out std_logic; -- Module Absent (SFP+ MOD_ABS =SFP MOD-DEF0) (optional)
  &lt;s_scl&gt; : in std_logic; -- Serial Interface Clock (SFP+SCL = SFP MOD-DEF1) (optional)
  &lt;s_sda&gt; : inout std_logic; -- Serial Interface Data Line (SFP+ SDA = SFP MOD-DEF2) (optional)
  &lt;s_tx_disable&gt; : in std_logic; -- Transmitter Disable; Turns off transmitter laser output (optional)
  &lt;s_tx_fault&gt; : out std_logic; -- Module Transmitter Fault (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txn&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; TXN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxn&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; RXN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txp&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; TXP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxp&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; RXP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rx_los&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; RX_LOS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_mod_abs&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; MOD_ABS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_scl&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; SCL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_sda&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; SDA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_disable&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; TX_DISABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tx_fault&gt;: SIGNAL is "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; TX_FAULT";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Sgmii" treetype="template">
-- sgmii - Bus interface between a GT and a connected PHY (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_txn&gt; : in std_logic; -- Transmit Data N of differential pair (required)
  &lt;s_rxn&gt; : out std_logic; -- Receive Data N of differential pair (required)
  &lt;s_txp&gt; : in std_logic; -- Transmit Data P of differential pair (required)
  &lt;s_rxp&gt; : out std_logic; -- Receive Data P of differential pair (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txn&gt;: SIGNAL is "xilinx.com:interface:sgmii:1.0 &lt;interface_name&gt; TXN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxn&gt;: SIGNAL is "xilinx.com:interface:sgmii:1.0 &lt;interface_name&gt; RXN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_txp&gt;: SIGNAL is "xilinx.com:interface:sgmii:1.0 &lt;interface_name&gt; TXP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rxp&gt;: SIGNAL is "xilinx.com:interface:sgmii:1.0 &lt;interface_name&gt; RXP";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="SPDIF Bus Definition" treetype="template">
-- spdif - SPDIF Bus Definition (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_spdif&gt; : in std_logic; -- Bi-Phase mark coded serial audio data (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_spdif&gt;: SIGNAL is "xilinx.com:interface:spdif:2.0 &lt;interface_name&gt; SPDIF";

begin
--  user logic here

end arch_impl;
-- spdif - SPDIF Bus Definition (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_spdif_o&gt; : out std_logic; -- Bi-Phase mark coded serial audio data out (optional)
  &lt;s_spdif_i&gt; : in std_logic; -- Bi-Phase mark coded serial audio data in (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_spdif_o&gt;: SIGNAL is "xilinx.com:interface:spdif:1.0 &lt;interface_name&gt; SPDIF_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_spdif_i&gt;: SIGNAL is "xilinx.com:interface:spdif:1.0 &lt;interface_name&gt; SPDIF_I";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Startup Primitive Interface" treetype="template">
-- startup - Startup Primitive Interface (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_cfgclk&gt; : out std_logic; -- Configuration main clock output (optional)
  &lt;s_cfgmclk&gt; : out std_logic; -- Configuration internal oscillator clock output (optional)
  &lt;s_eos&gt; : out std_logic; -- End Of Startup (optional)
  &lt;s_preq&gt; : out std_logic; -- PROGRAM request to fabric output (optional)
  &lt;s_clk&gt; : in std_logic; -- User start-up clock  (optional)
  &lt;s_gsr&gt; : in std_logic; -- Global Set/Reset (optional)
  &lt;s_gts&gt; : in std_logic; -- Global 3-state input (optional)
  &lt;s_keyclearb&gt; : in std_logic; -- Clear AES Decrypter Key (optional)
  &lt;s_pack&gt; : in std_logic; -- PROGRAM acknowledge (optional)
  &lt;s_usrcclko&gt; : in std_logic; -- User CCLK (optional)
  &lt;s_usrclkts&gt; : in std_logic; -- User CCLK 3-state enable (optional)
  &lt;s_userdoneo&gt; : in std_logic; -- User DONE pin  (optional)
  &lt;s_usrdonets&gt; : in std_logic; -- User DONE 3-state enable (optional)
  &lt;s_di&gt; : out std_logic_vector(3 downto 0); -- Pin inputs from STARTUP to FPGA (optional)
  &lt;s_do&gt; : in std_logic_vector(3 downto 0); -- FPGA logic signal routed to STARTUP (optional)
  &lt;s_dts&gt; : in std_logic_vector(3 downto 0); -- 3-state control (optional)
  &lt;s_fcsbo&gt; : in std_logic; -- User control of FCS_B pin for flash access (optional)
  &lt;s_fcsbts&gt; : in std_logic; -- 3-state control of external FCS_B pin (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfgclk&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; cfgclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cfgmclk&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; cfgmclk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_eos&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; eos";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_preq&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; preq";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; clk";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gsr&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; gsr";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_gts&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; gts";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_keyclearb&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; keyclearb";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_pack&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; pack";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_usrcclko&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; usrcclko";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_usrclkts&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; usrclkts";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_userdoneo&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; userdoneo";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_usrdonets&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; usrdonets";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_di&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; di";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_do&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; do";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dts&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; dts";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fcsbo&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; fcsbo";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_fcsbts&gt;: SIGNAL is "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; fcsbts";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Trigger" treetype="template">
-- trigger - This comprises of two ports TRIG (required) and TRIG_ACK (required) ports. When the interface is configured as a Master, external processor or ILA generates a trigger through TRIG port to mark a debugger event or hardware event. When configured as a Slave, external processor or ILA receives trigger from an external master to capture processor/hardware event. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_trig&gt; : in std_logic; -- Trigger (required)
  &lt;s_ack&gt; : out std_logic; -- Trigger acknowledgement (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_trig&gt;: SIGNAL is "xilinx.com:interface:trigger:1.0 &lt;interface_name&gt; TRIG";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ack&gt;: SIGNAL is "xilinx.com:interface:trigger:1.0 &lt;interface_name&gt; ACK";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Tx_mipi_ppi_if" treetype="template">
-- tx_mipi_ppi_if - MIPI PPI interface for tx clock lane and one (or) more tx data lane(s). This on-chip interface is used to connect with MIPI DSI IP to MIPI D-PHY IP in FPGA fabric. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_cl_txrequesths&gt; : out std_logic; -- Clock Lane High-Speed Transmit Request and Data Valid (required)
  &lt;s_cl_stopstate&gt; : in std_logic; -- Clock Lane is in Stop state (required)
  &lt;s_cl_enable&gt; : out std_logic; -- Enable Clock Lane Module (required)
  &lt;s_cl_txulpsclk&gt; : out std_logic; -- Transmit Ultra-Low Power State on Clock Lane (optional)
  &lt;s_cl_txulpsexit&gt; : out std_logic; -- Clock Lane Transmit ULP Exit Sequence (optional)
  &lt;s_cl_ulpsactivenot&gt; : in std_logic; -- Clock Lane ULP State (not) Active (optional)
  &lt;s_dl0_stopstate&gt; : in std_logic; -- Data Lane 0 is in Stop state (required)
  &lt;s_dl0_enable&gt; : out std_logic; -- Enable Data Lane 0 Module (required)
  &lt;s_dl0_txrequesths&gt; : out std_logic; -- Data Lane 0 High-Speed Transmit Request and Data Valid (required)
  &lt;s_dl0_txdatahs&gt; : out std_logic_vector(7 downto 0); -- Data Lane 0 High-Speed Transmit Data (required)
  &lt;s_dl0_txreadyhs&gt; : in std_logic; -- Data Lane 0 High-Speed Transmit Ready (required)
  &lt;s_dl0_forcetxstopmode&gt; : out std_logic; -- Force Data Lane 0 to Generate Stop state  (optional)
  &lt;s_dl0_txrequestesc&gt; : out std_logic; -- Data Lane 0 Escape Mode Transmit Request (optional)
  &lt;s_dl0_txulpsexit&gt; : out std_logic; -- Data Lane 0 Transmit ULP Exit Sequence (optional)
  &lt;s_dl0_ulpsactivenot&gt; : in std_logic; -- Data Lane 0 ULP State (not) Active (optional)
  &lt;s_dl0_txulpsesc&gt; : out std_logic; -- Data Lane 0 Escape Mode Transmit Ultra-Low Power State (optional)
  &lt;s_dl0_txlpdtesc&gt; : out std_logic; -- Data Lane 0 Escape Mode Transmit Low-Power Data (optional)
  &lt;s_dl0_txdataesc&gt; : out std_logic_vector(7 downto 0); -- Data Lane 0 Escape Mode Transmit Data (optional)
  &lt;s_dl0_txtriggeresc&gt; : out std_logic_vector(3 downto 0); -- Data Lane 0 Escape Mode Transmit Trigger 0-3 (optional)
  &lt;s_dl0_txvalidesc&gt; : out std_logic; -- Data Lane 0 Escape Mode Transmit Data Valid (optional)
  &lt;s_dl0_txreadyesc&gt; : in std_logic; -- Data Lane 0 Escape Mode Transmit Ready (optional)
  &lt;s_dl1_stopstate&gt; : in std_logic; -- Data Lane 1 is in Stop state (optional)
  &lt;s_dl1_enable&gt; : out std_logic; -- Enable Data Lane 1 Module (optional)
  &lt;s_dl1_txrequesths&gt; : out std_logic; -- Data Lane 1 High-Speed Transmit Request and Data Valid (optional)
  &lt;s_dl1_txdatahs&gt; : out std_logic_vector(7 downto 0); -- Data Lane 1 High-Speed Transmit Data (optional)
  &lt;s_dl1_txreadyhs&gt; : in std_logic; -- Data Lane 1 High-Speed Transmit Ready (optional)
  &lt;s_dl1_forcetxstopmode&gt; : out std_logic; -- Force Data Lane 1 to Generate Stop state  (optional)
  &lt;s_dl1_txrequestesc&gt; : out std_logic; -- Data Lane 1 Escape Mode Transmit Request (optional)
  &lt;s_dl1_txulpsexit&gt; : out std_logic; -- Data Lane 1 Transmit ULP Exit Sequence (optional)
  &lt;s_dl1_ulpsactivenot&gt; : in std_logic; -- Data Lane 1 ULP State (not) Active (optional)
  &lt;s_dl1_txulpsesc&gt; : out std_logic; -- Data Lane 1 Escape Mode Transmit Ultra-Low Power State (optional)
  &lt;s_dl1_txlpdtesc&gt; : out std_logic; -- Data Lane 1 Escape Mode Transmit Low-Power Data (optional)
  &lt;s_dl1_txdataesc&gt; : out std_logic_vector(7 downto 0); -- Data Lane 1 Escape Mode Transmit Data (optional)
  &lt;s_dl1_txtriggeresc&gt; : out std_logic_vector(3 downto 0); -- Data Lane 1 Escape Mode Transmit Trigger 0-3 (optional)
  &lt;s_dl1_txvalidesc&gt; : out std_logic; -- Data Lane 1 Escape Mode Transmit Data Valid (optional)
  &lt;s_dl1_txreadyesc&gt; : in std_logic; -- Data Lane 1 Escape Mode Transmit Ready (optional)
  &lt;s_dl2_stopstate&gt; : in std_logic; -- Data Lane 2 is in Stop state (optional)
  &lt;s_dl2_enable&gt; : out std_logic; -- Enable Data Lane 2 Module (optional)
  &lt;s_dl2_txrequesths&gt; : out std_logic; -- Data Lane 2 High-Speed Transmit Request and Data Valid (optional)
  &lt;s_dl2_txdatahs&gt; : out std_logic_vector(7 downto 0); -- Data Lane 2 High-Speed Transmit Data (optional)
  &lt;s_dl2_txreadyhs&gt; : in std_logic; -- Data Lane 2 High-Speed Transmit Ready (optional)
  &lt;s_dl2_forcetxstopmode&gt; : out std_logic; -- Force Data Lane 2 to Generate Stop state  (optional)
  &lt;s_dl2_txrequestesc&gt; : out std_logic; -- Data Lane 2 Escape Mode Transmit Request (optional)
  &lt;s_dl2_txulpsexit&gt; : out std_logic; -- Data Lane 2 Transmit ULP Exit Sequence (optional)
  &lt;s_dl2_ulpsactivenot&gt; : in std_logic; -- Data Lane 2 ULP State (not) Active (optional)
  &lt;s_dl2_txulpsesc&gt; : out std_logic; -- Data Lane 2 Escape Mode Transmit Ultra-Low Power State (optional)
  &lt;s_dl2_txlpdtesc&gt; : out std_logic; -- Data Lane 2 Escape Mode Transmit Low-Power Data (optional)
  &lt;s_dl2_txdataesc&gt; : out std_logic_vector(7 downto 0); -- Data Lane 2 Escape Mode Transmit Data (optional)
  &lt;s_dl2_txtriggeresc&gt; : out std_logic_vector(3 downto 0); -- Data Lane 2 Escape Mode Transmit Trigger 0-3 (optional)
  &lt;s_dl2_txvalidesc&gt; : out std_logic; -- Data Lane 2 Escape Mode Transmit Data Valid (optional)
  &lt;s_dl2_txreadyesc&gt; : in std_logic; -- Data Lane 2 Escape Mode Transmit Ready (optional)
  &lt;s_dl3_stopstate&gt; : in std_logic; -- Data Lane 3 is in Stop state (optional)
  &lt;s_dl3_enable&gt; : out std_logic; -- Enable Data Lane 3 Module (optional)
  &lt;s_dl3_txrequesths&gt; : out std_logic; -- Data Lane 3 High-Speed Transmit Request and Data Valid (optional)
  &lt;s_dl3_txdatahs&gt; : out std_logic_vector(7 downto 0); -- Data Lane 3 High-Speed Transmit Data (optional)
  &lt;s_dl3_txreadyhs&gt; : in std_logic; -- Data Lane 3 High-Speed Transmit Ready (optional)
  &lt;s_dl3_forcetxstopmode&gt; : out std_logic; -- Force Data Lane 3 to Generate Stop state  (optional)
  &lt;s_dl3_txrequestesc&gt; : out std_logic; -- Data Lane 3 Escape Mode Transmit Request (optional)
  &lt;s_dl3_txulpsexit&gt; : out std_logic; -- Data Lane 3 Transmit ULP Exit Sequence (optional)
  &lt;s_dl3_ulpsactivenot&gt; : in std_logic; -- Data Lane 3 ULP State (not) Active (optional)
  &lt;s_dl3_txulpsesc&gt; : out std_logic; -- Data Lane 3 Escape Mode Transmit Ultra-Low Power State (optional)
  &lt;s_dl3_txlpdtesc&gt; : out std_logic; -- Data Lane 3 Escape Mode Transmit Low-Power Data (optional)
  &lt;s_dl3_txdataesc&gt; : out std_logic_vector(7 downto 0); -- Data Lane 3 Escape Mode Transmit Data (optional)
  &lt;s_dl3_txtriggeresc&gt; : out std_logic_vector(3 downto 0); -- Data Lane 3 Escape Mode Transmit Trigger 0-3 (optional)
  &lt;s_dl3_txvalidesc&gt; : out std_logic; -- Data Lane 3 Escape Mode Transmit Data Valid (optional)
  &lt;s_dl3_txreadyesc&gt; : in std_logic; -- Data Lane 3 Escape Mode Transmit Ready (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_txrequesths&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_TXREQUESTHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_stopstate&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_enable&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_txulpsclk&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_TXULPSCLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_txulpsexit&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_TXULPSEXIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_cl_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_stopstate&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_enable&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txrequesths&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXREQUESTHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txdatahs&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXDATAHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txreadyhs&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXREADYHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_forcetxstopmode&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_FORCETXSTOPMODE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txrequestesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXREQUESTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txulpsexit&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXULPSEXIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txulpsesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXULPSESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txlpdtesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXLPDTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txdataesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXDATAESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txtriggeresc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXTRIGGERESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txvalidesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXVALIDESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl0_txreadyesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXREADYESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_stopstate&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_enable&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txrequesths&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXREQUESTHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txdatahs&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXDATAHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txreadyhs&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXREADYHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_forcetxstopmode&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_FORCETXSTOPMODE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txrequestesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXREQUESTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txulpsexit&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXULPSEXIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txulpsesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXULPSESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txlpdtesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXLPDTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txdataesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXDATAESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txtriggeresc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXTRIGGERESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txvalidesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXVALIDESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl1_txreadyesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXREADYESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_stopstate&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_enable&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txrequesths&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXREQUESTHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txdatahs&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXDATAHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txreadyhs&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXREADYHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_forcetxstopmode&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_FORCETXSTOPMODE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txrequestesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXREQUESTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txulpsexit&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXULPSEXIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txulpsesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXULPSESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txlpdtesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXLPDTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txdataesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXDATAESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txtriggeresc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXTRIGGERESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txvalidesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXVALIDESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl2_txreadyesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXREADYESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_stopstate&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_STOPSTATE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_enable&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ENABLE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txrequesths&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXREQUESTHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txdatahs&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXDATAHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txreadyhs&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXREADYHS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_forcetxstopmode&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_FORCETXSTOPMODE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txrequestesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXREQUESTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txulpsexit&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXULPSEXIT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_ulpsactivenot&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ULPSACTIVENOT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txulpsesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXULPSESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txlpdtesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXLPDTESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txdataesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXDATAESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txtriggeresc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXTRIGGERESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txvalidesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXVALIDESC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dl3_txreadyesc&gt;: SIGNAL is "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXREADYESC";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Uart" treetype="template">
-- uart -  (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_rxd&gt; : in std_logic; -- Serial Input (required)
  &lt;m_txd&gt; : out std_logic; -- Serial Output (required)
  &lt;m_rtsn&gt; : out std_logic; -- Request to Send (optional)
  &lt;m_ctsn&gt; : in std_logic; -- Clear to Send (optional)
  &lt;m_dtrn&gt; : out std_logic; -- Data Terminal Ready (optional)
  &lt;m_dsrn&gt; : in std_logic; -- Data Set Ready (optional)
  &lt;m_baudoutn&gt; : out std_logic; -- Baud Out (optional)
  &lt;m_rclk&gt; : in std_logic; -- Receiver Clock (optional)
  &lt;m_xin&gt; : in std_logic; -- External Crystal Input (optional)
  &lt;m_xout&gt; : out std_logic; -- External Crystal Output (optional)
  &lt;m_dcdn&gt; : in std_logic; -- Data Carrier Detect (optional)
  &lt;m_ddis&gt; : out std_logic; -- Driver Disable (optional)
  &lt;m_out1n&gt; : out std_logic; -- User Controlled Output1 (optional)
  &lt;m_out2n&gt; : out std_logic; -- User Controlled Output2 (optional)
  &lt;m_txrdyn&gt; : out std_logic; -- Transmitter DMA Control Signal (optional)
  &lt;m_rxrdyn&gt; : out std_logic; -- Receiver DMA Control Signal (optional)
  &lt;m_ri&gt; : in std_logic; -- Ring Indicator (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rxd&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RxD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_txd&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; TxD";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rtsn&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RTSn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ctsn&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; CTSn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dtrn&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; DTRn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dsrn&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; DSRn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_baudoutn&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; BAUDOUTn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rclk&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RCLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_xin&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; XIN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_xout&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; XOUT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dcdn&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; DCDn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ddis&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; DDIS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_out1n&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; OUT1n";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_out2n&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; OUT2n";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_txrdyn&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; TXRDYn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_rxrdyn&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RXRDYn";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_ri&gt;: SIGNAL is "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RI";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Ulpi" treetype="template">
-- ulpi - UTMI Low Pin Interface definition, used to define interfaces in IP's like USB (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_clk&gt; : in std_logic; --  (required)
  &lt;s_rst&gt; : out std_logic; --  (required)
  &lt;s_dir&gt; : in std_logic; --  (required)
  &lt;s_next&gt; : in std_logic; --  (required)
  &lt;s_stop&gt; : out std_logic; --  (required)
  &lt;s_data_i&gt; : in std_logic_vector(7 downto 0); --  (required)
  &lt;s_data_o&gt; : out std_logic_vector(7 downto 0); --  (required)
  &lt;s_data_t&gt; : out std_logic; --  (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk&gt;: SIGNAL is "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rst&gt;: SIGNAL is "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; RST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_dir&gt;: SIGNAL is "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; DIR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_next&gt;: SIGNAL is "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; NEXT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_stop&gt;: SIGNAL is "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; STOP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_i&gt;: SIGNAL is "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; DATA_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_o&gt;: SIGNAL is "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; DATA_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data_t&gt;: SIGNAL is "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; DATA_T";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Vga" treetype="template">
-- vga - VGA interface definition, used in TFT controller (master directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;m_clk&gt; : out std_logic; -- VGA Clock signal (required)
  &lt;m_red&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Red pixel data (required)
  &lt;m_green&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Green data of the pixel (required)
  &lt;m_blue&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- BLUE data of the pixel (required)
  &lt;m_hsync&gt; : out std_logic; -- Horizantal sync signal (required)
  &lt;m_vsync&gt; : out std_logic; -- Vertical sync signal (required)
  &lt;m_dps&gt; : out std_logic; -- Display scan signal (optional)
  &lt;m_de&gt; : out std_logic; -- Display enable signal (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_clk&gt;: SIGNAL is "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; CLK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_red&gt;: SIGNAL is "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; RED";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_green&gt;: SIGNAL is "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; GREEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_blue&gt;: SIGNAL is "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; BLUE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_hsync&gt;: SIGNAL is "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; HSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_vsync&gt;: SIGNAL is "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; VSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_dps&gt;: SIGNAL is "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; DPS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;m_de&gt;: SIGNAL is "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; DE";

begin
--  user logic here

end arch_impl;
			</Template>
			<SubFolder label="vid" treetype="folder">
				<Template label="Vid_io" treetype="template">
-- vid_io - Video interface bus which includes data, syncs, and blanks. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_data&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Parallel video data (required)
  &lt;s_active_video&gt; : in std_logic; -- Active video Flag (optional)
  &lt;s_hblank&gt; : in std_logic; -- Horizontal blanking signal (optional)
  &lt;s_vblank&gt; : in std_logic; -- Vertical blanking signal (optional)
  &lt;s_hsync&gt; : in std_logic; -- Horizontal sync signal (optional)
  &lt;s_vsync&gt; : in std_logic; -- Veritcal sync signal (optional)
  &lt;s_field&gt; : in std_logic; -- Field ID (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data&gt;: SIGNAL is "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; DATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_active_video&gt;: SIGNAL is "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; ACTIVE_VIDEO";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hblank&gt;: SIGNAL is "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; HBLANK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vblank&gt;: SIGNAL is "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; VBLANK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hsync&gt;: SIGNAL is "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; HSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vsync&gt;: SIGNAL is "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; VSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_field&gt;: SIGNAL is "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; FIELD";

begin
--  user logic here

end arch_impl;
				</Template>
			</SubFolder>
			<Template label="Video synchronization and timing signals" treetype="template">
-- video_timing - Video synchronization and timing signals. (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_active_video&gt; : in std_logic; -- Active video flag (optional)
  &lt;s_hblank&gt; : in std_logic; -- Horizontal blanking signal (optional)
  &lt;s_vblank&gt; : in std_logic; -- Veritcal blanking signal (optional)
  &lt;s_hsync&gt; : in std_logic; -- Horizontal sync signal (optional)
  &lt;s_vsync&gt; : in std_logic; -- Vertical sync signal (optional)
  &lt;s_field&gt; : in std_logic; -- Field ID (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_active_video&gt;: SIGNAL is "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; ACTIVE_VIDEO";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hblank&gt;: SIGNAL is "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; HBLANK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vblank&gt;: SIGNAL is "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; VBLANK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_hsync&gt;: SIGNAL is "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; HSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_vsync&gt;: SIGNAL is "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; VSYNC";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_field&gt;: SIGNAL is "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; FIELD";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Zynq_trace" treetype="template">
-- zynq_trace - TPIU (Trace Port Interface Unit) uses this interface to output trace data (slave directions)
-- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_clk_i&gt; : out std_logic; -- Trace clock input (optional)
  &lt;s_clk_o&gt; : in std_logic; -- Trace clock output (optional)
  &lt;s_ctl&gt; : in std_logic; -- Trace control (required)
  &lt;s_data&gt; : in std_logic_vector(31 downto 0); -- Trace data (required)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk_i&gt;: SIGNAL is "xilinx.com:interface:zynq_trace:1.0 &lt;interface_name&gt; CLK_I";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_clk_o&gt;: SIGNAL is "xilinx.com:interface:zynq_trace:1.0 &lt;interface_name&gt; CLK_O";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ctl&gt;: SIGNAL is "xilinx.com:interface:zynq_trace:1.0 &lt;interface_name&gt; CTL";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_data&gt;: SIGNAL is "xilinx.com:interface:zynq_trace:1.0 &lt;interface_name&gt; DATA";

begin
--  user logic here

end arch_impl;
			</Template>
		</SubFolder>
		<SubFolder label="AXI Interfaces" treetype="folder">
			<Template label="Axi Memory Mapped" treetype="template">
-- Normally AXI is automatically inferred.  However, if the names of your ports do not match, you can force the
-- the creation of an interface and map the physical ports to the logical ports by using the X_INTERFACE_INFO
-- attribute before each physical port
-- Typical parameters the user might specify: PROTOCOL {AXI4, AXI4LITE, AXI3}, SUPPORTS_NARROW_BURST {0, 1}, NUM_READ_OUTSTANDING, NUM_WRITE_OUTSTANDING, MAX_BURST_LENGTH
-- The PROTOCOL can be typically be inferred from the set of signals.
-- aximm - AMBA AXI Interface (slave directions)
-- 
-- Allowed parameters:
--  CLK_DOMAIN                - Clk Domain                (string default: &lt;blank&gt;) 
--  PHASE                     - Phase                     (float) 
--  MAX_BURST_LENGTH          - Max Burst Length          (long default: 256) [1, 256]
--  NUM_WRITE_OUTSTANDING     - Num Write Outstanding     (long default: 1) [0, 32]
--  NUM_READ_OUTSTANDING      - Num Read Outstanding      (long default: 1) [0, 32]
--  SUPPORTS_NARROW_BURST     - Supports Narrow Burst     (long default: 1) [0, 1]
--  READ_WRITE_MODE           - Read Write Mode           (string default: READ_WRITE) {READ_WRITE,READ_ONLY,WRITE_ONLY}
--  BUSER_WIDTH               - Buser Width               (long) 
--  RUSER_WIDTH               - Ruser Width               (long) 
--  WUSER_WIDTH               - Wuser Width               (long) 
--  ARUSER_WIDTH              - Aruser Width              (long) 
--  AWUSER_WIDTH              - Awuser Width              (long) 
--  ADDR_WIDTH                - Addr Width                (long default: 32) [1, 64]
--  ID_WIDTH                  - Id Width                  (long) 
--  FREQ_HZ                   - Frequency                 (float default: 100000000) 
--  PROTOCOL                  - Protocol                  (string default: AXI4) {AXI4,AXI4LITE,AXI3}
--  DATA_WIDTH                - Data Width                (long default: 32) {32,64,128,256,512,1024}
--  HAS_BURST                 - Has BURST                 (long default: 1) {0,1}
--  HAS_CACHE                 - Has CACHE                 (long default: 1) {0,1}
--  HAS_LOCK                  - Has LOCK                  (long default: 1) {0,1}
--  HAS_PROT                  - Has PROT                  (long default: 1) {0,1}
--  HAS_QOS                   - Has QOS                   (long default: 1) {0,1}
--  HAS_REGION                - Has REGION                (long default: 1) {0,1}
--  HAS_WSTRB                 - Has WSTRB                 (long default: 1) {0,1}
--  HAS_BRESP                 - Has BRESP                 (long default: 1) {0,1}
--  HAS_RRESP                 - Has RRESP                 (long default: 1) {0,1}

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_awid&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write address ID (optional)
  &lt;s_awaddr&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write address (optional)
  &lt;s_awlen&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Burst length (optional)
  &lt;s_awsize&gt; : in std_logic_vector(2 downto 0); -- Burst size (optional)
  &lt;s_awburst&gt; : in std_logic_vector(1 downto 0); -- Burst type (optional)
  &lt;s_awlock&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Lock type (optional)
  &lt;s_awcache&gt; : in std_logic_vector(3 downto 0); -- Cache type (optional)
  &lt;s_awprot&gt; : in std_logic_vector(2 downto 0); -- Protection type (optional)
  &lt;s_awregion&gt; : in std_logic_vector(3 downto 0); -- Write address slave region (optional)
  &lt;s_awqos&gt; : in std_logic_vector(3 downto 0); -- Transaction Quality of Service token (optional)
  &lt;s_awuser&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write address user sideband (optional)
  &lt;s_awvalid&gt; : in std_logic; -- Write address valid (optional)
  &lt;s_awready&gt; : out std_logic; -- Write address ready (optional)
  &lt;s_wid&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write ID tag (optional)
  &lt;s_wdata&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write data (optional)
  &lt;s_wstrb&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write strobes (optional)
  &lt;s_wlast&gt; : in std_logic; -- Write last beat (optional)
  &lt;s_wuser&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Write data user sideband (optional)
  &lt;s_wvalid&gt; : in std_logic; -- Write valid (optional)
  &lt;s_wready&gt; : out std_logic; -- Write ready (optional)
  &lt;s_bid&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Response ID (optional)
  &lt;s_bresp&gt; : out std_logic_vector(1 downto 0); -- Write response (optional)
  &lt;s_buser&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Write response user sideband (optional)
  &lt;s_bvalid&gt; : out std_logic; -- Write response valid (optional)
  &lt;s_bready&gt; : in std_logic; -- Write response ready (optional)
  &lt;s_arid&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Read address ID (optional)
  &lt;s_araddr&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Read address (optional)
  &lt;s_arlen&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Burst length (optional)
  &lt;s_arsize&gt; : in std_logic_vector(2 downto 0); -- Burst size (optional)
  &lt;s_arburst&gt; : in std_logic_vector(1 downto 0); -- Burst type (optional)
  &lt;s_arlock&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Lock type (optional)
  &lt;s_arcache&gt; : in std_logic_vector(3 downto 0); -- Cache type (optional)
  &lt;s_arprot&gt; : in std_logic_vector(2 downto 0); -- Protection type (optional)
  &lt;s_arregion&gt; : in std_logic_vector(3 downto 0); -- Read address slave region (optional)
  &lt;s_arqos&gt; : in std_logic_vector(3 downto 0); -- Quality of service token (optional)
  &lt;s_aruser&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Read address user sideband (optional)
  &lt;s_arvalid&gt; : in std_logic; -- Read address valid (optional)
  &lt;s_arready&gt; : out std_logic; -- Read address ready (optional)
  &lt;s_rid&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Read ID tag (optional)
  &lt;s_rdata&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Read data (optional)
  &lt;s_rresp&gt; : out std_logic_vector(1 downto 0); -- Read response (optional)
  &lt;s_rlast&gt; : out std_logic; -- Read last beat (optional)
  &lt;s_ruser&gt; : out std_logic_vector(&lt;left_bound&gt; downto 0); -- Read user sideband (optional)
  &lt;s_rvalid&gt; : out std_logic; -- Read valid (optional)
  &lt;s_rready&gt; : in std_logic; -- Read ready (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awaddr&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awlen&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWLEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awsize&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWSIZE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awburst&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWBURST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awlock&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWLOCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awcache&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWCACHE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awprot&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWPROT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awregion&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWREGION";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awqos&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWQOS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awuser&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awvalid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_awready&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wdata&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wstrb&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WSTRB";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wlast&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WLAST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wuser&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wvalid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_wready&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bresp&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BRESP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_buser&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bvalid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_bready&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_araddr&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARADDR";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arlen&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARLEN";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arsize&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARSIZE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arburst&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARBURST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arlock&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARLOCK";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arcache&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARCACHE";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arprot&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARPROT";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arregion&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARREGION";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arqos&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARQOS";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_aruser&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arvalid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_arready&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARREADY";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rdata&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rresp&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RRESP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rlast&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RLAST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_ruser&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rvalid&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_rready&gt;: SIGNAL is "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RREADY";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "CLK_DOMAIN &lt;value&gt;,PHASE &lt;value&gt;,MAX_BURST_LENGTH &lt;value&gt;,NUM_WRITE_OUTSTANDING &lt;value&gt;,NUM_READ_OUTSTANDING &lt;value&gt;,SUPPORTS_NARROW_BURST &lt;value&gt;,READ_WRITE_MODE &lt;value&gt;,BUSER_WIDTH &lt;value&gt;,RUSER_WIDTH &lt;value&gt;,WUSER_WIDTH &lt;value&gt;,ARUSER_WIDTH &lt;value&gt;,AWUSER_WIDTH &lt;value&gt;,ADDR_WIDTH &lt;value&gt;,ID_WIDTH &lt;value&gt;,FREQ_HZ &lt;value&gt;,PROTOCOL &lt;value&gt;,DATA_WIDTH &lt;value&gt;,HAS_BURST &lt;value&gt;,HAS_CACHE &lt;value&gt;,HAS_LOCK &lt;value&gt;,HAS_PROT &lt;value&gt;,HAS_QOS &lt;value&gt;,HAS_REGION &lt;value&gt;,HAS_WSTRB &lt;value&gt;,HAS_BRESP &lt;value&gt;,HAS_RRESP &lt;value&gt;";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="Axi Stream" treetype="template">
-- Normally AXI is automatically inferred.  However, if the names of your ports do not match, you can force the
-- the creation of an interface and map the physical ports to the logical ports by using the X_INTERFACE_INFO
-- attribute before each physical port
-- Parameters are typically computed by the Block Diagram and annotated onto the cell (no need to specify these)
-- axis - AMBA AXI4-Stream Interface (slave directions)
-- 
-- Allowed parameters:
--  CLK_DOMAIN                - Clk Domain                (string default: &lt;blank&gt;) 
--  PHASE                     - Phase                     (float) 
--  FREQ_HZ                   - Frequency                 (float default: 100000000) 
--  LAYERED_METADATA          - Layered Metadata          (string default: &lt;blank&gt;) 
--  HAS_TLAST                 - Has Tlast                 (long) {false - 0, true - 1}
--  HAS_TKEEP                 - Has Tkeep                 (long) {false - 0, true - 1}
--  HAS_TSTRB                 - Has Tstrb                 (long) {false - 0, true - 1}
--  HAS_TREADY                - Has Tready                (long) {false - 0, true - 1}
--  TUSER_WIDTH               - Tuser Width               (long) 
--  TID_WIDTH                 - Tid Width                 (long) 
--  TDEST_WIDTH               - Tdest Width               (long) 
--  TDATA_NUM_BYTES           - Tdata Num Bytes           (long) 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_module is
  port (

  &lt;s_tid&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Transfer ID tag (optional)
  &lt;s_tdest&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Transfer Destination (optional)
  &lt;s_tdata&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Transfer Data (optional)
  &lt;s_tstrb&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Transfer Data Byte Strobes (optional)
  &lt;s_tkeep&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Transfer Null Byte Indicators (optional)
  &lt;s_tlast&gt; : in std_logic; -- Packet Boundary Indicator (optional)
  &lt;s_tuser&gt; : in std_logic_vector(&lt;left_bound&gt; downto 0); -- Transfer user sideband (optional)
  &lt;s_tvalid&gt; : in std_logic; -- Transfer valid (required)
  &lt;s_tready&gt; : out std_logic; -- Transfer ready (optional)
  --  additional ports here

  );
end my_module;
architecture arch_impl of my_module is

  ATTRIBUTE X_INTERFACE_INFO : STRING;
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tid&gt;: SIGNAL is "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tdest&gt;: SIGNAL is "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TDEST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tdata&gt;: SIGNAL is "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TDATA";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tstrb&gt;: SIGNAL is "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TSTRB";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tkeep&gt;: SIGNAL is "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TKEEP";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tlast&gt;: SIGNAL is "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TLAST";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tuser&gt;: SIGNAL is "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TUSER";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tvalid&gt;: SIGNAL is "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TVALID";
  ATTRIBUTE X_INTERFACE_INFO of &lt;s_tready&gt;: SIGNAL is "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TREADY";
  -- Uncomment the following to set interface specific parameter on the bus interface.
  --  ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
  --  ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "CLK_DOMAIN &lt;value&gt;,PHASE &lt;value&gt;,FREQ_HZ &lt;value&gt;,LAYERED_METADATA &lt;value&gt;,HAS_TLAST &lt;value&gt;,HAS_TKEEP &lt;value&gt;,HAS_TSTRB &lt;value&gt;,HAS_TREADY &lt;value&gt;,TUSER_WIDTH &lt;value&gt;,TID_WIDTH &lt;value&gt;,TDEST_WIDTH &lt;value&gt;,TDATA_NUM_BYTES &lt;value&gt;";

begin
--  user logic here

end arch_impl;
			</Template>
			<Template label="_Info" treetype="template">
-- 
-- VHDL Attributes are used to declare interfaces and set parameters on them.
-- Due to the language, the attributes need to be placed into the architecture declaration section.
-- The attributes need to be declared and then attached to a declared port.
-- When mapping logical names from the interface to a port in your hdl, there will be a seperate
-- attribute attached for each port.
-- When adding one or more parameters for an interface, a single attribute with multiple
-- key value pairs should be added to one of the ports that was mapped into the interface.
-- Generally, the form of the attributes are:
--   ATTRIBUTE X_INTERFACE_INFO : STRING;
--   ATTRIBUTE X_INTERFACE_INFO of &lt;port_name&gt;: SIGNAL is "&lt;interface vlnv&gt; &lt;interface_name&gt; &lt;logical_port_name&gt;";
--   ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
--   ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "&lt;parameter_name1&gt; &lt;parameter_value1&gt;, &lt;parameter_name2&gt; &lt;parameter_value2&gt;"; 
			</Template>
		</SubFolder>
		<SubFolder label="Signal Interfaces" treetype="folder">
			<Template label="clock" treetype="template">
-- Declare the attributes in the architecture section
ATTRIBUTE X_INTERFACE_INFO : STRING;
ATTRIBUTE X_INTERFACE_INFO of &lt;clock_port_name&gt;: SIGNAL is "xilinx.com:signal:clock:1.0 &lt;clock_port_name&gt; CLK";
-- Supported parameters: ASSOCIATED_CLKEN, ASSOCIATED_RESET, ASSOCIATED_ASYNC_RESET, ASSOCIATED_BUSIF, CLK_DOMAIN, PHASE, FREQ_HZ
-- Most of these parameters are optional.  However, when using AXI, at least one clock must be associated to the AXI interface.
-- Use the axi interface name for ASSOCIATED_BUSIF, if there are multiple interfaces, separate each name by ':'
-- Use the port name for ASSOCIATED_RESET.
-- Output clocks will require FREQ_HZ to be set (note the value is in HZ and an integer is expected).
ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
ATTRIBUTE X_INTERFACE_PARAMETER of &lt;clock_port_name&gt;: SIGNAL is "ASSOCIATED_BUSIF &lt;AXI_interface_name&gt;, ASSOCIATED_RESET &lt;reset_port_name&gt;, FREQ_HZ 100000000";
			</Template>
			<Template label="clockenable" treetype="template">
-- Declare the attributes in the architecture section
ATTRIBUTE X_INTERFACE_INFO : STRING;
ATTRIBUTE X_INTERFACE_INFO of &lt;clockenable_port_name&gt;: SIGNAL is "xilinx.com:signal:clockenable:1.0 &lt;clockenable_port_name&gt; CE";
-- Supported parameter: POLARITY {ACTIVE_LOW, ACTIVE_HIGH}
-- Normally active low is assumed.  Use this parameter to force the level
ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
ATTRIBUTE X_INTERFACE_PARAMETER of &lt;clockenable_port_name&gt;: SIGNAL is "POLARITY ACTIVE_HIGH";
			</Template>
			<Template label="_Info" treetype="template">
-- 
-- VHDL Attributes are used to declare signal interfaces and set parameters on them.
-- Due to the language, the attributes need to be placed into the architecture declaration section.
-- The attributes need to be declared and then attached to a declared port.
-- When mapping logical names from the interface to a port in your hdl, there will be a seperate
-- attribute attached for each port.
-- When adding one or more parameters for an interface, a single attribute with multiple
-- key value pairs should be added to one of the ports that was mapped into the interface.
-- Generally, the form of the attributes are:
--   ATTRIBUTE X_INTERFACE_INFO : STRING;
--   ATTRIBUTE X_INTERFACE_INFO of &lt;port_name&gt;: SIGNAL is "&lt;interface vlnv&gt; &lt;interface_name&gt; &lt;logical_port_name&gt;";
--   ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
--   ATTRIBUTE X_INTERFACE_PARAMETER of &lt;port_name&gt;: SIGNAL is "&lt;parameter_name1&gt; &lt;parameter_value1&gt;, &lt;parameter_name2&gt; &lt;parameter_value2&gt;"; 
			</Template>
			<Template label="interrupt" treetype="template">
-- Declare the attributes in the architecture section
ATTRIBUTE X_INTERFACE_INFO : STRING;
ATTRIBUTE X_INTERFACE_INFO of &lt;interrupt_port_name&gt;: SIGNAL is "xilinx.com:signal:interrupt:1.0 &lt;interrput_port_name&gt; INTR";
-- Supported parameter: SENSITIVITY { LEVEL_HIGH, LEVEL_LOW, EDGE_RISING, EDGE_FALLING }
-- Normally LEVEL_HIGH is assumed.  Use this parameter to force the level
ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
ATTRIBUTE X_INTERFACE_PARAMETER of &lt;interrupt_port_name&gt;: SIGNAL is "SENSITIVITY EDGE_RISING";
			</Template>
			<Template label="reset" treetype="template">
-- Declare the attributes in the architecture section
ATTRIBUTE X_INTERFACE_INFO : STRING;
ATTRIBUTE X_INTERFACE_INFO of &lt;reset_port_name&gt;: SIGNAL is "xilinx.com:signal:reset:1.0 &lt;reset_port_name&gt; RST";
-- Supported parameter: POLARITY {ACTIVE_LOW, ACTIVE_HIGH}
-- Normally active low is assumed.  Use this parameter to force the level
ATTRIBUTE X_INTERFACE_PARAMETER : STRING;
ATTRIBUTE X_INTERFACE_PARAMETER of &lt;reset_port_name&gt;: SIGNAL is "POLARITY ACTIVE_HIGH";
			</Template>
		</SubFolder>
	</Folder>
	<Folder label="Simulation Constructs" treetype="folder">
		<SubFolder label="Assertions &amp; Functions" treetype="folder">
				<Template label="Info" treetype="template">
-- Assetions in VHDL
-- -----------------
-- The VHDL assert statment provides a quick and easy way to check expected values and
-- display messages from your test bench. When analyzed the condition expression is 
-- evaluated. If using an if conditional statement, the expression of an assert must
-- evaluate to a boolean true or false value. If the condition is evalauted to a false
-- (indicating the assertion failed) the text that is specified in the report statement
-- is displayed in the transcript window. The severity then indicates to the software
-- tool what action if any should be taken based on the failure.
--
-- The severity level can be any of the following:
-- NOTE
-- WARNING
-- ERROR
-- FAILURE
-- The actions that result from the use of these severity levels will depend on the 
-- software tool that is being used.
--
-- Example Assertion statment:
assert SRL_WIDTH &lt;= 17
report "The size of Shift Register exceeds the size of a single SRL" 
severity FAILURE;
				</Template>
			<SubFolder label="File I/O" treetype="folder">
				<Template label="Info" treetype="template">
-- The File I/O functions in VHDL
-- ==============================
-- The std.textio.all library will need to be used for these functions.
 
-- The Text I/O features of VHDL make it possible to open one or more data files, 
-- read lines from those files, and parse the lines to form individual data elements. 
-- These elements can then be stored in an array or record. To support the use of files, 
-- VHDL has the concept of a file data type, that includes standard 
-- built-in functions for opening, reading from, and writing to file data types. 
-- The textio package, which is a part of the standard IEEE library, 
-- expands on the built-in file type features by adding text parsing and formatting functions. 
-- 
-- Opening Command
-- ---------------
-- The function file_open() is used to open a file for reading, writing and/or appending.
-- When using the file_open, you must specify the file name and the file mode. The syntax 
-- looks like the following : file_open([&lt;file_status&gt;, &lt;file_handle&gt;, &lt;file_name&gt;, &lt;file_mode&gt;);
-- Status of the file_open can also be used to monitor if the file open did complete 
-- successfully. This information will be stored in the file_status type which is of type 
-- file_open_status. Upon opening the file a handle is issues for the file and must be used
-- to reference the file in subsequent commands.
--
-- The file mode can be one of the following:
-- READ_MODE
-- WRITE_MODE
-- APPEND_MODE
--
-- The file status can be one of the following:
-- OPEN_OK
-- STATUS_ERROR
-- NAME_ERROR
-- MODE_ERROR
--
-- Writing Command
-- ----------------
-- The function write() can be used to write a specified object to a
-- file. The syntax looks like the following: write(&lt;file_handle&gt;, &lt;object&gt;);
-- This will write the data contained in the object to the file that is pointed
-- to by the file handle. 
--
-- Reading Command
-- ----------------
-- The function read() can be used to read a specified object to a
-- file. The syntax looks like the following: read(&lt;file_handle&gt;, &lt;object&gt;);
-- Data is read from the file pointed to by the file handle and the file
-- is advanced to the beginning of the next data field in the file.
--
-- End of File Command
-- --------------------
-- The fucntion endfile() can be used to verify that the end of the file has been
-- reached. The syntax for this function is : endfile(&lt;file_handle&gt;); The function
-- will return a boolean true value if the current file marker is at the end of 
-- the file.
--
-- Closing File Command
-- --------------------
-- It is highly recommended to close a file once operations on the file have been
-- completed. The function file_close() can be used to close a file. The syntax for
-- this function is : file_close(&lt;file_handle&gt;);
--
-- The following example demonstrates how you can use the text I/O features 
-- of VHDL to read test data from a file using a process:
--
   read_input: process  
        type char_file is file of character;
        file c_file_handle: char_file;
        variable C: character;
        variable char_count: integer := 0;
   begin
        file_open(c_file_handle, "test_file.txt", READ_MODE);
        while not endfile(c_file_handle) loop
            read (c_file_handle, C) ;    
            char_count = char_count + 1;  -- Keep track of the number of
        -- characters
        end loop;
        file_close(c_file_handle);
   end process;

-- The following example demonstrates how you can use the text I/O features 
-- of VHDL to write test data from a file using a process:
--
   write_input: process  
        type char_file is file of character;
        file c_file_handle: char_file;
        variable C: character := "W";
        variable char_count: integer := 0;
   begin
        file_open(c_file_handle, "test_file.txt", WRITE_MODE);
        while not endfile(c_file_handle) loop
            write (c_file_handle, C) ;    
            char_count = char_count + 1;  -- Keep track of the number of
        -- characters
        end loop;
        file_close(c_file_handle);
   end process;
				</Template>
				<SubFolder label="Read/Write to a File" treetype="folder">
					<SubFolder label="Functions" treetype="folder">
						<Template label="Close a File" treetype="template">
file_close(&lt;file_handle&gt;);
						</Template>
						<Template label="End of File" treetype="template">
endfile(&lt;file_handle&gt;);
						</Template>
						<Template label="Open a File" treetype="template">
file_open([&lt;file_status&gt;, &lt;file_handle&gt;, &lt;file_name&gt;, &lt;file_mode&gt;);
						</Template>
						<SubFolder label="Read a File" treetype="folder">
							<Template label="Charachter" treetype="template">
read(&lt;file_handle&gt;, &lt;object&gt;);
							</Template>
							<Template label="Line" treetype="template">
readline(&lt;file_handle&gt;, &lt;line_variable&gt;);
							</Template>
						</SubFolder>
						<SubFolder label="Write To File" treetype="folder">
							<Template label="Charachter" treetype="template">
write(&lt;file_handle&gt;, &lt;object&gt;);
							</Template>
							<Template label="Line" treetype="template">
writeline(&lt;file_handle&gt;, &lt;line_variable&gt;);
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
			</SubFolder>
			<Template label="Random Number Generation" treetype="template">
shared variable &lt;seed1&gt;:integer:=844396720;  -- uniform procedure seed1
shared variable &lt;seed2&gt;:integer:=821616997;  -- uniform procedure seed2

impure function &lt;random_value_gen&gt;(constant &lt;lower_value&gt; : in integer;
                                   constant &lt;upper_value&gt; : in integer) return integer is
   variable &lt;result&gt; : integer;
   variable &lt;tmp_real&gt; : real;  -- return value from uniform procedure
begin
   uniform(&lt;seed1&gt;,&lt;seed2&gt;,&lt;tmp_real&gt;);
   &lt;result&gt;:=integer(trunc((&lt;tmp_real&gt; * real(&lt;upper_value&gt; - &lt;lower_value&gt;)) + real(&lt;lower_value&gt;)));
   return &lt;result&gt;;
end &lt;random_value_gen&gt;;
			</Template>
		</SubFolder>
		<SubFolder label="Clock Stimulus" treetype="folder">
			<SubFolder label="50% Duty Cycle" treetype="folder">
				<Template label="Using After (concurrent)" treetype="template">
-- Please ensure that the constant PERIOD is defined prior to the 
-- begin statement in the architecture. Refer to the PERIOD Constant Template 
-- for more info.

CLK &lt;= not CLK after PERIOD/2;
				</Template>
				<Template label="Using Wait For (sequential)" treetype="template">
-- Please ensure that the constant PERIOD is defined prior to the 
-- begin statement in the architecture. Refer to the PERIOD Constant Template 
-- for more info.

CLK &lt;= '0';
wait for PERIOD/2;
CLK &lt;= '1';
wait for PERIOD/2;
				</Template>
			</SubFolder>
			<SubFolder label="Constants" treetype="folder">
				<Template label="DUTY_CYCLE" treetype="template">
constant DUTY_CYCLE : real := &lt;value_0.01_to_0.99&gt;;
				</Template>
				<Template label="PERIOD" treetype="template">
constant PERIOD : time := &lt;value&gt;;
				</Template>
				<Template label="SIM_TIME" treetype="template">
constant SIM_TIME : time := 10 ms;
				</Template>
			</SubFolder>
			<SubFolder label="Differential, Non-50% Duty Cycle" treetype="folder">
				<Template label="Using After (concurrent)" treetype="template">
-- Please ensure that the constants PERIOD and DUTY_CYCLE are defined prior to the 
-- begin statement in the architecture. Refer to the PERIOD Constant Template 
-- and DUTY_CYCLE Constant Template for more info.

-- The CLK_P should be initialized to 0 and the CLK_N should be initialized to 1
CLK_P &lt;= '1' after (PERIOD - (PERIOD * DUTY_CYCLE)) when CLK_P = '0'
  else '0' after (PERIOD * DUTY_CYCLE);
CLK_N &lt;= '0' after (PERIOD - (PERIOD * DUTY_CYCLE)) when CLK_N = '1'
  else '1' after (PERIOD * DUTY_CYCLE);
				</Template>
				<Template label="Using Wait For (sequential)" treetype="template">
-- Please ensure that the constants PERIOD and DUTY_CYCLE are defined prior to the 
-- begin statement in the architecture. Refer to the PERIOD Constant Template 
-- and DUTY_CYCLE Constant Template for more info.

CLK_N &lt;= '0';
CLK_P &lt;= '1';
wait for (PERIOD - (PERIOD * DUTY_CYCLE));
CLK_N &lt;= '1';
CLK_P &lt;= '0';
wait for (PERIOD * DUTY_CYCLE);
				</Template>
			</SubFolder>
			<SubFolder label="Differential, 50% Duty Cycle" treetype="folder">
				<Template label="Using After (concurrent)" treetype="template">
-- Please ensure that the constant PERIOD is defined prior to the 
-- begin statement in the architecture. Refer to the PERIOD Constant Template 
-- for more info.

-- The CLK_P should be initialized to 0 and the CLK_N should be initialized to 1
CLK_P &lt;= not CLK_P after PERIOD/2;
CLK_N &lt;= not CLK_N after PERIOD/2;
				</Template>
				<Template label="Using Wait For (sequential)" treetype="template">
-- Please ensure that the constant PERIOD is defined prior to the 
-- begin statement in the architecture. Refer to the PERIOD Constant Template 
-- for more info.

CLK_P &lt;= '0';
CLK_N &lt;= '1';
wait for PERIOD/2;
CLK_P &lt;= '1';
CLK_N &lt;= '0';
wait for PERIOD/2;
				</Template>
			</SubFolder>
			<SubFolder label="Non-50% Duty Cycle" treetype="folder">
				<Template label="Using After (concurrent)" treetype="template">
-- Please ensure that the constants PERIOD and DUTY_CYCLE are defined prior to the 
-- begin statement in the architecture. Refer to the PERIOD Constant Template 
-- and DUTY_CYCLE Constant Template for more info.

CLK &lt;= '1' after (PERIOD - (PERIOD * DUTY_CYCLE)) when CLK = '0'
  else '0' after (PERIOD * DUTY_CYCLE);
				</Template>
				<Template label="Using Wait For (sequential)" treetype="template">
-- Please ensure that the constants PERIOD and DUTY_CYCLE are defined prior to the 
-- begin statement in the architecture. Refer to the PERIOD Constant Template 
-- and DUTY_CYCLE Constant Template for more info.

CLK &lt;= '0';
wait for (PERIOD - (PERIOD * DUTY_CYCLE));
CLK &lt;= '1';
wait for (PERIOD * DUTY_CYCLE);
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Configuration" treetype="folder">
			<SubFolder label="Component" treetype="folder">
				<SubFolder label="All" treetype="folder">
					<Template label="Configuration" treetype="template">
for all : &lt;component_name&gt;
use configuration &lt;configuration_name&gt;
   [generic map (&lt;generic_association_list&gt;)]
   [port map (&lt;port_association_list&gt;)];]
end for;
					</Template>
					<Template label="Entity" treetype="template">
for all : &lt;component_name&gt;
use entity &lt;entity_name&gt; [(&lt;architecture_identifier&gt;)]
   [generic map (&lt;generic_association_list&gt;)]
   [port map (&lt;port_association_list&gt;)];]
end for;
					</Template>
					<Template label="Open" treetype="template">
for all : &lt;component_name&gt;
use open
   [generic map (&lt;generic_association_list&gt;)]
   [port map (&lt;port_association_list&gt;)];]
end for;
					</Template>
				</SubFolder>
				<SubFolder label="Others" treetype="folder">
					<Template label="Configuration" treetype="template">
for others : &lt;component_name&gt;
use configuration &lt;configuration_name&gt;
   [generic map (&lt;generic_association_list&gt;)]
   [port map (&lt;port_association_list&gt;)];]
end for;
					</Template>
					<Template label="Entity" treetype="template">
for others : &lt;component_name&gt;
use entity &lt;entity_name&gt; [(&lt;architecture_identifier&gt;)]
   [generic map (&lt;generic_association_list&gt;)]
   [port map (&lt;port_association_list&gt;)];]
end for;
					</Template>
					<Template label="Open" treetype="template">
for others : &lt;component_name&gt;
use open
   [generic map (&lt;generic_association_list&gt;)]
   [port map (&lt;port_association_list&gt;)];]
end for;
					</Template>
				</SubFolder>
				<SubFolder label="Simple" treetype="folder">
					<Template label="Configuration" treetype="template">
for &lt;instantiation_name&gt;, &lt;instantiation_name&gt; : &lt;component_name&gt;
use configuration &lt;configuration_name&gt;
   [generic map (&lt;generic_association_list&gt;)]
   [port map (&lt;port_association_list&gt;)];]
end for;
					</Template>
					<Template label="Entity" treetype="template">
for &lt;instantiation_name&gt;, &lt;instantiation_name&gt; : &lt;component_name&gt;
use entity &lt;entity_name&gt; [(&lt;architecture_identifier&gt;)]
   [generic map (&lt;generic_association_list&gt;)]
   [port map (&lt;port_association_list&gt;)];]
end for;
					</Template>
					<Template label="Open" treetype="template">
for &lt;instantiation_name&gt;, &lt;instantiation_name&gt; : &lt;component_name&gt;
use open
   [generic map (&lt;generic_association_list&gt;)]
   [port map (&lt;port_association_list&gt;)];]
end for;
					</Template>
				</SubFolder>
			</SubFolder>
			<Template label="Declaration" treetype="template">
configuration &lt;configuration_identifier&gt; of &lt;entity_name&gt; is
   for &lt;architecture_name&gt;
   &lt;component_configuration&gt;
end &lt;configuration_identifier&gt;;
			</Template>
			<Template label="Info" treetype="template">
-- The VHDL Configuration Statement
-- ================================
-- Configuration statements are probably one of the hardest concepts in VHDL. 
-- It is one concept that confuses a lot of people. 
-- Configuration statements are extremely powerful and should only be used when their true 
-- nature is understood. Configuration statements are used when the default binding of a component needs to 
-- be modified. Majority of the time bindings should be done by default. There are exceptional conditions where
-- it makes sense to change the default bindings. This is where configuration statements can be used. 
-- Configuration statements can also be used if there are multiple architectures that could be bound to an 
-- entity. In general there are two main types of Configuration Statments:
-- 1. Block Configuration
-- 2. Component Configuration
-- Block configurations are not as common as the Component configuration, this is why the Block configuration 
-- not covered here. 
-- The component declaration identifies the component instances to which this component
-- configuration applies. A component configuration that appears immediately within a given block
-- configuration applies to component instances that appear immediately within the corresponding block.
-- Two component configurations cannot apply to the same component instance.
-- It is also an error if a component configuration contains an explicit block configuration and the component
-- configuration does not bind all identified component instances to the same design entity.
-- Configuration statements are not limited by the heirarchy. It is possible to change information on components
-- that is buried deep in the hierarchy.
-- In order to understand configuration clearly, it will need to be shown with examples
--
-- Example of using a Configuration Statement to over write the default information for a generics in a Unisim
-- BlockRAM:
configuration my_config of testbench is 
   for behavioral
      for uut : top
         for behavioral
            for ram1, ram2, ram3 : RAMB16_S1_S1 use entity unisim.RAMB16_S1_S1
               generic map (SETUP_ALL =&gt; 0 ns);
            end for;
         end for;
      end for;
   end for;
end my_config;
--
-- General template that can be used for most Xilinx BlockRAM Components:
configuration &lt;config_name&gt; of &lt;entity name in testbench&gt; is 
   for &lt;architecture name in testbench&gt;
      for &lt;instance name given to top level in the testbench&gt; : &lt;entity name of top level&gt;
         for &lt;architecture name of top level&gt;
            for &lt;instance name for next level of hierarchy&gt; : &lt;entity name in next level of hierarchy&gt;
               for &lt;architecture name in next level of hierarchy&gt;
                  :
                     for &lt;BRAM instance name&gt;, &lt;BRAM instance name&gt;, ... : &lt;BRAM model name&gt; use entity unisim.&lt;BRAM model name&gt;
                        generic map (SETUP_ALL =&gt; 0 ns);
                     end for;
                  :
               end for;
            end for;
      end for;
   end for;
end &lt;config name&gt;;
			</Template>
		</SubFolder>
		<SubFolder label="Delays" treetype="folder">
			<Template label="Finite Delay" treetype="template">
-- Please ensure that the constant SIM_TIME is defined prior to the 
-- begin statement in the architecture. Refer to the SIM_TIME Constant Template 
-- for more info.

&lt;signal_name&gt; &lt;= &lt;signal_value&gt; after SIM_TIME;
			</Template>
			<Template label="Wait for Any Signal Transition" treetype="template">
wait on &lt;signal_name&gt;;
			</Template>
			<Template label="Wait for Negative Signal Transition" treetype="template">
wait until falling_edge(&lt;signal_name&gt;);
			</Template>
			<Template label="Wait for Positive Signal Transition" treetype="template">
wait until rising_edge(&lt;signal_name&gt;);
			</Template>
			<Template label="Wait for Signal Condition" treetype="template">
wait until &lt;signal_name&gt; = &lt;value&gt;;
			</Template>
		</SubFolder>
		<SubFolder label="Loops" treetype="folder">
			<Template label="Forever Loop" treetype="template">
-- Please ensure that the constant PERIOD is defined prior to the 
-- begin statement in the architecture. Refer to the PERIOD Constant Template 
-- for more info.

loop
   CLK &lt;= not CLK;
   wait for PERIOD/2;
   if &lt;signal_name = &lt;value&gt; then
      exit;
   end if;
end loop;
			</Template>
			<Template label="For Loop" treetype="template">
for &lt;variable_name&gt; in &lt;lower_limit&gt; to &lt;upper_limit&gt; loop
   &lt;statement&gt;;
   &lt;statement&gt;;
end loop;
			</Template>
			<Template label="While Loop" treetype="template">
while &lt;condition&gt; loop
   &lt;statement&gt;;
   &lt;statement&gt;;
end loop;
			</Template>
		</SubFolder>
		<SubFolder label="Process" treetype="folder">
			<Template label="Combinatorial" treetype="template">
process (&lt;all_input_signals_seperated_by_commas&gt;)
begin
   &lt;statements&gt;;
end process;
			</Template>
			<SubFolder label="Negedge Clocked" treetype="folder">
				<Template label="/w Async &amp; Sync High Reset" treetype="template">
process (&lt;clock&gt;,&lt;async_reset&gt;)
begin  
   if &lt;async_reset&gt; = '1' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '0') then
      if &lt;sync_reset&gt; = '1' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Async &amp; Sync Low Reset" treetype="template">
process (&lt;clock&gt;,&lt;async_reset&gt;)
begin  
   if &lt;async_reset&gt; = '0' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '0') then
      if &lt;sync_reset&gt; = '0' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Async High Reset" treetype="template">
process (&lt;clock&gt;,&lt;reset&gt;)
begin  
   if &lt;reset&gt; = '1' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '0') then
      &lt;statements&gt;;
   end if;
end process;
				</Template>
				<Template label="/w Async High Reset and CE" treetype="template">
process (&lt;clock&gt;,&lt;reset&gt;)
begin  
   if &lt;reset&gt; = '1' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '0') then
      if &lt;clock_enable&gt; = '1' then
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Async Low Reset" treetype="template">
process (&lt;clock&gt;,&lt;reset&gt;)
begin  
   if &lt;reset&gt; = '0' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '0') then
      &lt;statements&gt;;
   end if;
end process;
				</Template>
				<Template label="/w Async Low Reset and CE" treetype="template">
process (&lt;clock&gt;,&lt;reset&gt;)
begin  
   if &lt;reset&gt; = '0' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '0') then
      if &lt;clock_enable&gt; = '1' then
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Sync High Reset" treetype="template">
process (&lt;clock&gt;)
begin  
   if (&lt;clock&gt;'event and &lt;clock&gt; = '0'&gt;) then
      if &lt;reset&gt; = '1' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Sync Low Reset" treetype="template">
process (&lt;clock&gt;)
begin  
   if (&lt;clock&gt;'event and &lt;clock&gt; = '0'&gt;) then
      if &lt;reset&gt; = '0' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
			</SubFolder>
			<SubFolder label="Posedge Clocked" treetype="folder">
				<Template label="/w Async &amp; Sync High Reset" treetype="template">
process (&lt;clock&gt;,&lt;async_reset&gt;)
begin  
   if &lt;async_reset&gt; = '1' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '1') then
      if &lt;sync_reset&gt; = '1' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Async &amp; Sync Low Reset" treetype="template">
process (&lt;clock&gt;,&lt;async_reset&gt;)
begin  
   if &lt;async_reset&gt; = '0' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '1') then
      if &lt;sync_reset&gt; = '0' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Async High Reset" treetype="template">
process (&lt;clock&gt;,&lt;reset&gt;)
begin  
   if &lt;reset&gt; = '1' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '1') then
      &lt;statements&gt;;
   end if;
end process;
				</Template>
				<Template label="/w Async High Reset and CE" treetype="template">
process (&lt;clock&gt;,&lt;reset&gt;)
begin  
   if &lt;reset&gt; = '1' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '1') then
      if &lt;clock_enable&gt; = '1' then
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Async Low Reset" treetype="template">
process (&lt;clock&gt;,&lt;reset&gt;)
begin  
   if &lt;reset&gt; = '0' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '1') then
      &lt;statements&gt;;
   end if;
end process;
				</Template>
				<Template label="/w Async Low Reset and CE" treetype="template">
process (&lt;clock&gt;,&lt;reset&gt;)
begin  
   if &lt;reset&gt; = '0' then
      &lt;statements&gt;;
   elsif (&lt;clock&gt;'event and &lt;clock&gt; = '1') then
      if &lt;clock_enable&gt; = '1' then
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Sync High Reset" treetype="template">
process (&lt;clock&gt;)
begin  
   if (&lt;clock&gt;'event and &lt;clock&gt; = '1'&gt;) then
      if &lt;reset&gt; = '1' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Sync Low Reset" treetype="template">
process (&lt;clock&gt;)
begin  
   if (&lt;clock&gt;'event and &lt;clock&gt; = '1'&gt;) then
      if &lt;reset&gt; = '0' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Signal, Constant &amp; Variable declaration" treetype="folder">
			<Template label="Constant Declaration" treetype="template">
constant &lt;name&gt;: &lt;type&gt; := &lt;value&gt;;
			</Template>
			<Template label="Signal Declaration" treetype="template">
signal &lt;name&gt;: &lt;type&gt; := &lt;value&gt;;
			</Template>
			<SubFolder label="Signal Declaration(Multiple)" treetype="folder">
				<SubFolder label="Initialized" treetype="folder">
					<Template label="1-bit" treetype="template">
   signal &lt;name&gt;: std_logic:= '0';
					</Template>
					<Template label="2-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(1 downto 0):= "00";
					</Template>
					<Template label="3-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(2 downto 0):= "000";
					</Template>
					<Template label="4-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(3 downto 0):= "0000";
					</Template>
					<Template label="8-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(7 downto 0):= "00000000";
					</Template>
					<Template label="16-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(15 downto 0):= x"0000";
					</Template>
					<Template label="32-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(31 downto 0):= x"00000000";
					</Template>
					<Template label="64-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(63 downto 0):= x"0000000000000000";
					</Template>
				</SubFolder>
				<SubFolder label="Unitialized" treetype="folder">
					<Template label="1-bit" treetype="template">
   signal &lt;name&gt;: std_logic;
					</Template>
					<Template label="2-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(1 downto 0);
					</Template>
					<Template label="3-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(2 downto 0);
					</Template>
					<Template label="4-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(3 downto 0);
					</Template>
					<Template label="8-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(7 downto 0);
					</Template>
					<Template label="16-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(15 downto 0);
					</Template>
					<Template label="32-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(31 downto 0);
					</Template>
					<Template label="64-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(63 downto 0);
					</Template>
				</SubFolder>
			</SubFolder>
			<Template label="Variable Declaration" treetype="template">
variable &lt;name&gt;: &lt;type&gt; := &lt;value&gt;;
			</Template>
			<SubFolder label="Variable Declaration(Multiple)" treetype="folder">
				<SubFolder label="Initialized" treetype="folder">
					<Template label="1-bit" treetype="template">
   variable &lt;name&gt;: std_logic:= '0';
					</Template>
					<Template label="2-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(1 downto 0):= "00";
					</Template>
					<Template label="3-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(2 downto 0):= "000";
					</Template>
					<Template label="4-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(3 downto 0):= "0000";
					</Template>
					<Template label="8-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(7 downto 0):= "00000000";
					</Template>
					<Template label="16-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(15 downto 0):= x"0000";
					</Template>
					<Template label="32-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(31 downto 0):= x"00000000";
					</Template>
					<Template label="64-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(63 downto 0):= x"0000000000000000";
					</Template>
				</SubFolder>
				<SubFolder label="Unitialized" treetype="folder">
					<Template label="1-bit" treetype="template">
   variable &lt;name&gt;: std_logic;
					</Template>
					<Template label="2-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(1 downto 0);
					</Template>
					<Template label="3-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(2 downto 0);
					</Template>
					<Template label="4-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(3 downto 0);
					</Template>
					<Template label="8-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(7 downto 0);
					</Template>
					<Template label="16-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(15 downto 0);
					</Template>
					<Template label="32-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(31 downto 0);
					</Template>
					<Template label="64-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(63 downto 0);
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Type &amp; Subtype" treetype="folder">
			<SubFolder label="Subtype Declaration" treetype="folder">
				<Template label="Array" treetype="template">
subtype &lt;subtype_name&gt; is array range &lt;lower_limit&gt; to &lt;upper_limit&gt;;
				</Template>
				<Template label="General" treetype="template">
subtype &lt;subtype_name&gt; is subtype &lt;subtype_definition&gt;; 
				</Template>
				<Template label="Subtype of Integer" treetype="template">
subtype &lt;subtype_name&gt; is integer range &lt;lower_limit&gt; to &lt;upper_limit&gt;; 
				</Template>
			</SubFolder>
			<SubFolder label="Type Declaration" treetype="folder">
				<Template label="Array of Integers" treetype="template">
type &lt;type_name&gt; is array integer range &lt;lower_limit&gt; to &lt;upper_limit&gt;;
				</Template>
				<Template label="Enumeration" treetype="template">
type &lt;type_name&gt; is (&lt;string1&gt;, &lt;string2&gt;, ...); 
				</Template>
				<Template label="General" treetype="template">
type &lt;type_name&gt; is type &lt;type_definition&gt;; 
				</Template>
			</SubFolder>
		</SubFolder>
	</Folder>
	<Folder label="Synthesis Constructs" treetype="folder">
		<SubFolder label="Assertions &amp; Functions" treetype="folder">
				<Template label="Info" treetype="template">
-- NOTE: Assertion support varies across different synthesis tools.
-- Assetions in VHDL
-- -----------------
-- The VHDL assert statment provides a quick and easy way to check expected values and
-- display messages from your test bench. When analyzed the condition expression is
-- evaluated. If using an if conditional statement, the expression of an assert must
-- evaluate to a boolean true or false value. If the condition is evalauted to a false
-- (indicating the assertion failed) the text that is specified in the report statement
-- is displayed in the transcript window. The severity then indicates to the software
-- tool what action if any should be taken based on the failure.
--
-- The severity level can be any of the following:
-- NOTE
-- WARNING
-- ERROR
-- FAILURE
-- The actions that result from the use of these severity levels will depend on the
-- software tool that is being used.
--
-- Example Assertion statment:
assert SRL_WIDTH &lt;= 17
report "The size of Shift Register exceeds the size of a single SRL" 
severity FAILURE;

				</Template>
			<SubFolder label="File I/O" treetype="folder">
				<Template label="Info" treetype="template">
-- The File I/O functions in VHDL
-- ==============================
-- NOTE: File I/O support varies across different synthesis tools.
-- The std.textio.all library will need to be used for these functions.

-- The Text I/O features of VHDL make it possible to open one or more data files,
-- read lines from those files, and parse the lines to form individual data elements.
-- These elements can then be stored in an array or record. To support the use of files,
-- VHDL has the concept of a file data type, that includes standard
-- built-in functions for opening, reading from, and writing to file data types.
-- The textio package, which is a part of the standard IEEE library,
-- expands on the built-in file type features by adding text parsing and formatting functions.
--
-- Opening Command
-- ---------------
-- The function file_open() is used to open a file for reading, writing and/or appending.
-- When using the file_open, you must specify the file name and the file mode. The syntax
-- looks like the following : file_open([&lt;file_status&gt;, &lt;file_handle&gt;, &lt;file_name&gt;, &lt;file_mode&gt;);
-- Status of the file_open can also be used to monitor if the file open did complete
-- successfully. This information will be stored in the file_status type which is of type
-- file_open_status. Upon opening the file a handle is issues for the file and must be used
-- to reference the file in subsequent commands.
--
-- The file mode can be one of the following:
-- READ_MODE
-- WRITE_MODE
-- APPEND_MODE
--
-- The file status can be one of the following:
-- OPEN_OK
-- STATUS_ERROR
-- NAME_ERROR
-- MODE_ERROR
--
-- Reading Command
-- ----------------
-- The function read() can be used to read a specified object to a
-- file. The syntax looks like the following: read(&lt;file_handle&gt;, &lt;object&gt;);
-- Object can only be of the following types:
-- bit
-- bit_vector
-- boolean
-- std_ulogic
-- std_ulogic_vector
-- std_logic_vector
-- Data is read from the file pointed to by the file handle and the file
-- is advanced to the beginning of the next data field in the file.

--
-- End of File Command
-- --------------------
-- The function endfile() can be used to verify that the end of the file has been
-- reached. The syntax for this function is : endfile(&lt;file_handle&gt;); The function
-- will return a boolean true value if the current file marker is at the end of
-- the file.
--
-- Closing File Command
-- --------------------
-- It is highly recommended to close a file once operations on the file have been
-- completed. The function file_close() can be used to close a file. The syntax for
-- this function is : file_close(&lt;file_handle&gt;);
--
-- The following example demonstrates how you can use the text I/O features
-- of VHDL to read test data from a file using a process:
--
   read_input: process
        type char_file is file of character;
        file c_file_handle: char_file;
        variable C: std_ulogic;
        variable char_count: integer := 0;
   begin
        file_open(c_file_handle, "test_file.txt", READ_MODE);
        while not endfile(c_file_handle) loop
            read (c_file_handle, C) ;
            char_count = char_count + 1;  -- Keep track of the number of
        -- characters
        end loop;
        file_close(c_file_handle);
   end process;

-- The following example demonstrates how you can use the text I/O features
-- of VHDL to write test data from a file using a process:
--
   write_input: process
        type char_file is file of character;
        file c_file_handle: char_file;
        variable C: std_ulogic := '0';
        constant char_count: integer := 0;
   begin
        file_open(c_file_handle, "test_file.txt", WRITE_MODE);
        while not endfile(c_file_handle) loop
            write (c_file_handle, C) ;
            char_count = char_count + 1;  -- Keep track of the number of
        -- characters
        end loop;
        file_close(c_file_handle);
   end process;
				</Template>
				<SubFolder label="Read/Write to a File" treetype="folder">
					<SubFolder label="Functions" treetype="folder">
						<Template label="Close a File" treetype="template">
-- NOTE: File I/O support varies across different synthesis tools.
file_close(&lt;file_handle&gt;);
						</Template>
						<Template label="End of File" treetype="template">
-- NOTE: File I/O support varies across different synthesis tools.
endfile(&lt;file_handle&gt;);
						</Template>
						<Template label="Open a File" treetype="template">
-- NOTE: File I/O support varies across different synthesis tools.
file_open([&lt;file_handle&gt;, &lt;file_name&gt;, &lt;file_mode&gt;);
						</Template>
						<SubFolder label="Read a File" treetype="folder">
							<Template label="Charachter" treetype="template">
-- NOTE: File I/O support varies across different synthesis tools.
read(&lt;file_handle&gt;, &lt;object&gt;);
							</Template>
							<Template label="Line" treetype="template">
-- NOTE: File I/O support varies across different synthesis tools.
readline(&lt;file_handle&gt;, &lt;line_variable&gt;);
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Attributes" treetype="folder">
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="Don't Place Register into IOB" treetype="folder">
					<Template label="Component (IOB)" treetype="template">
attribute IOB : string;
attribute IOB of &lt;component_name&gt;: component is "FALSE";
					</Template>
					<Template label="Port (IOB)" treetype="template">
attribute IOB : string;
attribute IOB of &lt;port_name&gt;: signal is "FALSE";
					</Template>
				</SubFolder>
				<SubFolder label="IOB Delay" treetype="folder">
					<SubFolder label="Component" treetype="folder">
						<Template label="Both (IOBDELAY)" treetype="template">
attribute IOBDELAY : string;
attribute IOBDELAY of &lt;component_name&gt;: component is "BOTH";
						</Template>
						<Template label="IBUF (IOBDELAY)" treetype="template">
attribute IOBDELAY : string;
attribute IOBDELAY of &lt;component_name&gt;: component is "IBUF";
						</Template>
						<Template label="IFD (IOBDELAY)" treetype="template">
attribute IOBDELAY : string;
attribute IOBDELAY of &lt;component_name&gt;: component is "IFD";
						</Template>
						<Template label="None (IOBDELAY)" treetype="template">
attribute IOBDELAY : string;
attribute IOBDELAY of &lt;component_name&gt;: component is "NONE";
						</Template>
					</SubFolder>
					<SubFolder label="No Delay" treetype="folder">
						<Template label="Component (NODELAY)" treetype="template">
attribute NODELAY : string;
attribute NODELAY of &lt;component_name&gt;: component is "TRUE";
						</Template>
						<Template label="Signal (NODELAY)" treetype="template">
attribute NODELAY : string;
attribute NODELAY of &lt;signal_name&gt;: signal is "TRUE";
						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="I/O Standard" treetype="folder">
					<Template label="Port (IOSTANDARD)" treetype="template">
attribute IOSTANDARD : string;
attribute IOSTANDARD of &lt;port_name&gt;: signal is "&lt;standard&gt;";
					</Template>
				</SubFolder>
				<SubFolder label="Place Register into IOB" treetype="folder">
					<Template label="Component (IOB)" treetype="template">
attribute IOB : string;
attribute IOB of &lt;component_name&gt;: component is "TRUE";
					</Template>
					<Template label="Port (IOB)" treetype="template">
attribute IOB : string;
attribute IOB of &lt;port_name&gt;: signal is "TRUE";
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Location" treetype="folder">
				<SubFolder label="Absolute Location Constraint" treetype="folder">
					<Template label="Bus (Pin LOC) (LOC)" treetype="template">
attribute LOC : string;
attribute LOC of &lt;bus_name&gt;: signal is "&lt;value&gt; &lt;value&gt;";
					</Template>
					<Template label="Instance (LOC)" treetype="template">
attribute LOC : string;
attribute LOC of &lt;inst_name&gt;: label is "&lt;value&gt;";
					</Template>
					<Template label="Signal (Pin LOC) (LOC)" treetype="template">
attribute LOC : string;
attribute LOC of &lt;signal_name&gt;: signal is "&lt;value&gt;";
					</Template>
				</SubFolder>
				<SubFolder label="Relative Location Constraint" treetype="folder">
					<Template label="Instance (RLOC)" treetype="template">
attribute RLOC : string;
attribute RLOC of &lt;inst_name&gt;: label is "&lt;value&gt;";
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Location / Packing" treetype="folder">
				<Template label="Hierarchical LUT Packing Constraint (HLUTNM)" treetype="template">
-- Specifies LUT packing of two LUT5s into the same LUT6 for Virtex-5 uniquified by hierarchy
attribute HLUTNM : string;
attribute HLUTNM of &lt;inst_name&gt;: label is "&lt;value&gt;";
				</Template>
				<Template label="LUT Packing Constraint (LUTNM)" treetype="template">
-- Specifies LUT packing of two LUT5s into the same LUT6 for Virtex-5
attribute LUTNM : string;
attribute LUTNM of &lt;inst_name&gt;: label is "&lt;value&gt;";
				</Template>
			</SubFolder>
			<SubFolder label="Misc" treetype="folder">
				<Template label="Asynchronous Register Specification (ASYNC_REG)" treetype="template">
attribute ASYNC_REG : string;
attribute ASYNC_REG of &lt;instance_name&gt;: signal is "TRUE";
				</Template>
			</SubFolder>
			<SubFolder label="Synthesis" treetype="folder">
				<Template label="Black Box(BLACK_BOX)" treetype="template">
attribute BLACK_BOX : string;
attribute BLACK_BOX of &lt;architecture_name&gt;: architecture is "TRUE";
				</Template>
				<SubFolder label="Clock" treetype="folder">
					<SubFolder label="Buffer Type" treetype="folder">
						<Template label="BUFR (CLOCK_BUFFER_TYPE)" treetype="template">
attribute CLOCK_BUFFER_TYPE : string;
attribute CLOCK_BUFFER_TYPE of &lt;signal_name&gt;: signal is "BUFR";
						</Template>
						<Template label="NONE (CLOCK_BUFFER_TYPE)" treetype="template">
attribute CLOCK_BUFFER_TYPE : string;
attribute CLOCK_BUFFER_TYPE of &lt;signal_name&gt;: signal is "NONE";
						</Template>
					</SubFolder>
				</SubFolder>
				<Template label="Do not optimize a Signal (DONT_TOUCH)" treetype="template">
attribute DONT_TOUCH : string;
attribute DONT_TOUCH of &lt;signal_name&gt;: signal is "TRUE";
				</Template>
				<Template label="Do not optimize(DONT_TOUCH)" treetype="template">
attribute DONT_TOUCH : string;
attribute DONT_TOUCH of &lt;inst_name&gt;: label is "TRUE";
				</Template>
				<SubFolder label="Equivalent Register Removal" treetype="folder">
					<SubFolder label="No" treetype="folder">
						<Template label="Entity (EQUIVALENT_REGISTER_REMOVAL)" treetype="template">
attribute EQUIVALENT_REGISTER_REMOVAL : string;
attribute EQUIVALENT_REGISTER_REMOVAL of &lt;entity_name&gt;: entity is "NO";
						</Template>
						<Template label="Signal (EQUIVALENT_REGISTER_REMOVAL)" treetype="template">
attribute EQUIVALENT_REGISTER_REMOVAL : string;
attribute EQUIVALENT_REGISTER_REMOVAL of &lt;signal_name&gt;: signal is "NO";
						</Template>
					</SubFolder>
					<SubFolder label="Yes" treetype="folder">
						<Template label="Entity (EQUIVALENT_REGISTER_REMOVAL)" treetype="template">
attribute EQUIVALENT_REGISTER_REMOVAL : string;
attribute EQUIVALENT_REGISTER_REMOVAL of &lt;entity_name&gt;: entity is "YES";
						</Template>
						<Template label="Signal (EQUIVALENT_REGISTER_REMOVAL)" treetype="template">
attribute EQUIVALENT_REGISTER_REMOVAL : string;
attribute EQUIVALENT_REGISTER_REMOVAL of &lt;signal_name&gt;: signal is "YES";
						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Finite State-Machine" treetype="folder">
					<SubFolder label="FSM Encoding" treetype="folder">
						<SubFolder label="Gray" treetype="folder">
							<Template label="Entity (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;entity_name&gt;: entity is "GRAY";
							</Template>
							<Template label="Signal (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;signal_name&gt;: signal is "GRAY";
							</Template>
						</SubFolder>
						<SubFolder label="Johnson" treetype="folder">
							<Template label="Entity (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;entity_name&gt;: entity is "JOHNSON";
							</Template>
							<Template label="Signal (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;signal_name&gt;: signal is "JOHNSON";
							</Template>
						</SubFolder>
						<SubFolder label="One-hot" treetype="folder">
							<Template label="Entity (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;entity_name&gt;: entity is "ONE-HOT";
							</Template>
							<Template label="Signal (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;signal_name&gt;: signal is "ONE-HOT";
							</Template>
						</SubFolder>
						<SubFolder label="Sequential" treetype="folder">
							<Template label="Entity (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;entity_name&gt;: entity is "SEQUENTIAL";
							</Template>
							<Template label="Signal (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;signal_name&gt;: signal is "SEQUENTIAL";
							</Template>
						</SubFolder>
						<SubFolder label="User" treetype="folder">
							<Template label="Entity (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;entity_name&gt;: entity is "USER";
							</Template>
							<Template label="Signal (FSM_ENCODING)" treetype="template">
attribute FSM_ENCODING : string;
attribute FSM_ENCODING of &lt;signal_name&gt;: signal is "USER";
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<Template label="Info" treetype="template">
-- You can describe constraints with VHDL attributes in your VHDL code. Before it can be
-- used, an attribute must be declared with the following syntax.
-- attribute AttributeName : string ;
-- Example
-- attribute RLOC : string ;
-- The attribute type defines the type of the attribute value.
-- An attribute can be declared in an entity or architecture. If declared in the entity, it
-- is visible both in the entity and the architecture body. If the attribute is declared in the
-- architecture, it cannot be used in the entity declaration. Once declared a VHDL attribute
-- can be specified as follows:
-- attribute AttributeName of ObjectList : ObjectType is AttributeValue ;
-- Examples
-- attribute RLOC of u123 : label is R11C1.S0 ;
-- attribute BUFG of my_signal : signal is sr;
-- The object list is a comma separated list of identifiers. Accepted object types are entity,
-- component, label, signal, variable and type.

				</Template>
				<SubFolder label="I/O" treetype="folder">
					<SubFolder label="Buffer Type" treetype="folder">
						<Template label="AUTO (BUFFER_TYPE)" treetype="template">
attribute BUFFER_TYPE : string;
attribute BUFFER_TYPE of &lt;signal_name&gt;: signal is "AUTO";
						</Template>
						<Template label="BUFR (BUFFER_TYPE)" treetype="template">
attribute BUFFER_TYPE : string;
attribute BUFFER_TYPE of &lt;signal_name&gt;: signal is "BUFR";
						</Template>
						<Template label="IBUF (BUFFER_TYPE)" treetype="template">
attribute BUFFER_TYPE : string;
attribute BUFFER_TYPE of &lt;signal_name&gt;: signal is "IBUF";
						</Template>
						<Template label="IBUF (IO_BUFFER_TYPE)" treetype="template">
attribute IO_BUFFER_TYPE : string;
attribute IO_BUFFER_TYPE of &lt;signal_name&gt;: signal is "IBUF";
						</Template>
						<Template label="NONE (BUFFER_TYPE)" treetype="template">
attribute BUFFER_TYPE : string;
attribute BUFFER_TYPE of &lt;signal_name&gt;: signal is "NONE";
						</Template>
						<Template label="NONE (IO_BUFFER_TYPE)" treetype="template">
attribute IO_BUFFER_TYPE : string;
attribute IO_BUFFER_TYPE of &lt;signal_name&gt;: signal is "NONE";
						</Template>
					</SubFolder>
				</SubFolder>
				<Template label="Keep Hierarchy (KEEP_HIERARCHY)" treetype="template">
attribute KEEP_HIERARCHY : string;
attribute KEEP_HIERARCHY of &lt;inst_name&gt;: label is "TRUE";
				</Template>
				<Template label="Keep/Preserve a Signal (KEEP)" treetype="template">
attribute KEEP : string;
attribute KEEP of &lt;signal_name&gt;: signal is "TRUE";
				</Template>
				<Template label="Mark Signal for Debug (MARK_DEBUG)" treetype="template">
attribute MARK_DEBUG : string;
attribute MARK_DEBUG of &lt;signal_name&gt;: signal is "TRUE";
				</Template>
				<SubFolder label="RAM Inference Styles" treetype="folder">
					<SubFolder label="Auto" treetype="folder">
						<Template label="Entity (RAM_STYLE)" treetype="template">
attribute RAM_STYLE : string;
attribute RAM_STYLE of &lt;entity_name&gt;: entity is "AUTO";
						</Template>
						<Template label="Signal (RAM_STYLE)" treetype="template">
attribute RAM_STYLE : string;
attribute RAM_STYLE of &lt;signal_name&gt;: signal is "AUTO";
						</Template>
					</SubFolder>
					<SubFolder label="Block" treetype="folder">
						<Template label="Entity (RAM_STYLE)" treetype="template">
attribute RAM_STYLE : string;
attribute RAM_STYLE of &lt;entity_name&gt;: entity is "BLOCK";
						</Template>
						<Template label="Signal (RAM_STYLE)" treetype="template">
attribute RAM_STYLE : string;
attribute RAM_STYLE of &lt;signal_name&gt;: signal is "BLOCK";
						</Template>
					</SubFolder>
					<SubFolder label="Distributed" treetype="folder">
						<Template label="Entity (RAM_STYLE)" treetype="template">
attribute RAM_STYLE : string;
attribute RAM_STYLE of &lt;entity_name&gt;: entity is "DISTRIBUTED";
						</Template>
						<Template label="Signal (RAM_STYLE)" treetype="template">
attribute RAM_STYLE : string;
attribute RAM_STYLE of &lt;signal_name&gt;: signal is "DISTRIBUTED";
						</Template>
					</SubFolder>
				</SubFolder>
				<Template label="Reduce Fanout(MAX_FANOUT)" treetype="template">
attribute MAX_FANOUT : integer;
attribute MAX_FANOUT of &lt;signal_name&gt;: signal is &lt;integer&gt;;
				</Template>
				<SubFolder label="Use DSP48" treetype="folder">
					<SubFolder label="Yes" treetype="folder">
						<Template label="Component (USE_DSP48)" treetype="template">
attribute USE_DSP48 : string;
attribute USE_DSP48 of &lt;component_name&gt;: component is "YES";
						</Template>
						<Template label="Entity (USE_DSP48)" treetype="template">
attribute USE_DSP48 : string;
attribute USE_DSP48 of &lt;entity_name&gt;: entity is "YES";
						</Template>
						<Template label="Signal (USE_DSP48)" treetype="template">
attribute USE_DSP48 : string;
attribute USE_DSP48 of &lt;signal_name&gt;: signal is "YES";
						</Template>
					</SubFolder>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Coding Examples" treetype="folder">
			<SubFolder label="Accumulators" treetype="folder">
				<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity accumulators_1 is
    port(CLK, CLR : in std_logic;
         D : in unsigned(3 downto 0);
         Q : out unsigned(3 downto 0));
end accumulators_1;

architecture archi of accumulators_1 is
    signal tmp: unsigned(3 downto 0);
begin

    process (CLK)
    begin
        if (CLK'event and CLK='1') then
          if (CLR='1') then
            tmp &lt;= "0000";
          else
            tmp &lt;= tmp + D;
          end if;
        end if;
    end process;

    Q &lt;= tmp;

end archi;

				</Template>
				<Template label="Sync Reset &amp; CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='1' then
         &lt;accumulate_out&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;accumulate_out&gt; &lt;= &lt;accumulate_out&gt; + &lt;accumulate_in&gt;;
      end if;
   end if;
end process;

				</Template>
				<Template label="Sync Reset, CE &amp; Sync Load" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='1' then
         &lt;accumulate_out&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         if &lt;load_enable&gt;='1' then
            &lt;accumulate_out&gt; &lt;= &lt;load_value&gt;;
         else
            &lt;accumulate_out&gt; &lt;= &lt;accumulate_out&gt; + &lt;accumulate_in&gt;;
         end if;
      end if;
   end if;
end process;


				</Template>
			</SubFolder>
			<SubFolder label="Arithmetic" treetype="folder">
				<SubFolder label="Adder" treetype="folder">
					<Template label="Adder with Carry In" treetype="template">
   &lt;output&gt; &lt;= &lt;input1&gt; + &lt;input2&gt; + &lt;one_bit_carry_in&gt;;

					</Template>
					<Template label="Adder with Carry Out" treetype="template">
   &lt;temp_value&gt; &lt;= &lt;input1&gt; + &lt;input2&gt;;
   &lt;output_sum&gt; &lt;= &lt;temp_value&gt;((&lt;adder_width&gt;-1) downto 0);
   &lt;carry_out&gt; &lt;= &lt;temp_value&gt;(&lt;adder_width&gt;);

					</Template>
					<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity adders_1 is
    port(A,B : in unsigned(7 downto 0);
         SUM : out unsigned(7 downto 0));
end adders_1;

architecture archi of adders_1 is
begin

    SUM &lt;= A + B;

end archi;
					</Template>
					<Template label="Simple Adder" treetype="template">
   &lt;output&gt; &lt;= &lt;input1&gt; + &lt;input2&gt;;


					</Template>
				</SubFolder>
				<SubFolder label="Add/Sub" treetype="folder">
					<Template label="Simple Adder/Subtractor" treetype="template">
process (&lt;input1&gt;, &lt;input2&gt;)
begin
   if &lt;add_sub&gt; = '1' then
      &lt;addsub_output&gt; &lt;= &lt;input1&gt; + &lt;input2&gt;;
   else
      &lt;addsub_output&gt; &lt;= &lt;input1&gt; - &lt;input2&gt;;
   end if;
end process;


					</Template>
				</SubFolder>
				<SubFolder label="Multipliers" treetype="folder">
					<Template label="Asyncronous Multiplier" treetype="template">

   &lt;output&gt; &lt;= &lt;input1&gt; * &lt;input2&gt;;

					</Template>
					<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity multipliers_1 is
    port(A : in signed(7 downto 0);
         B : in signed(3 downto 0);
         RES : out signed(11 downto 0));
end multipliers_1;

architecture beh of multipliers_1 is
begin
    RES &lt;= A * B;
end beh;


					</Template>
					<Template label="Synchronous Multiplier" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      &lt;output&gt; &lt;= &lt;input1&gt; * &lt;input2&gt;;
   end if;
end process;


					</Template>
				</SubFolder>
				<SubFolder label="Subtractor" treetype="folder">
					<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity adders_1 is
    port(A,B : in unsigned(7 downto 0);
         RES : out unsigned(7 downto 0));
end adders_1;

architecture archi of adders_1 is
begin

    RES &lt;= A - B;

end archi;


					</Template>
					<Template label="Simple Subtractor" treetype="template">
   &lt;output&gt; &lt;= &lt;input1&gt; - &lt;input2&gt;;

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Basic Gates" treetype="folder">
				<SubFolder label="AND" treetype="folder">
					<Template label="2-Input AND Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; and &lt;input2&gt;;


					</Template>
					<Template label="3-Input AND Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; and &lt;input2&gt; and &lt;input3&gt;;


					</Template>
					<Template label="4-Input AND Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; and &lt;input2&gt; and &lt;input3&gt; and &lt;input4&gt;;


					</Template>
				</SubFolder>
				<SubFolder label="Inverter" treetype="folder">
					<Template label="Inverter" treetype="template">
	&lt;output&gt; &lt;= not &lt;input1&gt;;

					</Template>
				</SubFolder>
				<SubFolder label="NAND" treetype="folder">
					<Template label="2-Input NAND Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; nand &lt;input2&gt; ;


					</Template>
					<Template label="3-Input NAND Gate" treetype="template">
	&lt;output&gt; &lt;= not (&lt;input1&gt; and &lt;input2&gt; and &lt;input3&gt;);


					</Template>
					<Template label="4-Input NAND Gate" treetype="template">
	&lt;output&gt; &lt;= not (&lt;input1&gt; and &lt;input2&gt; and &lt;input3&gt; and &lt;input4&gt;);


					</Template>
				</SubFolder>
				<SubFolder label="NOR" treetype="folder">
					<Template label="2-Input NOR Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; nor &lt;input2&gt; ;


					</Template>
					<Template label="3-Input NOR Gate" treetype="template">
	&lt;output&gt; &lt;= not (&lt;input1&gt; or &lt;input2&gt; or &lt;input3&gt;);


					</Template>
					<Template label="4-Input NOR Gate" treetype="template">
	&lt;output&gt; &lt;= not (&lt;input1&gt; or &lt;input2&gt; or &lt;input3&gt; or &lt;input4&gt;);


					</Template>
				</SubFolder>
				<SubFolder label="OR" treetype="folder">
					<Template label="2-Input OR Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; or &lt;input2&gt; ;


					</Template>
					<Template label="3-Input OR Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; or &lt;input2&gt; or &lt;input3&gt;;


					</Template>
					<Template label="4-Input OR Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; or &lt;input2&gt; or &lt;input3&gt; or &lt;input4&gt;;


					</Template>
				</SubFolder>
				<SubFolder label="XNOR" treetype="folder">
					<Template label="2-Input XNOR Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; xnor &lt;input2&gt; ;


					</Template>
					<Template label="3-Input XNOR Gate" treetype="template">
	&lt;output&gt; &lt;= not(&lt;input1&gt; xor &lt;input2&gt; xor &lt;input3&gt;);


					</Template>
					<Template label="4-Input XNOR Gate" treetype="template">
	&lt;output&gt; &lt;= not(&lt;input1&gt; xor &lt;input2&gt; xor &lt;input3&gt; xor &lt;input4&gt;);


					</Template>
				</SubFolder>
				<SubFolder label="XOR" treetype="folder">
					<Template label="2-Input XOR Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; xor &lt;input2&gt; ;


					</Template>
					<Template label="3-Input XOR Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; xor &lt;input2&gt; xor &lt;input3&gt;;



					</Template>
					<Template label="4-Input XOR Gate" treetype="template">
	&lt;output&gt; &lt;= &lt;input1&gt; xor &lt;input2&gt; xor &lt;input3&gt; xor &lt;input4&gt; ;


					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Bi-directional I/O" treetype="folder">
				<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;
entity top_bi_dir is
	port(T : in std_logic;
		  I : in std_logic;
		  O_NEW : out std_logic;
		  IO : inout std_logic);
end top_bi_dir;

architecture archi of top_bi_dir is
begin

	IO &lt;= I when T = '0' else 'Z';
	O_NEW &lt;= IO;

end archi;

				</Template>
				<Template label="Info" treetype="template">
--
--  The following represents the connectivity of the registered
--    bi-directional I/O example
--                                    ______
--                                   |     |
--                           |-------|D    |
--                           |       |    Q|-----input_signal
--                           | clock_|\    |
--    ________________       |       |/    |
--   / top_level_port \______|       |_____|
--   \________________/      |
--                           |
--                           |     /|
--                           |____/ |____________________
--                                \ |          _____     |
--                      _____     |\|         |     |    |
--                     |     |    |   out_sig-|D   Q|----|
--   output_enable_sig-|D   Q|____|           |     |output_tmp_signal
--                     |     |          clock_|\    |
--               clock_|\    |                |/    |
--                     |/    |                |_____|
--                     |_____|
--
--
--  The following represents the connectivity of the unregistered
--    bi-directional I/O example
--
--                           |----------input_signal
--                           |
--                           |
--    ________________       |
--   / top_level_port \______|
--   \________________/      |
--                           |
--                           |     /|
--                           |____/ |______output_signal
--                                \ |
--                                |\|
--                                |
--                                |---output_enable_signal
--


				</Template>
				<SubFolder label="Registered Input Only" treetype="folder">
					<Template label="1-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else 'Z';
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= '0';
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
    end if;
  end if;
end process;


					</Template>
					<Template label="2-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 2-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZ";
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "00";
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
    end if;
  end if;
end process;

					</Template>
					<Template label="4-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 4-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZZZ";
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "0000";
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
    end if;
  end if;
end process;

					</Template>
					<Template label="8-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 8-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZZZZZZZ";
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "00000000";
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
    end if;
  end if;
end process;

					</Template>
					<Template label="16-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 16-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZZZZZZZZZZZZZZZ";
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "0000000000000000";
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
    end if;
  end if;
end process;

					</Template>
					<Template label="32-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 32-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ";
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "00000000000000000000000000000000";
   else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
    end if;
  end if;
end process;

					</Template>
				</SubFolder>
				<SubFolder label="Registered Input, Output and OE" treetype="folder">
					<Template label="1-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a inout port
&lt;top_level_port&gt; &lt;= &lt;output_tmp_signal&gt; when &lt;output_enable_tmp_signal&gt; = '0' else 'Z';
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= '0';
      &lt;output_signal&gt; &lt;= '0';
      &lt;output_enable_signal&gt; &lt;= '0';
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= &lt;output_enable_signal&gt;;
    end if;
  end if;
end process;

					</Template>
					<Template label="2-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 2-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "00";
      &lt;output_signal&gt; &lt;= "00";
      &lt;output_enable_signal&gt; &lt;= "00";
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
					<Template label="4-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 4-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
&lt;top_level_port&gt;(2) &lt;= &lt;output_tmp_signal&gt;(2) when &lt;output_enable_tmp_signal&gt;(2) = '0' else 'Z';
&lt;top_level_port&gt;(3) &lt;= &lt;output_tmp_signal&gt;(3) when &lt;output_enable_tmp_signal&gt;(3) = '0' else 'Z';
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "0000";
      &lt;output_signal&gt; &lt;= "0000";
      &lt;output_enable_signal&gt; &lt;= "0000";
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
					<Template label="8-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 8-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
&lt;top_level_port&gt;(2) &lt;= &lt;output_tmp_signal&gt;(2) when &lt;output_enable_tmp_signal&gt;(2) = '0' else 'Z';
&lt;top_level_port&gt;(3) &lt;= &lt;output_tmp_signal&gt;(3) when &lt;output_enable_tmp_signal&gt;(3) = '0' else 'Z';
&lt;top_level_port&gt;(4) &lt;= &lt;output_tmp_signal&gt;(4) when &lt;output_enable_tmp_signal&gt;(4) = '0' else 'Z';
&lt;top_level_port&gt;(5) &lt;= &lt;output_tmp_signal&gt;(5) when &lt;output_enable_tmp_signal&gt;(5) = '0' else 'Z';
&lt;top_level_port&gt;(6) &lt;= &lt;output_tmp_signal&gt;(6) when &lt;output_enable_tmp_signal&gt;(6) = '0' else 'Z';
&lt;top_level_port&gt;(7) &lt;= &lt;output_tmp_signal&gt;(7) when &lt;output_enable_tmp_signal&gt;(7) = '0' else 'Z';
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "00000000";
      &lt;output_signal&gt; &lt;= "00000000";
      &lt;output_enable_signal&gt; &lt;= "00000000";
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
					<Template label="16-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 16-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
&lt;top_level_port&gt;(2) &lt;= &lt;output_tmp_signal&gt;(2) when &lt;output_enable_tmp_signal&gt;(2) = '0' else 'Z';
&lt;top_level_port&gt;(3) &lt;= &lt;output_tmp_signal&gt;(3) when &lt;output_enable_tmp_signal&gt;(3) = '0' else 'Z';
&lt;top_level_port&gt;(4) &lt;= &lt;output_tmp_signal&gt;(4) when &lt;output_enable_tmp_signal&gt;(4) = '0' else 'Z';
&lt;top_level_port&gt;(5) &lt;= &lt;output_tmp_signal&gt;(5) when &lt;output_enable_tmp_signal&gt;(5) = '0' else 'Z';
&lt;top_level_port&gt;(6) &lt;= &lt;output_tmp_signal&gt;(6) when &lt;output_enable_tmp_signal&gt;(6) = '0' else 'Z';
&lt;top_level_port&gt;(7) &lt;= &lt;output_tmp_signal&gt;(7) when &lt;output_enable_tmp_signal&gt;(7) = '0' else 'Z';
&lt;top_level_port&gt;(8) &lt;= &lt;output_tmp_signal&gt;(8) when &lt;output_enable_tmp_signal&gt;(8) = '0' else 'Z';
&lt;top_level_port&gt;(9) &lt;= &lt;output_tmp_signal&gt;(9) when &lt;output_enable_tmp_signal&gt;(9) = '0' else 'Z';
&lt;top_level_port&gt;(10) &lt;= &lt;output_tmp_signal&gt;(10) when &lt;output_enable_tmp_signal&gt;(10) = '0' else 'Z';
&lt;top_level_port&gt;(11) &lt;= &lt;output_tmp_signal&gt;(11) when &lt;output_enable_tmp_signal&gt;(11) = '0' else 'Z';
&lt;top_level_port&gt;(12) &lt;= &lt;output_tmp_signal&gt;(12) when &lt;output_enable_tmp_signal&gt;(12) = '0' else 'Z';
&lt;top_level_port&gt;(13) &lt;= &lt;output_tmp_signal&gt;(13) when &lt;output_enable_tmp_signal&gt;(13) = '0' else 'Z';
&lt;top_level_port&gt;(14) &lt;= &lt;output_tmp_signal&gt;(14) when &lt;output_enable_tmp_signal&gt;(14) = '0' else 'Z';
&lt;top_level_port&gt;(15) &lt;= &lt;output_tmp_signal&gt;(15) when &lt;output_enable_tmp_signal&gt;(15) = '0' else 'Z';
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "0000000000000000";
      &lt;output_signal&gt; &lt;= "0000000000000000";
      &lt;output_enable_signal&gt; &lt;= "00000000000000000";
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
					<Template label="32-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 32-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
&lt;top_level_port&gt;(2) &lt;= &lt;output_tmp_signal&gt;(2) when &lt;output_enable_tmp_signal&gt;(2) = '0' else 'Z';
&lt;top_level_port&gt;(3) &lt;= &lt;output_tmp_signal&gt;(3) when &lt;output_enable_tmp_signal&gt;(3) = '0' else 'Z';
&lt;top_level_port&gt;(4) &lt;= &lt;output_tmp_signal&gt;(4) when &lt;output_enable_tmp_signal&gt;(4) = '0' else 'Z';
&lt;top_level_port&gt;(5) &lt;= &lt;output_tmp_signal&gt;(5) when &lt;output_enable_tmp_signal&gt;(5) = '0' else 'Z';
&lt;top_level_port&gt;(6) &lt;= &lt;output_tmp_signal&gt;(6) when &lt;output_enable_tmp_signal&gt;(6) = '0' else 'Z';
&lt;top_level_port&gt;(7) &lt;= &lt;output_tmp_signal&gt;(7) when &lt;output_enable_tmp_signal&gt;(7) = '0' else 'Z';
&lt;top_level_port&gt;(8) &lt;= &lt;output_tmp_signal&gt;(8) when &lt;output_enable_tmp_signal&gt;(8) = '0' else 'Z';
&lt;top_level_port&gt;(9) &lt;= &lt;output_tmp_signal&gt;(9) when &lt;output_enable_tmp_signal&gt;(9) = '0' else 'Z';
&lt;top_level_port&gt;(10) &lt;= &lt;output_tmp_signal&gt;(10) when &lt;output_enable_tmp_signal&gt;(10) = '0' else 'Z';
&lt;top_level_port&gt;(11) &lt;= &lt;output_tmp_signal&gt;(11) when &lt;output_enable_tmp_signal&gt;(11) = '0' else 'Z';
&lt;top_level_port&gt;(12) &lt;= &lt;output_tmp_signal&gt;(12) when &lt;output_enable_tmp_signal&gt;(12) = '0' else 'Z';
&lt;top_level_port&gt;(13) &lt;= &lt;output_tmp_signal&gt;(13) when &lt;output_enable_tmp_signal&gt;(13) = '0' else 'Z';
&lt;top_level_port&gt;(14) &lt;= &lt;output_tmp_signal&gt;(14) when &lt;output_enable_tmp_signal&gt;(14) = '0' else 'Z';
&lt;top_level_port&gt;(15) &lt;= &lt;output_tmp_signal&gt;(15) when &lt;output_enable_tmp_signal&gt;(15) = '0' else 'Z';
&lt;top_level_port&gt;(16) &lt;= &lt;output_tmp_signal&gt;(16) when &lt;output_enable_tmp_signal&gt;(16) = '0' else 'Z';
&lt;top_level_port&gt;(17) &lt;= &lt;output_tmp_signal&gt;(17) when &lt;output_enable_tmp_signal&gt;(17) = '0' else 'Z';
&lt;top_level_port&gt;(18) &lt;= &lt;output_tmp_signal&gt;(18) when &lt;output_enable_tmp_signal&gt;(18) = '0' else 'Z';
&lt;top_level_port&gt;(19) &lt;= &lt;output_tmp_signal&gt;(19) when &lt;output_enable_tmp_signal&gt;(19) = '0' else 'Z';
&lt;top_level_port&gt;(20) &lt;= &lt;output_tmp_signal&gt;(20) when &lt;output_enable_tmp_signal&gt;(20) = '0' else 'Z';
&lt;top_level_port&gt;(21) &lt;= &lt;output_tmp_signal&gt;(21) when &lt;output_enable_tmp_signal&gt;(21) = '0' else 'Z';
&lt;top_level_port&gt;(22) &lt;= &lt;output_tmp_signal&gt;(22) when &lt;output_enable_tmp_signal&gt;(22) = '0' else 'Z';
&lt;top_level_port&gt;(23) &lt;= &lt;output_tmp_signal&gt;(23) when &lt;output_enable_tmp_signal&gt;(23) = '0' else 'Z';
&lt;top_level_port&gt;(24) &lt;= &lt;output_tmp_signal&gt;(24) when &lt;output_enable_tmp_signal&gt;(24) = '0' else 'Z';
&lt;top_level_port&gt;(25) &lt;= &lt;output_tmp_signal&gt;(25) when &lt;output_enable_tmp_signal&gt;(25) = '0' else 'Z';
&lt;top_level_port&gt;(26) &lt;= &lt;output_tmp_signal&gt;(26) when &lt;output_enable_tmp_signal&gt;(26) = '0' else 'Z';
&lt;top_level_port&gt;(27) &lt;= &lt;output_tmp_signal&gt;(27) when &lt;output_enable_tmp_signal&gt;(27) = '0' else 'Z';
&lt;top_level_port&gt;(28) &lt;= &lt;output_tmp_signal&gt;(28) when &lt;output_enable_tmp_signal&gt;(28) = '0' else 'Z';
&lt;top_level_port&gt;(29) &lt;= &lt;output_tmp_signal&gt;(29) when &lt;output_enable_tmp_signal&gt;(29) = '0' else 'Z';
&lt;top_level_port&gt;(30) &lt;= &lt;output_tmp_signal&gt;(30) when &lt;output_enable_tmp_signal&gt;(30) = '0' else 'Z';
&lt;top_level_port&gt;(31) &lt;= &lt;output_tmp_signal&gt;(31) when &lt;output_enable_tmp_signal&gt;(31) = '0' else 'Z';
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;input_signal&gt; &lt;= "00000000000000000000000000000000";
      &lt;output_signal&gt; &lt;= "00000000000000000000000000000000";
      &lt;output_enable_signal&gt; &lt;= "00000000000000000000000000000000";
    else
      &lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
				</SubFolder>
				<SubFolder label="Registered Output and Output Enable only" treetype="folder">
					<Template label="1-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a inout port
&lt;top_level_port&gt; &lt;= &lt;output_tmp_signal&gt; when &lt;output_enable_tmp_signal&gt; = '0' else 'Z';
&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;output_signal&gt; &lt;= '0';
      &lt;output_enable_signal&gt; &lt;= '0';
    else
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= &lt;output_enable_signal&gt;;
    end if;
  end if;
end process;

					</Template>
					<Template label="2-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 2-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;output_signal&gt; &lt;= "00";
      &lt;output_enable_signal&gt; &lt;= "00";
    else
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
					<Template label="4-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 4-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
&lt;top_level_port&gt;(2) &lt;= &lt;output_tmp_signal&gt;(2) when &lt;output_enable_tmp_signal&gt;(2) = '0' else 'Z';
&lt;top_level_port&gt;(3) &lt;= &lt;output_tmp_signal&gt;(3) when &lt;output_enable_tmp_signal&gt;(3) = '0' else 'Z';
&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;output_signal&gt; &lt;= "0000";
      &lt;output_enable_signal&gt; &lt;= "0000";
    else
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
					<Template label="8-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 8-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
&lt;top_level_port&gt;(2) &lt;= &lt;output_tmp_signal&gt;(2) when &lt;output_enable_tmp_signal&gt;(2) = '0' else 'Z';
&lt;top_level_port&gt;(3) &lt;= &lt;output_tmp_signal&gt;(3) when &lt;output_enable_tmp_signal&gt;(3) = '0' else 'Z';
&lt;top_level_port&gt;(4) &lt;= &lt;output_tmp_signal&gt;(4) when &lt;output_enable_tmp_signal&gt;(4) = '0' else 'Z';
&lt;top_level_port&gt;(5) &lt;= &lt;output_tmp_signal&gt;(5) when &lt;output_enable_tmp_signal&gt;(5) = '0' else 'Z';
&lt;top_level_port&gt;(6) &lt;= &lt;output_tmp_signal&gt;(6) when &lt;output_enable_tmp_signal&gt;(6) = '0' else 'Z';
&lt;top_level_port&gt;(7) &lt;= &lt;output_tmp_signal&gt;(7) when &lt;output_enable_tmp_signal&gt;(7) = '0' else 'Z';
&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;output_signal&gt; &lt;= "00000000";
      &lt;output_enable_signal&gt; &lt;= "00000000";
    else
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
					<Template label="16-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 16-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
&lt;top_level_port&gt;(2) &lt;= &lt;output_tmp_signal&gt;(2) when &lt;output_enable_tmp_signal&gt;(2) = '0' else 'Z';
&lt;top_level_port&gt;(3) &lt;= &lt;output_tmp_signal&gt;(3) when &lt;output_enable_tmp_signal&gt;(3) = '0' else 'Z';
&lt;top_level_port&gt;(4) &lt;= &lt;output_tmp_signal&gt;(4) when &lt;output_enable_tmp_signal&gt;(4) = '0' else 'Z';
&lt;top_level_port&gt;(5) &lt;= &lt;output_tmp_signal&gt;(5) when &lt;output_enable_tmp_signal&gt;(5) = '0' else 'Z';
&lt;top_level_port&gt;(6) &lt;= &lt;output_tmp_signal&gt;(6) when &lt;output_enable_tmp_signal&gt;(6) = '0' else 'Z';
&lt;top_level_port&gt;(7) &lt;= &lt;output_tmp_signal&gt;(7) when &lt;output_enable_tmp_signal&gt;(7) = '0' else 'Z';
&lt;top_level_port&gt;(8) &lt;= &lt;output_tmp_signal&gt;(8) when &lt;output_enable_tmp_signal&gt;(8) = '0' else 'Z';
&lt;top_level_port&gt;(9) &lt;= &lt;output_tmp_signal&gt;(9) when &lt;output_enable_tmp_signal&gt;(9) = '0' else 'Z';
&lt;top_level_port&gt;(10) &lt;= &lt;output_tmp_signal&gt;(10) when &lt;output_enable_tmp_signal&gt;(10) = '0' else 'Z';
&lt;top_level_port&gt;(11) &lt;= &lt;output_tmp_signal&gt;(11) when &lt;output_enable_tmp_signal&gt;(11) = '0' else 'Z';
&lt;top_level_port&gt;(12) &lt;= &lt;output_tmp_signal&gt;(12) when &lt;output_enable_tmp_signal&gt;(12) = '0' else 'Z';
&lt;top_level_port&gt;(13) &lt;= &lt;output_tmp_signal&gt;(13) when &lt;output_enable_tmp_signal&gt;(13) = '0' else 'Z';
&lt;top_level_port&gt;(14) &lt;= &lt;output_tmp_signal&gt;(14) when &lt;output_enable_tmp_signal&gt;(14) = '0' else 'Z';
&lt;top_level_port&gt;(15) &lt;= &lt;output_tmp_signal&gt;(15) when &lt;output_enable_tmp_signal&gt;(15) = '0' else 'Z';
&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;output_signal&gt; &lt;= "0000000000000000";
      &lt;output_enable_signal&gt; &lt;= "00000000000000000";
    else
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
					<Template label="32-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 32-bit inout port
&lt;top_level_port&gt;(0) &lt;= &lt;output_tmp_signal&gt;(0) when &lt;output_enable_tmp_signal&gt;(0) = '0' else 'Z';
&lt;top_level_port&gt;(1) &lt;= &lt;output_tmp_signal&gt;(1) when &lt;output_enable_tmp_signal&gt;(1) = '0' else 'Z';
&lt;top_level_port&gt;(2) &lt;= &lt;output_tmp_signal&gt;(2) when &lt;output_enable_tmp_signal&gt;(2) = '0' else 'Z';
&lt;top_level_port&gt;(3) &lt;= &lt;output_tmp_signal&gt;(3) when &lt;output_enable_tmp_signal&gt;(3) = '0' else 'Z';
&lt;top_level_port&gt;(4) &lt;= &lt;output_tmp_signal&gt;(4) when &lt;output_enable_tmp_signal&gt;(4) = '0' else 'Z';
&lt;top_level_port&gt;(5) &lt;= &lt;output_tmp_signal&gt;(5) when &lt;output_enable_tmp_signal&gt;(5) = '0' else 'Z';
&lt;top_level_port&gt;(6) &lt;= &lt;output_tmp_signal&gt;(6) when &lt;output_enable_tmp_signal&gt;(6) = '0' else 'Z';
&lt;top_level_port&gt;(7) &lt;= &lt;output_tmp_signal&gt;(7) when &lt;output_enable_tmp_signal&gt;(7) = '0' else 'Z';
&lt;top_level_port&gt;(8) &lt;= &lt;output_tmp_signal&gt;(8) when &lt;output_enable_tmp_signal&gt;(8) = '0' else 'Z';
&lt;top_level_port&gt;(9) &lt;= &lt;output_tmp_signal&gt;(9) when &lt;output_enable_tmp_signal&gt;(9) = '0' else 'Z';
&lt;top_level_port&gt;(10) &lt;= &lt;output_tmp_signal&gt;(10) when &lt;output_enable_tmp_signal&gt;(10) = '0' else 'Z';
&lt;top_level_port&gt;(11) &lt;= &lt;output_tmp_signal&gt;(11) when &lt;output_enable_tmp_signal&gt;(11) = '0' else 'Z';
&lt;top_level_port&gt;(12) &lt;= &lt;output_tmp_signal&gt;(12) when &lt;output_enable_tmp_signal&gt;(12) = '0' else 'Z';
&lt;top_level_port&gt;(13) &lt;= &lt;output_tmp_signal&gt;(13) when &lt;output_enable_tmp_signal&gt;(13) = '0' else 'Z';
&lt;top_level_port&gt;(14) &lt;= &lt;output_tmp_signal&gt;(14) when &lt;output_enable_tmp_signal&gt;(14) = '0' else 'Z';
&lt;top_level_port&gt;(15) &lt;= &lt;output_tmp_signal&gt;(15) when &lt;output_enable_tmp_signal&gt;(15) = '0' else 'Z';
&lt;top_level_port&gt;(16) &lt;= &lt;output_tmp_signal&gt;(16) when &lt;output_enable_tmp_signal&gt;(16) = '0' else 'Z';
&lt;top_level_port&gt;(17) &lt;= &lt;output_tmp_signal&gt;(17) when &lt;output_enable_tmp_signal&gt;(17) = '0' else 'Z';
&lt;top_level_port&gt;(18) &lt;= &lt;output_tmp_signal&gt;(18) when &lt;output_enable_tmp_signal&gt;(18) = '0' else 'Z';
&lt;top_level_port&gt;(19) &lt;= &lt;output_tmp_signal&gt;(19) when &lt;output_enable_tmp_signal&gt;(19) = '0' else 'Z';
&lt;top_level_port&gt;(20) &lt;= &lt;output_tmp_signal&gt;(20) when &lt;output_enable_tmp_signal&gt;(20) = '0' else 'Z';
&lt;top_level_port&gt;(21) &lt;= &lt;output_tmp_signal&gt;(21) when &lt;output_enable_tmp_signal&gt;(21) = '0' else 'Z';
&lt;top_level_port&gt;(22) &lt;= &lt;output_tmp_signal&gt;(22) when &lt;output_enable_tmp_signal&gt;(22) = '0' else 'Z';
&lt;top_level_port&gt;(23) &lt;= &lt;output_tmp_signal&gt;(23) when &lt;output_enable_tmp_signal&gt;(23) = '0' else 'Z';
&lt;top_level_port&gt;(24) &lt;= &lt;output_tmp_signal&gt;(24) when &lt;output_enable_tmp_signal&gt;(24) = '0' else 'Z';
&lt;top_level_port&gt;(25) &lt;= &lt;output_tmp_signal&gt;(25) when &lt;output_enable_tmp_signal&gt;(25) = '0' else 'Z';
&lt;top_level_port&gt;(26) &lt;= &lt;output_tmp_signal&gt;(26) when &lt;output_enable_tmp_signal&gt;(26) = '0' else 'Z';
&lt;top_level_port&gt;(27) &lt;= &lt;output_tmp_signal&gt;(27) when &lt;output_enable_tmp_signal&gt;(27) = '0' else 'Z';
&lt;top_level_port&gt;(28) &lt;= &lt;output_tmp_signal&gt;(28) when &lt;output_enable_tmp_signal&gt;(28) = '0' else 'Z';
&lt;top_level_port&gt;(29) &lt;= &lt;output_tmp_signal&gt;(29) when &lt;output_enable_tmp_signal&gt;(29) = '0' else 'Z';
&lt;top_level_port&gt;(30) &lt;= &lt;output_tmp_signal&gt;(30) when &lt;output_enable_tmp_signal&gt;(30) = '0' else 'Z';
&lt;top_level_port&gt;(31) &lt;= &lt;output_tmp_signal&gt;(31) when &lt;output_enable_tmp_signal&gt;(31) = '0' else 'Z';
&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;
process(&lt;clock&gt;)
begin
  if rising_edge(&lt;clock&gt;) then
    if &lt;reset&gt;='1' then
      &lt;output_signal&gt; &lt;= "00000000000000000000000000000000";
      &lt;output_enable_signal&gt; &lt;= "00000000000000000000000000000000";
    else
      &lt;output_tmp_signal&gt; &lt;= &lt;output_signal&gt;;
      &lt;output_enable_tmp_signal&gt; &lt;= (others =&gt; &lt;output_enable_signal&gt;);
    end if;
  end if;
end process;

					</Template>
				</SubFolder>
				<SubFolder label="Unregistered" treetype="folder">
					<Template label="1-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else 'Z';
	&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;

					</Template>
					<Template label="2-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 2-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZ";
	&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;

					</Template>
					<Template label="4-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 4-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZZZ";
	&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;

					</Template>
					<Template label="8-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 8-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZZZZZZZ";
	&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;

					</Template>
					<Template label="16-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 16-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZZZZZZZZZZZZZZZ";
	&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;

					</Template>
					<Template label="32-bit" treetype="template">
-- Declare the &lt;top_level_port&gt; as a 32-bit inout port
&lt;top_level_port&gt; &lt;= &lt;input_signal&gt; when &lt;output_enable_signal&gt; = '0' else "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ";
	&lt;input_signal&gt; &lt;= &lt;top_level_port&gt;;

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Comparators" treetype="folder">
				<Template label="Equal" treetype="template">
process(&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if ( &lt;input1&gt; = &lt;input2&gt; ) then
         &lt;output&gt; &lt;= '1';
      else
         &lt;output&gt; &lt;= '0';
      end if;
   end if;
end process;


				</Template>
				<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity comparator_1 is
    port(A,B : in  std_logic_vector(7 downto 0);
         CMP : out std_logic);
end comparator_1;

architecture archi of comparator_1 is
begin

    CMP &lt;= '1' when A &gt;= B else '0';

end archi;
				</Template>
				<Template label="Greater-Than" treetype="template">
process(&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if ( &lt;input1&gt; &gt; &lt;input2&gt; ) then
         &lt;output&gt; &lt;= '1';
      else
         &lt;output&gt; &lt;= '0';
      end if;
   end if;
end process;


				</Template>
				<Template label="Greater-Than or Equal" treetype="template">
process(&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if ( &lt;input1&gt; &gt;= &lt;input2&gt; ) then
         &lt;output&gt; &lt;= '1';
      else
         &lt;output&gt; &lt;= '0';
      end if;
   end if;
end process;


				</Template>
				<Template label="Less-Than" treetype="template">
process(&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if ( &lt;input1&gt; &lt; &lt;input2&gt; ) then
         &lt;output&gt; &lt;= '1';
      else
         &lt;output&gt; &lt;= '0';
      end if;
   end if;
end process;


				</Template>
				<Template label="Less-Than or Equal" treetype="template">
process(&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if ( &lt;input1&gt; &lt;= &lt;input2&gt; ) then
         &lt;output&gt; &lt;= '1';
      else
         &lt;output&gt; &lt;= '0';
      end if;
   end if;
end process;


				</Template>
				<Template label="Not Equal" treetype="template">
process(&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if ( &lt;input1&gt; /= &lt;input2&gt; ) then
         &lt;output&gt; &lt;= '1';
      else
         &lt;output&gt; &lt;= '0';
      end if;
   end if;
end process;


				</Template>
			</SubFolder>
			<SubFolder label="Counters" treetype="folder">
				<SubFolder label="Binary" treetype="folder">
					<SubFolder label="Down Counters" treetype="folder">
						<Template label="Simple Counter" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      &lt;count&gt; &lt;= &lt;count&gt; - 1;
   end if;
end process;


						</Template>
						<Template label="/w CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;clock_enable&gt;='1' then
         &lt;count&gt; &lt;= &lt;count&gt; - 1;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w CE and Sync Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='1' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;count&gt; &lt;= &lt;count&gt; - 1;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w CE and Sync Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='0' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;count&gt; &lt;= &lt;count&gt; - 1;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w Load, CE and Sync Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='1' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         if &lt;load_enable&gt;='1' then
            &lt;count&gt; &lt;= &lt;input&gt;;
         else
            &lt;count&gt; &lt;= &lt;count&gt; - 1;
         end if;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w Load, CE and Sync Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='0' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         if &lt;load_enable&gt;='1' then
            &lt;count&gt; &lt;= &lt;input&gt;;
         else
            &lt;count&gt; &lt;= &lt;count&gt; - 1;
         end if;
      end if;
   end if;
end process;

						</Template>
					</SubFolder>
					<SubFolder label="Up Counters" treetype="folder">
						<Template label="Simple Counter" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      &lt;count&gt; &lt;= &lt;count&gt; + 1;
   end if;
end process;


						</Template>
						<Template label="/w CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;clock_enable&gt;='1' then
         &lt;count&gt; &lt;= &lt;count&gt; + 1;
      end if;
   end if;
end process;


						</Template>
						<Template label="/w CE and Sync Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='1' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;count&gt; &lt;= &lt;count&gt; + 1;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w CE and Sync Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='0' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;count&gt; &lt;= &lt;count&gt; + 1;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w Load, CE and Sync Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='1' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         if &lt;load_enable&gt;='1' then
            &lt;count&gt; &lt;= &lt;input&gt;;
         else
            &lt;count&gt; &lt;= &lt;count&gt; + 1;
         end if;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w Load, CE and Sync Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='0' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         if &lt;load_enable&gt;='1' then
            &lt;count&gt; &lt;= &lt;input&gt;;
         else
            &lt;count&gt; &lt;= &lt;count&gt; + 1;
         end if;
      end if;
   end if;
end process;

						</Template>
					</SubFolder>
					<SubFolder label="Up/Down Counters" treetype="folder">
						<Template label="Simple Counter" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;count_direction&gt;='1' then
         &lt;count&gt; &lt;= &lt;count&gt; + 1;
      else
         &lt;count&gt; &lt;= &lt;count&gt; - 1;
      end if;
   end if;
end process;


						</Template>
						<Template label="/w CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;clock_enable&gt;='1' then
         if &lt;count_direction&gt;='1' then
            &lt;count&gt; &lt;= &lt;count&gt; + 1;
         else
            &lt;count&gt; &lt;= &lt;count&gt; - 1;
         end if;
      end if;
   end if;
end process;


						</Template>
						<Template label="/w CE and Sync Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='1' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         if &lt;count_direction&gt;='1' then
            &lt;count&gt; &lt;= &lt;count&gt; + 1;
         else
            &lt;count&gt; &lt;= &lt;count&gt; - 1;
         end if;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w CE and Sync Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='0' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         if &lt;count_direction&gt;='1' then
            &lt;count&gt; &lt;= &lt;count&gt; + 1;
         else
            &lt;count&gt; &lt;= &lt;count&gt; - 1;
         end if;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w Load, CE and Sync Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='1' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         if &lt;load_enable&gt;='1' then
            &lt;count&gt; &lt;= &lt;input&gt;;
         else
            if &lt;count_direction&gt;='1' then
               &lt;count&gt; &lt;= &lt;count&gt; + 1;
            else
               &lt;count&gt; &lt;= &lt;count&gt; - 1;
            end if;
         end if;
      end if;
   end if;
end process;

						</Template>
						<Template label="/w Load, CE and Sync Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;='1' and &lt;clock&gt;'event then
      if &lt;reset&gt;='0' then
         &lt;count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         if &lt;load_enable&gt;='1' then
            &lt;count&gt; &lt;= &lt;input&gt;;
         else
            if &lt;count_direction&gt;='1' then
               &lt;count&gt; &lt;= &lt;count&gt; + 1;
            else
               &lt;count&gt; &lt;= &lt;count&gt; - 1;
            end if;
         end if;
      end if;
   end if;
end process;

						</Template>
					</SubFolder>
				</SubFolder>
				<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity counters_1 is
    port(CLK, CLR : in std_logic;
         Q : out unsigned(3 downto 0));
end counters_1;

architecture archi of counters_1 is
    signal tmp: unsigned(3 downto 0);
begin
    process (CLK)
    begin
        if (CLK'event and CLK='1') then
          if (CLR='1') then
            tmp &lt;= "0000";
          else
            tmp &lt;= tmp + 1;
          end if;
        end if;
    end process;

    Q &lt;= tmp;

end archi;
				</Template>
				<SubFolder label="Gray Code" treetype="folder">
					<Template label="w/ CE and Sync Active High Reset" treetype="template">
&lt;next_binary_count&gt; &lt;= &lt;binary_count&gt; + 1;

process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if (&lt;reset&gt; = '1') then
         &lt;binary_count&gt; &lt;= (others =&gt; '0');
         &lt;gray_count&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;binary_count&gt; &lt;= &lt;next_binary_count&gt;;
         &lt;gray_count&gt; &lt;= (('0' &amp; next_binary_count(&lt;width-1&gt; downto 1)) XOR &lt;next_binary_count&gt;);
      end if;
   end if;
end process;

					</Template>
				</SubFolder>
				<SubFolder label="LFSR" treetype="folder">
					<Template label="4-Bit w/ CE and Sync Active High Reset" treetype="template">
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if (&lt;reset&gt; = '1') then
         &lt;reg_name&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;reg_name&gt;(3 downto 1) &lt;= &lt;reg_name&gt;(2 downto 0) ;
         &lt;reg_name&gt;(0) &lt;= not(&lt;reg_name&gt;(4) XOR &lt;reg_name&gt;(3));
      end if;
   end if;
end process;

					</Template>
					<Template label="8-Bit w/ CE and Sync Active High Reset" treetype="template">
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if (&lt;reset&gt; = '1') then
         &lt;reg_name&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;reg_name&gt;(7 downto 1) &lt;= &lt;reg_name&gt;(6 downto 0) ;
         &lt;reg_name&gt;(0) &lt;= not(&lt;reg_name&gt;(7) XOR &lt;reg_name&gt;(6) XOR &lt;reg_name&gt;(4));
      end if;
   end if;
end process;

					</Template>
					<Template label="16-Bit w/ CE and Sync Active High Reset" treetype="template">
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if (&lt;reset&gt; = '1') then
         &lt;reg_name&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;reg_name&gt;(15 downto 1) &lt;= &lt;reg_name&gt;(14 downto 0) ;
         &lt;reg_name&gt;(0) &lt;= not(&lt;reg_name&gt;(15) XOR &lt;reg_name&gt;(14) XOR &lt;reg_name&gt;(13) XOR &lt;reg_name&gt;(4));
      end if;
   end if;
end process;

					</Template>
					<Template label="32-Bit w/ CE and Sync Active High Reset" treetype="template">
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if (&lt;reset&gt; = '1') then
         &lt;reg_name&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt;='1' then
         &lt;reg_name&gt;(31 downto 1) &lt;= &lt;reg_name&gt;(30 downto 0) ;
         &lt;reg_name&gt;(0) &lt;= not(&lt;reg_name&gt;(31) XOR &lt;reg_name&gt;(22) XOR &lt;reg_name&gt;(2) XOR &lt;reg_name&gt;(1));
      end if;
   end if;
end process;

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Decoders" treetype="folder">
				<Template label="4-bit Registered Output" treetype="template">
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if ( &lt;reset&gt; = '1') then
         &lt;output&gt; &lt;= "0000";
      else
         case &lt;input&gt; is
            when "00" =&gt; &lt;output&gt; &lt;= "0001";
            when "01" =&gt; &lt;output&gt; &lt;= "0010";
            when "10" =&gt; &lt;output&gt; &lt;= "0100";
            when "11" =&gt; &lt;output&gt; &lt;= "1000";
            when others =&gt; &lt;output&gt; &lt;= "0000";
         end case;
      end if;
   end if;
end process;

				</Template>
				<Template label="8-bit Registered Output" treetype="template">
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if ( &lt;reset&gt; = '1') then
         &lt;output&gt; &lt;= "00000000";
      else
         case &lt;input&gt; is
            when "000" =&gt; &lt;output&gt; &lt;= "00000001";
            when "001" =&gt; &lt;output&gt; &lt;= "00000010";
            when "010" =&gt; &lt;output&gt; &lt;= "00000100";
            when "011" =&gt; &lt;output&gt; &lt;= "00001000";
            when "100" =&gt; &lt;output&gt; &lt;= "00010000";
            when "101" =&gt; &lt;output&gt; &lt;= "00100000";
            when "110" =&gt; &lt;output&gt; &lt;= "01000000";
            when "111" =&gt; &lt;output&gt; &lt;= "10000000";
            when others =&gt; &lt;output&gt; &lt;= "00000000";
         end case;
      end if;
   end if;
end process;


				</Template>
			</SubFolder>
			<SubFolder label="DSP" treetype="folder">
				<Template label="Complex Multiplier" treetype="template">
--  Complex Multilier
--  The following code implements a parameterizable complex multiplier
--  The style described uses 3 DSP's to implement the complex multiplier
--  taking advantage of the pre-adder, so widths chosen should be less
--  than what the architecture supports or else extra-logic/extra DSPs
--  will be inferred

--  Below libraries need to be used
--  library ieee;
--  use ieee.std_logic_1164.all;
--  use ieee.numeric_std.all;
constant AWIDTH : natural := &lt;awidth&gt;; -- size of 1st input of multiplier
constant BWIDTH : natural := &lt;bwidth&gt;  -- size of 2nd input of multiplier
signal &lt;clk&gt;: std_logic;
signal &lt;ar&gt; : std_logic_vector(AWIDTH-1 downto 0); -- 1st input's real part
signal &lt;ai&gt; : std_logic_vector(AWIDTH-1 downto 0); -- 1st input's imaginary part
signal &lt;br&gt; : std_logic_vector(BWIDTH-1 downto 0); -- 2nd input's real part
signal &lt;bi&gt; : std_logic_vector(BWIDTH-1 downto 0); -- 2nd input's imaginary part
signal &lt;pr&gt; : std_logic_vector(AWIDTH+BWIDTH downto 0);  -- real part of output
signal &lt;pi&gt; : std_logic_vector(AWIDTH+BWIDTH downto 0)); -- imaginary part of output

-- Insert the below before begin keyword in architecture
signal &lt;ai_d&gt;, &lt;ai_dd&gt;, &lt;ai_ddd&gt;, &lt;ai_dddd&gt;                 : signed(AWIDTH-1 downto 0);
signal &lt;ar_d&gt;, &lt;ar_dd&gt;, &lt;ar_ddd&gt;, &lt;ar_dddd&gt;                 : signed(AWIDTH-1 downto 0);
signal &lt;bi_d&gt;, &lt;bi_dd&gt;, &lt;bi_ddd&gt;, &lt;br_d&gt;, &lt;br_dd&gt;, &lt;br_ddd&gt; : signed(BWIDTH-1 downto 0);
signal &lt;addcommon&gt;                                          : signed(AWIDTH downto 0);
signal &lt;addr&gt;, &lt;addi&gt;                                       : signed(BWIDTH downto 0);
signal &lt;mult0&gt;, &lt;multr&gt;, &lt;multi&gt;, &lt;pr_int&gt;, &lt;pi_int&gt;        : signed(AWIDTH+BWIDTH downto 0);
signal &lt;common&gt;, &lt;commonr1&gt;, &lt;commonr2&gt;                     : signed(AWIDTH+BWIDTH downto 0);

-- Insert the below after begin keyword in architecture
process(&lt;clk&gt;)
 begin
   if rising_edge(&lt;clk&gt;) then
      &lt;ar_d&gt;   &lt;= signed(&lt;ar&gt;);
      &lt;ar_dd&gt;  &lt;= signed(&lt;ar_d&gt;);
      &lt;ai_d&gt;   &lt;= signed(&lt;ai&gt;);
      &lt;ai_dd&gt;  &lt;= signed(&lt;ai_d&gt;);
      &lt;br_d&gt;   &lt;= signed(&lt;br&gt;);
      &lt;br_dd&gt;  &lt;= signed(&lt;br_d&gt;);
      &lt;br_ddd&gt; &lt;= signed(&lt;br_dd&gt;);
      &lt;bi_d&gt;   &lt;= signed(&lt;bi&gt;);
      &lt;bi_dd&gt;  &lt;= signed(&lt;bi_d&gt;);
      &lt;bi_ddd&gt; &lt;= signed(&lt;bi_dd&gt;);
   end if;
end process;

-- Common factor (ar - ai) x bi, shared for the calculations
-- of the real and imaginary final products.
--
process(&lt;clk&gt;)
 begin
  if rising_edge(&lt;clk&gt;) then
      &lt;addcommon&gt; &lt;= resize(&lt;ar_d&gt;, AWIDTH+1) - resize(&lt;ai_d&gt;, AWIDTH+1);
      &lt;mult0&gt;     &lt;= &lt;addcommon&gt; * &lt;bi_dd&gt;;
      &lt;common&gt;    &lt;= &lt;mult0&gt;;
 end if;
end process;

-- Real product
process(&lt;clk&gt;)
 begin
  if rising_edge(&lt;clk&gt;) then
      &lt;ar_ddd&gt;   &lt;= &lt;ar_dd&gt;;
      &lt;ar_dddd&gt;  &lt;= &lt;ar_ddd&gt;;
      &lt;addr&gt;     &lt;= resize(&lt;br_ddd&gt;, BWIDTH+1) - resize(&lt;bi_ddd&gt;, BWIDTH+1);
      &lt;multr&gt;    &lt;= &lt;addr&gt; * &lt;ar_dddd&gt;;
      &lt;commonr1&gt; &lt;= &lt;common&gt;;
      &lt;pr_int&gt;   &lt;= &lt;multr&gt; + &lt;commonr1&gt;;
  end if;
end process;

-- Imaginary product
--
process(&lt;clk&gt;)
 begin
  if rising_edge(&lt;clk&gt;) then
      &lt;ai_ddd&gt;   &lt;= &lt;ai_dd&gt;;
      &lt;ai_dddd&gt;  &lt;= &lt;ai_ddd&gt;;
      &lt;addi&gt;     &lt;= resize(&lt;br_ddd&gt;, BWIDTH+1) + resize(&lt;bi_ddd&gt;, BWIDTH+1);
      &lt;multi&gt;    &lt;= &lt;addi&gt; * &lt;ai_dddd&gt;;
      &lt;commonr2&gt; &lt;= &lt;common&gt;;
      &lt;pi_int&gt;   &lt;= &lt;multi&gt; + &lt;commonr2&gt;;
  end if;
end process;

&lt;pr&gt; &lt;= std_logic_vector(&lt;pr_int&gt;);
&lt;pi&gt; &lt;= std_logic_vector(&lt;pi_int&gt;);


				</Template>
				<Template label="Convergent Rounding(Even)" treetype="template">
-- This example shows how to infer Convergent Rounding
-- (Even) using pattern detect within DSP block
-- (Width of the inputs should be within what can be supported by the DSP architecture)
-- Following libraries have to be used
-- library ieee;
-- use ieee.std_logic_1164.all;
-- use ieee.numeric_std.all;

signal &lt;clk&gt;   :  std_logic;  --clock input
signal &lt;a&gt;     :  std_logic_vector (23 downto 0); -- First input
signal &lt;b&gt;     :  std_logic_vector (15 downto 0); -- Second input
signal &lt;zlast&gt; :  std_logic_vector (23 downto 0); -- Convergent Rounding output

-- Insert the following before the 'begin' keyword
-- Declare intermediate values
  signal &lt;ar&gt; : signed(&lt;a&gt;'range);
  signal &lt;br&gt; : signed(&lt;b&gt;'range);
  signal &lt;z1&gt; : signed(&lt;a&gt;'length + &lt;b&gt;'length - 1 downto 0);

  signal &lt;multaddr&gt;       : signed(&lt;a&gt;'length + &lt;b&gt;'length - 1 downto 0);
  signal &lt;multadd&gt;        : signed(&lt;a&gt;'length + &lt;b&gt;'length - 1 downto 0);
  signal &lt;pattern_detect&gt; : boolean;

  constant &lt;pattern&gt; : signed(15 downto 0) := (others =&gt; '0');
  constant &lt;c&gt; : signed := "0000000000000000000000000111111111111111";

  -- Convergent Rounding: LSB Correction Technique
  -- ---------------------------------------------
  -- For static convergent rounding, the pattern detector can be used
  -- to detect the midpoint case. For example, in an 8-bit round, if
  -- the decimal place is set at 4, the C input should be set to
  -- 0000.0111.  Round to even rounding should use CARRYIN = "1" and
  -- check for PATTERN "XXXX.0000" and replace the units place with 0
  -- if the pattern is matched. See UG193 for more details.

-- Insert the following after the begin keyword
  &lt;multadd&gt; &lt;= &lt;z1&gt; + &lt;c&gt;;

  process(&lt;clk&gt;)
  begin
    if rising_edge(&lt;clk&gt;) then
      &lt;ar&gt;       &lt;= signed(&lt;a&gt;);
      &lt;br&gt;       &lt;= signed(&lt;b&gt;);
      &lt;z1&gt;       &lt;= &lt;ar&gt; * &lt;br&gt;;
      &lt;multaddr&gt; &lt;= &lt;multadd&gt;;
      if &lt;multadd&gt;(15 downto 0) = &lt;pattern&gt; then
        &lt;pattern_detect&gt; &lt;= true;
      else
        &lt;pattern_detect&gt; &lt;= false;
      end if;
    end if;
  end process;

  -- Unit bit replaced with 0 if pattern is detected
  process(&lt;clk&gt;)
  begin
    if rising_edge(&lt;clk&gt;) then
      if &lt;pattern_detect&gt; = true then
        &lt;zlast&gt; &lt;= std_logic_vector(&lt;multaddr&gt;(39 downto 17)) &amp; "0";
      else
        &lt;zlast&gt; &lt;= std_logic_vector(&lt;multaddr&gt;(39 downto 16));
      end if;
    end if;
  end process;
				</Template>
				<Template label="Convergent Rounding(Odd)" treetype="template">
-- This example shows how to infer Convergent Rounding (Odd)
-- using pattern detect within DSP block (Width of the inputs
-- should be within what can be supported by the DSP architecture)
-- Following libraries have to be used
-- library ieee;
-- use ieee.std_logic_1164.all;
-- use ieee.numeric_std.all;
signal &lt;clk&gt;   :  std_logic;  --clock input
signal &lt;a&gt;     :  std_logic_vector (23 downto 0); -- First input
signal &lt;b&gt;     :  std_logic_vector (15 downto 0); -- Second input
signal &lt;zlast&gt; :  std_logic_vector (23 downto 0); -- Convergent Rounding output

-- Insert the following before the 'begin' keyword
-- Declare intermediate values
  signal &lt;ar&gt; : signed(&lt;a&gt;'range);
  signal &lt;br&gt; : signed(&lt;b&gt;'range);
  signal &lt;z1&gt; : signed(&lt;a&gt;'length + &lt;b&gt;'length - 1 downto 0);

  signal &lt;multadd&gt;, &lt;multaddr&gt; : signed(&lt;a&gt;'length + &lt;b&gt;'length - 1 downto 0);
  signal &lt;pattern_detect&gt;    : boolean;

  &lt;constant&gt; &lt;pattern&gt; : signed(15 downto 0) := (others =&gt; '1');
  &lt;constant&gt; &lt;c&gt;       : signed := "0000000000000000000000000111111111111111";

  -- Convergent Rounding: LSB Correction Technique
  -- ---------------------------------------------
  -- For static convergent rounding,  the pattern detector can be
  -- used to detect  the midpoint case. For example,  in an 8-bit
  -- round, if the decimal place is  set at 4, the C input should
  -- be  set to  0000.0111.   Round to  odd  rounding should  use
  -- CARRYIN =  "0" and  check for  PATTERN "XXXX.1111"  and then
  -- replace  the  units place  bit  with  1  if the  pattern  is
  -- matched. See UG193 for details

-- Insert the following after the 'begin' keyword
  &lt;multadd&gt; &lt;= &lt;z1&gt; + &lt;c&gt;;

  process(&lt;clk&gt;)
  begin
    if rising_edge(&lt;clk&gt;) then
      &lt;ar&gt;       &lt;= signed(&lt;a&gt;);
      &lt;br&gt;       &lt;= signed(&lt;b&gt;);
      &lt;z1&gt;       &lt;= &lt;ar&gt; * &lt;br&gt;;
      &lt;multaddr&gt; &lt;= &lt;multadd&gt;;
      if &lt;multadd&gt;(15 downto 0) = &lt;pattern&gt; then
        &lt;pattern_detect&gt; &lt;= &lt;true&gt;;
      else
        &lt;pattern_detect&gt; &lt;= &lt;false&gt;;
      end if;
    end if;
  end process;

  process(&lt;clk&gt;)
  begin
    if rising_edge(&lt;clk&gt;) then
      if &lt;pattern_detect&gt; = &lt;true&gt; then
        &lt;zlast&gt; &lt;= std_logic_vector(&lt;multaddr&gt;(39 downto 17)) &amp; "1";
      else
        &lt;zlast&gt; &lt;= std_logic_vector(&lt;multaddr&gt;(39 downto 16));
      end if;
    end if;
  end process;

				</Template>
				<Template label="Dynamic preadd sub followed by mult add" treetype="template">
-- This module describes a dynamic pre add/sub followed by multiplier, adder
-- Make sure the widths are less than what is supported by the architecture
-- Following libraries have to be used
-- library ieee;
-- use ieee.std_logic_1164.all;
-- use ieee.numeric_std.all;
constant AWIDTH : natural := 12;
constant BWIDTH : natural := 16;
constant CWIDTH : natural := 17;
signal	&lt;clk&gt;    :  std_logic;  -- clock input
signal	&lt;subadd&gt; :  std_logic;  -- Dynamic subadd control
signal	&lt;ain&gt;    :  std_logic_vector(AWIDTH - 1 downto 0);
signal	&lt;bin&gt;    :  std_logic_vector(BWIDTH - 1 downto 0);
signal	&lt;cin&gt;    :  std_logic_vector(CWIDTH - 1 downto 0);
signal	&lt;din&gt;    :  std_logic_vector(BWIDTH + CWIDTH downto 0);
signal	&lt;pout&gt;   :  std_logic_vector(BWIDTH + CWIDTH downto 0)

-- Insert the following before the 'begin' keyword
-- Declare intermediate values
signal &lt;a&gt;          : signed(AWIDTH - 1 downto 0);
signal &lt;b&gt;          : signed(BWIDTH - 1 downto 0);
signal &lt;c&gt;          : signed(CWIDTH - 1 downto 0);
signal &lt;add&gt;        : signed(BWIDTH downto 0);
signal &lt;d&gt;, &lt;mult&gt;, &lt;p&gt; : signed(BWIDTH + CWIDTH downto 0);
-- Insert the following after the 'begin' keyword 
process(&lt;clk&gt;)
begin
	if rising_edge(&lt;clk&gt;) then
		&lt;a&gt; &lt;= signed(&lt;ain&gt;);
		&lt;b&gt; &lt;= signed(&lt;bin&gt;);
		&lt;c&gt; &lt;= signed(&lt;cin&gt;);
		&lt;d&gt; &lt;= signed(&lt;din&gt;);
		if &lt;subadd&gt; = '1' then
			&lt;add&gt; &lt;= resize(&lt;a&gt;, BWIDTH + 1) - resize(&lt;b&gt;, BWIDTH + 1);
		else
			&lt;add&gt; &lt;= resize(&lt;a&gt;, BWIDTH + 1) + resize(&lt;b&gt;, BWIDTH + 1);
		end if;
		&lt;mult&gt; &lt;= &lt;add&gt; * &lt;c&gt;;
		&lt;p&gt;    &lt;= &lt;mult&gt; + &lt;d&gt;;
	end if;
end process;

--
-- Type conversion for output
--
&lt;pout&gt; &lt;= std_logic_vector(&lt;p&gt;);

				</Template>
				<Template label="Multiply and accumulate" treetype="template">
--  Multiply-accumulate unit
--  The following code implements a parameterizable Multiply-accumulate unit
--  with synchronous load to reset the accumulator without losing a clock cycle
--  Size of inputs/output should be less than/equal to what is supported by the architecture else extra logic/dsps will be inferred
--  Below libraries need to be used
--  library ieee;
--  use ieee.std_logic_1164.all;
--  use ieee.numeric_std.all;

constant &lt;SIZEIN&gt;  : natural := &lt;sizein&gt;;  -- Input size
constant &lt;SIZEOUT&gt; : natural := &lt;sizeout&gt;; -- Output size
signal &lt;clk&gt;         : in std_logic;  -- Clock
signal &lt;ce&gt;          : in std_logic;  -- clock enable
signal &lt;sload&gt;       : in  std_logic; -- synchronous load
signal &lt;a&gt;           : in  signed (SIZEIN-1 downto 0);  -- 1st input to MACC
signal &lt;b&gt;           : in  signed (SIZEIN-1 downto 0);  -- 2nd input to MACC
signal &lt;accum_out&gt;   : out signed (SIZEOUT-1 downto 0); -- MACC output

-- Insert the below before begin keyword in architecture

-- Declare registers for intermediate values
signal &lt;a_reg&gt;, &lt;b_reg&gt;           : signed (&lt;SIZEIN&gt;-1 downto 0);
signal &lt;sload_reg&gt;                : std_logic;
signal &lt;mult_reg&gt;                 : signed (2*&lt;SIZEIN&gt;-1 downto 0);
signal &lt;adder_out&gt;, &lt;old_result&gt;  : signed (&lt;SIZEOUT&gt;-1 downto 0);

-- Insert the below after begin keyword in architecture

process (&lt;adder_out&gt;, &lt;sload_reg&gt;)
 begin
  if &lt;sload_reg&gt; = '1' then
      &lt;old_result&gt; &lt;= (others =&gt; '0');
  else
      -- 'sload' is now active (=low) and opens the accumulation loop.
      -- The accumulator takes the next multiplier output in
      -- the same cycle.
      &lt;old_result&gt; &lt;= &lt;adder_out&gt;;
  end if;
end process;

process (&lt;clk&gt;)
 begin
  if rising_edge(&lt;clk&gt;) then
    if &lt;ce&gt; = '1' then
        &lt;a_reg&gt;     &lt;= &lt;a&gt;;
        &lt;b_reg&gt;     &lt;= &lt;b&gt;;
        &lt;mult_reg&gt;  &lt;= &lt;a_reg&gt; * &lt;b_reg&gt;;
        &lt;sload_reg&gt; &lt;= &lt;sload&gt;;
        -- Store accumulation result into a register
        &lt;adder_out&gt; &lt;= &lt;old_result&gt; + &lt;mult_reg&gt;;
    end if;
  end if;
end process;

 -- Output accumulation result
  &lt;accum_out&gt; &lt;= &lt;adder_out&gt;;
				</Template>
				<Template label="Pre-subtractor with multiplication" treetype="template">
-- This code implements a parameterizable subtractor followed by multiplier which will be packed into DSP Block. Widths must be less than or equal to what is supported by the DSP block else exta logic will be inferred
-- Operation : (a-b) * c
-- Following libraries have to be used
-- library ieee;
-- use ieee.std_logic_1164.all;
-- use ieee.numeric_std.all;
constant AWIDTH : natural := &lt;awidth&gt;;  -- Width of A input
constant BWIDTH : natural := &lt;bwidth&gt;;  -- Width of B input
constant CWIDTH : natural := &lt;cwidth&gt;;  -- Width of C input

signal &lt;clk&gt;  :  std_logic;     -- Clock
signal &lt;ain&gt;  :  std_logic_vector(AWIDTH-1 downto 0); -- A input
signal &lt;bin&gt;  :  std_logic_vector(BWIDTH-1 downto 0); -- B input
signal &lt;cin&gt;  :  std_logic_vector(CWIDTH-1 downto 0); -- C input
signal &lt;pout&gt; :  std_logic_vector(BWIDTH+CWIDTH downto 0); -- Output

-- Insert the below before begin keyword in architecture
signal &lt;a&gt;         : signed(AWIDTH-1 downto 0);
signal &lt;b&gt;         : signed(BWIDTH-1 downto 0);
signal &lt;c&gt;         : signed(CWIDTH-1 downto 0);
signal &lt;add&gt;       : signed(BWIDTH downto 0);
signal &lt;mult&gt;, &lt;p&gt; : signed(BWIDTH+CWIDTH downto 0);

-- Insert the below after begin keyword in architecture
process(&lt;clk&gt;)
 begin
  if rising_edge(&lt;clk&gt;) then
      &lt;a&gt;    &lt;= signed(&lt;ain&gt;);
      &lt;b&gt;    &lt;= signed(&lt;bin&gt;);
      &lt;c&gt;    &lt;= signed(&lt;cin&gt;);
      &lt;add&gt;  &lt;= resize(&lt;a&gt;, BWIDTH+1) - resize(&lt;b&gt;, BWIDTH+1);
      &lt;mult&gt; &lt;= &lt;add&gt; * &lt;c&gt;;
      &lt;p&gt;    &lt;= &lt;mult&gt;;
  end if;
end process;

--
-- Type conversion for output
--
&lt;pout&gt; &lt;= std_logic_vector(&lt;p&gt;);

				</Template>
				<Template label="Squarer" treetype="template">
-- This module implements a parameterizable (a-b) squarer
-- which can be implemented in a DSP48E2(ultrascale) by using the pre-adder
-- The size should be less than or equal to what is supported
-- by the architecture
-- Following libraries have to be used
-- library ieee;
-- use ieee.std_logic_1164.all;
-- use ieee.numeric_std.all;
constant SIZEIN : natural := &lt;sizein&gt;;  -- Size of the inputs
signal &lt;clk&gt; :   std_logic;     -- clock
signal &lt;ce&gt;  :   std_logic;     -- clock enable
signal &lt;rst&gt; :   std_logic;     -- reset
signal &lt;ain&gt; :   std_logic_vector(SIZEIN-1 downto 0); -- Input a
signal &lt;bin&gt; :   std_logic_vector(SIZEIN-1 downto 0); -- Input b
signal &lt;square_out&gt;  :  std_logic_vector(2*SIZEIN+1 downto 0); -- output result

-- Insert the following before the 'begin' keyword
-- Declare intermediate values
signal &lt;a_reg&gt;, &lt;b_reg&gt; : signed(SIZEIN-1 downto 0);
signal &lt;diff_reg&gt;     : signed(SIZEIN downto 0);
signal &lt;m_reg&gt;, &lt;p_reg&gt; : signed(2*SIZEIN+1 downto 0);

-- Insert the following after the begin keyword

process(&lt;clk&gt;)
 begin
  if rising_edge(&lt;clk&gt;) then
   if &lt;rst&gt; = '1' then
      &lt;a_reg&gt;    &lt;= (others =&gt; '0');
      &lt;b_reg&gt;    &lt;= (others =&gt; '0');
      &lt;diff_reg&gt; &lt;= (others =&gt; '0');
      &lt;m_reg&gt;    &lt;= (others =&gt; '0');
      &lt;p_reg&gt;    &lt;= (others =&gt; '0');
    else
      &lt;a_reg&gt;    &lt;= signed(&lt;ain&gt;);
      &lt;b_reg&gt;    &lt;= signed(&lt;bin&gt;);
      &lt;diff_reg&gt; &lt;= resize(&lt;a_reg&gt;, SIZEIN+1) - resize(&lt;b_reg&gt;, SIZEIN+1);
      &lt;m_reg&gt;    &lt;= &lt;diff_reg&gt; * &lt;diff_reg&gt;;
      &lt;p_reg&gt;    &lt;= &lt;m_reg&gt;;
    end if;
  end if;
end process;

--
-- Type conversion for output
--
&lt;square_out&gt; &lt;= std_logic_vector(&lt;p_reg&gt;);
				</Template>
			</SubFolder>
			<SubFolder label="Encoders" treetype="folder">
				<Template label="4-bit Registered Output" treetype="template">
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if (&lt;reset&gt; = '1') then
         &lt;output&gt; &lt;= "00";
      else
         case &lt;input&gt; is
            when "0001" =&gt; &lt;output&gt; &lt;= "00";
            when "0010" =&gt; &lt;output&gt; &lt;= "01";
            when "0100" =&gt; &lt;output&gt; &lt;= "10";
            when "1000" =&gt; &lt;output&gt; &lt;= "11";
            when others =&gt; &lt;output&gt; &lt;= "00";
         end case;
      end if;
   end if;
end process;



				</Template>
				<Template label="8-bit Regsitered Output" treetype="template">
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      if ( &lt;reset&gt; = '1') then
         &lt;output&gt; &lt;= "000";
      else
         case &lt;input&gt; is
            when "00000001" =&gt; &lt;output&gt; &lt;= "000";
            when "00000010" =&gt; &lt;output&gt; &lt;= "001";
            when "00000100" =&gt; &lt;output&gt; &lt;= "010";
            when "00001000" =&gt; &lt;output&gt; &lt;= "011";
            when "00010000" =&gt; &lt;output&gt; &lt;= "100";
            when "00100000" =&gt; &lt;output&gt; &lt;= "101";
            when "01000000" =&gt; &lt;output&gt; &lt;= "110";
            when "10000000" =&gt; &lt;output&gt; &lt;= "111";
            when others =&gt; &lt;output&gt; &lt;= "000";
         end case;
      end if;
   end if;
end process;


				</Template>
			</SubFolder>
			<SubFolder label="Flip Flops" treetype="folder">
				<Template label="Coding Example" treetype="template">
library ieee;
use ieee.std_logic_1164.all;

entity registers_1 is
    port(C, D : in std_logic;
         Q    : out std_logic);
end registers_1;

architecture archi of registers_1 is
begin
    process (C)
    begin
        if (C'event and C='1') then
            Q &lt;= D;
        end if;
    end process;
end archi;

				</Template>
				<SubFolder label="D Flip Flop" treetype="folder">
					<SubFolder label="Negedge" treetype="folder">
						<Template label="Simple Register" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      &lt;output&gt; &lt;= &lt;input&gt;;
   end if;
end process;

						</Template>
						<Template label="w/ Synchronous Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      if &lt;reset&gt;='1' then
         &lt;output&gt; &lt;= '0';
      else
         &lt;output&gt; &lt;= &lt;input&gt;;
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active High Reset and CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      if &lt;reset&gt;='1' then
         &lt;output&gt; &lt;= '0';
      elsif &lt;clock_enable&gt; ='1' then
         &lt;output&gt; &lt;= &lt;input&gt;;
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      if &lt;reset&gt;='0' then
         &lt;output&gt; &lt;= '0';
      else
         &lt;output&gt; &lt;= &lt;input&gt;;
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active Low Reset and CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      if &lt;reset&gt;='0' then
         &lt;output&gt; &lt;= '0';
      elsif &lt;clock_enable&gt; ='1' then
         &lt;output&gt; &lt;= &lt;input&gt;;
      end if;
   end if;
end process;



						</Template>
					</SubFolder>
					<SubFolder label="Posedge" treetype="folder">
						<Template label="Simple Register" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      &lt;output&gt; &lt;= &lt;input&gt;;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt;='1' then
         &lt;output&gt; &lt;= '0';
      else
         &lt;output&gt; &lt;= &lt;input&gt;;
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active High Reset and CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt;='1' then
         &lt;output&gt; &lt;= '0';
      elsif &lt;clock_enable&gt; ='1' then
         &lt;output&gt; &lt;= &lt;input&gt;;
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt;='0' then
         &lt;output&gt; &lt;= '0';
      else
         &lt;output&gt; &lt;= &lt;input&gt;;
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active Low Reset and CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt;='0' then
         &lt;output&gt; &lt;= '0';
      elsif &lt;clock_enable&gt; ='1' then
         &lt;output&gt; &lt;= &lt;input&gt;;
      end if;
   end if;
end process;



						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="T Flip Flop" treetype="folder">
					<SubFolder label="Negedge" treetype="folder">
						<Template label="Simple Register" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      &lt;output&gt; &lt;= not(&lt;output&gt;);
   end if;
end process;



						</Template>
						<Template label="w/ Synchronous Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      if &lt;reset&gt;='1' then
         &lt;output&gt; &lt;= '0';
      else
         &lt;output&gt; &lt;= not(&lt;output&gt;);
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active High Reset and CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      if &lt;reset&gt;='1' then
         &lt;output&gt; &lt;= '0';
      elsif &lt;clock_enable&gt; ='1' then
         &lt;output&gt; &lt;= not(&lt;output&gt;);
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      if &lt;reset&gt;='0' then
         &lt;output&gt; &lt;= '0';
      else
         &lt;output&gt; &lt;= not(&lt;output&gt;);
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active Low Reset and CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='0' then
      if &lt;reset&gt;='0' then
         &lt;output&gt; &lt;= '0';
      elsif &lt;clock_enable&gt; ='1' then
         &lt;output&gt; &lt;= not(&lt;output&gt;);
      end if;
   end if;
end process;



						</Template>
					</SubFolder>
					<SubFolder label="Posedge" treetype="folder">
						<Template label="Simple Register" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      &lt;output&gt; &lt;= not(&lt;output&gt;);
   end if;
end process;

						</Template>
						<Template label="w/ Synchronous Active High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt;='1' then
         &lt;output&gt; &lt;= '0';
      else
         &lt;output&gt; &lt;= not(&lt;output&gt;);
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active High Reset and CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt;='1' then
         &lt;output&gt; &lt;= '0';
      elsif &lt;clock_enable&gt; ='1' then
         &lt;output&gt; &lt;= not(&lt;output&gt;);
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt;='0' then
         &lt;output&gt; &lt;= '0';
      else
         &lt;output&gt; &lt;= not(&lt;output&gt;);
      end if;
   end if;
end process;


						</Template>
						<Template label="w/ Synchronous Active Low Reset and CE" treetype="template">
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt;='0' then
         &lt;output&gt; &lt;= '0';
      elsif &lt;clock_enable&gt; ='1' then
         &lt;output&gt; &lt;= not(&lt;output&gt;);
      end if;
   end if;
end process;



						</Template>
					</SubFolder>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Logical Shifters" treetype="folder">
				<Template label="2-bit Select" treetype="template">
--Input and Output need to be type unsigned
--use IEEE.numeric_std.all;
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      case &lt;selector&gt; is
         when "00" =&gt; &lt;output&gt; &lt;= &lt;input&gt; ;
         when "01" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 1;
         when "10" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 2;
         when "11" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 3;
         when others =&gt; &lt;output&gt; &lt;= &lt;input&gt; ;
      end case;
   end if;
end process;

				</Template>
				<Template label="3-bit Select" treetype="template">
--Input and Output need to be type unsigned
--use IEEE.numeric_std.all;
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      case &lt;selector&gt; is
         when "000" =&gt; &lt;output&gt; &lt;= &lt;input&gt; ;
         when "001" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 1;
         when "010" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 2;
         when "011" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 3;
         when "100" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 4;
         when "101" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 5;
         when "110" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 6;
         when "111" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 7;
         when others =&gt; &lt;output&gt; &lt;= &lt;input&gt; ;
      end case;
   end if;
end process;


				</Template>
				<Template label="4-bit Select" treetype="template">
--Input and Output need to be type unsigned
--use IEEE.numeric_std.all;
process(&lt;clock&gt;)
begin
   if ( &lt;clock&gt;'event and &lt;clock&gt; ='1') then
      case &lt;selector&gt; is
         when "0000" =&gt; &lt;output&gt; &lt;= &lt;input&gt; ;
         when "0001" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 1;
         when "0010" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 2;
         when "0011" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 3;
         when "0100" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 4;
         when "0101" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 5;
         when "0110" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 6;
         when "0111" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 7;
         when "1000" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 8;
         when "1001" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 9;
         when "1010" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 10;
         when "1011" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 11;
         when "1100" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 12;
         when "1101" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 13;
         when "1110" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 14;
         when "1111" =&gt; &lt;output&gt; &lt;= &lt;input&gt; sll 15;
         when others =&gt; &lt;output&gt; &lt;= &lt;input&gt; ;
      end case;
   end if;
end process;

				</Template>
				<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity logical_shifters_1 is
    port(CLK : in std_logic;
         DI : in unsigned(7 downto 0);
         SEL : in unsigned(1 downto 0);
         SO : out unsigned(7 downto 0));
end logical_shifters_1;

architecture archi of logical_shifters_1 is
   process (CLK)
   begin
      if (CLK'event and CLK = '1') then
         case s is
            when "00" =&gt; SO &lt;= DI ;
            when "01" =&gt; SO &lt;= DI sll 1;
            when "10" =&gt; S0 &lt;= DI sll 2;
            when "11" =&gt; SO &lt;= DI sll 3;
            when others =&gt; SO &lt;= DI ;
         end case;
      end if;
   end process;
end archi;


				</Template>
			</SubFolder>
			<SubFolder label="Misc" treetype="folder">
				<Template label="7-Segment Display Hex Conversion" treetype="template">
--HEX-to-seven-segment decoder
--   HEX:   in    STD_LOGIC_VECTOR (3 downto 0);
--   LED:   out   STD_LOGIC_VECTOR (6 downto 0);
--
-- segment encoinputg
--      0
--     ---
--  5 |   | 1
--     ---   &lt;- 6
--  4 |   | 2
--     ---
--      3

    with HEX SELect
   LED&lt;= "1111001" when "0001",   --1
         "0100100" when "0010",   --2
         "0110000" when "0011",   --3
         "0011001" when "0100",   --4
         "0010010" when "0101",   --5
         "0000010" when "0110",   --6
         "1111000" when "0111",   --7
         "0000000" when "1000",   --8
         "0010000" when "1001",   --9
         "0001000" when "1010",   --A
         "0000011" when "1011",   --b
         "1000110" when "1100",   --C
         "0100001" when "1101",   --d
         "0000110" when "1110",   --E
         "0001110" when "1111",   --F
         "1000000" when others;   --0


				</Template>
				<Template label="Asynchronous Input Synchronization (Reduces Issues w/ Metastability)" treetype="template">
-- Asynchronous Input Synchronization
--
-- The following code is an example of synchronizing an asynchronous input
-- of a design to reduce the probability of metastability affecting a circuit.
--
-- The following synthesis and implementation attributes are added to the code
-- in order improve the MTBF characteristics of the implementation:
--
--  ASYNC_REG="TRUE" - Specifies registers will be receiving asynchronous data
--                     input to allow tools to report and improve metastability
--
-- The following constants are available for customization:
--
--   SYNC_STAGES     - Integer value for number of synchronizing registers, must be 2 or higher
--   PIPELINE_STAGES - Integer value for number of registers on the output of the
--                     synchronizer for the purpose of improveing performance.
--                     Particularly useful for high-fanout nets.
--   INIT            - Initial value of synchronizer registers upon startup, 1'b0 or 1'b1.

-- Insert the following before begin keyword of architecture
constant SYNC_STAGES : integer := 3;
constant PIPELINE_STAGES : integer := 1;
constant INIT : std_logic := '0';

signal &lt;sync_out&gt; : std_logic;  -- Synchronized output

signal sreg : std_logic_vector(SYNC_STAGES-1 downto 0) := (others =&gt; INIT);
attribute async_reg : string;
attribute async_reg of sreg : signal is "true";

signal sreg_pipe : std_logic_vector(PIPELINE_STAGES-1 downto 0) := (others =&gt; INIT);
attribute shreg_extract : string;
attribute shreg_extract of sreg_pipe : signal is "false";

-- Insert the following in the architecture after the begin keyword
   process(&lt;clk&gt;)
   begin
    if(&lt;clk&gt;'event and &lt;clk&gt;='1')then
       sreg &lt;= sreg(SYNC_STAGES-2 downto 0) &amp; &lt;async_in&gt;;  -- Async Input &lt;async_in&gt;
    end if;
   end process;

   no_pipeline : if PIPELINE_STAGES = 0 generate
   begin
      &lt;sync_out&gt; &lt;= sreg(SYNC_STAGES-1);
   end generate;

   one_pipeline : if PIPELINE_STAGES = 1 generate
   begin
    process(&lt;clk&gt;)
    begin
      if(&lt;clk&gt;'event and &lt;clk&gt;='1') then
        &lt;sync_out&gt; &lt;= sreg(SYNC_STAGES-1);
      end if;
    end process;
   end generate;

   multiple_pipeline : if PIPELINE_STAGES &gt; 1 generate
   begin
    process(&lt;clk&gt;)
    begin
      if(&lt;clk&gt;'event and &lt;clk&gt;='1') then
        sreg_pipe &lt;= sreg_pipe(PIPELINE_STAGES-2 downto 0) &amp; sreg(SYNC_STAGES-1);
      end if;
    end process;
    &lt;sync_out&gt; &lt;= sreg_pipe(PIPELINE_STAGES-1);
   end generate;

				</Template>
				<Template label="Barrel Shifter" treetype="template">
-- A Sample 16-bit barrel shifter code
-- This code can be cut and pasted to the design file
-- directly.

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity BARREL_SHIFT is

	port( DIN : in std_logic_vector(15 downto 0);
	      SHIFT_AMT   : in std_logic_vector(3 downto 0);
	      CLK, ENB : in std_logic;
	      DOUT : out std_logic_vector (15 downto 0));
end BARREL_SHIFT;

architecture RTL of BARREL_SHIFT is
signal DIN_BIT, DOUT_BIT : bit_vector (15 downto 0);
signal S_INT : integer;
begin
	DIN_BIT &lt;= to_bitvector(DIN);
	S_INT &lt;= TO_INTEGER(UNSIGNED(SHIFT_AMT));
	process(CLK)
	begin
	  if(CLK' event and CLK='1') then
	      if(ENB = '0') then
		      DOUT &lt;= DIN;
		   else
			   DOUT_BIT &lt;= DIN_BIT ror S_INT;
			   DOUT &lt;= to_stdlogicvector(DOUT_BIT);
		   end if;
	  end if;
	end process;
end RTL;

				</Template>
				<Template label="Debounce circuit" treetype="template">
--  Provides a one-shot pulse from a non-clock input, with reset
--**Insert the following between the 'architecture' and
---'begin' keywords**
signal Q1, Q2, Q3 : std_logic;

--**Insert the following after the 'begin' keyword**
process(&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; = '1') then
      if (&lt;reset&gt; = '1') then
         Q1 &lt;= '0';
         Q2 &lt;= '0';
         Q3 &lt;= '0';
      else
         Q1 &lt;= D_IN;
         Q2 &lt;= Q1;
         Q3 &lt;= Q2;
      end if;
   end if;
end process;

Q_OUT &lt;= Q1 and Q2 and (not Q3);


				</Template>
				<Template label="Open Drain Output (bused reg)" treetype="template">
      for i in 0 to &lt;upper_limit&gt; loop
         &lt;output&gt;(i) &lt;= 'Z' when &lt;internal_out&gt; = '1' else
                        '0';
      end loop;
				</Template>
				<Template label="Open Drain Output (single signal)" treetype="template">
   &lt;output&gt; &lt;= 'Z' when &lt;internal_out&gt; = '1' else
               '0';
				</Template>
				<Template label="Output Clock Forwarding Using DDR" treetype="template">
-- Place this code in the top-level HDL file
-- Before the 'begin' keyword

   signal &lt;output_clock&gt; : std_logic;
   signal &lt;internal_clock&gt; : std_logic;
   signal &lt;stop_clock&gt; : std_logic;
   signal &lt;hold_clock_low&gt; : std_logic;
   signal &lt;hold_clock_high&gt; : std_logic;

   -- Clock forwarding circuit using the double data-rate register
   --       7Series
   -- Xilinx HDL Language Template, version 2016.4

   ODDR_inst : ODDR
   generic map(
      DDR_CLK_EDGE =&gt; "OPPOSITE_EDGE", -- "OPPOSITE_EDGE" or "SAME_EDGE" 
      INIT =&gt; '0',   -- Initial value for Q port ('1' or '0')
      SRTYPE =&gt; "SYNC") -- Reset Type ("ASYNC" or "SYNC")
   port map (
      Q =&gt; &lt;output_clock&gt;,   -- 1-bit DDR output
      C =&gt; &lt;internal_clock&gt;,    -- 1-bit clock input
      CE =&gt; &lt;stop_clock&gt;,  -- 1-bit clock enable input
      D1 =&gt; '0',  -- 1-bit data input (positive edge)
      D2 =&gt; '1',  -- 1-bit data input (negative edge)
      R =&gt; &lt;hold_clock_low&gt;,    -- 1-bit reset input
      S =&gt; &lt;hold_clock_high&gt;     -- 1-bit set input
   );

   -- End of clock_forward_inst instantiation

				</Template>
				<Template label="Output Clock Forwarding Using DDR (Info)" treetype="template">
--  A common method for supplying an external clock from the FPGA to drive
--  other devices on the PCB board is to use clock forwarding via a double
--  data-rate register.  This provides an external clock with a relatively
--  small offset delay and does not consume any additional DLL/DCM/PLL/MMCM, clock
--  buffers or input pins.  The basic technique is to supply the input clock
--  to an output DDR register where one value is tied to a logic 0 and the
--  other is tied to a logic 1.  A clock can be made with the same phase
--  relationship (plus the added offset delay) or 180 degrees out of phase by
--  changing the 1 and 0 values to the inputs to the DDR register.  Set SRTYPE
--  to "SYNC" to avoid possible glitches on the clock if the set/reset signals
--  are used.  For FPGA architectures which use two separate clocks into the
--  DDR register, you may use a simple inversion of duty-cycle is not important
--  however for output clocks that you wish to retain the duty-cycle as much as
--  possible, it is suggested to supply a 0 degree and 180 degree clock from a
--  DLL/DCM/PLL/MMCM to the input clocks to the outpuit DDR component.

				</Template>
			</SubFolder>
			<SubFolder label="Multiplexers" treetype="folder">
				<Template label="2-to-1 (assign)" treetype="template">
&lt;output&gt; &lt;= &lt;input1&gt; WHEN &lt;selector&gt; ='1' ELSE
            &lt;input2&gt;;


				</Template>
				<Template label="4-to-1 (process)" treetype="template">
process (&lt;selector&gt;,&lt;input1&gt;,&lt;input2&gt;,&lt;input3&gt;,&lt;input4&gt;)
begin
   case &lt;selector&gt; is
      when "00" =&gt; &lt;output&gt; &lt;= &lt;input1&gt;;
      when "01" =&gt; &lt;output&gt; &lt;= &lt;input2&gt;;
      when "10" =&gt; &lt;output&gt; &lt;= &lt;input3&gt;;
      when "11" =&gt; &lt;output&gt; &lt;= &lt;input4&gt;;
      when others =&gt; &lt;output&gt; &lt;= &lt;input1&gt;;
   end case;
end process;


				</Template>
				<Template label="8-to-1 (process)" treetype="template">
process (&lt;selector&gt;,&lt;input1&gt;,&lt;input2&gt;,&lt;input3&gt;,&lt;input4&gt;,
         &lt;input5&gt;,&lt;input6&gt;,&lt;input7&gt;,&lt;input8&gt;)
begin
   case &lt;selector&gt; is
      when "000" =&gt; &lt;output&gt; &lt;= &lt;input1&gt;;
      when "001" =&gt; &lt;output&gt; &lt;= &lt;input2&gt;;
      when "010" =&gt; &lt;output&gt; &lt;= &lt;input3&gt;;
      when "011" =&gt; &lt;output&gt; &lt;= &lt;input4&gt;;
      when "100" =&gt; &lt;output&gt; &lt;= &lt;input5&gt;;
      when "101" =&gt; &lt;output&gt; &lt;= &lt;input6&gt;;
      when "110" =&gt; &lt;output&gt; &lt;= &lt;input7&gt;;
      when "111" =&gt; &lt;output&gt; &lt;= &lt;input8&gt;;
      when others =&gt; &lt;output&gt; &lt;= &lt;input1&gt;;
   end case;
end process;

				</Template>
				<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;

entity multiplexers_1 is
    port (A, B, C, D : in std_logic;
          S : in std_logic_vector (1 downto 0);
          O : out std_logic);
end multiplexers_1;

architecture archi of multiplexers_1 is
begin
    process (A, B, C, D, S)
    begin
      case s is
         when "00" =&gt; O &lt;= A;
         when "01" =&gt; O &lt;= B;
         when "10" =&gt; O &lt;= C;
         when "11" =&gt; O &lt;= D;
         when others =&gt; O &lt;= A;
      end case;
    end process;
end archi;
				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<Template label="Info" treetype="template">
-- In order for the RAM to be initialized using a FILE, the FILE should have the correct
-- syntax.

-- An example file that can be used to intialize memory is provided below
-- This example is for a 8x32-bit single port block RAM

00001111000011110000111100001111
01001010001000001100000010000100
00000000001111100000000001000001
11111101010000011100010000100100
00001111000011110000111100001111
01001010001000001100000010000100
00000000001111100000000001000001
11111101010000011100010000100100

					</Template>
					<SubFolder label="Simple Dual Port" treetype="folder">
						<Template label="1 Clock" treetype="template">
--  Xilinx Simple Dual Port Single Clock RAM
--  This code implements a parameterizable SDP single clock memory.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;


-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_RAM_WIDTH : integer := &lt;ram_width&gt;;            		-- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;ram_depth&gt;; 				        -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;; 		-- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;    				 -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : std_logic_vector((clogb2(C_RAM_DEPTH)-1) downto 0);     -- Write address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : std_logic_vector((clogb2(C_RAM_DEPTH)-1) downto 0);     -- Read address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);		  -- RAM input data
signal &lt;clka&gt;  : std_logic;                       			  -- Clock
signal &lt;wea&gt;   : std_logic;                       			  -- Write enable
signal &lt;enb&gt;   : std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
signal &lt;rstb&gt;  : std_logic;                       			  -- Output reset (does not affect memory contents)
signal &lt;regceb&gt;: std_logic;                       			  -- Output register enable
signal &lt;doutb&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0); 		  -- RAM output data

signal &lt;doutb_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal
signal &lt;ram_data&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware
function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
signal &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;wea&gt; = '1') then
            &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) &lt;= &lt;dina&gt;;
        end if;
        if(&lt;enb&gt; = '1') then
            &lt;ram_data&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;doutb&gt; &lt;= &lt;ram_data&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;
end generate;

						</Template>
						<Template label="1 Clock w/ Byte-write" treetype="template">
--  Xilinx Simple Dual Port Single Clock RAM with Byte-write
--  This code implements a parameterizable SDP single clock memory.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_NB_COL : integer := &lt;nb_col&gt;;		 	                 -- Specify number of colums (number of bytes)
constant C_COL_WIDTH : integer := &lt;col_width&gt;;		 	                 -- Specify colum width (byte width, typically 8 or 9)
constant C_RAM_DEPTH : integer := &lt;ram_depth&gt;; 				 -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;; 		 -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;    				 -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : std_logic_vector((clogb2(C_RAM_DEPTH)-1) downto 0);     -- Write address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : std_logic_vector((clogb2(C_RAM_DEPTH)-1) downto 0);     -- Read address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0);		  -- RAM input data
signal &lt;clka&gt;  : std_logic;                       			  -- Clock
signal &lt;wea&gt;   : std_logic_vector(C_NB_COL-1 downto 0);                       			  -- Write enable
signal &lt;enb&gt;   : std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
signal &lt;rstb&gt;   : std_logic;                       			  -- Output reset (does not affect memory contents)
signal &lt;regceb&gt;: std_logic;                       			  -- Output register enable
signal &lt;doutb&gt; : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0); 		  -- RAM output data

signal &lt;doutb_reg&gt; : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0) := (others =&gt; '0');
type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector ((C_NB_COL*C_COL_WIDTH)-1 downto 0);          -- 2D Array Declaration for RAM signal
signal &lt;ram_data&gt; : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
  if ramfile = "&lt;Init File Name&gt;" then
    return InitRamFromFile("&lt;Init File Name&gt;") ;
  else
    return (others =&gt; (others =&gt; '0'));
  end if;
end;

-- Define RAM
signal &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);
--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
  if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
    if(&lt;enb&gt; = '1') then
       &lt;ram_data&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
    end if;
  end if;
end process;

process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        for i in  0 to C_NB_COL-1 loop
            if(&lt;wea&gt;(i) = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)))(((i+1)*C_COL_WIDTH)-1 downto i*C_COL_WIDTH) &lt;= &lt;dina&gt;(((i+1)*C_COL_WIDTH)-1 downto i*C_COL_WIDTH);
            end if;
        end loop;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;doutb&gt; &lt;= &lt;ram_data&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing
output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;
end generate;

						</Template>
						<Template label="2 Clock" treetype="template">
--  Xilinx Simple Dual Port 2 Clock RAM
--  This code implements a parameterizable SDP dual clock memory.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_RAM_WIDTH : integer := &lt;ram_width&gt;;            		-- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;ram_depth&gt;; 				        -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;; 		-- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;    				      -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : in std_logic_vector((clogb2(C_RAM_DEPTH)-1) downto 0);     -- Write address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : in std_logic_vector((clogb2(C_RAM_DEPTH)-1) downto 0);     -- Read address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : in std_logic_vector(C_RAM_WIDTH-1 downto 0);		  -- RAM input data
signal &lt;clka&gt;  : in std_logic;                       			  -- Write Clock
signal &lt;clkb&gt;  : in std_logic;                       			  -- Read Clock
signal &lt;wea&gt;   : in std_logic;                       			  -- Write enable
signal &lt;enb&gt;   : in std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
signal &lt;rstb&gt;  : in std_logic;                       			  -- Output reset (does not affect memory contents)
signal &lt;regceb&gt;: in std_logic;                       			  -- Output register enable
signal &lt;doutb&gt; : out std_logic_vector(C_RAM_WIDTH-1 downto 0) 		  -- RAM output data

signal &lt;doutb_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal
signal &lt;ram_data&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Define RAM
signal &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;wea&gt; = '1') then
            &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) &lt;= &lt;dina&gt;;
        end if;
    end if;
end process;

process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            &lt;ram_data&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;doutb&gt; &lt;= &lt;ram_data&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing
output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;
end generate;

						</Template>
						<Template label="2 Clock w/ Byte-write" treetype="template">
--  Xilinx Simple Dual Port 2 Clock RAM with Byte-write
--  This code implements a parameterizable SDP dual clock memory.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_NB_COL : integer := &lt;nb_col&gt;;            		-- Specify number of colums (number of bytes)
constant C_COL_WIDTH : integer := &lt;col_width&gt;;   			-- Specify column width (byte width, typically 8 or 9)
constant C_RAM_DEPTH : integer := &lt;ram_depth&gt;; 				 -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;; 		 -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;    				 -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : std_logic_vector((clogb2(C_RAM_DEPTH)-1) downto 0);     -- Write address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : std_logic_vector((clogb2(C_RAM_DEPTH)-1) downto 0);     -- Read address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0);		  -- RAM input data
signal &lt;clka&gt;  : std_logic;                       			  -- Write Clock
signal &lt;clkb&gt;  : std_logic;                       			  -- Read Clock
signal &lt;wea&gt;   : std_logic_vector(C_NB_COL-1 downto 0);                       			  -- Write enable
signal &lt;enb&gt;   : std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
signal &lt;rstb&gt;  : std_logic;                       			  -- Output reset (does not affect memory contents)
signal &lt;regceb&gt;: std_logic;                       			  -- Output register enable
signal &lt;doutb&gt; : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0); 		  -- RAM output data

signal &lt;doutb_reg&gt; : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0) := (others =&gt; '0');
type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector ((C_NB_COL*C_COL_WIDTH)-1 downto 0);          -- 2D Array Declaration for RAM signal
signal &lt;ram_data&gt; : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Define RAM
signal &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            &lt;ram_data&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
        end if;
    end if;
end process;

process(&lt;clka&gt;) begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        for i in  0 to C_NB_COL-1 loop
            if(&lt;wea&gt;(i) = '1') then
                ram_name(to_integer(unsigned(&lt;addra&gt;)))(((i+1)*C_COL_WIDTH)-1 downto i*C_COL_WIDTH) &lt;= &lt;dina&gt;(((i+1)*C_COL_WIDTH)-1 downto i*C_COL_WIDTH);
            end if;
        end loop;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
  &lt;doutb&gt; &lt;= &lt;ram_data&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing
output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;
end generate;

						</Template>
					</SubFolder>
					<SubFolder label="Single Port" treetype="folder">
						<SubFolder label="Byte-wide Write Enable" treetype="folder">
							<Template label="Read First Mode" treetype="template">
--  Xilinx Single Port Byte-Write Read First RAM
--  This code implements a parameterizable single-port byte-write read-first memory where when data
--  is written to the memory, the output reflects the prior contents of the memory location.
--  If the output data is not needed during writes or the last read value is desired to be
--  retained, it is suggested to use Single Port.Byte-write Enable.No Change Mode template as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;

--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
  while temp &gt; 1 loop
    ret_val := ret_val + 1;
    temp    := temp / 2;
  end loop;

  return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_NB_COL     : integer := &lt;nb_col&gt;;                                                 -- Specify number of columns
constant C_COL_WIDTH  : integer := &lt;col_width&gt;;                                              -- Specify column width (byte width)
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)
signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                         -- RAM input data
signal &lt;clka&gt;  : std_logic;                                                                 -- Clock
signal &lt;wea&gt;   : std_logic_vector(C_NB_COL-1 downto 0);                                     -- Byte-Write enable
signal &lt;ena&gt;   : std_logic;                                                                 -- RAM Enable, for additional power savings, disable port when not in use
signal &lt;rsta&gt;  : std_logic;                                                                 -- Output reset (does not affect memory contents)
signal &lt;regcea&gt;: std_logic;                                                                 -- Output register enable
signal &lt;douta&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                                  -- RAM output data
signal &lt;douta_reg&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');           -- RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_NB_COL*C_COL_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);
begin
  for i in ram_type'range loop
    readline (ramfile, ramfileline);
    read (ramfileline, bitvec);
    ram_name(i) := to_stdlogicvector(bitvec);
  end loop;
  return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
  if ramfile = "&lt;Init File Name&gt;" then
    return InitRamFromFile("&lt;Init File Name&gt;") ;
  else
    return (others =&gt; (others =&gt; '0'));
  end if;
end;

-- Define RAM
signal &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            for i in 0 to C_NB_COL-1 loop
                if(&lt;wea(i)&gt; = '1') then
                    &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) &lt;= &lt;dina&gt;((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
            &lt;ram_data&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
    begin
        if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
            if(&lt;rsta&gt; = '1') then
                &lt;douta_reg&gt; &lt;= (others =&gt; '0');
            elsif(&lt;regcea&gt; = '1') then
                &lt;douta_reg&gt; &lt;= &lt;ram_data&gt;;
            end if;
        end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;
end generate;

							</Template>
						</SubFolder>
						<Template label="No Change Mode" treetype="template">
--  Xilinx Single Port No Change RAM
--  This code implements a parameterizable single-port no-change memory where when data is written
--  to the memory, the output remains unchanged.  This is the most power efficient write mode.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


-- Insert the following in the architecture before the begin keyword
-- The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2

constant C_RAM_WIDTH : integer := &lt;width&gt;;                                                   -- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                  -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- RAM input data
signal &lt;clka&gt;  : std_logic;                                                                 -- Clock
signal &lt;wea&gt;   : std_logic;                                                                 -- Write enable
signal &lt;ena&gt;   : std_logic;                                                                 -- RAM Enable, for additional power savings, disable port when not in use
signal &lt;rsta&gt;  : std_logic;                                                                 -- Output reset (does not affect memory contents)
signal &lt;regcea&gt;: std_logic;                                                                 -- Output register enable
signal &lt;douta&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- RAM output data
signal &lt;douta_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
signal &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            if(&lt;wea&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) &lt;= &lt;dina&gt;;
            else
                &lt;ram_data&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data&gt;;
        end if;
    end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;
end generate;

						</Template>
						<Template label="Read First Mode" treetype="template">
--  Xilinx Single Port Read First RAM
--  This code implements a parameterizable single-port read-first memory where when data
--  is written to the memory, the output reflects the prior contents of the memory location.
--  If the output data is not needed during writes or the last read value is desired to be
--  retained, it is suggested to use Single Port.No Change Mode Template as it is more power
--  efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.

--Following libraries have to be used
-- use ieee.std_logic_1164.all;
-- use std.textio.all;
-- use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2

constant C_RAM_WIDTH : integer := &lt;width&gt;;                                                   -- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                  -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)
signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- RAM input data
signal &lt;clka&gt;  : std_logic;                                                                 -- Clock
signal &lt;wea&gt;   : std_logic;                                                                 -- Write enable
signal &lt;ena&gt;   : std_logic;                                                                 -- RAM Enable, for additional power savings, disable port when not in use
signal &lt;rsta&gt;  : std_logic;                                                                 -- Output reset (does not affect memory contents)
signal &lt;regcea&gt;: std_logic;                                                                 -- Output register enable
signal &lt;douta&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- RAM output data
signal &lt;douta_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
signal &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            if(&lt;wea&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) &lt;= &lt;dina&gt;;
            end if;
            &lt;ram_data&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
        if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
            if(&lt;rsta&gt; = '1') then
                &lt;douta_reg&gt; &lt;= (others =&gt; '0');
            elsif(&lt;regcea&gt; = '1') then
                &lt;douta_reg&gt; &lt;= &lt;ram_data&gt;;
            end if;
        end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;
end generate;

						</Template>
						<Template label="Write First Mode" treetype="template">
--  Xilinx Single Port Write First RAM
--  This code implements a parameterizable single-port write-first memory where when data
--  is written to the memory, the output reflects the same data being written to the memory.
--  If the output data is not needed during writes or the last read value is desired to be retained
--  it is suggested to use a Single-Port.No Change Template as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
  while temp &gt; 1 loop
    ret_val := ret_val + 1;
    temp    := temp / 2;
  end loop;

  return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_RAM_WIDTH : integer := &lt;width&gt;;                                                   -- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                  -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)

 signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Address bus, width determined from RAM_DEPTH
 signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- RAM input data
 signal &lt;clka&gt;  : std_logic;                                                                 -- Clock
 signal &lt;wea&gt;   : std_logic;                                                                 -- Write enable
 signal &lt;ena&gt;   : std_logic;                                                                 -- RAM Enable, for additional power savings, disable port when not in use
 signal &lt;rsta&gt;  : std_logic;                                                                 -- Output reset (does not affect memory contents)
 signal &lt;regcea&gt;: std_logic;                                                                 -- Output register enable
 signal &lt;douta&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- RAM output data
 signal &lt;douta_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
signal &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

-- Insert the following after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            if(&lt;wea&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) &lt;= &lt;dina&gt;;
                &lt;ram_data&gt; &lt;= &lt;dina&gt;;
            else
                &lt;ram_data&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data&gt;;
        end if;
    end if;
 end process;
 &lt;douta&gt; &lt;= &lt;douta_reg&gt;;

end generate;

						</Template>
					</SubFolder>
					<SubFolder label="True Dual Port" treetype="folder">
						<SubFolder label="1 Clock" treetype="folder">
							<Template label="No Change Mode" treetype="template">
--  Xilinx True Dual Port RAM No Change Single Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  This is a no change RAM which retains the last read value on the output during writes
--  which is the most power efficient mode.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_RAM_WIDTH : integer := &lt;width&gt;;                                                   -- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                  -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port A Address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port B Address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM input data
signal &lt;dinb&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM input data
signal &lt;clka&gt;  : std_logic;                                                                 -- Clock
signal &lt;wea&gt;   : std_logic;                                                                 -- Port A Write enable
signal &lt;web&gt;   : std_logic;                                                                 -- Port B Write enable
signal &lt;ena&gt;   : std_logic;                                                                 -- Port A RAM Enable, for additional power savings, disable port when not in use
signal &lt;enb&gt;   : std_logic;                                                                 -- Port B RAM Enable, for additional power savings, disable port when not in use
signal &lt;rsta&gt;  : std_logic;                                                                 -- Port A Output reset (does not affect memory contents)
signal &lt;rstb&gt;  : std_logic;                                                                 -- Port B Output reset (does not affect memory contents)
signal &lt;regcea&gt;: std_logic;                                                                 -- Port A Output register enable
signal &lt;regceb&gt;: std_logic;                                                                 -- Port B Output register enable
signal &lt;douta&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM output data
signal &lt;doutb&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM output data
signal &lt;douta_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port A RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE
signal &lt;doutb_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port B RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data_a&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal &lt;ram_data_b&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
shared variable &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            if(&lt;wea&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) := &lt;dina&gt;;
            else
                &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
            end if;
        end if;
    end if;
end process;

process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            if(&lt;web&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;))) := &lt;dinb&gt;;
            else
                &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
            end if;
        end if;
    end if;
end process;


--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data_a&gt;;
    &lt;doutb&gt; &lt;= &lt;ram_data_b&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data_a&gt;;
        end if;
    end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;

process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data_b&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;

end generate;

							</Template>
							<Template label="Read First Mode" treetype="template">
--  Xilinx True Dual Port RAM Read First Single Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  The behavior of this RAM is when data is written, the prior memory contents at the write
--  address are presented on the output port.  If the output data is not needed during writes
--  or the last read value is desired to be retained, it is suggested to use a no change RAM
--  as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_RAM_WIDTH : integer := &lt;width&gt;;                                                   -- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                  -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)

 signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port A Address bus, width determined from RAM_DEPTH
 signal &lt;addrb&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port B Address bus, width determined from RAM_DEPTH
 signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM input data
 signal &lt;dinb&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM input data
 signal &lt;clka&gt;  : std_logic;                                                                 -- Clock
 signal &lt;wea&gt;   : std_logic;                                                                 -- Port A Write enable
 signal &lt;web&gt;   : std_logic;                                                                 -- Port B Write enable
 signal &lt;ena&gt;   : std_logic;                                                                 -- Port A RAM Enable, for additional power savings, disable port when not in use
 signal &lt;enb&gt;   : std_logic;                                                                 -- Port B RAM Enable, for additional power savings, disable port when not in use
 signal &lt;rsta&gt;  : std_logic;                                                                 -- Port A Output reset (does not affect memory contents)
 signal &lt;rstb&gt;  : std_logic;                                                                 -- Port B Output reset (does not affect memory contents)
 signal &lt;regcea&gt;: std_logic;                                                                 -- Port A Output register enable
 signal &lt;regceb&gt;: std_logic;                                                                 -- Port B Output register enable
 signal &lt;douta&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM output data
 signal &lt;doutb&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM output data
 signal &lt;douta_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port A RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE
 signal &lt;doutb_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port B RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data_a&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal &lt;ram_data_b&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
shared variable &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
            if(&lt;wea&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) := &lt;dina&gt;;
            end if;
        end if;
    end if;
end process;

process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
            if(&lt;web&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;))) := &lt;dinb&gt;;
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data_a&gt;;
    &lt;doutb&gt; &lt;= &lt;ram_data_b&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data_a&gt;;
        end if;
    end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;

process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data_b&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;

end generate;

							</Template>
							<Template label="Read First Mode w/ Byte-write" treetype="template">
--  Xilinx True Dual Port RAM Byte Write Read First Single Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  The behavior of this RAM is when data is written, the prior memory contents at the write
--  address are presented on the output port.  If the output data is
--  not needed during writes or the last read value is desired to be retained,
--  it is suggested to use a no change RAM as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.


-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
  	return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2

constant C_NB_COL    : integer := &lt;nb_col&gt;;
           -- Specify number of columns (number of bytes)
constant C_COL_WIDTH : integer := &lt;col_width&gt;;
           -- Specify column width (byte width, typically 8 or 9)
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                                    -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                                -- Specify name/location of RAM initialization file if using one (leave blank if not)
signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port A Address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port B Address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                         -- Port A RAM input data
signal &lt;dinb&gt;  : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                         -- Port B RAM input data
signal &lt;clka&gt;  : std_logic;                                                                 -- Clock
signal &lt;wea&gt;   : std_logic_vector(C_NB_COL-1 downto 0);                                     -- Port A Write enable
signal &lt;web&gt;   : std_logic_vector(C_NB_COL-1 downto 0);                                     -- Port B Write enable
signal &lt;ena&gt;   : std_logic;                                                                 -- Port A RAM Enable, for additional power savings, disable port when not in use
signal &lt;enb&gt;   : std_logic;                                                                 -- Port B RAM Enable, for additional power savings, disable port when not in use
signal &lt;rsta&gt;  : std_logic;                                                                 -- Port A Output reset (does not affect memory contents)
signal &lt;rstb&gt;  : std_logic;                                                                 -- Port B Output reset (does not affect memory contents)
signal &lt;regcea&gt;: std_logic;                                                                 -- Port A Output register enable
signal &lt;regceb&gt;: std_logic;                                                                 -- Port B Output register enable
signal &lt;douta&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                                  -- Port A RAM output data
signal &lt;doutb&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                                  -- Port B RAM output data
signal &lt;douta_reg&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port A RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE
signal &lt;doutb_reg&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port B RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_NB_COL*C_COL_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data_a&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;
signal &lt;ram_data_b&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
shared variable &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
            for i in 0 to C_NB_COL-1 loop
                if(&lt;wea&gt;(i) = '1') then
                    &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := &lt;dina&gt;((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
        end if;
    end if;
end process;

process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
            for i in 0 to C_NB_COL-1 loop
                if(&lt;web&gt;(i) = '1') then
                    &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := &lt;dinb&gt;((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
        end if;
    end if;
end process;


--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data_a&gt;;
    &lt;doutb&gt; &lt;= &lt;ram_data_b&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data_a&gt;;
        end if;
    end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;

process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data_b&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;

end generate;

							</Template>
							<Template label="Write First Mode" treetype="template">
--  Xilinx True Dual Port RAM Write First Single Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  This implementes write-first mode where the data being written to the RAM also resides on
--  the output port.  If the output data is not needed during writes or the last read value is
--  desired to be retained, it is suggested to use no change as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_RAM_WIDTH : integer := &lt;width&gt;;                                                   -- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                  -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port A Address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port B Address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM input data
signal &lt;dinb&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM input data
signal &lt;clka&gt;  : std_logic;                                                                 -- Clock
signal &lt;wea&gt;   : std_logic;                                                                 -- Port A Write enable
signal &lt;web&gt;   : std_logic;                                                                 -- Port B Write enable
signal &lt;ena&gt;   : std_logic;                                                                 -- Port A RAM Enable, for additional power savings, disable port when not in use
signal &lt;enb&gt;   : std_logic;                                                                 -- Port B RAM Enable, for additional power savings, disable port when not in use
signal &lt;rsta&gt;  : std_logic;                                                                 -- Port A Output reset (does not affect memory contents)
signal &lt;rstb&gt;  : std_logic;                                                                 -- Port B Output reset (does not affect memory contents)
signal &lt;regcea&gt;: std_logic;                                                                 -- Port A Output register enable
signal &lt;regceb&gt;: std_logic;                                                                 -- Port B Output register enable
signal &lt;douta&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM output data
signal &lt;doutb&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM output data
signal &lt;douta_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port A RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE
signal &lt;doutb_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port B RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data_a&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal &lt;ram_data_b&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
shared vairable &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            if(&lt;wea&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) := &lt;dina&gt;;
                &lt;ram_data_a&gt; &lt;= &lt;dina&gt;;
            else
                &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
            end if;
        end if;
    end if;
end process;

process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            if(&lt;web&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;))) := &lt;dinb&gt;;
                &lt;ram_data_b&gt; &lt;= &lt;dinb&gt;;
            else
                &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data_a&gt;;
    &lt;doutb&gt; &lt;= &lt;ram_data_b&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data_a&gt;;
        end if;
    end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;

process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data_b&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;

end generate;

							</Template>
						</SubFolder>
						<SubFolder label="2 Clock" treetype="folder">
							<Template label="No Change Mode" treetype="template">
--  Xilinx True Dual Port RAM No Change Dual Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  This is a no change RAM which retains the last read value on the output during writes
--  which is the most power efficient mode.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
  	return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_RAM_WIDTH : integer := &lt;width&gt;;                                                   -- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                  -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port A Address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port B Address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM input data
signal &lt;dinb&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM input data
signal &lt;clka&gt;  : std_logic;                                                                 -- Port A Clock
signal &lt;clkb&gt;  : std_logic;                                                                 -- Port B Clock
signal &lt;wea&gt;   : std_logic;                                                                 -- Port A Write enable
signal &lt;web&gt;   : std_logic;                                                                 -- Port B Write enable
signal &lt;ena&gt;   : std_logic;                                                                 -- Port A RAM Enable, for additional power savings, disable port when not in use
signal &lt;enb&gt;   : std_logic;                                                                 -- Port B RAM Enable, for additional power savings, disable port when not in use
signal &lt;rsta&gt;  : std_logic;                                                                 -- Port A Output reset (does not affect memory contents)
signal &lt;rstb&gt;  : std_logic;                                                                 -- Port B Output reset (does not affect memory contents)
signal &lt;regcea&gt;: std_logic;                                                                 -- Port A Output register enable
signal &lt;regceb&gt;: std_logic;                                                                 -- Port B Output register enable
signal &lt;douta&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM output data
signal &lt;doutb&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM output data
signal &lt;douta_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port A RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE
signal &lt;doutb_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port B RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data_a&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal &lt;ram_data_b&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
shared variable &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            if(&lt;wea&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) := &lt;dina&gt;;
            else
                &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
        end if;
    end if;
end if;

end process;

process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            if(&lt;web&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;))) := &lt;dinb&gt;;
            else
                &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data_a&gt;;
    &lt;doutb&gt; &lt;= &lt;ram_data_b&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data_a&gt;;
        end if;
    end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;

process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data_b&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;

end generate;

							</Template>
							<Template label="Read First Mode" treetype="template">
--  Xilinx True Dual Port RAM Read First Dual Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  The behavior of this RAM is when data is written, the prior memory contents at the write
--  address are presented on the output port.  If the output data is
--  not needed during writes or the last read value is desired to be retained,
--  it is suggested to use a no change RAM as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_RAM_WIDTH : integer := &lt;width&gt;;                                                   -- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                  -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)

 signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port A Address bus, width determined from RAM_DEPTH
 signal &lt;addrb&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port B Address bus, width determined from RAM_DEPTH
 signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM input data
 signal &lt;dinb&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM input data
 signal &lt;clka&gt;  : std_logic;                                                                 -- Port A Clock
 signal &lt;clkb&gt;  : std_logic;                                                                 -- Port B Clock
 signal &lt;wea&gt;   : std_logic;                                                                 -- Port A Write enable
 signal &lt;web&gt;   : std_logic;                                                                 -- Port B Write enable
 signal &lt;ena&gt;   : std_logic;                                                                 -- Port A RAM Enable, for additional power savings, disable port when not in use
 signal &lt;enb&gt;   : std_logic;                                                                 -- Port B RAM Enable, for additional power savings, disable port when not in use
 signal &lt;rsta&gt;  : std_logic;                                                                 -- Port A Output reset (does not affect memory contents)
 signal &lt;rstb&gt;  : std_logic;                                                                 -- Port B Output reset (does not affect memory contents)
 signal &lt;regcea&gt;: std_logic;                                                                 -- Port A Output register enable
 signal &lt;regceb&gt;: std_logic;                                                                 -- Port B Output register enable
 signal &lt;douta&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM output data
 signal &lt;doutb&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM output data
 signal &lt;douta_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port A RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE
 signal &lt;doutb_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port B RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data_a&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal &lt;ram_data_b&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
shared variable &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
            if(&lt;wea&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) := &lt;dina&gt;;
            end if;
        end if;
    end if;
end process;

process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
            if(&lt;web&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;))) := &lt;dinb&gt;;
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data_a&gt;;
    &lt;doutb&gt; &lt;= &lt;ram_data_b&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data_a&gt;;
        end if;
    end if;
 end process;
 &lt;douta&gt; &lt;= &lt;douta_reg&gt;;

process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data_b&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;

end generate;

							</Template>
							<Template label="Read First Mode w/ Byte-write" treetype="template">
--  Xilinx True Dual Port RAM Byte Write Read First Dual Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  The behavior of this RAM is when data is written, the prior memory contents at the write
--  address are presented on the output port.  If the output data is
--  not needed during writes or the last read value is desired to be retained,
--  it is suggested to use a no change RAM as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;


-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2

constant C_NB_COL    : integer := &lt;nb_col&gt;;
           -- Specify number of columns (number of bytes)
constant C_COL_WIDTH : integer := &lt;col_width&gt;;
           -- Specify column width (byte width, typically 8 or 9)
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                            -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                                 -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port A Address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port B Address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                         -- Port A RAM input data
signal &lt;dinb&gt;  : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                         -- Port B RAM input data
signal &lt;clka&gt;  : std_logic;                                                                 -- Port A Clock
signal &lt;clkb&gt;  : std_logic;                                                                 -- Port B Clock
signal &lt;wea&gt;   : std_logic_vector(C_NB_COL-1 downto 0);                                     -- Port A Write enable
signal &lt;web&gt;   : std_logic_vector(C_NB_COL-1 downto 0);                                     -- Port B Write enable
signal &lt;ena&gt;   : std_logic;                                                                 -- Port A RAM Enable, for additional power savings, disable port when not in use
signal &lt;enb&gt;   : std_logic;                                                                 -- Port B RAM Enable, for additional power savings, disable port when not in use
signal &lt;rsta&gt;  : std_logic;                                                                 -- Port A Output reset (does not affect memory contents)
signal &lt;rstb&gt;  : std_logic;                                                                 -- Port B Output reset (does not affect memory contents)
signal &lt;regcea&gt;: std_logic;                                                                 -- Port A Output register enable
signal &lt;regceb&gt;: std_logic;                                                                 -- Port B Output register enable
signal &lt;douta&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                                  -- Port A RAM output data
signal &lt;doutb&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);                                  -- Port B RAM output data
signal &lt;douta_reg&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port A RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE
signal &lt;doutb_reg&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port B RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_NB_COL*C_COL_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data_a&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;
signal &lt;ram_data_b&gt; : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Define RAM
shared variable &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
            for i in 0 to C_NB_COL-1 loop
                if(&lt;wea&gt;(i) = '1') then
                    &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := &lt;dina&gt;((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
        end if;
    end if;
end process;

process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
            for i in 0 to C_NB_COL-1 loop
                if(&lt;web&gt;(i) = '1') then
                    &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := &lt;dinb&gt;((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data_a&gt;;
    &lt;doutb&gt; &lt;= &lt;ram_data_b&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data_a&gt;;
        end if;
    end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;

process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data_b&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;

end generate;

							</Template>
							<Template label="Write First Mode" treetype="template">
--  Xilinx True Dual Port RAM Write First Dual Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  This implementes write-first mode where the data being written to the RAM also resides on
--  the output port.  If the output data is not needed during writes or the last read value is
--  desired to be retained, it is suggested to use no change as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

-- Following libraries have to be used
--use ieee.std_logic_1164.all;
--use std.textio.all;
--use ieee.numeric_std.all;


--Insert the following in the architecture before the begin keyword
--  The following function calculates the address width based on specified RAM depth
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

-- Note :
-- If the chosen width and depth values are low, Synthesis will infer Distributed RAM.
-- C_RAM_DEPTH should be a power of 2
constant C_RAM_WIDTH : integer := &lt;width&gt;;                                                   -- Specify RAM data width
constant C_RAM_DEPTH : integer := &lt;depth&gt;;                                                   -- Specify RAM depth (number of entries)
constant C_RAM_PERFORMANCE : string := &lt;ram_performance&gt;;                  -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
constant C_INIT_FILE : string := &lt;init_file&gt;;                                         -- Specify name/location of RAM initialization file if using one (leave blank if not)

signal &lt;addra&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port A Address bus, width determined from RAM_DEPTH
signal &lt;addrb&gt; : std_logic_vector(clogb2(C_RAM_DEPTH)-1 downto 0);                          -- Port B Address bus, width determined from RAM_DEPTH
signal &lt;dina&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM input data
signal &lt;dinb&gt;  : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM input data
signal &lt;clka&gt;  : std_logic;                                                                 -- Port A Clock
signal &lt;clkb&gt;  : std_logic;                                                                 -- Port B Clock
signal &lt;wea&gt;   : std_logic;                                                                 -- Port A Write enable
signal &lt;web&gt;   : std_logic;                                                                 -- Port B Write enable
signal &lt;ena&gt;   : std_logic;                                                                 -- Port A RAM Enable, for additional power savings, disable port when not in use
signal &lt;enb&gt;   : std_logic;                                                                 -- Port B RAM Enable, for additional power savings, disable port when not in use
signal &lt;rsta&gt;  : std_logic;                                                                 -- Port A Output reset (does not affect memory contents)
signal &lt;rstb&gt;  : std_logic;                                                                 -- Port B Output reset (does not affect memory contents)
signal &lt;regcea&gt;: std_logic;                                                                 -- Port A Output register enable
signal &lt;regceb&gt;: std_logic;                                                                 -- Port B Output register enable
signal &lt;douta&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port A RAM output data
signal &lt;doutb&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0);                                  -- Port B RAM output data
signal &lt;douta_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port A RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE
signal &lt;doutb_reg&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');           -- Port B RAM output data when RAM_PERFORMANCE = HIGH_PERFORMANCE

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);      -- 2D Array Declaration for RAM signal
signal &lt;ram_data_a&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal &lt;ram_data_b&gt; : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "&lt;Init File Name&gt;" then
        return InitRamFromFile("&lt;Init File Name&gt;") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;

-- Following code defines RAM
shared variable &lt;ram_name&gt; : ram_type := init_from_file_or_zeroes(C_INIT_FILE);
--Insert the following in the architecture after the begin keyword
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;ena&gt; = '1') then
            if(&lt;wea&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;))) := &lt;dina&gt;;
                &lt;ram_data_a&gt; &lt;= &lt;dina&gt;;
            else
                &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addra&gt;)));
            end if;
        end if;
    end if;
end process;

process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;enb&gt; = '1') then
            if(&lt;web&gt; = '1') then
                &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;))) := &lt;dinb&gt;;
                &lt;ram_data_b&gt; &lt;= &lt;dinb&gt;;
            else
                &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;(to_integer(unsigned(&lt;addrb&gt;)));
            end if;
        end if;
    end if;
end process;


--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    &lt;douta&gt; &lt;= &lt;ram_data_a&gt;;
    &lt;doutb&gt; &lt;= &lt;ram_data_b&gt;;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(&lt;clka&gt;)
begin
    if(&lt;clka&gt;'event and &lt;clka&gt; = '1') then
        if(&lt;rsta&gt; = '1') then
            &lt;douta_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regcea&gt; = '1') then
            &lt;douta_reg&gt; &lt;= &lt;ram_data_a&gt;;
        end if;
    end if;
end process;
&lt;douta&gt; &lt;= &lt;douta_reg&gt;;

process(&lt;clkb&gt;)
begin
    if(&lt;clkb&gt;'event and &lt;clkb&gt; = '1') then
        if(&lt;rstb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= (others =&gt; '0');
        elsif(&lt;regceb&gt; = '1') then
            &lt;doutb_reg&gt; &lt;= &lt;ram_data_b&gt;;
        end if;
    end if;
end process;
&lt;doutb&gt; &lt;= &lt;doutb_reg&gt;;

end generate;

							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Distributed RAM" treetype="folder">
					<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity rams_04 is
    port (CLK : in std_logic;
          WE  : in std_logic;
          A   : in std_logic_vector(5 downto 0);
          DI  : in std_logic_vector(15 downto 0);
          DO  : out std_logic_vector(15 downto 0));
end rams_04;

architecture syn of rams_04 is
    type ram_type is array (63 downto 0) of std_logic_vector (15 downto 0);
    signal RAM : ram_type;
begin

    process (CLK)
    begin
        if (CLK'event and CLK = '1') then
            if (WE = '1') then
                RAM(to_integer(unsigned(A))) &lt;= DI;
            end if;
        end if;
    end process;

    DO &lt;= RAM(to_integer(unsigned(A)));

end syn;

					</Template>
				</SubFolder>
				<SubFolder label="UltraRAM" treetype="folder">
					<Template label="Simple Dual Port" treetype="template">
--  Xilinx UltraRAM Simple Dual Port.  This code implements 
--  a parameterizable UltraRAM block 1 Read and 1 write. 
--  when addra == addrb, old data will show at doutb 

-- Following libraries have to be used
--library ieee;
--use ieee.std_logic_1164.all;
--use ieee.numeric_std.all;

--Insert the following in the architecture before the begin keyword
constant C_AWIDTH : integer := &lt;AWIDTH&gt;;
constant C_DWIDTH : integer := &lt;DWIDTH&gt;;
constant C_NBPIPE : integer := &lt;NBPIPE&gt;;

signal   &lt;clk&gt; :  std_logic;                                   -- Clock 
signal   &lt;rstb&gt; :  std_logic;                                  -- Reset
signal   &lt;wea&gt; :  std_logic;                                   -- Write Enable
signal   &lt;regceb&gt; :  std_logic;                                -- Output Register Enable&gt;
signal   &lt;mem_en&gt; :  std_logic;                                -- Memory Enable
signal   &lt;dina&gt; :  std_logic_vector(C_DWIDTH-1 downto 0);      -- Data Input  
signal   &lt;addra&gt; :  std_logic_vector(C_AWIDTH-1 downto 0);     -- Write Address
signal   &lt;addrb&gt; :  std_logic_vector(C_AWIDTH-1 downto 0);     -- Read Address
signal   &lt;doutb&gt; : std_logic_vector(C_DWIDTH-1 downto 0)       -- Data Output

-- Internal Signals
type &lt;mem_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_data_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_en_t&gt; is array(natural range&lt;&gt;) of std_logic;

signal &lt;mem&gt; : &lt;mem_t&gt;(2**C_AWIDTH-1 downto 0);                -- Memory Declaration
signal &lt;memreg&gt; : std_logic_vector(C_DWIDTH-1 downto 0);              
signal &lt;mem_pipe_reg&gt; : &lt;pipe_data_t&gt;(C_NBPIPE-1 downto 0);    -- Pipelines for Memory
signal &lt;mem_en_pipe_reg&gt; : &lt;pipe_en_t&gt;(C_NBPIPE downto 0);     -- Pipelines for Memory enable  

attribute ram_style : string;
attribute ram_style of &lt;mem&gt; : signal is "ultra";
-- Insert the following after the begin keyword

-- RAM : Read has one latency, Write has one latency as well.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and clk='1')then
    if(&lt;mem_en&gt; = '1') then
      if(&lt;wea&gt; = '1') then
        &lt;mem&gt;(to_integer(unsigned(&lt;addra&gt;))) &lt;= &lt;dina&gt;;
      end if;
      &lt;memreg&gt; &lt;= &lt;mem&gt;(to_integer(unsigned(&lt;addrb&gt;)));
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    &lt;mem_en_pipe_reg&gt;(0) &lt;= &lt;mem_en&gt;;
    for i in 0 to C_NBPIPE-1 loop
      &lt;mem_en_pipe_reg&gt;(i+1) &lt;= &lt;mem_en_pipe_reg&gt;(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;mem_en_pipe_reg&gt;(0) = '1') then
      &lt;mem_pipe_reg&gt;(0) &lt;= &lt;memreg&gt;;
    end if;
  end if;
end process;

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(&lt;mem_en_pipe_reg&gt;(i+1) = '1') then
        &lt;mem_pipe_reg&gt;(i+1) &lt;= &lt;mem_pipe_reg&gt;(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;rstb&gt; = '1') then
      &lt;doutb&gt; &lt;= (others =&gt; '0');
    elsif(&lt;mem_en_pipe_reg&gt;(C_NBPIPE) = '1' and &lt;regceb&gt; = '1' ) then
      &lt;doutb&gt; &lt;= &lt;mem_pipe_reg&gt;(C_NBPIPE-1);
    end if;
  end if;    
end process;
					</Template>
					<SubFolder label="Single Port" treetype="folder">
						<Template label="No Change Mode" treetype="template">
--  Xilinx UltraRAM Single Port No Change Mode.  This code implements 
--  a parameterizable UltraRAM block in No Change mode. The behavior of this RAM is 
--  when data is written, the output of RAM is unchanged. Only when write is
--  inactive data corresponding to the address is presented on the output port.
--

-- Following libraries have to be used
--library ieee;
--use ieee.std_logic_1164.all;
--use ieee.numeric_std.all;

--Insert the following in the architecture before the begin keyword
constant C_AWIDTH : integer := &lt;AWIDTH&gt;;
constant C_DWIDTH : integer := &lt;DWIDTH&gt;;
constant C_NBPIPE : integer := &lt;NBPIPE&gt;;

signal   &lt;clk&gt; :  std_logic;                                  -- Clock 
signal   &lt;rst&gt; :  std_logic;                                  -- Reset
signal   &lt;we&gt; :  std_logic;                                   -- Write Enable
signal   &lt;regce&gt; :  std_logic;                                -- Output Register Enable&gt;
signal   &lt;mem_en&gt; :  std_logic;                               -- Memory Enable
signal   &lt;din&gt; :  std_logic_vector(C_DWIDTH-1 downto 0);      -- Data Input  
signal   &lt;addr&gt; :  std_logic_vector(C_AWIDTH-1 downto 0);     -- Address Input
signal   &lt;dout&gt; : std_logic_vector(C_DWIDTH-1 downto 0);       -- Data Output



-- Internal Signals
type &lt;mem_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_data_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_en_t&gt; is array(natural range&lt;&gt;) of std_logic;

signal &lt;mem&gt; : &lt;mem_t&gt;(2**C_AWIDTH-1 downto 0);                -- Memory Declaration
signal &lt;memreg&gt; : std_logic_vector(C_DWIDTH-1 downto 0);              
signal &lt;mem_pipe_reg&gt; : &lt;pipe_data_t&gt;(C_NBPIPE-1 downto 0);    -- Pipelines for Memory
signal &lt;mem_en_pipe_reg&gt; : &lt;pipe_en_t&gt;(C_NBPIPE downto 0);     -- Pipelines for Memory enable  

attribute ram_style : string;
attribute ram_style of &lt;mem&gt; : signal is "ultra";
-- Insert the following after the begin keyword

-- RAM : Read has one latency, Write has one latency as well.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and clk='1')then
    if(&lt;mem_en&gt; = '1') then
      if(&lt;we&gt; = '1') then
        &lt;mem&gt;(to_integer(unsigned(&lt;addr&gt;))) &lt;= &lt;din&gt;;
      else
        &lt;memreg&gt; &lt;= &lt;mem&gt;(to_integer(unsigned(&lt;addr&gt;)));
      end if;
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    &lt;mem_en_pipe_reg&gt;(0) &lt;= &lt;mem_en&gt;;
    for i in 0 to C_NBPIPE-1 loop
      &lt;mem_en_pipe_reg&gt;(i+1) &lt;= &lt;mem_en_pipe_reg&gt;(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;mem_en_pipe_reg&gt;(0) = '1') then
      &lt;mem_pipe_reg&gt;(0) &lt;= &lt;memreg&gt;;
    end if;
  end if;
end process;

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(&lt;mem_en_pipe_reg&gt;(i+1) = '1') then
        &lt;mem_pipe_reg&gt;(i+1) &lt;= &lt;mem_pipe_reg&gt;(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;rst&gt; = '1') then
      &lt;dout&gt; &lt;= (others =&gt; '0');
    elsif(&lt;mem_en_pipe_reg&gt;(C_NBPIPE) = '1' and &lt;regce&gt; = '1' ) then
      &lt;dout&gt; &lt;= &lt;mem_pipe_reg&gt;(C_NBPIPE-1);
    end if;
  end if;    
end process;
						</Template>
						<Template label="Read First Mode" treetype="template">
-- Xilinx UltraRAM Single Port Read First.  This code implements 
-- a parameterizable UltraRAM block in Read First mode. The behavior of this RAM is 
-- when data is written, the old memory contents at the write address is
-- presented on the output port.

-- Following libraries have to be used
--library ieee;
--use ieee.std_logic_1164.all;
--use ieee.numeric_std.all;

--Insert the following in the architecture before the begin keyword
constant C_AWIDTH : integer := &lt;AWIDTH&gt;;
constant C_DWIDTH : integer := &lt;DWIDTH&gt;;
constant C_NBPIPE : integer := &lt;NBPIPE&gt;;

signal   &lt;clk&gt; :  std_logic;                                  -- Clock 
signal   &lt;rst&gt; :  std_logic;                                  -- Reset
signal   &lt;we&gt; :  std_logic;                                   -- Write Enable
signal   &lt;regce&gt; :  std_logic;                                -- Output Register Enable&gt;
signal   &lt;mem_en&gt; :  std_logic;                               -- Memory Enable
signal   &lt;din&gt; :  std_logic_vector(C_DWIDTH-1 downto 0);      -- Data Input  
signal   &lt;addr&gt; :  std_logic_vector(C_AWIDTH-1 downto 0);     -- Address Input
signal   &lt;dout&gt; : std_logic_vector(C_DWIDTH-1 downto 0);       -- Data Output



-- Internal Signals
type &lt;mem_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_data_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_en_t&gt; is array(natural range&lt;&gt;) of std_logic;

signal &lt;mem&gt; : &lt;mem_t&gt;(2**C_AWIDTH-1 downto 0);                -- Memory Declaration
signal &lt;memreg&gt; : std_logic_vector(C_DWIDTH-1 downto 0);              
signal &lt;mem_pipe_reg&gt; : &lt;pipe_data_t&gt;(C_NBPIPE-1 downto 0);    -- Pipelines for Memory
signal &lt;mem_en_pipe_reg&gt; : &lt;pipe_en_t&gt;(C_NBPIPE downto 0);     -- Pipelines for Memory enable  

attribute ram_style : string;
attribute ram_style of &lt;mem&gt; : signal is "ultra";
-- Insert the following after the begin keyword

-- RAM : Read has one latency, Write has one latency as well.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and clk='1')then
    if(&lt;mem_en&gt; = '1') then
      if(&lt;we&gt; = '1') then
        &lt;mem&gt;(to_integer(unsigned(&lt;addr&gt;))) &lt;= &lt;din&gt;;
      end if;
      &lt;memreg&gt; &lt;= &lt;mem&gt;(to_integer(unsigned(&lt;addr&gt;)));
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    &lt;mem_en_pipe_reg&gt;(0) &lt;= &lt;mem_en&gt;;
    for i in 0 to C_NBPIPE-1 loop
      &lt;mem_en_pipe_reg&gt;(i+1) &lt;= &lt;mem_en_pipe_reg&gt;(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;mem_en_pipe_reg&gt;(0) = '1') then
      &lt;mem_pipe_reg&gt;(0) &lt;= &lt;memreg&gt;;
    end if;
  end if;
end process;

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(&lt;mem_en_pipe_reg&gt;(i+1) = '1') then
        &lt;mem_pipe_reg&gt;(i+1) &lt;= &lt;mem_pipe_reg&gt;(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;rst&gt; = '1') then
      &lt;dout&gt; &lt;= (others =&gt; '0');
    elsif(&lt;mem_en_pipe_reg&gt;(C_NBPIPE) = '1' and &lt;regce&gt; = '1' ) then
      &lt;dout&gt; &lt;= &lt;mem_pipe_reg&gt;(C_NBPIPE-1);
    end if;
  end if;    
end process;


						</Template>
						<Template label="Write First Mode" treetype="template">
-- Xilinx UltraRAM Single Port Write First Mode.  This code implements 
-- a parameterizable UltraRAM block in Write First mode. The behavior of this RAM is 
-- when data is written, the new memory contents at the write address is
-- presented on the output port.

-- Following libraries have to be used
--library ieee;
--use ieee.std_logic_1164.all;
--use ieee.numeric_std.all;

--Insert the following in the architecture before the begin keyword
constant C_AWIDTH : integer := &lt;AWIDTH&gt;;
constant C_DWIDTH : integer := &lt;DWIDTH&gt;;
constant C_NBPIPE : integer := &lt;NBPIPE&gt;;

signal   &lt;clk&gt; :  std_logic;                                  -- Clock 
signal   &lt;rst&gt; :  std_logic;                                  -- Reset
signal   &lt;we&gt; :  std_logic;                                   -- Write Enable
signal   &lt;regce&gt; :  std_logic;                                -- Output Register Enable&gt;
signal   &lt;mem_en&gt; :  std_logic;                               -- Memory Enable
signal   &lt;din&gt; :  std_logic_vector(C_DWIDTH-1 downto 0);      -- Data Input  
signal   &lt;addr&gt; :  std_logic_vector(C_AWIDTH-1 downto 0);     -- Address Input
signal   &lt;dout&gt; : std_logic_vector(C_DWIDTH-1 downto 0);       -- Data Output



-- Internal Signals
type &lt;mem_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_data_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_en_t&gt; is array(natural range&lt;&gt;) of std_logic;

signal &lt;mem&gt; : &lt;mem_t&gt;(2**C_AWIDTH-1 downto 0);                -- Memory Declaration
signal &lt;memreg&gt; : std_logic_vector(C_DWIDTH-1 downto 0);              
signal &lt;mem_pipe_reg&gt; : &lt;pipe_data_t&gt;(C_NBPIPE-1 downto 0);    -- Pipelines for Memory
signal &lt;mem_en_pipe_reg&gt; : &lt;pipe_en_t&gt;(C_NBPIPE downto 0);     -- Pipelines for Memory enable  

attribute ram_style : string;
attribute ram_style of &lt;mem&gt; : signal is "ultra";
-- Insert the following after the begin keyword

-- RAM : Read has one latency, Write has one latency as well.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and clk='1')then
    if(&lt;mem_en&gt; = '1') then
      if(&lt;we&gt; = '1') then
        &lt;mem&gt;(to_integer(unsigned(&lt;addr&gt;))) &lt;= &lt;din&gt;;
        &lt;memreg&gt; &lt;= &lt;din&gt;;
      else
        &lt;memreg&gt; &lt;= &lt;mem&gt;(to_integer(unsigned(&lt;addr&gt;)));
      end if;
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    &lt;mem_en_pipe_reg&gt;(0) &lt;= &lt;mem_en&gt;;
    for i in 0 to C_NBPIPE-1 loop
      &lt;mem_en_pipe_reg&gt;(i+1) &lt;= &lt;mem_en_pipe_reg&gt;(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;mem_en_pipe_reg&gt;(0) = '1') then
      &lt;mem_pipe_reg&gt;(0) &lt;= &lt;memreg&gt;;
    end if;
  end if;
end process;

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(&lt;mem_en_pipe_reg&gt;(i+1) = '1') then
        &lt;mem_pipe_reg&gt;(i+1) &lt;= &lt;mem_pipe_reg&gt;(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;rst&gt; = '1') then
      &lt;dout&gt; &lt;= (others =&gt; '0');
    elsif(&lt;mem_en_pipe_reg&gt;(C_NBPIPE) = '1' and &lt;regce&gt; = '1' ) then
      &lt;dout&gt; &lt;= &lt;mem_pipe_reg&gt;(C_NBPIPE-1);
    end if;
  end if;    
end process;
						</Template>
					</SubFolder>
					<SubFolder label="True Dual Port" treetype="folder">
						<Template label="Non Byte-write" treetype="template">
--  Xilinx UltraRAM True Dual Port Mode.  This code implements 
--  a parameterizable UltraRAM block with write/read on both ports in 
--  No change behavior on both the ports . The behavior of this RAM is 
--  when data is written, the output of RAM is unchanged w.r.t each port. 
--  Only when write is inactive data corresponding to the address is 
--  presented on the output port.

-- Following libraries have to be used
--library ieee;
--use ieee.std_logic_1164.all;
--use ieee.numeric_std.all;

--Insert the following in the architecture before the begin keyword
constant C_AWIDTH : integer := &lt;AWIDTH&gt;;
constant C_DWIDTH : integer := &lt;DWIDTH&gt;;
constant C_NBPIPE : integer := &lt;NBPIPE&gt;;

signal   &lt;clk&gt; :  std_logic;                                  -- Clock 

-- Port A
signal   &lt;rsta&gt; :  std_logic;                                  -- Reset
signal   &lt;wea&gt; :  std_logic;                                   -- Write Enable
signal   &lt;regcea&gt; :  std_logic;                                -- Output Register Enablea&gt;
signal   &lt;mem_ena&gt; :  std_logic;                               -- Memory Enable
signal   &lt;dina&gt; :  std_logic_vector(C_DWIDTH-1 downto 0);      -- Data Input  
signal   &lt;addra&gt; :  std_logic_vector(C_AWIDTH-1 downto 0);     -- Address Input
signal   &lt;douta&gt; : std_logic_vector(C_DWIDTH-1 downto 0);      -- Data Output

-- Port b 
signal   &lt;rstb&gt; :  std_logic;                                  -- Reset
signal   &lt;web&gt; :  std_logic;                                   -- Write Enable
signal   &lt;regceb&gt; :  std_logic;                                -- Output Register Enableb&gt;
signal   &lt;mem_enb&gt; :  std_logic;                               -- Memory Enable
signal   &lt;dinb&gt; :  std_logic_vector(C_DWIDTH-1 downto 0);      -- Data Input  
signal   &lt;addrb&gt; :  std_logic_vector(C_AWIDTH-1 downto 0);     -- Address Input
signal   &lt;doutb&gt; : std_logic_vector(C_DWIDTH-1 downto 0);      -- Data Output

-- Internal Signals
type &lt;mem_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_data_t&gt; is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type &lt;pipe_en_t&gt; is array(natural range&lt;&gt;) of std_logic;

signal &lt;mem&gt; : &lt;mem_t&gt;(2**C_AWIDTH-1 downto 0);                -- Memory Declaration

signal &lt;memrega&gt; : std_logic_vector(C_DWIDTH-1 downto 0);              
signal &lt;mem_pipe_rega&gt; : &lt;pipe_data_t&gt;(C_NBPIPE-1 downto 0);    -- Pipelines for Memory
signal &lt;mem_en_pipe_rega&gt; : &lt;pipe_en_t&gt;(C_NBPIPE downto 0);     -- Pipelines for Memory enable  

signal &lt;memregb&gt; : std_logic_vector(C_DWIDTH-1 downto 0);              
signal &lt;mem_pipe_regb&gt; : &lt;pipe_data_t&gt;(C_NBPIPE-1 downto 0);    -- Pipelines for Memory
signal &lt;mem_en_pipe_regb&gt; : &lt;pipe_en_t&gt;(C_NBPIPE downto 0);     -- Pipelines for Memory enable  
attribute ram_style : string;

attribute ram_style of &lt;mem&gt; : signal is "ultra";
-- Insert the following after the begin keyword

-- RAM : Read has one latency, Write has one latency as well.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and clk='1')then
    if(&lt;mem_ena&gt; = '1') then
      if(&lt;wea&gt; = '1') then
        &lt;mem&gt;(to_integer(unsigned(&lt;addra&gt;))) &lt;= &lt;dina&gt;;
      else
        &lt;memrega&gt; &lt;= &lt;mem&gt;(to_integer(unsigned(&lt;addra&gt;)));
      end if;
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    &lt;mem_en_pipe_rega&gt;(0) &lt;= &lt;mem_ena&gt;;
    for i in 0 to C_NBPIPE-1 loop
      &lt;mem_en_pipe_rega&gt;(i+1) &lt;= &lt;mem_en_pipe_rega&gt;(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;mem_en_pipe_rega&gt;(0) = '1') then
      &lt;mem_pipe_rega&gt;(0) &lt;= &lt;memrega&gt;;
    end if;
  end if;
end process;

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(&lt;mem_en_pipe_rega&gt;(i+1) = '1') then
        &lt;mem_pipe_rega&gt;(i+1) &lt;= &lt;mem_pipe_rega&gt;(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;rsta&gt; = '1') then
      &lt;douta&gt; &lt;= (others =&gt; '0');
    elsif(&lt;mem_en_pipe_rega&gt;(C_NBPIPE) = '1' and &lt;regcea&gt; = '1' ) then
      &lt;douta&gt; &lt;= &lt;mem_pipe_rega&gt;(C_NBPIPE-1);
    end if;
  end if;    
end process;


process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and clk='1')then
    if(&lt;mem_enb&gt; = '1') then
      if(&lt;web&gt; = '1') then
        &lt;mem&gt;(to_integer(unsigned(&lt;addrb&gt;))) &lt;= &lt;dinb&gt;;
      else
        &lt;memregb&gt; &lt;= &lt;mem&gt;(to_integer(unsigned(&lt;addrb&gt;)));
      end if;
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    &lt;mem_en_pipe_regb&gt;(0) &lt;= &lt;mem_enb&gt;;
    for i in 0 to C_NBPIPE-1 loop
      &lt;mem_en_pipe_regb&gt;(i+1) &lt;= &lt;mem_en_pipe_regb&gt;(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;mem_en_pipe_regb&gt;(0) = '1') then
      &lt;mem_pipe_regb&gt;(0) &lt;= &lt;memregb&gt;;
    end if;
  end if;
end process;

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(&lt;mem_en_pipe_regb&gt;(i+1) = '1') then
        &lt;mem_pipe_regb&gt;(i+1) &lt;= &lt;mem_pipe_regb&gt;(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(&lt;clk&gt;)
begin
  if(&lt;clk&gt;'event and &lt;clk&gt; = '1') then
    if(&lt;rstb&gt; = '1') then
      &lt;doutb&gt; &lt;= (others =&gt; '0');
    elsif(&lt;mem_en_pipe_regb&gt;(C_NBPIPE) = '1' and &lt;regceb&gt; = '1' ) then
      &lt;doutb&gt; &lt;= &lt;mem_pipe_regb&gt;(C_NBPIPE-1);
    end if;
  end if;    
end process;
						</Template>
					</SubFolder>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Shift Registers" treetype="folder">
				<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;

entity shift_registers_1 is
    port(CLK, SI : in std_logic;
         SO : out std_logic);
end shift_registers_1;

architecture archi of shift_registers_1 is
    signal tmp: std_logic_vector(7 downto 0);
begin

    process (CLK)
    begin
        if (CLK'event and CLK='1') then
            for i in 0 to 6 loop
                tmp(i+1) &lt;= tmp(i);
            end loop;
            tmp(0) &lt;= SI;
        end if;
    end process;

    SO &lt;= tmp(7);

end archi;

				</Template>
				<SubFolder label="Parallel Load, Serial In, Serial Out" treetype="folder">
					<Template label="Simple Shift" treetype="template">
-- Define a temporary signal that is of type std_logic_vector(&lt;width&gt;-1 downto 0).
-- Where width is the number of bits to shift
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      &lt;tmp_sig&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-2 downto 0) &amp; &lt;input&gt;;
   elsif &lt;load_enable&gt; = '1' then
      &lt;tmp_sig&gt; &lt;= &lt;load_data&gt;;
   end if;
end process;
&lt;output&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-1);

					</Template>
					<Template label="w/ CE" treetype="template">
-- Define a temporary signal that is of type std_logic_vector(&lt;width&gt;-1 downto 0).
-- Where width is the number of bits to shift
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;load_enable&gt; = '1' then
         &lt;tmp_sig&gt; &lt;= &lt;load_data&gt;;
      elsif &lt;clock_enable&gt; = '1' then
         &lt;tmp_sig&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-2 downto 0) &amp; &lt;input&gt;;
      end if;
   end if;
end process;
&lt;output&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-1);

					</Template>
					<Template label="w/ CE and Sync Active High Reset" treetype="template">
-- Define a temporary signal that is of type std_logic_vector(&lt;width&gt;-1 downto 0).
-- Where width is the number of bits to shift
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt; ='1' then
         &lt;tmp_sig&gt; &lt;= (others =&gt; '0');
      elsif &lt;load_enable&gt; = '1' then
         &lt;tmp_sig&gt; &lt;= &lt;load_data&gt;;
      elsif &lt;clock_enable&gt; = '1' then
         &lt;tmp_sig&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-2 downto 0) &amp; &lt;input&gt;;
      end if;
   end if;
end process;
&lt;output&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-1);

					</Template>
					<Template label="w/ CE and Sync Active Low Reset" treetype="template">
-- Define a temporary signal that is of type std_logic_vector(&lt;width&gt;-1 downto 0).
-- Where width is the number of bits to shift
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt; ='0' then
         &lt;tmp_sig&gt; &lt;= (others =&gt; '0');
      elsif &lt;load_enable&gt; = '1' then
         &lt;tmp_sig&gt; &lt;= &lt;load_data&gt;;
      elsif &lt;clock_enable&gt; = '1' then
         &lt;tmp_sig&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-2 downto 0) &amp; &lt;input&gt;;
      end if;
   end if;
end process;
&lt;output&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-1);


					</Template>
				</SubFolder>
				<SubFolder label="Serial In, Serial Out" treetype="folder">
					<Template label="Simple Shift" treetype="template">
-- Define a temporary signal that is of type std_logic_vector(&lt;width&gt;-1 downto 0).
-- Where width is the number of bits to shift

process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      for i in 0 to &lt;width&gt;-2 loop
         &lt;tmp_sig&gt;(i+1) &lt;= &lt;tmp_sig&gt;(i);
      end loop;
      &lt;tmp_sig&gt;(0) &lt;= &lt;input&gt;;
   end if;
end process;
&lt;output&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-1);

					</Template>
					<Template label="w/ CE" treetype="template">
-- Define a temporary signal that is of type std_logic_vector(&lt;width&gt;-1 downto 0).
-- Where width is the number of bits to shift
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;clock_enable&gt; = '1' then
         for i in 0 to &lt;width&gt;-2 loop
            &lt;tmp_sig&gt;(i+1) &lt;= &lt;tmp_sig&gt;(i);
         end loop;
         &lt;tmp_sig&gt;(0) &lt;= &lt;input&gt;;
      end if;
   end if;
end process;
&lt;output&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-1);

					</Template>
					<Template label="w/ CE and Sync Active High Reset" treetype="template">
-- Define a temporary signal that is of type std_logic_vector(&lt;width&gt;-1 downto 0).
-- Where width is the number of bits to shift

process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt; ='1' then
         &lt;tmp_sig&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt; = '1' then
         for i in 0 to &lt;width&gt;-2 loop
            &lt;tmp_sig&gt;(i+1) &lt;= &lt;tmp_sig&gt;(i);
         end loop;
         &lt;tmp_sig&gt;(0) &lt;= &lt;input&gt;;
      end if;
   end if;
end process;
&lt;output&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-1);

					</Template>
					<Template label="w/ CE and Sync Active Low Reset" treetype="template">
-- Define a temporary signal that is of type std_logic_vector(&lt;width&gt;-1 downto 0).
-- Where width is the number of bits to shift

process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;reset&gt; ='0' then
         &lt;tmp_sig&gt; &lt;= (others =&gt; '0');
      elsif &lt;clock_enable&gt; = '1' then
         for i in 0 to &lt;width&gt;-2 loop
            &lt;tmp_sig&gt;(i+1) &lt;= &lt;tmp_sig&gt;(i);
         end loop;
         &lt;tmp_sig&gt;(0) &lt;= &lt;input&gt;;
      end if;
   end if;
end process;
&lt;output&gt; &lt;= &lt;tmp_sig&gt;(&lt;width&gt;-1);

					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="Dynamic Depth /w no register on output (bus)" treetype="template">

-- Shift register depth will be selectable from 1 (SELECT is all zeroes) to 2**depth_select_bits (SELECT is all ones) deep
-- Note: The following code with produce an SRL without a register on the output.
-- For improved clock-to-out times, it is suggested to infer a register on the
-- output of the SRL code when minimum of two clock cycle latency is possible.

-- Below library needs to be used for this template
-- use ieee.numeric_std.all;

-- Constant and signal declarations
-- Add these before begin keyword in architecture
constant depth_select_bits = &lt;number_of_select_bits&gt;; -- Specify depth
constant data_width   = &lt;width&gt;; -- Specify width
signal &lt;data_in&gt; : std_logic_vector(data_width-1 downto 0); -- shift register input
signal &lt;data_out&gt; : std_logic_vector(data_width-1 downto 0); -- shift register output

signal &lt;srl_select&gt; : std_logic_vector(depth_select_bits-1 downto 0); -- Dynamic select input

type array_slv is array (data_width-1 downto 0) of std_logic_vector(2**depth_select_bits-1 downto 0);
signal &lt;shift_reg&gt; : array_slv;
-- Add the below after begin keyword in architecture
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;clock_enable&gt; = '1' then
       for i in 0 to data_width-1 loop
           &lt;shift_reg&gt;(i) &lt;= &lt;shift_reg&gt;(i)(2**depth_select_bits-2 downto 0) &amp; &lt;data_in&gt;(i);
       end loop;
      end if;
   end if;
end process;

process (&lt;shift_reg&gt;,&lt;srl_select&gt;)
begin
   for i in 0 to data_width-1 loop
      &lt;data_out&gt;(i) &lt;= &lt;shift_reg&gt;(i)(to_integer(unsigned(&lt;srl_select&gt;)));
   end loop;
end process;


					</Template>
					<Template label="Dynamic Depth /w no register on output (single)" treetype="template">

-- Shift register depth will be selectable from 1 (SELECT is all zeroes) to 2**depth_select_bits (SELECT is all ones) deep
-- Note: The following code with produce an SRL without a register on the output.
-- For improved clock-to-out times, it is suggested to infer a register on the
-- output of the SRL code when minimum of two clock cycle latency is possible.

-- Below library needs to be used for this template
-- use ieee.numeric_std.all;

-- Constant and signal declarations
-- Add these before begin keyword in architecture
constant depth_select_bits = &lt;number_of_select_bits&gt;; -- Specify depth
signal &lt;data_in&gt; : std_logic; -- shift register input
signal &lt;data_out&gt; : std_logic; -- shift register output
signal &lt;srl_select&gt; : std_logic_vector(depth_select_bits-1 downto 0); -- Dynamic select input

signal &lt;shift_reg&gt; : std_logic_vector(2**depth_select_bits-1 downto 0);

-- Add the below after begin keyword in architecture
process(&lt;clock&gt;)
begin
 if &lt;clock&gt;'event and &lt;clock&gt;='1' then
    if &lt;clock_enable&gt; = '1' then
         &lt;shift_reg&gt; &lt;= &lt;shift_reg&gt;(2**depth_select_bits-2 downto 0) &amp; &lt;data_in&gt;;
    end if;
 end if;
end process;
&lt;data_out&gt; &lt;= &lt;shift_reg&gt;(to_integer(unsigned(&lt;srl_select&gt;)));

					</Template>
					<Template label="Dynamic Depth /w register on output (bus)" treetype="template">

-- Shift register depth will be selectable from 2 (SELECT is all zeroes) to 2**depth_select_bits+1 (
-- SELECT is all ones) deep
-- Note: The following code with produce an SRL a register on the output for improved clock-to-out performance.
-- As a result of this, the shift register has a minimum of 2 clock delays.

-- Below library needs to be used for this template
-- use ieee.numeric_std.all;

-- Constant and signal declarations
-- Add these before begin keyword in architecture
constant depth_select_bits = &lt;number_of_select_bits&gt;; -- specify depth
constant data_width   = &lt;bus_width&gt;; -- specify data width

signal &lt;data_in&gt; : std_logic_vector(data_width-1 downto 0); -- shift register input
signal &lt;data_out&gt; : std_logic_vector(data_width-1 downto 0); -- shift register output

signal &lt;srl_select&gt; : std_logic_vector(depth_select_bits-1 downto 0); -- Dynamic select input to SRL
signal &lt;srl_out&gt; : std_logic_vector(data_width-1 downto 0); -- intermediate signal between srl and register

type array_slv is array (data_width-1 downto 0) of std_logic_vector(2**depth_select_bits-1 downto 0);
signal &lt;shift_reg&gt; : array_slv;


-- Add the below after begin keyword in architecture
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;clock_enable&gt; = '1' then
       for i in 0 to data_width-1 loop
           &lt;shift_reg&gt;(i) &lt;= &lt;shift_reg&gt;(i)(2**depth_select_bits-2 downto 0) &amp; &lt;data_in&gt;(i);
       end loop;
      end if;
   end if;
end process;

process(&lt;shift_reg&gt;,&lt;srl_select&gt;)
begin
   for i in 0 to data_width-1 loop
      &lt;srl_out&gt;(i) &lt;= &lt;shift_reg&gt;(i)(to_integer(unsigned(&lt;srl_select&gt;)));
   end loop;
end process;

process(&lt;clock&gt;)
begin
  if &lt;clock&gt;'event and &lt;clock&gt;='1' then
     if &lt;clock_enable&gt; = '1' then
       &lt;data_out&gt; &lt;= &lt;srl_out&gt;;
     end if;
  end if;
end process;

					</Template>
					<Template label="Static Shift SRL (bus)" treetype="template">

-- Constant and signal declarations
-- Add these before begin keyword in architecture
constant clock_cycles = &lt;number_of_clock_cycles&gt;; -- Specify Number of clock cycles to shift
constant data_width   = &lt;width&gt;; -- Specify data width

signal &lt;data_in&gt;  : std_logic_vector(data_width-1 downto 0); -- Shift register Input
signal &lt;data_out&gt; : std_logic_vector(data_width-1 downto 0); -- Shift register Output

type array_slv is array (data_width-1 downto 0) of std_logic_vector(clock_cycles-1 downto 0);
signal &lt;shift_reg&gt; : array_slv;

-- Add the below after begin keyword in architecture
process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;clock_enable&gt; = '1' then
       for i in 0 to data_width-1 loop
           &lt;shift_reg&gt;(i) &lt;= &lt;shift_reg&gt;(i)(clock_cycles-2 downto 0) &amp; &lt;data_in&gt;(i);
       end loop;
      end if;
   end if;
end process;

process (&lt;shift_reg&gt;)
begin
   for i in 0 to data_width-1 loop
      &lt;data_out&gt;(i) &lt;= &lt;shift_reg&gt;(i)(clock_cycles-1);
   end loop;
end process;


					</Template>
					<Template label="Static Shift SRL (Single-bit)" treetype="template">
-- Constant and signal declarations
-- Add these before begin keyword in architecture

constant clock_cycles = &lt;number_of_clock_cycles&gt;; -- Specify Number of clock cycles to shift
signal &lt;data_in&gt; : std_logic; -- Shift register Input
signal &lt;data_out&gt; : std_logic; -- Shift register Output
signal &lt;shift_reg&gt; : std_logic_vector(clock_cycles-1 downto 0);

-- Add the below after begin keyword in architecture

process (&lt;clock&gt;)
begin
   if &lt;clock&gt;'event and &lt;clock&gt;='1' then
      if &lt;clock_enable&gt; = '1' then
         &lt;shift_reg&gt; &lt;= &lt;shift_reg&gt;(clock_cycles-2 downto 0) &amp; &lt;data_in&gt;;
      end if;
   end if;
end process;
&lt;data_out&gt; &lt;= &lt;shift_reg&gt;(clock_cycles-1);

					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="State-Machines" treetype="folder">
				<Template label="Info (State-machine)" treetype="template">
--  Finite State-machines
--
--  There are several methods to code state-machines however following certain
-- coding styles ensures the synthesis tool FSM (Finite State-Machine)
-- extration algorithms properly identify and optimize the state-machine as
-- well as possibly improving the simulation, timing and debug of the circuit.
-- The following examples are broken down into Mealy implementations.
-- The basic trade-offs for each
-- implementation is explained below.  The general recommendation for the
-- choice of state-machine depends on the target architecture and specifics of
-- the state-machine size and behavior however typically, Moore style
-- state-machines implement better for FPGAs and Mealy implement best for
-- CPLDs.
--
--  Mealy vs. Moore Styles
--
--  There are two well known implementation styles for state-machines, Mealy
-- and Moore.  The main difference between Mealy and Moore styles is the Mealy
-- state-machine determines the output values based on both the current state
-- state as well as the inputs to the state-machine where Moore determines its
-- outputs solely on the state.  In general, Moore type of state-machines
-- implement best in FPGAs due to the fact that most often one-hot
-- state-machines are the choosen encoding method and there is little or no
-- decode and thus logic necessary for output values.  If a binary encoding is
-- used, it is possible that a more compact and sometimes faster state-machine
-- can be built using the Mealy method however this is not always true and not
-- easy to determine without knowing more specifics of the state-machine.
--
--  One-hot vs. Binary Encoding
--
--  There are several encoding methods for state-machine design however the two
-- most popular for FPGA or CPLD design are binary and one-hot.  For most FPGA
-- architectures, one-hot is the better encoding method due the the abundance
-- for FF resources and the lesser fan-in requirements for the next
-- state-equation (maps better into LUTs).  When targeting CPLDs, binary can
-- many times work better due to the logic structure of the CPLD and fewer
-- register resources.  In any case, most modern synthesis tools contain FSM
-- extraction algorithms that can identify state-machine code and choose the
-- best encoding method for the size, type and target architecture.  Eventhough
-- this facility exists, many times it can be most advantagous to manually code
-- and control the best encoding scheme f0r the design to allwo better control
-- and possibly ease debug of the implemented design.  It is suggested to
-- consult the synthesis tool documentation for details about the state-machine
-- extraction capabilities of the synthesis tool you are using.
--
--  Safe vs. Fast
--
--  When coding a state-machine, there are two generally conflicting goals that
-- must be understood, safe vs. fast.  A safe state-machine implementation
-- refers to the case where if a state-machine should get an unknown input or
-- into an unknown state that it can recover into a known state the next clock
-- cycle and resume from recovery state.  On the other hand, if this
-- requirement is discarded (no recovery state) many times the state-machine
-- can be implemeted with less logic and more speed than if state-machine
-- recovery is necessary.  How to design a safe state-machine generally
-- involves coding in a default state into the state-machine next-state case
-- clause and/or specifying to the synthesis tool to implement the
-- state-machine encoding in a "safe" mode.  Again it is suggested to consult
-- the synthesis tool documentation for details about implementing a safe
-- state-machine.


				</Template>
				<Template label="Mealy State-Machine" treetype="template">
-- This is a sample state-machine using enumerated types.
-- This will allow the synthesis tool to select the appropriate
-- encoding style and will make the code more readable.

--Insert the following in the architecture before the begin keyword
   --Use descriptive names for the states, like st1_reset, st2_search
   type state_type is (st1_&lt;name_state&gt;, st2_&lt;name_state&gt;, ...);
   signal state, next_state : state_type;
   --Declare internal signals for all outputs of the state-machine
   signal &lt;output&gt;_i : std_logic;  -- example output signal
   --other outputs

--Insert the following in the architecture after the begin keyword
   SYNC_PROC: process (&lt;clock&gt;)
   begin
      if (&lt;clock&gt;'event and &lt;clock&gt; = '1') then
         if (&lt;reset&gt; = '1') then
            state &lt;= st1_&lt;name_state&gt;;
            &lt;output&gt; &lt;= '0';
         else
            state &lt;= next_state;
            &lt;output&gt; &lt;= &lt;output&gt;_i;
         -- assign other outputs to internal signals
         end if;
      end if;
   end process;

   --MEALY State-Machine - Outputs based on state and inputs
   OUTPUT_DECODE: process (state, &lt;input1&gt;, &lt;input2&gt;, ...)
   begin
      --insert statements to decode internal output signals
      --below is simple example
      if (state = st3_&lt;name&gt; and &lt;input1&gt; = '1') then
         &lt;output&gt;_i &lt;= '1';
      else
         &lt;output&gt;_i &lt;= '0';
      end if;
   end process;

   NEXT_STATE_DECODE: process (state, &lt;input1&gt;, &lt;input2&gt;, ...)
   begin
      --declare default state for next_state to avoid latches
      next_state &lt;= state;  --default is to stay in current state
      --insert statements to decode next_state
      --below is a simple example
      case (state) is
         when st1_&lt;name&gt; =&gt;
            if &lt;input_1&gt; = '1' then
               next_state &lt;= st2_&lt;name&gt;;
            end if;
         when st2_&lt;name&gt; =&gt;
            if &lt;input_2&gt; = '1' then
               next_state &lt;= st3_&lt;name&gt;;
            end if;
         when st3_&lt;name&gt; =&gt;
            next_state &lt;= st1_&lt;name&gt;;
         when others =&gt;
            next_state &lt;= st1_&lt;name&gt;;
      end case;
   end process;

				</Template>
				<Template label="Moore State-Machine" treetype="template">
-- This is a sample state-machine using enumerated types.
-- This will allow the synthesis tool to select the appropriate
-- encoding style and will make the code more readable.

--Insert the following in the architecture before the begin keyword
   --Use descriptive names for the states, like st1_reset, st2_search
   type state_type is (st1_&lt;name_state&gt;, st2_&lt;name_state&gt;, ...);
   signal state, next_state : state_type;
   --Declare internal signals for all outputs of the state-machine
   signal &lt;output&gt;_i : std_logic;  -- example output signal
   --other outputs

--Insert the following in the architecture after the begin keyword
   SYNC_PROC: process (&lt;clock&gt;)
   begin
      if (&lt;clock&gt;'event and &lt;clock&gt; = '1') then
         if (&lt;reset&gt; = '1') then
            state &lt;= st1_&lt;name_state&gt;;
            &lt;output&gt; &lt;= '0';
         else
            state &lt;= next_state;
            &lt;output&gt; &lt;= &lt;output&gt;_i;
         -- assign other outputs to internal signals
         end if;
      end if;
   end process;

   --MOORE State-Machine - Outputs based on state only
   OUTPUT_DECODE: process (state)
   begin
      --insert statements to decode internal output signals
      --below is simple example
      if state = st3_&lt;name&gt; then
         &lt;output&gt;_i &lt;= '1';
      else
         &lt;output&gt;_i &lt;= '0';
      end if;
   end process;

   NEXT_STATE_DECODE: process (state, &lt;input1&gt;, &lt;input2&gt;, ...)
   begin
      --declare default state for next_state to avoid latches
      next_state &lt;= state;  --default is to stay in current state
      --insert statements to decode next_state
      --below is a simple example
      case (state) is
         when st1_&lt;name&gt; =&gt;
            if &lt;input_1&gt; = '1' then
               next_state &lt;= st2_&lt;name&gt;;
            end if;
         when st2_&lt;name&gt; =&gt;
            if &lt;input_2&gt; = '1' then
               next_state &lt;= st3_&lt;name&gt;;
            end if;
         when st3_&lt;name&gt; =&gt;
            next_state &lt;= st1_&lt;name&gt;;
         when others =&gt;
            next_state &lt;= st1_&lt;name&gt;;
      end case;
   end process;

				</Template>
			</SubFolder>
			<SubFolder label="Tristate Buffers" treetype="folder">
				<SubFolder label="Active High" treetype="folder">
					<Template label="Using Process" treetype="template">
process (&lt;enable&gt;, &lt;input&gt;)
begin
   if (&lt;enable&gt;='1') then
      &lt;output&gt; &lt;= &lt;input&gt;;
   else
      &lt;output&gt; &lt;= 'Z';
   end if;
end process;

					</Template>
					<Template label="Using When/Else" treetype="template">
&lt;output&gt; &lt;= &lt;input&gt; when &lt;enable&gt; ='1' else 'Z';

					</Template>
				</SubFolder>
				<SubFolder label="Active Low" treetype="folder">
					<Template label="Using Process" treetype="template">
process (&lt;enable&gt;, &lt;input&gt;)
begin
   if (&lt;enable&gt;='0') then
      &lt;output&gt; &lt;= &lt;input&gt;;
   else
      &lt;output&gt; &lt;= 'Z';
   end if;
end process;

					</Template>
					<Template label="Using When/Else" treetype="template">
&lt;output&gt; &lt;= &lt;input&gt; when &lt;enable&gt; ='0' else 'Z';

					</Template>
				</SubFolder>
				<Template label="Example Code" treetype="template">
library ieee;
use ieee.std_logic_1164.all;

entity three_st_1 is
    port(T : in  std_logic;
         I : in  std_logic;
         O : out std_logic);
end three_st_1;

architecture archi of three_st_1 is
begin

    process (I, T)
    begin
        if (T='0') then
            O &lt;= I;
        else
            O &lt;= 'Z';
        end if;
    end process;

end archi;
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Conditional" treetype="folder">
			<SubFolder label="Case" treetype="folder">
				<Template label="2-input Select" treetype="template">
   case (&lt;2-bit select&gt;) is
      when "00" =&gt;
         &lt;statement&gt;;
      when "01" =&gt;
         &lt;statement&gt;;
      when "10" =&gt;
         &lt;statement&gt;;
      when "11" =&gt;
         &lt;statement&gt;;
      when others =&gt;
         &lt;statement&gt;;
   end case;
				</Template>
				<Template label="3-input Select" treetype="template">
   case (&lt;3-bit select&gt;) is
      when "000" =&gt;
         &lt;statement&gt;;
      when "001" =&gt;
         &lt;statement&gt;;
      when "010" =&gt;
         &lt;statement&gt;;
      when "011" =&gt;
         &lt;statement&gt;;
      when "100" =&gt;
         &lt;statement&gt;;
      when "101" =&gt;
         &lt;statement&gt;;
      when "110" =&gt;
         &lt;statement&gt;;
      when "111" =&gt;
         &lt;statement&gt;;
      when others =&gt;
         &lt;statement&gt;;
   end case;
				</Template>
				<Template label="4-input Select" treetype="template">
   case (&lt;4-bit select&gt;) is
      when "0000" =&gt;
         &lt;statement&gt;;
      when "0001" =&gt;
         &lt;statement&gt;;
      when "0010" =&gt;
         &lt;statement&gt;;
      when "0011" =&gt;
         &lt;statement&gt;;
      when "0100" =&gt;
         &lt;statement&gt;;
      when "0101" =&gt;
         &lt;statement&gt;;
      when "0110" =&gt;
         &lt;statement&gt;;
      when "0111" =&gt;
         &lt;statement&gt;;
      when "1000" =&gt;
         &lt;statement&gt;;
      when "1001" =&gt;
         &lt;statement&gt;;
      when "1010" =&gt;
         &lt;statement&gt;;
      when "1011" =&gt;
         &lt;statement&gt;;
      when "1100" =&gt;
         &lt;statement&gt;;
      when "1101" =&gt;
         &lt;statement&gt;;
      when "1110" =&gt;
         &lt;statement&gt;;
      when "1111" =&gt;
         &lt;statement&gt;;
      when others =&gt;
         &lt;statement&gt;;
   end case;
				</Template>
				<Template label="5-input Select" treetype="template">
   case (&lt;5-bit select&gt;) is
      when "00000" =&gt;
         &lt;statement&gt;;
      when "00001" =&gt;
         &lt;statement&gt;;
      when "00010" =&gt;
         &lt;statement&gt;;
      when "00011" =&gt;
         &lt;statement&gt;;
      when "00100" =&gt;
         &lt;statement&gt;;
      when "00101" =&gt;
         &lt;statement&gt;;
      when "00110" =&gt;
         &lt;statement&gt;;
      when "00111" =&gt;
         &lt;statement&gt;;
      when "01000" =&gt;
         &lt;statement&gt;;
      when "01001" =&gt;
         &lt;statement&gt;;
      when "01010" =&gt;
         &lt;statement&gt;;
      when "01011" =&gt;
         &lt;statement&gt;;
      when "01100" =&gt;
         &lt;statement&gt;;
      when "01101" =&gt;
         &lt;statement&gt;;
      when "01110" =&gt;
         &lt;statement&gt;;
      when "01111" =&gt;
         &lt;statement&gt;;
      when "10000" =&gt;
         &lt;statement&gt;;
      when "10001" =&gt;
         &lt;statement&gt;;
      when "10010" =&gt;
         &lt;statement&gt;;
      when "10011" =&gt;
         &lt;statement&gt;;
      when "10100" =&gt;
         &lt;statement&gt;;
      when "10101" =&gt;
         &lt;statement&gt;;
      when "10110" =&gt;
         &lt;statement&gt;;
      when "10111" =&gt;
         &lt;statement&gt;;
      when "11000" =&gt;
         &lt;statement&gt;;
      when "11001" =&gt;
         &lt;statement&gt;;
      when "11010" =&gt;
         &lt;statement&gt;;
      when "11011" =&gt;
         &lt;statement&gt;;
      when "11100" =&gt;
         &lt;statement&gt;;
      when "11101" =&gt;
         &lt;statement&gt;;
      when "11110" =&gt;
         &lt;statement&gt;;
      when "11111" =&gt;
         &lt;statement&gt;;
      when others =&gt;
         &lt;statement&gt;;
   end case;
				</Template>
				<Template label="6-input Select" treetype="template">
   case (&lt;6-bit select&gt;) is
      when "000000" =&gt;
         &lt;statement&gt;;
      when "000001" =&gt;
         &lt;statement&gt;;
      when "000010" =&gt;
         &lt;statement&gt;;
      when "000011" =&gt;
         &lt;statement&gt;;
      when "000100" =&gt;
         &lt;statement&gt;;
      when "000101" =&gt;
         &lt;statement&gt;;
      when "000110" =&gt;
         &lt;statement&gt;;
      when "000111" =&gt;
         &lt;statement&gt;;
      when "001000" =&gt;
         &lt;statement&gt;;
      when "001001" =&gt;
         &lt;statement&gt;;
      when "001010" =&gt;
         &lt;statement&gt;;
      when "001011" =&gt;
         &lt;statement&gt;;
      when "001100" =&gt;
         &lt;statement&gt;;
      when "001101" =&gt;
         &lt;statement&gt;;
      when "001110" =&gt;
         &lt;statement&gt;;
      when "001111" =&gt;
         &lt;statement&gt;;
      when "010000" =&gt;
         &lt;statement&gt;;
      when "010001" =&gt;
         &lt;statement&gt;;
      when "010010" =&gt;
         &lt;statement&gt;;
      when "010011" =&gt;
         &lt;statement&gt;;
      when "010100" =&gt;
         &lt;statement&gt;;
      when "010101" =&gt;
         &lt;statement&gt;;
      when "010110" =&gt;
         &lt;statement&gt;;
      when "010111" =&gt;
         &lt;statement&gt;;
      when "011000" =&gt;
         &lt;statement&gt;;
      when "011001" =&gt;
         &lt;statement&gt;;
      when "011010" =&gt;
         &lt;statement&gt;;
      when "011011" =&gt;
         &lt;statement&gt;;
      when "011100" =&gt;
         &lt;statement&gt;;
      when "011101" =&gt;
         &lt;statement&gt;;
      when "011110" =&gt;
         &lt;statement&gt;;
      when "011111" =&gt;
         &lt;statement&gt;;
      when "100000" =&gt;
         &lt;statement&gt;;
      when "100001" =&gt;
         &lt;statement&gt;;
      when "100010" =&gt;
         &lt;statement&gt;;
      when "100011" =&gt;
         &lt;statement&gt;;
      when "100100" =&gt;
         &lt;statement&gt;;
      when "100101" =&gt;
         &lt;statement&gt;;
      when "100110" =&gt;
         &lt;statement&gt;;
      when "100111" =&gt;
         &lt;statement&gt;;
      when "101000" =&gt;
         &lt;statement&gt;;
      when "101001" =&gt;
         &lt;statement&gt;;
      when "101010" =&gt;
         &lt;statement&gt;;
      when "101011" =&gt;
         &lt;statement&gt;;
      when "101100" =&gt;
         &lt;statement&gt;;
      when "101101" =&gt;
         &lt;statement&gt;;
      when "101110" =&gt;
         &lt;statement&gt;;
      when "101111" =&gt;
         &lt;statement&gt;;
      when "110000" =&gt;
         &lt;statement&gt;;
      when "110001" =&gt;
         &lt;statement&gt;;
      when "110010" =&gt;
         &lt;statement&gt;;
      when "110011" =&gt;
         &lt;statement&gt;;
      when "110100" =&gt;
         &lt;statement&gt;;
      when "110101" =&gt;
         &lt;statement&gt;;
      when "110110" =&gt;
         &lt;statement&gt;;
      when "110111" =&gt;
         &lt;statement&gt;;
      when "111000" =&gt;
         &lt;statement&gt;;
      when "111001" =&gt;
         &lt;statement&gt;;
      when "111010" =&gt;
         &lt;statement&gt;;
      when "111011" =&gt;
         &lt;statement&gt;;
      when "111100" =&gt;
         &lt;statement&gt;;
      when "111101" =&gt;
         &lt;statement&gt;;
      when "111110" =&gt;
         &lt;statement&gt;;
      when "111111" =&gt;
         &lt;statement&gt;;
      when others =&gt;
         &lt;statement&gt;;
   end case;
				</Template>
			</SubFolder>
			<Template label="If / Else If / Else Statement" treetype="template">
   if &lt;condition&gt; then
      &lt;statement&gt;
   elsif &lt;condition&gt; then
      &lt;statement&gt;
   else
      &lt;statement&gt;
   end if;
			</Template>
			<Template label="Select / When Statement" treetype="template">
   with &lt;choice_expression&gt; select
      &lt;name&gt; &lt;= &lt;expression&gt; when &lt;choices&gt;,
                &lt;expression&gt; when &lt;choices&gt;,
                &lt;expression&gt; when others;
			</Template>
			<Template label="When / Else Statement" treetype="template">
   &lt;name&gt; &lt;= &lt;expression&gt; when &lt;condition&gt; else
             &lt;expression&gt; when &lt;condition&gt; else
             &lt;expression&gt;;
			</Template>
		</SubFolder>
		<SubFolder label="Example Modules" treetype="folder">
			<SubFolder label="DSP" treetype="folder">
				<Template label="Complex Multiplier" treetype="template">
--  Complex Multilier
--  The following code implements a parameterizable complex multiplier
--  The style described uses 3 DSP's to implement the complex multiplier
--  taking advantage of the pre-adder, so widths chosen should be less
--  than what the architecture supports or else extra-logic/extra DSPs
--  will be inferred

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity cmult is
  generic (AWIDTH : natural := 16; -- size of 1st input of multiplier
           BWIDTH : natural := 18  -- size of 2nd input of multiplier
          );
  port (clk    : in  std_logic;
        ar : in  std_logic_vector(AWIDTH-1 downto 0); -- 1st input's real part
        ai : in  std_logic_vector(AWIDTH-1 downto 0); -- 1st input's imaginary part
        br : in  std_logic_vector(BWIDTH-1 downto 0); -- 2nd input's real part
        bi : in  std_logic_vector(BWIDTH-1 downto 0); -- 2nd input's imaginary part
        pr : out std_logic_vector(AWIDTH+BWIDTH downto 0);  -- real part of output
        pi : out std_logic_vector(AWIDTH+BWIDTH downto 0)); -- imaginary part of output
end cmult;

architecture rtl of cmult is

signal ai_d, ai_dd, ai_ddd, ai_dddd             : signed(AWIDTH-1 downto 0);
signal ar_d, ar_dd, ar_ddd, ar_dddd             : signed(AWIDTH-1 downto 0);
signal bi_d, bi_dd, bi_ddd, br_d, br_dd, br_ddd : signed(BWIDTH-1 downto 0);
signal addcommon                                : signed(AWIDTH downto 0);
signal addr, addi                               : signed(BWIDTH downto 0);
signal mult0, multr, multi, pr_int, pi_int      : signed(AWIDTH+BWIDTH downto 0);
signal common, commonr1, commonr2               : signed(AWIDTH+BWIDTH downto 0);

begin
process(clk)
 begin
  if rising_edge(clk) then
      ar_d   &lt;= signed(ar);
      ar_dd  &lt;= signed(ar_d);
      ai_d   &lt;= signed(ai);
      ai_dd  &lt;= signed(ai_d);
      br_d   &lt;= signed(br);
      br_dd  &lt;= signed(br_d);
      br_ddd &lt;= signed(br_dd);
      bi_d   &lt;= signed(bi);
      bi_dd  &lt;= signed(bi_d);
      bi_ddd &lt;= signed(bi_dd);
  end if;
end process;

-- Common factor (ar - ai) x bi, shared for the calculations
-- of the real and imaginary final products.
--
process(clk)
 begin
  if rising_edge(clk) then
      addcommon &lt;= resize(ar_d, AWIDTH+1) - resize(ai_d, AWIDTH+1);
      mult0     &lt;= addcommon * bi_dd;
      common    &lt;= mult0;
 end if;
end process;

-- Real product
process(clk)
begin
  if rising_edge(clk) then
      ar_ddd   &lt;= ar_dd;
      ar_dddd  &lt;= ar_ddd;
      addr     &lt;= resize(br_ddd, BWIDTH+1) - resize(bi_ddd, BWIDTH+1);
      multr    &lt;= addr * ar_dddd;
      commonr1 &lt;= common;
      pr_int   &lt;= multr + commonr1;
  end if;
end process;

-- Imaginary product
--
process(clk)
 begin
  if rising_edge(clk) then
      ai_ddd   &lt;= ai_dd;
      ai_dddd  &lt;= ai_ddd;
      addi     &lt;= resize(br_ddd, BWIDTH+1) + resize(bi_ddd, BWIDTH+1);
      multi    &lt;= addi * ai_dddd;
      commonr2 &lt;= common;
      pi_int   &lt;= multi + commonr2;
  end if;
end process;

pr &lt;= std_logic_vector(pr_int);
pi &lt;= std_logic_vector(pi_int);

end rtl;
-- The following is an instantiation template for cmult
-- Component Declaration
-- Uncomment the below component declaration when using
--component cmult
--  generic (AWIDTH : natural := 16; -- size of 1st input of multiplier
--           BWIDTH : natural := 18  -- size of 2nd input of multiplier
--          );
--  port (clk    : in  std_logic;
--        ar : in  std_logic_vector(AWIDTH-1 downto 0); -- 1st input's real part
--        ai : in  std_logic_vector(AWIDTH-1 downto 0); -- 1st input's imaginary part
--        br : in  std_logic_vector(BWIDTH-1 downto 0); -- 2nd input's real part
--        bi : in  std_logic_vector(BWIDTH-1 downto 0); -- 2nd input's imaginary part
--        pr : out std_logic_vector(AWIDTH+BWIDTH downto 0);  -- real part of output
--        pi : out std_logic_vector(AWIDTH+BWIDTH downto 0)); -- imaginary part of output
--end cmult;
-- Instantiation
-- Uncomment the instantiation below when using
-- &lt;your_instance_name&gt; : cmult
--              generic map (
--                           AWIDTH =&gt; 16,
--                           BWIDTH =&gt; 18
--                          )
--              port map (
--                        clk     =&gt; clk,
--                        ar  =&gt; ar,
--                        ai  =&gt; ai,
--                        br  =&gt; br,
--                        bi  =&gt; bi,
--                        pr  =&gt; pr,
--                        pi  =&gt; pi
--                      );
				</Template>
				<Template label="Convergent Rounding(Even)" treetype="template">
-- This example shows how to infer Convergent Rounding (Even) using
-- pattern detect within DSP block (Width of the inputs should be within
-- what can be supported by the DSP architecture)
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity convergentRoundingEven is
  port (clk   : in  std_logic;
        a     : in  std_logic_vector (23 downto 0);
        b     : in  std_logic_vector (15 downto 0);
        zlast : out std_logic_vector (23 downto 0));
end convergentRoundingEven;

architecture beh of convergentRoundingEven is

  signal ar : signed(a'range);
  signal br : signed(b'range);
  signal z1 : signed(a'length + b'length - 1 downto 0);

  signal multaddr       : signed(a'length + b'length - 1 downto 0);
  signal multadd        : signed(a'length + b'length - 1 downto 0);
  signal pattern_detect : boolean;

  constant pattern : signed(15 downto 0) := (others =&gt; '0');
  constant c : signed := "0000000000000000000000000111111111111111";

  -- Convergent Rounding: LSB Correction Technique
  -- ---------------------------------------------
  -- For static convergent rounding, the pattern detector can be used
  -- to detect the midpoint case. For example, in an 8-bit round, if
  -- the decimal place is set at 4, the C input should be set to
  -- 0000.0111.  Round to even rounding should use CARRYIN = "1" and
  -- check for PATTERN "XXXX.0000" and replace the units place with 0
  -- if the pattern is matched. See UG193 for more details.

begin

  multadd &lt;= z1 + c;

  process(clk)
  begin
    if rising_edge(clk) then
      ar       &lt;= signed(a);
      br       &lt;= signed(b);
      z1       &lt;= ar * br;
      multaddr &lt;= multadd;
      if multadd(15 downto 0) = pattern then
        pattern_detect &lt;= true;
      else
        pattern_detect &lt;= false;
      end if;
    end if;
  end process;

  -- Unit bit replaced with 0 if pattern is detected
  process(clk)
  begin
    if rising_edge(clk) then
      if pattern_detect = true then
        zlast &lt;= std_logic_vector(multaddr(39 downto 17)) &amp; "0";
      else
        zlast &lt;= std_logic_vector(multaddr(39 downto 16));
      end if;
    end if;
  end process;

end beh;
-- The following is an instantiation template for squarediffmult
-- Component Declaration
-- Uncomment the below component declaration when using
--component convergentRoundingEven
--  port (clk   : in  std_logic;
--        a     : in  std_logic_vector (23 downto 0);
--        b     : in  std_logic_vector (15 downto 0);
--        zlast : out std_logic_vector (23 downto 0)
--       );
--end component;
-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : convergentRoundingEven
-- port map (
--           clk   =&gt; clk,
--           a     =&gt; a,
--           b     =&gt; b,
--           zlast =&gt; zlast
--          );
				</Template>
				<Template label="Convergent Rounding(Odd)" treetype="template">
-- This example shows how to infer Convergent Rounding (Odd)
-- using pattern detect within DSP block (Width of the inputs
-- should be within what can be supported by the DSP architecture)
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity convergentRoundingOdd is
  port (clk   : in  std_logic;
        a     : in  std_logic_vector (23 downto 0);
        b     : in  std_logic_vector (15 downto 0);
        zlast : out std_logic_vector (23 downto 0));
end convergentRoundingOdd;

architecture beh of convergentRoundingOdd is

  signal ar : signed(a'range);
  signal br : signed(b'range);
  signal z1 : signed(a'length + b'length - 1 downto 0);

  signal multadd, multaddr : signed(a'length + b'length - 1 downto 0);
  signal pattern_detect    : boolean;

  constant pattern : signed(15 downto 0) := (others =&gt; '1');
  constant c       : signed := "0000000000000000000000000111111111111111";

  -- Convergent Rounding: LSB Correction Technique
  -- ---------------------------------------------
  -- For static convergent rounding,  the pattern detector can be
  -- used to detect  the midpoint case. For example,  in an 8-bit
  -- round, if the decimal place is  set at 4, the C input should
  -- be  set to  0000.0111.   Round to  odd  rounding should  use
  -- CARRYIN =  "0" and  check for  PATTERN "XXXX.1111"  and then
  -- replace  the  units place  bit  with  1  if the  pattern  is
  -- matched. See UG193 for details

begin

  multadd &lt;= z1 + c;

  process(clk)
  begin
    if rising_edge(clk) then
      ar       &lt;= signed(a);
      br       &lt;= signed(b);
      z1       &lt;= ar * br;
      multaddr &lt;= multadd;
      if multadd(15 downto 0) = pattern then
        pattern_detect &lt;= true;
      else
        pattern_detect &lt;= false;
      end if;
    end if;
  end process;

  process(clk)
  begin
    if rising_edge(clk) then
      if pattern_detect = true then
        zlast &lt;= std_logic_vector(multaddr(39 downto 17)) &amp; "1";
      else
        zlast &lt;= std_logic_vector(multaddr(39 downto 16));
      end if;
    end if;
  end process;
end beh;
-- The following is an instantiation template for squarediffmult
-- Component Declaration
-- Uncomment the below component declaration when using
--component convergentRoundingOdd
--  port (clk   : in  std_logic;
--        a     : in  std_logic_vector (23 downto 0);
--        b     : in  std_logic_vector (15 downto 0);
--        zlast : out std_logic_vector (23 downto 0)
--       );
--end component;
-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : convergentRoundingOdd
-- port map (
--           clk   =&gt; clk,
--           a     =&gt; a,
--           b     =&gt; b,
--           zlast =&gt; zlast
--          );
				</Template>
				<Template label="Dynamic preadd sub followed by mult add" treetype="template">
-- This module describes a dynamic pre add/sub followed by multiplier, adder
-- Make sure the widths are less than what is supported by the architecture
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity dynpreaddmultadd is
	generic(
		AWIDTH : natural := 12;
		BWIDTH : natural := 16;
		CWIDTH : natural := 17
	);
	port(
		clk    : in  std_logic;  -- clock input
 		subadd : in  std_logic;  -- Dynamic subadd control
		ain    : in  std_logic_vector(AWIDTH - 1 downto 0);
		bin    : in  std_logic_vector(BWIDTH - 1 downto 0);
		cin    : in  std_logic_vector(CWIDTH - 1 downto 0);
		din    : in  std_logic_vector(BWIDTH + CWIDTH downto 0);
		pout   : out std_logic_vector(BWIDTH + CWIDTH downto 0)
	);
end dynpreaddmultadd;

architecture rtl of dynpreaddmultadd is
	signal a          : signed(AWIDTH - 1 downto 0);
	signal b          : signed(BWIDTH - 1 downto 0);
	signal c          : signed(CWIDTH - 1 downto 0);
	signal add        : signed(BWIDTH downto 0);
	signal d, mult, p : signed(BWIDTH + CWIDTH downto 0);

begin
	process(clk)
	begin
		if rising_edge(clk) then
			a &lt;= signed(ain);
			b &lt;= signed(bin);
			c &lt;= signed(cin);
			d &lt;= signed(din);
			if subadd = '1' then
				add &lt;= resize(a, BWIDTH + 1) - resize(b, BWIDTH + 1);
			else
				add &lt;= resize(a, BWIDTH + 1) + resize(b, BWIDTH + 1);
			end if;
			mult &lt;= add * c;
			p    &lt;= mult + d;
		end if;
	end process;

	--
	-- Type conversion for output
	--
	pout &lt;= std_logic_vector(p);

end rtl;
-- The following is an instantiation template for dynpreaddmultadd 
-- Component Declaration
-- Uncomment the below component declaration when using
-- component dynpreaddmultadd
	generic(
		AWIDTH : natural := 12;
		BWIDTH : natural := 16;
		CWIDTH : natural := 17
	);
	port(
		clk    : in  std_logic;  -- clock input
 		subadd : in  std_logic;  -- Dynamic subadd control
		ain    : in  std_logic_vector(AWIDTH - 1 downto 0);
		bin    : in  std_logic_vector(BWIDTH - 1 downto 0);
		cin    : in  std_logic_vector(CWIDTH - 1 downto 0);
		din    : in  std_logic_vector(BWIDTH + CWIDTH downto 0);
		pout   : out std_logic_vector(BWIDTH + CWIDTH downto 0)
	);
end component;
-- Instantiation
-- Uncomment the below component declaration when using
-- &lt;your_instance_name&gt; : dynpreaddmultadd
-- generic map (
--		AWIDTH =&gt; AWIDTH, 
--		BWIDTH =&gt; BWIDTH, 
--		CWIDTH =&gt; CWIDTH
--       )
-- port map (
--		clk =&gt; clk,    
-- 		subadd =&gt; subadd,          
--		ain =&gt; ain,    
--		bin =&gt; bin,    
--		cin =&gt; cin,    
--		din =&gt; din,    
--		pout =&gt; pout
--       );  
				</Template>
				<Template label="FIR Symmetric Systolic Filter" treetype="template">
-- Top module is sfir_even_symmetric_systolic_top
-- Two submodules sfir_shifter and sfir_even_symmetric_systolic_element are
-- instantiated in the toplevel

-- FIR filter shifter
-- submodule used in top (sfir_even_symmetric_systolic_top)
-- This module is a shift register which shifts data by the specified taps
library ieee;
use ieee.std_logic_1164.all;

entity sfir_shifter is
  generic (DSIZE : natural := 16; NBTAP : natural := 4);
  port (clk     : in  std_logic;
        datain  : in  std_logic_vector (DSIZE-1 downto 0);
        dataout : out std_logic_vector (DSIZE-1 downto 0));
end sfir_shifter;

architecture rtl of sfir_shifter is
  -- Declare signals
  --
  type CHAIN is array (0 to 2*NBTAP-1) of std_logic_vector(DSIZE-1 downto 0);
  signal tmp: CHAIN;

begin

process(clk)
begin
 if rising_edge(clk) then
   tmp(0) &lt;= datain;
   looptmp :
   for i in 0 to 2*NBTAP-2 loop
        tmp(i+1) &lt;= tmp(i);
    end loop;
 end if;
end process;

dataout &lt;= tmp(2*NBTAP-1);

end rtl;

--
-- FIR filter engine (multiply with pre-add and post-add)
-- submodule used in top (sfir_even_symmetric_systolic_top)
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity sfir_even_symmetric_systolic_element is
  generic (DSIZE : natural := 16);
  port (clk                      : in  std_logic;
        coeffin, datain, datazin : in  std_logic_vector(DSIZE-1 downto 0);
        cascin                   : in  std_logic_vector(2*DSIZE downto 0);
        cascdata                 : out std_logic_vector(DSIZE-1 downto 0);
        cascout                  : out std_logic_vector(2*DSIZE downto 0));
end sfir_even_symmetric_systolic_element;

architecture rtl of sfir_even_symmetric_systolic_element is

-- Declare signals
--
signal coeff, data, dataz, datatwo : signed (DSIZE-1 downto 0);
signal preadd                      : signed (DSIZE downto 0);
signal product, cascouttmp         : signed (2*DSIZE downto 0);

begin

process(clk)
 begin
  if rising_edge(clk) then
      coeff      &lt;= signed(coeffin);
      data       &lt;= signed(datain);
      datatwo    &lt;= data;
      dataz      &lt;= signed(datazin);
      preadd     &lt;= resize(datatwo,DSIZE+1) + resize(dataz,DSIZE+1);
      product    &lt;= preadd * coeff;
      cascouttmp &lt;= product + signed(cascin);
  end if;
end process;

-- Type conversion for output
--
cascout  &lt;= std_logic_vector(cascouttmp);
cascdata &lt;= std_logic_vector(datatwo);

end rtl;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity sfir_even_symmetric_systolic_top is
  generic (
            NBTAP : natural := 4;
            DSIZE : natural := 16;
            PSIZE : natural := 33
          );
  port    (
           clk    : in  std_logic;
           datain : in  std_logic_vector (DSIZE-1 downto 0);
           firout : out std_logic_vector (PSIZE-1 downto 0)
          );
end sfir_even_symmetric_systolic_top;

architecture rtl of sfir_even_symmetric_systolic_top is

-- Declare signals
--
type DTAB is array (0 to NBTAP-1) of std_logic_vector(DSIZE-1 downto 0);
type HTAB is array (0 to NBTAP-1) of std_logic_vector(0 to DSIZE-1);
type PTAB is array (0 to NBTAP-1) of std_logic_vector(PSIZE-1 downto 0);

signal arraydata, dataz : DTAB;
signal arrayprod        : PTAB;
signal shifterout       : std_logic_vector (DSIZE-1 downto 0);

-- Initialize coefficients and a "zero" for the first filter element
--
constant h          : HTAB := ((std_logic_vector(TO_SIGNED(  63, DSIZE))),
                               (std_logic_vector(TO_SIGNED(  18, DSIZE))),
                               (std_logic_vector(TO_SIGNED(-100, DSIZE))),
                               (std_logic_vector(TO_SIGNED(   1, DSIZE))));
constant zero_psize : std_logic_vector(PSIZE-1 downto 0) := (others =&gt; '0');

begin

-- Connect last product to output
--
firout &lt;= arrayprod(nbtap-1);

-- Shifter
--
shift_u0 :  entity work.sfir_shifter
                   generic map (
                                DSIZE =&gt; DSIZE,
                                NBTAP =&gt; NBTAP
                               )
                   port map    (
                                clk =&gt; clk,
                                datain =&gt; datain,
                                dataout =&gt; shifterout
                               );


-- Connect the arithmetic building blocks of the FIR
--
gen : for I in 0 to NBTAP-1 generate
      begin
      g0 : if I = 0 generate
            element_u0 :  entity work.sfir_even_symmetric_systolic_element
                          generic map (DSIZE =&gt; DSIZE)
                          port map(
                                    clk       =&gt; clk,
                                    coeffin   =&gt; h(I),
                                    datain    =&gt; datain,
                                    datazin   =&gt; shifterout,
                                    cascin    =&gt; zero_psize,
                                    cascdata  =&gt; arraydata(I),
                                    cascout   =&gt; arrayprod(I)
                                   );
           end generate g0;
      gi : if I /= 0 generate
            element_ui :  entity work.sfir_even_symmetric_systolic_element
                          generic map (DSIZE =&gt; DSIZE)
                          port map(
                                    clk       =&gt; clk,
                                    coeffin   =&gt; h(I),
                                    datain    =&gt; arraydata(I-1),
                                    datazin   =&gt; shifterout,
                                    cascin    =&gt; arrayprod(I-1),
                                    cascdata  =&gt; arraydata(I),
                                    cascout   =&gt; arrayprod(I)
                                  );
           end generate gi;
      end generate gen;
end rtl;

-- The following is an instantiation template for sfir_even_symmetric_systolic_top
-- Component Declaration
-- Uncomment the below component declaration when using
--component sfir_even_symmetric_systolic_top
--  generic (
--            NBTAP : natural := 4;
--            DSIZE : natural := 16;
--            PSIZE : natural := 33
--          );
--  port    (
--           clk    : in  std_logic;
--           datain : in  std_logic_vector (DSIZE-1 downto 0);
--           firout : out std_logic_vector (PSIZE-1 downto 0)
--          );
--end component;
-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : sfir_even_symmetric_systolic_top
--  generic map (
--                NBTAP =&gt; 4,
--                DSIZE =&gt; 16,
--                PSIZE =&gt; 33
--             )
--  port map   (
--              clk   =&gt; clk,
--              datain =&gt; datain,
--              firout =&gt; firout
--             );
				</Template>
				<Template label="Multiply and accumulate" treetype="template">
--  Multiply-accumulate unit
--  The following code implements a parameterizable Multiply-accumulate unit
--  with synchronous load to reset the accumulator without losing a clock cycle
--  Size of inputs/output should be less than/equal to what is supported by the architecture else extra logic/dsps will be inferred
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity macc is
  generic (
           SIZEIN  : natural := 16; -- width of the inputs
           SIZEOUT : natural := 40  -- width of the output
          );
  port (
        clk         : in std_logic;
        ce          : in std_logic;
        sload       : in  std_logic;
        a           : in  signed (SIZEIN-1 downto 0);
        b           : in  signed (SIZEIN-1 downto 0);
        accum_out   : out signed (SIZEOUT-1 downto 0));
end entity;

architecture rtl of macc is
  -- Declare registers for intermediate values
signal a_reg, b_reg          : signed (SIZEIN-1 downto 0);
signal sload_reg             : std_logic;
signal mult_reg              : signed (2*SIZEIN-1 downto 0);
signal adder_out, old_result : signed (SIZEOUT-1 downto 0);

begin

process (adder_out, sload_reg)
 begin
  if sload_reg = '1' then
      old_result &lt;= (others =&gt; '0');
  else
      -- 'sload' is now active (=low) and opens the accumulation loop.
      -- The accumulator takes the next multiplier output in
      -- the same cycle.
      old_result &lt;= adder_out;
  end if;
end process;

process (clk)
 begin
  if rising_edge(clk) then
    if ce = '1' then
        a_reg     &lt;= a;
        b_reg     &lt;= b;
        mult_reg  &lt;= a_reg * b_reg;
        sload_reg &lt;= sload;
        -- Store accumulation result into a register
        adder_out &lt;= old_result + mult_reg;
    end if;
  end if;
end process;

-- Output accumulation result
accum_out &lt;= adder_out;

end rtl;
-- The following is an instantiation template for macc
-- Component Declaration
-- Uncomment the below component declaration when using
--component macc
--  generic (
--           SIZEIN  : natural := 16; -- width of the inputs
--           SIZEOUT : natural := 40  -- width of the output
--          );
--  port (
--        clk         : in std_logic;
--        ce          : in std_logic;
--        sload       : in  std_logic;
--        a           : in  signed (SIZEIN-1 downto 0);
--        b           : in  signed (SIZEIN-1 downto 0);
--        accum_out   : out signed (SIZEOUT-1 downto 0));
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : macc
--  generic map (
--                SIZEIN =&gt;   16, -- width of the inputs
--                SIZEOUT =&gt;  40  -- width of the output
--          );
--  port map (
--            clk =&gt; clk,
--            ce =&gt; ce,
--            sload =&gt; sload,
--            a =&gt; a,
--            b =&gt; b,
--            accum_out =&gt; accum_out
--           );
				</Template>
				<Template label="Pre-subtractor with multiplication" treetype="template">
-- This code implements a parameterizable subtractor followed by multiplier which will be packed into DSP Block. Widths must be less than or equal to what is supported by the DSP block else exta logic will be inferred
-- Operation : (a-b) * c
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity presubmult is
  generic (
           AWIDTH : natural := 12;  -- Width of A input
           BWIDTH : natural := 16;  -- Width of B input
           CWIDTH : natural := 17   -- Width of C input
          );
  port (
        clk  : in  std_logic;     -- Clock
        ain  : in  std_logic_vector(AWIDTH-1 downto 0); -- A input
        bin  : in  std_logic_vector(BWIDTH-1 downto 0); -- B input
        cin  : in  std_logic_vector(CWIDTH-1 downto 0); -- C input
        pout : out std_logic_vector(BWIDTH+CWIDTH downto 0) -- Output
       );
end presubmult;

architecture rtl of presubmult is

signal a       : signed(AWIDTH-1 downto 0);
signal b       : signed(BWIDTH-1 downto 0);
signal c       : signed(CWIDTH-1 downto 0);
signal add     : signed(BWIDTH downto 0);
signal mult, p : signed(BWIDTH+CWIDTH downto 0);

begin

process(clk)
 begin
  if rising_edge(clk) then
     a    &lt;= signed(ain);
     b    &lt;= signed(bin);
     c    &lt;= signed(cin);
     add  &lt;= resize(a, BWIDTH+1) - resize(b, BWIDTH+1);
     mult &lt;= add * c;
     p    &lt;= mult;
  end if;
end process;

--
-- Type conversion for output
--
pout &lt;= std_logic_vector(p);

end rtl;
-- The following is an instantiation template for presubmult
-- Component Declaration
-- Uncomment the below component declaration when using
--component presubmult
--  generic (
--           AWIDTH : natural := 12;  -- Width of A input
--           BWIDTH : natural := 16;  -- Width of B input
--           CWIDTH : natural := 17   -- Width of C input
--          );
--  port (
--        clk  : in  std_logic;     -- Clock
--        ain  : in  std_logic_vector(AWIDTH-1 downto 0); -- A input
--        bin  : in  std_logic_vector(BWIDTH-1 downto 0); -- B input
--        cin  : in  std_logic_vector(CWIDTH-1 downto 0); -- C input
--        pout : out std_logic_vector(BWIDTH+CWIDTH downto 0) -- Output
--       );
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
-- &lt;your_instance_name&gt; : presubmult
--  generic map (
--           AWIDTH =&gt; 12;  -- Width of A input
--           BWIDTH =&gt; 16;  -- Width of B input
--           CWIDTH =&gt; 17   -- Width of C input
--          );
--  port map
--       (
--        clk =&gt; clk,
--        ain =&gt; ain,
--        bin =&gt; bin,
--        cin =&gt; cin,
--        pout =&gt; pout
--       );
				</Template>
				<Template label="Squarer" treetype="template">
-- This module implements a parameterizable (a-b) squarer
-- which can be implemented in a DSP48E2(ultrascale) by using the pre-adder
-- The size should be less than or equal to what is supported
-- by the architecture
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity squarediffmult is
  generic (
           SIZEIN : natural := 16
          );
    port (
          clk : in  std_logic;
          ce  : in  std_logic;
          rst : in  std_logic;
          ain : in  std_logic_vector(SIZEIN-1 downto 0);
          bin : in  std_logic_vector(SIZEIN-1 downto 0);
          square_out  : out std_logic_vector(2*SIZEIN+1 downto 0)
         );
end squarediffmult;

architecture rtl of squarediffmult is

  -- Declare intermediate values
  signal a_reg, b_reg : signed(SIZEIN-1 downto 0);
  signal diff_reg     : signed(SIZEIN downto 0);
  signal m_reg, p_reg : signed(2*SIZEIN+1 downto 0);

begin

process(clk)
 begin
  if rising_edge(clk) then
   if rst = '1' then
      a_reg    &lt;= (others =&gt; '0');
      b_reg    &lt;= (others =&gt; '0');
      diff_reg &lt;= (others =&gt; '0');
      m_reg    &lt;= (others =&gt; '0');
      p_reg    &lt;= (others =&gt; '0');
   else
      a_reg    &lt;= signed(ain);
      b_reg    &lt;= signed(bin);
      diff_reg &lt;= resize(a_reg, SIZEIN+1) - resize(b_reg, SIZEIN+1);
      m_reg    &lt;= diff_reg * diff_reg;
      p_reg    &lt;= m_reg;
   end if;
  end if;
end process;

--
-- Type conversion for output
--
square_out &lt;= std_logic_vector(p_reg);

end rtl;
-- The following is an instantiation template for squarediffmult
-- Component Declaration
-- Uncomment the below component declaration when using
--component squarediffmult
--  generic (
--           SIZEIN : natural := 16
--          );
--    port (
--          clk : in  std_logic;
--          ce  : in  std_logic;
--          rst : in  std_logic;
--          ain : in  std_logic_vector(SIZEIN-1 downto 0);
--          bin : in  std_logic_vector(SIZEIN-1 downto 0);
--          square_out  : out std_logic_vector(2*SIZEIN+1 downto 0)
--         );
--end component;
-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : squarediffmult
--&lt;your_instance_name&gt; : squarediffmult
--  generic map (
--               SIZEIN =&gt; 16
--              )
--    port map
--         (
--          clk =&gt; clk,
--          ce  =&gt; ce,
--          rst =&gt; rst,
--          ain =&gt; ain,
--          bin =&gt; bin,
--          square_out =&gt; square_out
--         );
				</Template>
			</SubFolder>
			<SubFolder label="Misc" treetype="folder">
				<Template label="Asynchronous Input Synchronization (Reduces Issues w/ Metastability)" treetype="template">
-- Asynchronous Input Synchronization
--
-- The following code is an example of synchronizing an asynchronous input
-- of a design to reduce the probability of metastability affecting a circuit.
--
-- The following synthesis and implementation attributes are added to the code
-- in order improve the MTBF characteristics of the implementation:
--
--  ASYNC_REG="TRUE" - Specifies registers will be receiving asynchronous data
--                     input to allow tools to report and improve metastability
--
-- The following constants are available for customization:
--
--   SYNC_STAGES     - Integer value for number of synchronizing registers, must be 2 or higher
--   PIPELINE_STAGES - Integer value for number of registers on the output of the
--                     synchronizer for the purpose of improveing performance.
--                     Particularly useful for high-fanout nets.
--   INIT            - Initial value of synchronizer registers upon startup, 1'b0 or 1'b1.

library ieee;
use ieee.std_logic_1164.all;
entity async_input_sync is generic (
                                    SYNC_STAGES : integer := 3;
                                    PIPELINE_STAGES : integer := 1;
                                    INIT : std_logic := '0'
                                   );
                            port   (
                                    clk : in std_logic;
                                    async_in : in std_logic;
                                    sync_out : out std_logic
                                   );
end async_input_sync;

architecture rtl of async_input_sync is
signal sreg : std_logic_vector(SYNC_STAGES-1 downto 0) := (others =&gt; INIT);
attribute async_reg : string;
attribute async_reg of sreg : signal is "true";
signal sreg_pipe : std_logic_vector(PIPELINE_STAGES-1 downto 0) := (others =&gt; INIT);
attribute shreg_extract : string;
attribute shreg_extract of sreg_pipe : signal is "false";
begin
   process(clk)
   begin
    if(clk'event and clk='1')then
       sreg &lt;= sreg(SYNC_STAGES-2 downto 0) &amp; async_in;  -- Async Input async_in
    end if;
   end process;

   no_pipeline : if PIPELINE_STAGES = 0 generate
   begin
      sync_out &lt;= sreg(SYNC_STAGES-1);
   end generate;

   one_pipeline : if PIPELINE_STAGES = 1 generate
   begin
    process(clk)
    begin
      if(clk'event and clk='1') then
        sync_out &lt;= sreg(SYNC_STAGES-1);
      end if;
    end process;
   end generate;

   multiple_pipeline : if PIPELINE_STAGES &gt; 1 generate
   begin
    process(clk)
    begin
      if(clk'event and clk='1') then
        sreg_pipe &lt;= sreg_pipe(PIPELINE_STAGES-2 downto 0) &amp; sreg(SYNC_STAGES-1);
      end if;
    end process;
    sync_out &lt;= sreg_pipe(PIPELINE_STAGES-1);
   end generate;
end rtl;
-- The following is an instantiation template for async_input_sync
-- Component Declaration
-- Uncomment the below component declaration when using
-- component async_input_sync
-- generic (
--          SYNC_STAGES : integer := 3;
--          PIPELINE_STAGES : integer := 1;
--          INIT : std_logic := '0'
--          );
-- port   (
--          clk : in std_logic;
--          async_in : in std_logic;
--          sync_out : out std_logic
--        );
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : async_input_sync
--
-- generic map (
--          SYNC_STAGES =&gt; 3,
--          PIPELINE_STAGES =&gt; 1,
--          INIT =&gt; '0'
--          );
-- port map (
--          clk =&gt; clk,
--          async_in =&gt; async_in,
--          sync_out =&gt; sync_out
--        );

				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<SubFolder label="Simple Dual Port" treetype="folder">
						<Template label="1 Clock" treetype="template">
--  Xilinx Simple Dual Port Single Clock RAM
--  This code implements a parameterizable SDP single clock memory.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
return ret_val;
end function;

end package body ram_pkg;

library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_simple_dual_port_1_clock_ram is
generic (
    RAM_WIDTH : integer := 64;                      -- Specify RAM data width
    RAM_DEPTH : integer := 512;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"                        -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Write address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Read address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic;                       			  -- Write enable
        enb   : in std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
        rstb  : in std_logic;                       			  -- Output reset (does not affect memory contents)
        regceb: in std_logic;                       			  -- Output register enable
        doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  -- RAM output data
    );

end xilinx_simple_dual_port_1_clock_ram;

architecture rtl of xilinx_simple_dual_port_1_clock_ram is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;

signal doutb_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal
signal ram_data : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);

begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

signal ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(wea = '1') then
            ram_name(to_integer(unsigned(addra))) &lt;= dina;
        end if;
        if(enb = '1') then
            ram_data &lt;= ram_name(to_integer(unsigned(addrb)));
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    doutb &lt;= ram_data;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data;
        end if;
    end if;
end process;

doutb &lt;= doutb_reg;

end generate;

end rtl;

-- The following is an instantiation template for xilinx_simple_dual_port_1_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_simple_dual_port_1_clock_ram is
-- generic (
-- RAM_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic;
-- enb   : in std_logic;
-- rstb  : in std_logic;
-- regceb: in std_logic;
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--
--end component;
--
-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_simple_dual_port_1_clock_ram
-- generic map (
-- RAM_WIDTH =&gt; 18,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- clka   =&gt; clka,
-- wea    =&gt; wea,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- regceb =&gt; regceb,
-- doutb  =&gt; doutb
--);

						</Template>
						<Template label="1 Clock w/ Byte-write" treetype="template">
--  Xilinx Simple Dual Port Single Clock RAM with Byte-write
--  This code implements a parameterizable SDP single clock memory.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

end package body ram_pkg;


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_simple_dual_port_byte_write_1_clock_ram is
generic (
    NB_COL : integer := 8; 	                 -- Specify number of colums (number of bytes)
    COL_WIDTH : integer := 8;                      -- Specify column width (byte width, typically 8 or 9)
    RAM_DEPTH : integer := 512;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"                        -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Write address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Read address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector((NB_COL*COL_WIDTH)-1 downto 0);		  -- RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic_vector(NB_COL-1 downto 0);                       			  -- Write enable
        enb   : in std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
        rstb  : in std_logic;                       			  -- Output reset (does not affect memory contents)
        regceb: in std_logic;                       			  -- Output register enable
        doutb : out std_logic_vector((NB_COL*COL_WIDTH)-1 downto 0)   			  -- RAM output data
    );

end xilinx_simple_dual_port_byte_write_1_clock_ram;

architecture rtl of xilinx_simple_dual_port_byte_write_1_clock_ram is
constant C_NB_COL : integer := NB_COL;
constant C_COL_WIDTH : integer := COL_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;

signal doutb_reg : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector ((C_NB_COL*C_COL_WIDTH)-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

signal ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(enb = '1') then
            ram_data &lt;= ram_name(to_integer(unsigned(addrb)));
        end if;
    end if;
end process;

process(clka)
begin
    if(clka'event and clka = '1') then
        for i in 0 to C_NB_COL-1 loop
            if(wea(i) = '1') then
                ram_name(to_integer(unsigned(addra)))(((i+1)*C_COL_WIDTH)-1 downto i*C_COL_WIDTH) &lt;= dina(((i+1)*C_COL_WIDTH)-1 downto i*C_COL_WIDTH);
            end if;
        end loop;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    doutb &lt;= ram_data;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data;
        end if;
    end if;
end process;

doutb &lt;= doutb_reg;

end generate;

end rtl;

-- The following is an instantiation template for xilinx_simple_dual_port_byte_write_1_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_simple_dual_port_byte_write_1_clock_ram is
-- generic (
-- NB_COL : integer,
-- COL_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic;
-- enb   : in std_logic;
-- rstb  : in std_logic;
-- regceb: in std_logic;
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_simple_dual_port_byte_write_1_clock_ram
-- generic map (
-- NB_COL =&gt; 4,
-- COL_WIDTH =&gt; 9,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
--
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- clka   =&gt; clka,
-- wea    =&gt; wea,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- regceb =&gt; regceb,
-- doutb  =&gt; doutb
--);

						</Template>
						<Template label="2 Clock" treetype="template">
--  Xilinx Simple Dual Port 2 Clock RAM
--  This code implements a parameterizable SDP dual clock memory.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

end package body ram_pkg;


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_simple_dual_port_2_clock_ram is
generic (
    RAM_WIDTH : integer := 64;                      -- Specify RAM data width
    RAM_DEPTH : integer := 512;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"                        -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Write address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Read address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- RAM input data
        clka  : in std_logic;                       			  -- Write Clock
        clkb  : in std_logic;                       			  -- Read Clock
        wea   : in std_logic;                       			  -- Write enable
        enb   : in std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
        rstb  : in std_logic;                       			  -- Output reset (does not affect memory contents)
        regceb: in std_logic;                       			  -- Output register enable
        doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  -- RAM output data
     );

end xilinx_simple_dual_port_2_clock_ram;

architecture rtl of xilinx_simple_dual_port_2_clock_ram is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal doutb_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

signal ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(wea = '1') then
            ram_name(to_integer(unsigned(addra))) &lt;= dina;
        end if;
    end if;
end process;

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(enb = '1') then
            ram_data &lt;= ram_name(to_integer(unsigned(addrb)));
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    doutb &lt;= ram_data;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data;
        end if;
    end if;
end process;
doutb &lt;= doutb_reg;

end generate;
end rtl;

-- The following is an instantiation template for xilinx_simple_dual_port_2_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_simple_dual_port_2_clock_ram is
-- generic (
-- RAM_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- clkb  : in std_logic;
-- wea   : in std_logic;
-- enb   : in std_logic;
-- rstb  : in std_logic;
-- regceb: in std_logic;
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--end component;
-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_simple_dual_port_2_clock_ram
-- generic map (
-- RAM_WIDTH =&gt; 18,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- clka   =&gt; clka,
-- clkb   =&gt; clkb,
-- wea    =&gt; wea,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- regceb =&gt; regceb,
-- doutb  =&gt; doutb
--);

						</Template>
						<Template label="2 Clock w/ Byte-write" treetype="template">
--  Xilinx Simple Dual Port 2 Clock RAM with Byte-write
--  This code implements a parameterizable SDP dual clock memory.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
 	return ret_val;

end function;

end package body ram_pkg;

library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_simple_dual_port_byte_write_2_clock_ram is
generic (
    NB_COL : integer := 8; 	                 -- Specify number of colums (number of bytes)
    COL_WIDTH : integer := 8;                      -- Specify column width (byte width, typically 8 or 9)
    RAM_DEPTH : integer := 512;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"                        -- Specify name/location of RAM initialization file if using one (leave blank if not)
);

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Write address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Read address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector((NB_COL*COL_WIDTH)-1 downto 0);		  -- RAM input data
        clka  : in std_logic;                       			  -- Write Clock
        clkb  : in std_logic;                       			  -- Read Clock
        wea   : in std_logic_vector(NB_COL-1 downto 0);                       			  -- Write enable
        enb   : in std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
        rstb  : in std_logic;                       			  -- Output reset (does not affect memory contents)
        regceb: in std_logic;                       			  -- Output register enable
        doutb : out std_logic_vector((NB_COL*COL_WIDTH)-1 downto 0)   			  -- RAM output data
);

end xilinx_simple_dual_port_byte_write_2_clock_ram;

architecture rtl of xilinx_simple_dual_port_byte_write_2_clock_ram is
constant C_NB_COL : integer := NB_COL;
constant C_COL_WIDTH : integer := COL_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;

signal doutb_reg : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector ((C_NB_COL*C_COL_WIDTH)-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data : std_logic_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector((C_NB_COL*C_COL_WIDTH)-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

signal ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(enb = '1') then
            ram_data &lt;= ram_name(to_integer(unsigned(addrb)));
        end if;
    end if;
end process;

process(clka) begin
    if(clka'event and clka = '1') then
        for i in 0 to C_NB_COL-1 loop
            if(wea(i) = '1') then
                ram_name(to_integer(unsigned(addra)))(((i+1)*C_COL_WIDTH)-1 downto i*C_COL_WIDTH) &lt;= dina(((i+1)*C_COL_WIDTH)-1 downto i*C_COL_WIDTH);
            end if;
        end loop;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

 no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    doutb &lt;= ram_data;
 end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data;
        end if;
    end if;
end process;
doutb &lt;= doutb_reg;

end generate;

end rtl;

-- The following is an instantiation template for xilinx_simple_dual_port_byte_write_2_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_simple_dual_port_byte_write_2_clock_ram is
-- generic (
-- NB_COL : integer,
-- COL_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- clkb  : in std_logic;
-- wea   : in std_logic;
-- enb   : in std_logic;
-- rstb  : in std_logic;
-- regceb: in std_logic;
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_simple_dual_port_byte_write_2_clock_ram
-- generic map (
-- NB_COL =&gt; 4,
-- COL_WIDTH =&gt; 9,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
--
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- clka   =&gt; clka,
-- clkb   =&gt; clkb,
-- wea    =&gt; wea,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- regceb =&gt; regceb,
-- doutb  =&gt; doutb
--);

						</Template>
					</SubFolder>
					<SubFolder label="Single Port" treetype="folder">
						<SubFolder label="Byte-wide Write Enable" treetype="folder">
							<Template label="Read First Mode" treetype="template">
  --  Xilinx Single Port Byte-Write Read First RAM
  --  This code implements a parameterizable single-port byte-write read-first memory where when data
  --  is written to the memory, the output reflects the prior contents of the memory location.
  --  If a reset or enable is not necessary, it may be tied off or removed from the code.
  --  Modify the parameters for the desired RAM characteristics.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
   end loop;

   return ret_val;
end function;

end package body ram_pkg;

library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_single_port_byte_write_ram_read_first is
generic (
    NB_COL    : integer := 4;                      -- Specify number of columns (number of bytes)
    COL_WIDTH : integer := 9;                      -- Specify column width (byte width, typically 8 or 9)
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "HIGH_PERFORMANCE";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (

        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);		  -- RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic_vector(NB_COL-1 downto 0);    	-- Byte-write enable
        ena   : in std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Output register enable
        douta : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0)   			  -- RAM output data
    );

end xilinx_single_port_byte_write_ram_read_first;

architecture rtl of xilinx_single_port_byte_write_ram_read_first is

constant C_NB_COL     : integer := NB_COL;
constant C_COL_WIDTH  : integer := COL_WIDTH;
constant C_RAM_DEPTH  : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_NB_COL*C_COL_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
  if ramfile = "RAM_INIT.dat" then
    return InitRamFromFile("RAM_INIT.dat") ;
  else
    return (others =&gt; (others =&gt; '0'));
  end if;
end;
-- Following code defines RAM

signal ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            for i in 0 to C_NB_COL-1 loop
                if wea(i) = '1' then
                    ram_name(to_integer(unsigned(addra)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) &lt;= dina((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
            ram_data &lt;= ram_name(to_integer(unsigned(addra)));
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
   douta &lt;= ram_data;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

end generate;

end rtl;

-- The following is an instantiation template for xilinx_single_port_byte_write_ram_read_first
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_single_port_byte_write_ram_read_first is
-- generic (
-- NB_COL : integer,
-- COL_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- ena   : in std_logic;
-- rsta  : in std_logic;
-- regcea: in std_logic;
-- douta : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0)
--);
--end component;
--
-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_single_port_byte_write_ram_read_first
--
-- generic map (
-- NB_COL =&gt; 4,
-- COL_WID =&gt; 8,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
--
-- addra  =&gt; addra,
-- dina   =&gt; dina,
-- clka   =&gt; clka,
-- wea    =&gt; wea,
-- ena    =&gt; ena,
-- rsta   =&gt; rsta,
-- regcea =&gt; regcea,
-- douta  =&gt; douta
--);

							</Template>
						</SubFolder>
						<Template label="No Change Mode" treetype="template">
--  Xilinx Single Port No Change RAM
--  This code implements a parameterizable single-port no-change memory where when data is written
--  to the memory, the output remains unchanged.  This is the most power efficient write mode.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

--  Modify the parameters for the desired RAM characteristics.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

end package body ram_pkg;

library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_single_port_ram_no_change is
generic (
    RAM_WIDTH : integer := 18;                      -- Specify RAM data width
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic;                       			  -- Write enable
        ena   : in std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Output register enable
        douta : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  -- RAM output data
    );

end xilinx_single_port_ram_no_change;

architecture rtl of xilinx_single_port_ram_no_change is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;

signal douta_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal
signal ram_data : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

signal ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);
begin
process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            if(wea = '1') then
                ram_name(to_integer(unsigned(addra))) &lt;= dina;
            else
                ram_data &lt;= ram_name(to_integer(unsigned(addra)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data;
        end if;
    end if;
end process;
douta &lt;= douta_reg;
end generate;

end rtl;

-- The following is an instantiation template for xilinx_single_port_write_first
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_single_port_ram_write_first is
-- generic (
-- RAM_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic;
-- ena   : in std_logic;
-- rsta  : in std_logic;
-- regcea: in std_logic;
-- douta : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_single_port_ram_write_first
--
-- generic map (
-- RAM_WIDTH =&gt; 18,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
--
-- addra  =&gt; addra,
-- dina   =&gt; dina,
-- clka   =&gt; clka,
-- wea    =&gt; wea,
-- ena    =&gt; ena,
-- rsta   =&gt; rsta,
-- regcea =&gt; regcea,
-- douta  =&gt; douta
--);

						</Template>
						<Template label="Read First Mode" treetype="template">
  --  Xilinx Single Port Read First RAM
  --  This code implements a parameterizable single-port read-first memory where when data
  --  is written to the memory, the output reflects the prior contents of the memory location.
  --  If the output data is not needed during writes or the last read value is desired to be
  --  retained, it is suggested to use No Change Mode example as it is more power efficient.
  --  If a reset or enable is not necessary, it may be tied off or removed from the code.
  --  Modify the parameters for the desired RAM characteristics.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
  	return ret_val;
end function;

end package body ram_pkg;


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_single_port_ram_read_first is
generic (
    RAM_WIDTH : integer := 18;                      -- Specify RAM data width
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic;                       			  -- Write enable
        ena   : in std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Output register enable
        douta : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  -- RAM output data
    );

end xilinx_single_port_ram_read_first;

architecture rtl of xilinx_single_port_ram_read_first is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal
signal ram_data : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

signal ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            if(wea = '1') then
                ram_name(to_integer(unsigned(addra))) &lt;= dina;
            end if;
            ram_data &lt;= ram_name(to_integer(unsigned(addra)));
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing
output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

end generate;

end rtl;

						</Template>
						<Template label="Write First Mode" treetype="template">
--  Xilinx Single Port Write First RAM
--  This code implements a parameterizable single-port write-first memory where when data
--  is written to the memory, the output reflects the same data being written to the memory.
--  If the output data is not needed during writes or the last read value is desired to be retained
--  it is suggested to use Single-Port.No Change Example as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.

--  Modify the parameters for the desired RAM characteristics.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;
end package body ram_pkg;

library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_single_port_ram_write_first is
generic (
    RAM_WIDTH : integer := 18;                      -- Specify RAM data width
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (

        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic;                       			  -- Write enable
        ena   : in std_logic;                       			  -- RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Output register enable
        douta : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  -- RAM output data
     );

end xilinx_single_port_ram_write_first;

architecture rtl of xilinx_single_port_ram_write_first is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal
signal ram_data : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat");
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

signal ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin
process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            if(wea = '1') then
                ram_name(to_integer(unsigned(addra))) &lt;= dina;
                ram_data &lt;= dina;
            else
                ram_data &lt;= ram_name(to_integer(unsigned(addra)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
  douta &lt;= ram_data;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing
output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

end generate;

end rtl;

						</Template>
					</SubFolder>
					<SubFolder label="True Dual Port" treetype="folder">
						<SubFolder label="1 Clock" treetype="folder">
							<Template label="No Change Mode" treetype="template">
--  Xilinx True Dual Port RAM No Change Single Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  This is a no change RAM which retains the last read value on the output during writes
--  which is the most power efficient mode.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.
library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

end package body ram_pkg;


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_true_dual_port_no_change_1_clock_ram is
generic (
    RAM_WIDTH : integer := 18;                      -- Specify RAM data width
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port A Address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port B Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port A RAM input data
        dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port B RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic;                       			  -- Port A Write enable
        web   : in std_logic;                       			  -- Port B Write enable
        ena   : in std_logic;                       			  -- Port A RAM Enable, for additional power savings, disable port when not in use
        enb   : in std_logic;                       			  -- Port B RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Port A Output reset (does not affect memory contents)
        rstb  : in std_logic;                       			  -- Port B Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Port A Output register enable
        regceb: in std_logic;                       			  -- Port B Output register enable
        douta : out std_logic_vector(RAM_WIDTH-1 downto 0);   			  --  Port A RAM output data
        doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  --  Port B RAM output data
    );

end xilinx_true_dual_port_no_change_1_clock_ram;

architecture rtl of xilinx_true_dual_port_no_change_1_clock_ram is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
signal doutb_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data_a : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal ram_data_b : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

shared variable ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            if(wea = '1') then
                ram_name(to_integer(unsigned(addra))) := dina;
            else
                ram_data_a &lt;= ram_name(to_integer(unsigned(addra)));
            end if;
        end if;
    end if;
end process;

process(clka)
begin
    if(clka'event and clka = '1') then
        if(enb = '1') then
            if(web = '1') then
                ram_name(to_integer(unsigned(addrb))) := dinb;
            else
                ram_data_b &lt;= ram_name(to_integer(unsigned(addrb)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data_a;
    doutb &lt;= ram_data_b;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data_a;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

process(clka)
begin
    if(clka'event and clka = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data_b;
        end if;
    end if;
end process;
doutb &lt;= doutb_reg;

end generate;
end rtl;

-- The following is an instantiation template for xilinx_true_dual_port_no_change_1_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_true_dual_port_no_change_1_clock_ram is
-- generic (
-- RAM_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic;
-- web   : in std_logic;
-- ena   : in std_logic;
-- enb   : in std_logic;
-- rsta  : in std_logic;
-- rstb  : in std_logic;
-- regcea: in std_logic;
-- regceb: in std_logic;
-- douta : out std_logic_vector(RAM_WIDTH-1 downto 0)
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_true_dual_port_no_change_1_clock_ram
-- generic map (
-- RAM_WIDTH =&gt; 18,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- dinb   =&gt; dinb,
-- clka   =&gt; clka,
-- wea    =&gt; wea,
-- web    =&gt; web,
-- ena    =&gt; ena,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- rstb   =&gt; rstb,
-- regcea =&gt; regcea,
-- regceb =&gt; regceb,
-- douta  =&gt; douta
-- doutb  =&gt; doutb
--);

							</Template>
							<Template label="Read First Mode" treetype="template">
--  Xilinx True Dual Port RAM Read First Single Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  The behavior of this RAM is when data is written, the prior memory contents at the write
--  address are presented on the output port.  If the output data is
--  not needed during writes or the last read value is desired to be retained,
--  it is suggested to use a no change RAM as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is
function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;
end package body ram_pkg;

library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_true_dual_port_read_first_1_clock_ram is
generic (
    RAM_WIDTH : integer := 18;                      -- Specify RAM data width
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
);

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port A Address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port B Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port A RAM input data
        dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port B RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic;                       			  -- Port A Write enable
        web   : in std_logic;                       			  -- Port B Write enable
        ena   : in std_logic;                       			  -- Port A RAM Enable, for additional power savings, disable port when not in use
        enb   : in std_logic;                       			  -- Port B RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Port A Output reset (does not affect memory contents)
        rstb  : in std_logic;                       			  -- Port B Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Port A Output register enable
        regceb: in std_logic;                       			  -- Port B Output register enable
        douta : out std_logic_vector(RAM_WIDTH-1 downto 0);   			  --  Port A RAM output data
        doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  --  Port B RAM output data
    );

end xilinx_true_dual_port_read_first_1_clock_ram;

architecture rtl of xilinx_true_dual_port_read_first_1_clock_ram is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
signal doutb_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data_a : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal ram_data_b : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

shared variable ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            ram_data_a &lt;= ram_name(to_integer(unsigned(addra)));
            if(wea = '1') then
                ram_name(to_integer(unsigned(addra))) := dina;
            end if;
        end if;
    end if;
end process;

process(clka)
begin
    if(clka'event and clka = '1') then
        if(enb = '1') then
            ram_data_b &lt;= ram_name(to_integer(unsigned(addrb)));
            if(web = '1') then
                ram_name(to_integer(unsigned(addrb))) := dinb;
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data_a;
    doutb &lt;= ram_data_b;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data_a;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

process(clka)
begin
    if(clka'event and clka = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data_b;
        end if;
    end if;
 end process;
 doutb &lt;= doutb_reg;

end generate;
end rtl;

-- The following is an instantiation template for xilinx_true_dual_port_read_first_1_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_true_dual_port_read_first_1_clock_ram is
-- generic (
-- RAM_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic;
-- web   : in std_logic;
-- ena   : in std_logic;
-- enb   : in std_logic;
-- rsta  : in std_logic;
-- rstb  : in std_logic;
-- regcea: in std_logic;
-- regceb: in std_logic;
-- douta : out std_logic_vector(RAM_WIDTH-1 downto 0)
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--end component;

-- Instatiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_true_dual_port_read_first_1_clock_ram
-- generic map (
-- RAM_WIDTH =&gt; 18,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- dinb   =&gt; dinb,
-- clka   =&gt; clka,
-- wea    =&gt; wea,
-- web    =&gt; web,
-- ena    =&gt; ena,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- rstb   =&gt; rstb,
-- regcea =&gt; regcea,
-- regceb =&gt; regceb,
-- douta  =&gt; douta
-- doutb  =&gt; doutb
--);

							</Template>
							<Template label="Read First Mode w/ Byte-write" treetype="template">
--  Xilinx True Dual Port RAM Byte Write Read First Single Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  The behavior of this RAM is when data is written, the prior memory contents at the write
--  address are presented on the output port.  If the output data is
--  not needed during writes or the last read value is desired to be retained,
--  it is suggested to use a no change RAM as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

end package body ram_pkg;

library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_true_dual_port_read_first_byte_write_1_clock_ram is
generic (
    NB_COL    : integer := 4;                       -- Specify number of columns (number of bytes)
    COL_WIDTH : integer := 9;                       -- Specify column width (byte width, typically 8 or 9)
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port A Address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port B Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);		  -- Port A RAM input data
        dinb  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);		  -- Port B RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic_vector(NB_COL-1 downto 0);	  -- Port A Write enable
        web   : in std_logic_vector(NB_COL-1 downto 0); 	  -- Port B Write enable
        ena   : in std_logic;                       			  -- Port A RAM Enable, for additional power savings, disable port when not in use
        enb   : in std_logic;                       			  -- Port B RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Port A Output reset (does not affect memory contents)
        rstb  : in std_logic;                       			  -- Port B Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Port A Output register enable
        regceb: in std_logic;                       			  -- Port B Output register enable
        douta : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);   --  Port A RAM output data
        doutb : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0)   	--  Port B RAM output data
    );

end xilinx_true_dual_port_read_first_byte_write_1_clock_ram;

architecture rtl of xilinx_true_dual_port_read_first_byte_write_1_clock_ram is

constant C_NB_COL    : integer := NB_COL;
constant C_COL_WIDTH : integer := COL_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');
signal doutb_reg : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_NB_COL*C_COL_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data_a : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;
signal ram_data_b : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

shared variable ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            ram_data_a &lt;= ram_name(to_integer(unsigned(addra)));
            for i in 0 to C_NB_COL-1 loop
                if(wea(i) = '1') then
                    ram_name(to_integer(unsigned(addra)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := dina((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
        end if;
    end if;
end process;

process(clka)
begin
    if(clka'event and clka = '1') then
        if(enb = '1') then
            ram_data_b &lt;= ram_name(to_integer(unsigned(addrb)));
            for i in 0 to C_NB_COL-1 loop
                if(web(i) = '1') then
                    ram_name(to_integer(unsigned(addrb)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := dinb((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data_a;
    doutb &lt;= ram_data_b;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data_a;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

process(clka)
begin
    if(clka'event and clka = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data_b;
        end if;
    end if;
end process;
doutb &lt;= doutb_reg;

end generate;
end rtl;

-- The following is an instantiation template for xilinx_true_dual_port_read_first_byte_write_1_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_true_dual_port_read_first_byte_write_1_clock_ram is
-- generic (
-- NB_COL : integer,
-- COL_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- dinb  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- web   : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- ena   : in std_logic;
-- enb   : in std_logic;
-- rsta  : in std_logic;
-- rstb  : in std_logic;
-- regcea: in std_logic;
-- regceb: in std_logic;
-- douta : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0)
-- doutb : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0)
--);
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_true_dual_port_read_first_byte_write_1_clock_ram
--
-- generic map (
-- NB_COL =&gt; 4,
-- COL_WID =&gt; 8,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- dinb   =&gt; dinb,
-- clka   =&gt; clka,
-- wea    =&gt; wea,
-- web    =&gt; web,
-- ena    =&gt; ena,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- rstb   =&gt; rstb,
-- regcea =&gt; regcea,
-- regceb =&gt; regceb,
-- douta  =&gt; douta,
-- doutb  =&gt; doutb
--);

							</Template>
							<Template label="Write First Mode" treetype="template">
--  Xilinx True Dual Port RAM Write First Single Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  This implementes write-first mode where the data being written to the RAM also resides on
--  the output port.  If the output data is not needed during writes or the last read value is
--  desired to be retained, it is suggested to use no change RAM as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.
library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

end package body ram_pkg;


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_true_dual_port_write_first_1_clock_ram is
generic (
    RAM_WIDTH : integer := 18;                      -- Specify RAM data width
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port A Address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port B Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port A RAM input data
        dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port B RAM input data
        clka  : in std_logic;                       			  -- Clock
        wea   : in std_logic;                       			  -- Port A Write enable
        web   : in std_logic;                       			  -- Port B Write enable
        ena   : in std_logic;                       			  -- Port A RAM Enable, for additional power savings, disable port when not in use
        enb   : in std_logic;                       			  -- Port B RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Port A Output reset (does not affect memory contents)
        rstb  : in std_logic;                       			  -- Port B Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Port A Output register enable
        regceb: in std_logic;                       			  -- Port B Output register enable
        douta : out std_logic_vector(RAM_WIDTH-1 downto 0);   			  --  Port A RAM output data
        doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  --  Port B RAM output data
    );

end xilinx_true_dual_port_write_first_1_clock_ram;
architecture rtl of xilinx_true_dual_port_write_first_1_clock_ram is
constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;

signal douta_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
signal doutb_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal
signal ram_data_a : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal ram_data_b : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

shared variable ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);
begin
process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            if(wea = '1') then
                ram_name(to_integer(unsigned(addra))) := dina;
                ram_data_a &lt;= dina;
            else
                ram_data_a &lt;= ram_name(to_integer(unsigned(addra)));
            end if;
        end if;
    end if;
end process;

process(clka)
begin
    if(clka'event and clka = '1') then
        if(enb = '1') then
            if(web = '1') then
                ram_name(to_integer(unsigned(addrb))) := dinb;
                ram_data_b &lt;= dinb;
            else
                ram_data_b &lt;= ram_name(to_integer(unsigned(addrb)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data_a;
    doutb &lt;= ram_data_b;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
if(clka'event and clka = '1') then
    if(rsta = '1') then
        douta_reg &lt;= (others =&gt; '0');
    elsif(regcea = '1') then
        douta_reg &lt;= ram_data_a;
    end if;
  end if;
end process;
douta &lt;= douta_reg;

process(clka)
begin
  if(clka'event and clka = '1') then
    if(rstb = '1') then
      doutb_reg &lt;= (others =&gt; '0');
    elsif(regceb = '1') then
      doutb_reg &lt;= ram_data_b;
    end if;
  end if;
end process;
doutb &lt;= doutb_reg;

end generate;
end rtl;

-- The following is an instantiation template for xilinx_true_dual_port_write_first_1_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_true_dual_port_write_first_1_clock_ram is
-- generic (
-- RAM_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic;
-- web   : in std_logic;
-- ena   : in std_logic;
-- enb   : in std_logic;
-- rsta  : in std_logic;
-- rstb  : in std_logic;
-- regcea: in std_logic;
-- regceb: in std_logic;
-- douta : out std_logic_vector(RAM_WIDTH-1 downto 0)
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_true_dual_port_write_first_1_clock_ram
-- generic map (
-- RAM_WIDTH =&gt; 18,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- dinb   =&gt; dinb,
-- clka   =&gt; clka,
-- wea    =&gt; wea,
-- web    =&gt; web,
-- ena    =&gt; ena,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- rstb   =&gt; rstb,
-- regcea =&gt; regcea,
-- regceb =&gt; regceb,
-- douta  =&gt; douta
-- doutb  =&gt; doutb
--);

							</Template>
						</SubFolder>
						<SubFolder label="2 Clock" treetype="folder">
							<Template label="No Change Mode" treetype="template">
--  Xilinx True Dual Port RAM No Change Dual Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  This is a no change RAM which retains the last read value on the output during writes
--  which is the most power efficient mode.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.
library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

end package body ram_pkg;

library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_true_dual_port_no_change_2_clock_ram is
generic (
    RAM_WIDTH : integer := 18;                      -- Specify RAM data width
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (

        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port A Address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port B Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port A RAM input data
        dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port B RAM input data
        clka  : in std_logic;                       			  -- Port A Clock
        clkb  : in std_logic;                       			  -- Port B Clock
        wea   : in std_logic;                       			  -- Port A Write enable
        web   : in std_logic;                       			  -- Port B Write enable
        ena   : in std_logic;                       			  -- Port A RAM Enable, for additional power savings, disable port when not in use
        enb   : in std_logic;                       			  -- Port B RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Port A Output reset (does not affect memory contents)
        rstb  : in std_logic;                       			  -- Port B Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Port A Output register enable
        regceb: in std_logic;                       			  -- Port B Output register enable
        douta : out std_logic_vector(RAM_WIDTH-1 downto 0);   			  --  Port A RAM output data
        doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  --  Port B RAM output data
    );

end xilinx_true_dual_port_no_change_2_clock_ram;

architecture rtl of xilinx_true_dual_port_no_change_2_clock_ram is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
signal doutb_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data_a : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal ram_data_b : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

shared variable ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            if(wea = '1') then
                ram_name(to_integer(unsigned(addra))) := dina;
            else
                ram_data_a &lt;= ram_name(to_integer(unsigned(addra)));
            end if;
        end if;
    end if;
end process;

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(enb = '1') then
            if(web = '1') then
                ram_name(to_integer(unsigned(addrb))) := dinb;
            else
                ram_data_b &lt;= ram_name(to_integer(unsigned(addrb)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data_a;
    doutb &lt;= ram_data_b;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data_a;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data_b;
        end if;
    end if;
end process;
doutb &lt;= doutb_reg;

end generate;
end rtl;

-- The following is an instantiation template for xilinx_true_dual_port_no_change_2_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_true_dual_port_no_change_2_clock_ram is
-- generic (
-- RAM_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- clkb  : in std_logic;
-- wea   : in std_logic;
-- web   : in std_logic;
-- ena   : in std_logic;
-- enb   : in std_logic;
-- rsta  : in std_logic;
-- rstb  : in std_logic;
-- regcea: in std_logic;
-- regceb: in std_logic;
-- douta : out std_logic_vector(RAM_WIDTH-1 downto 0)
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_true_dual_port_no_change_2_clock_ram
-- generic map (
-- RAM_WIDTH =&gt; 18,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- dinb   =&gt; dinb,
-- clka   =&gt; clka,
-- clkb   =&gt; clkb,
-- wea    =&gt; wea,
-- web    =&gt; web,
-- ena    =&gt; ena,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- rstb   =&gt; rstb,
-- regcea =&gt; regcea,
-- regceb =&gt; regceb,
-- douta  =&gt; douta
-- doutb  =&gt; doutb
--);

							</Template>
							<Template label="Read First Mode" treetype="template">
--  Xilinx True Dual Port RAM Read First Dual Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  The behavior of this RAM is when data is written, the prior memory contents at the write
--  address are presented on the output port.  If the output data is
--  not needed during writes or the last read value is desired to be retained,
--  it is suggested to use a no change RAM as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

end package body ram_pkg;


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_true_dual_port_read_first_2_clock_ram is
generic (
    RAM_WIDTH : integer := 18;                      -- Specify RAM data width
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
);

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port A Address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port B Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port A RAM input data
        dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port B RAM input data
        clka  : in std_logic;                       			  -- Port A Clock
        clkb  : in std_logic;                       			  -- Port B Clock
        wea   : in std_logic;                       			  -- Port A Write enable
        web   : in std_logic;                       			  -- Port B Write enable
        ena   : in std_logic;                       			  -- Port A RAM Enable, for additional power savings, disable port when not in use
        enb   : in std_logic;                       			  -- Port B RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Port A Output reset (does not affect memory contents)
        rstb  : in std_logic;                       			  -- Port B Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Port A Output register enable
        regceb: in std_logic;                       			  -- Port B Output register enable
        douta : out std_logic_vector(RAM_WIDTH-1 downto 0);   			  --  Port A RAM output data
        doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  --  Port B RAM output data
    );

end xilinx_true_dual_port_read_first_2_clock_ram;

architecture rtl of xilinx_true_dual_port_read_first_2_clock_ram is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
signal doutb_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data_a : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal ram_data_b : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

shared variable ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            ram_data_a &lt;= ram_name(to_integer(unsigned(addra)));
            if(wea = '1') then
                ram_name(to_integer(unsigned(addra))) := dina;
            end if;
        end if;
  end if;
end process;

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(enb = '1') then
            ram_data_b &lt;= ram_name(to_integer(unsigned(addrb)));
            if(web = '1') then
                ram_name(to_integer(unsigned(addrb))) := dinb;
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data_a;
    doutb &lt;= ram_data_b;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data_a;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data_b;
        end if;
    end if;
end process;
doutb &lt;= doutb_reg;
end generate;
end rtl;

-- The following is an instantiation template for xilinx_true_dual_port_read_first_2_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_true_dual_port_read_first_2_clock_ram is
-- generic (
-- RAM_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic;
-- web   : in std_logic;
-- ena   : in std_logic;
-- enb   : in std_logic;
-- rsta  : in std_logic;
-- rstb  : in std_logic;
-- regcea: in std_logic;
-- regceb: in std_logic;
-- douta : out std_logic_vector(RAM_WIDTH-1 downto 0)
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_true_dual_port_read_first_2_clock_ram
-- generic map (
-- RAM_WIDTH =&gt; 18,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- dinb   =&gt; dinb,
-- clka   =&gt; clka,
-- clkb   =&gt; clkb,
-- wea    =&gt; wea,
-- web    =&gt; web,
-- ena    =&gt; ena,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- rstb   =&gt; rstb,
-- regcea =&gt; regcea,
-- regceb =&gt; regceb,
-- douta  =&gt; douta
-- doutb  =&gt; doutb
--);

							</Template>
							<Template label="Read First Mode w/ Byte-write" treetype="template">
--  Xilinx True Dual Port RAM Byte Write Read First with Dual Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  The behavior of this RAM is when data is written, the prior memory contents at the write
--  address are presented on the output port.  If the output data is
--  not needed during writes or the last read value is desired to be retained,
--  it is suggested to use a no change RAM as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
 --  Modify the parameters for the desired RAM characteristics.

library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;
    return ret_val;
end function;

end package body ram_pkg;


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_true_dual_port_read_first_byte_write_2_clock_ram is
generic (
    NB_COL    : integer := 4;                       -- Specify number of columns (number of bytes)
    COL_WIDTH : integer := 9;                       -- Specify column width (byte width, typically 8 or 9)
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
    );

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port A Address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port B Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);		  -- Port A RAM input data
        dinb  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);		  -- Port B RAM input data
        clka  : in std_logic;                       			  -- Port A Clock
        clkb  : in std_logic;                       			  -- Port B Clock
        wea   : in std_logic_vector(NB_COL-1 downto 0);	  -- Port A Write enable
        web   : in std_logic_vector(NB_COL-1 downto 0); 	  -- Port B Write enable
        ena   : in std_logic;                       			  -- Port A RAM Enable, for additional power savings, disable port when not in use
        enb   : in std_logic;                       			  -- Port B RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Port A Output reset (does not affect memory contents)
        rstb  : in std_logic;                       			  -- Port B Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Port A Output register enable
        regceb: in std_logic;                       			  -- Port B Output register enable
        douta : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);   --  Port A RAM output data
        doutb : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0)   	--  Port B RAM output data
    );

end xilinx_true_dual_port_read_first_byte_write_2_clock_ram;

architecture rtl of xilinx_true_dual_port_read_first_byte_write_2_clock_ram is

constant C_NB_COL    : integer := NB_COL;
constant C_COL_WIDTH : integer := COL_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');
signal doutb_reg : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_NB_COL*C_COL_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data_a : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;
signal ram_data_b : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_NB_COL*C_COL_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

shared variable ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            ram_data_a &lt;= ram_name(to_integer(unsigned(addra)));
            for i in 0 to C_NB_COL-1 loop
                if(wea(i) = '1') then
                    ram_name(to_integer(unsigned(addra)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := dina((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
        end if;
    end if;
end process;

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(enb = '1') then
            ram_data_b &lt;= ram_name(to_integer(unsigned(addrb)));
            for i in 0 to C_NB_COL-1 loop
                if(web(i) = '1') then
                    ram_name(to_integer(unsigned(addrb)))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := dinb((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                end if;
            end loop;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data_a;
    doutb &lt;= ram_data_b;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data_a;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data_b;
        end if;
    end if;
end process;
doutb &lt;= doutb_reg;

end generate;

end rtl;

-- The following is an instantiation template for xilinx_true_dual_port_read_first_byte_write_2_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_true_dual_port_read_first_byte_write_2_clock_ram is
-- generic (
-- NB_COL : integer,
-- COL_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- dinb  : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- clkb  : in std_logic;
-- wea   : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- web   : in std_logic_vector(NB_COL*COL_WIDTH-1 downto 0);
-- ena   : in std_logic;
-- enb   : in std_logic;
-- rsta  : in std_logic;
-- rstb  : in std_logic;
-- regcea: in std_logic;
-- regceb: in std_logic;
-- douta : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0)
-- doutb : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0)
--);
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_true_dual_port_read_first_byte_write_2_clock_ram
--
-- generic map (
-- NB_COL =&gt; 4,
-- COL_WID =&gt; 8,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- dinb   =&gt; dinb,
-- clka   =&gt; clka,
-- clkb   =&gt; clkb,
-- wea    =&gt; wea,
-- web    =&gt; web,
-- ena    =&gt; ena,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- rstb   =&gt; rstb,
-- regcea =&gt; regcea,
-- regceb =&gt; regceb,
-- douta  =&gt; douta,
-- doutb  =&gt; doutb
--);
							</Template>
							<Template label="Write First Mode" treetype="template">
--  Xilinx True Dual Port RAM Write First Dual Clock
--  This code implements a parameterizable true dual port memory (both ports can read and write).
--  This implementes write-first mode where the data being written to the RAM also resides on
--  the output port.  If the output data is not needed during writes or the last read value is
--  desired to be retained, it is suggested to use no change RAM as it is more power efficient.
--  If a reset or enable is not necessary, it may be tied off or removed from the code.
--  Modify the parameters for the desired RAM characteristics.
library ieee;
use ieee.std_logic_1164.all;

package ram_pkg is
    function clogb2 (depth: in natural) return integer;
end ram_pkg;

package body ram_pkg is

function clogb2( depth : natural) return integer is
variable temp    : integer := depth;
variable ret_val : integer := 0;
begin
    while temp &gt; 1 loop
        ret_val := ret_val + 1;
        temp    := temp / 2;
    end loop;

    return ret_val;
end function;

end package body ram_pkg;


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ram_pkg.all;
USE std.textio.all;

entity xilinx_true_dual_port_write_first_2_clock_ram is
generic (
    RAM_WIDTH : integer := 18;                      -- Specify RAM data width
    RAM_DEPTH : integer := 1024;                    -- Specify RAM depth (number of entries)
    RAM_PERFORMANCE : string := "LOW_LATENCY";      -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    INIT_FILE : string := "RAM_INIT.dat"            -- Specify name/location of RAM initialization file if using one (leave blank if not)
);

port (
        addra : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port A Address bus, width determined from RAM_DEPTH
        addrb : in std_logic_vector((clogb2(RAM_DEPTH)-1) downto 0);     -- Port B Address bus, width determined from RAM_DEPTH
        dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port A RAM input data
        dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);		  -- Port B RAM input data
        clka  : in std_logic;                       			  -- Port A Clock
        clkb  : in std_logic;                       			  -- Port B Clock
        wea   : in std_logic;                       			  -- Port A Write enable
        web   : in std_logic;                       			  -- Port B Write enable
        ena   : in std_logic;                       			  -- Port A RAM Enable, for additional power savings, disable port when not in use
        enb   : in std_logic;                       			  -- Port B RAM Enable, for additional power savings, disable port when not in use
        rsta  : in std_logic;                       			  -- Port A Output reset (does not affect memory contents)
        rstb  : in std_logic;                       			  -- Port B Output reset (does not affect memory contents)
        regcea: in std_logic;                       			  -- Port A Output register enable
        regceb: in std_logic;                       			  -- Port B Output register enable
        douta : out std_logic_vector(RAM_WIDTH-1 downto 0);   			  --  Port A RAM output data
        doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)   			  --  Port B RAM output data
    );

end xilinx_true_dual_port_write_first_2_clock_ram;

architecture rtl of xilinx_true_dual_port_write_first_2_clock_ram is

constant C_RAM_WIDTH : integer := RAM_WIDTH;
constant C_RAM_DEPTH : integer := RAM_DEPTH;
constant C_RAM_PERFORMANCE : string := RAM_PERFORMANCE;
constant C_INIT_FILE : string := INIT_FILE;


signal douta_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');
signal doutb_reg : std_logic_vector(C_RAM_WIDTH-1 downto 0) := (others =&gt; '0');

type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_RAM_WIDTH-1 downto 0);          -- 2D Array Declaration for RAM signal

signal ram_data_a : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;
signal ram_data_b : std_logic_vector(C_RAM_WIDTH-1 downto 0) ;

-- The folowing code either initializes the memory values to a specified file or to all zeros to match hardware

function initramfromfile (ramfilename : in string) return ram_type is
file ramfile	: text is in ramfilename;
variable ramfileline : line;
variable ram_name	: ram_type;
variable bitvec : bit_vector(C_RAM_WIDTH-1 downto 0);
begin
    for i in ram_type'range loop
        readline (ramfile, ramfileline);
        read (ramfileline, bitvec);
        ram_name(i) := to_stdlogicvector(bitvec);
    end loop;
    return ram_name;
end function;

function init_from_file_or_zeroes(ramfile : string) return ram_type is
begin
    if ramfile = "RAM_INIT.dat" then
        return InitRamFromFile("RAM_INIT.dat") ;
    else
        return (others =&gt; (others =&gt; '0'));
    end if;
end;
-- Following code defines RAM

shared variable ram_name : ram_type := init_from_file_or_zeroes(C_INIT_FILE);

begin

process(clka)
begin
    if(clka'event and clka = '1') then
        if(ena = '1') then
            if(wea = '1') then
                ram_name(to_integer(unsigned(addra))) := dina;
                ram_data_a &lt;= dina;
            else
                ram_data_a &lt;= ram_name(to_integer(unsigned(addra)));
            end if;
        end if;
    end if;
end process;

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(enb = '1') then
            if(web = '1') then
                ram_name(to_integer(unsigned(addrb))) := dinb;
                ram_data_b &lt;= dinb;
            else
                ram_data_b &lt;= ram_name(to_integer(unsigned(addrb)));
            end if;
        end if;
    end if;
end process;

--  Following code generates LOW_LATENCY (no output register)
--  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
    douta &lt;= ram_data_a;
    doutb &lt;= ram_data_b;
end generate;

--  Following code generates HIGH_PERFORMANCE (use output register)
--  Following is a 2 clock cycle read latency with improved clock-to-out timing

output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE"  generate
process(clka)
begin
    if(clka'event and clka = '1') then
        if(rsta = '1') then
            douta_reg &lt;= (others =&gt; '0');
        elsif(regcea = '1') then
            douta_reg &lt;= ram_data_a;
        end if;
    end if;
end process;
douta &lt;= douta_reg;

process(clkb)
begin
    if(clkb'event and clkb = '1') then
        if(rstb = '1') then
            doutb_reg &lt;= (others =&gt; '0');
        elsif(regceb = '1') then
            doutb_reg &lt;= ram_data_b;
        end if;
    end if;
end process;
doutb &lt;= doutb_reg;

end generate;
end rtl;

-- The following is an instantiation template for xilinx_true_dual_port_write_first_2_clock_ram
-- Component Declaration
-- Uncomment the below component declaration when using
--component xilinx_true_dual_port_write_first_2_clock_ram is
-- generic (
-- RAM_WIDTH : integer,
-- RAM_DEPTH : integer,
-- RAM_PERFORMANCE : string,
-- INIT_FILE : string
--);
--port
--(
-- addra : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- addrb : in std_logic_vector(clogb2(RAM_DEPTH)-1) downto 0);
-- dina  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- dinb  : in std_logic_vector(RAM_WIDTH-1 downto 0);
-- clka  : in std_logic;
-- wea   : in std_logic;
-- web   : in std_logic;
-- ena   : in std_logic;
-- enb   : in std_logic;
-- rsta  : in std_logic;
-- rstb  : in std_logic;
-- regcea: in std_logic;
-- regceb: in std_logic;
-- douta : out std_logic_vector(RAM_WIDTH-1 downto 0)
-- doutb : out std_logic_vector(RAM_WIDTH-1 downto 0)
--);
--end component;

-- Instantiation
-- Uncomment the instantiation below when using
--&lt;your_instance_name&gt; : xilinx_true_dual_port_write_first_2_clock_ram
-- generic map (
-- RAM_WIDTH =&gt; 18,
-- RAM_DEPTH =&gt; 1024,
-- RAM_PERFORMANCE =&gt; "HIGH_PERFORMANCE",
-- INIT_FILE =&gt; "" 
--)
--  port map  (
-- addra  =&gt; addra,
-- addrb  =&gt; addrb,
-- dina   =&gt; dina,
-- dinb   =&gt; dinb,
-- clka   =&gt; clka,
-- clkb   =&gt; clkb,
-- wea    =&gt; wea,
-- web    =&gt; web,
-- ena    =&gt; ena,
-- enb    =&gt; enb,
-- rsta   =&gt; rsta,
-- rstb   =&gt; rstb,
-- regcea =&gt; regcea,
-- regceb =&gt; regceb,
-- douta  =&gt; douta
-- doutb  =&gt; doutb
--);

							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="UltraRAM" treetype="folder">
					<Template label="Simple Dual Port" treetype="template">
--  Xilinx UltraRAM Simple Dual Port.  This code implements 
--  a parameterizable UltraRAM block 1 Read and 1 write. 
--  when addra == addrb, old data will show at doutb 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity xilinx_ultraram_simple_dual_port is
generic (
         AWIDTH : integer := 12;  -- Address Width
         DWIDTH : integer := 72;  -- Data Width
         NBPIPE : integer := 3    -- Number of pipeline Registers
        );
port    (
         clk : in std_logic;                                  -- Clock 
         rstb : in std_logic;                                 -- Reset
         wea : in std_logic;                                  -- Write Enable
         regceb : in std_logic;                               -- Output Register Enable
         mem_en : in std_logic;                               -- Memory Enable
         dina : in std_logic_vector(DWIDTH-1 downto 0);       -- Data Input  
         addra : in std_logic_vector(AWIDTH-1 downto 0);      -- Write Address
         addrb : in std_logic_vector(AWIDTH-1 downto 0);      -- Read Address
         doutb : out std_logic_vector(DWIDTH-1 downto 0)      -- Data Output
        );
end xilinx_ultraram_simple_dual_port;

architecture rtl of xilinx_ultraram_simple_dual_port is

constant C_AWIDTH : integer := AWIDTH;
constant C_DWIDTH : integer := DWIDTH;
constant C_NBPIPE : integer := NBPIPE;

-- Internal Signals
type mem_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_data_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_en_t is array(natural range&lt;&gt;) of std_logic;

signal mem : mem_t(2**C_AWIDTH-1 downto 0);                -- Memory Declaration
signal memreg : std_logic_vector(C_DWIDTH-1 downto 0);              
signal mem_pipe_reg : pipe_data_t(C_NBPIPE-1 downto 0);    -- Pipelines for memory
signal mem_en_pipe_reg : pipe_en_t(C_NBPIPE downto 0);     -- Pipelines for memory enable  

attribute ram_style : string;
attribute ram_style of mem : signal is "ultra";

begin

-- RAM : Read has one latency, Write has one latency as well.
process(clk)
begin
  if(clk'event and clk='1')then
    if(mem_en = '1') then
      if(wea = '1') then
        mem(to_integer(unsigned(addra))) &lt;= dina;
      end if;
      memreg &lt;= mem(to_integer(unsigned(addrb)));
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    mem_en_pipe_reg(0) &lt;= mem_en;
    for i in 0 to C_NBPIPE-1 loop
      mem_en_pipe_reg(i+1) &lt;= mem_en_pipe_reg(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    if(mem_en_pipe_reg(0) = '1') then
      mem_pipe_reg(0) &lt;= memreg;
    end if;
  end if;
end process;

process(clk)
begin
  if(clk'event and clk = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(mem_en_pipe_reg(i+1) = '1') then
        mem_pipe_reg(i+1) &lt;= mem_pipe_reg(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(clk)
begin
  if(clk'event and clk = '1') then
    if(rstb = '1') then
      doutb &lt;= (others =&gt; '0');
    elsif(mem_en_pipe_reg(C_NBPIPE) = '1' and regceb = '1' ) then
      doutb &lt;= mem_pipe_reg(C_NBPIPE-1);
    end if;
  end if;    
end process;

end rtl;

-- The following is an instantiation template for xilinx_ultraram_simple_dual_port 
-- Component Declaration
-- Uncomment the below component declaration when using
-- component xilinx_ultraram_simple_dual_port
--generic (
--         AWIDTH : integer := 12;  -- Address Width
--         DWIDTH : integer := 72;  -- Data Width
--         NBPIPE : integer := 3    -- Number of pipeline Registers
--        );
--port    (
--         clk : in std_logic;                                   -- Clock 
--         rstb : in std_logic;                                  -- Reset
--         wea : in std_logic;                                   -- Write Enable
--         regceb : in std_logic;                                -- Output Register Enable
--         mem_en : in std_logic;                                -- Memory Enable
--         dina : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
--         addra : in std_logic_vector(AWIDTH-1 downto 0);       -- Write Address
--         addrb : in std_logic_vector(AWIDTH-1 downto 0);       -- Read Address
--         doutb : out std_logic_vector(DWIDTH-1 downto 0)       -- Data Output
--        );
-- end component;
-- Instantiation
-- Uncomment the below component declaration when using
-- &lt;your_instance_name&gt; : xilinx_ultraram_simple_dual_port 
-- generic map (
--		  AWIDTH =&gt; AWIDTH, 
--		  DWIDTH =&gt; DWIDTH, 
--	    NBPIPE =&gt; NBPIPE	
--       )
-- port map (
--         clk =&gt; clk, 
--         rstb =&gt; rstb, 
--         wea =&gt; wea, 
--         regceb =&gt; regceb, 
--         mem_en =&gt; mem_en, 
--         dina =&gt; dina, 
--         addra =&gt; addra, 
--         addrb =&gt; addrb, 
--         doutb =&gt; doutb
--         );
					</Template>
					<SubFolder label="Single Port" treetype="folder">
						<Template label="No Change Mode" treetype="template">
--  Xilinx UltraRAM Single Port No Change Mode.  This code implements 
--  a parameterizable UltraRAM block in No Change mode. The behavior of this RAM is 
--  when data is written, the output of RAM is unchanged. Only when write is
--  inactive data corresponding to the address is presented on the output port.
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity xilinx_ultraram_single_port_no_change is
generic (
         AWIDTH : integer := 12;  -- Address Width
         DWIDTH : integer := 72;  -- Data Width
         NBPIPE : integer := 3    -- Number of pipeline Registers
        );
port    (
         clk : in std_logic;                                  -- Clock 
         rst : in std_logic;                                  -- Reset
         we : in std_logic;                                   -- Write Enable
         regce : in std_logic;                                -- Output Register Enable
         mem_en : in std_logic;                               -- Memory Enable
         din : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
         addr : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
         dout : out std_logic_vector(DWIDTH-1 downto 0)       -- Data Output
        );
end xilinx_ultraram_single_port_no_change;

architecture rtl of xilinx_ultraram_single_port_no_change is

constant C_AWIDTH : integer := AWIDTH;
constant C_DWIDTH : integer := DWIDTH;
constant C_NBPIPE : integer := NBPIPE;

-- Internal Signals
type mem_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_data_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_en_t is array(natural range&lt;&gt;) of std_logic;

signal mem : mem_t(2**C_AWIDTH-1 downto 0);                -- Memory Declaration
signal memreg : std_logic_vector(C_DWIDTH-1 downto 0);              
signal mem_pipe_reg : pipe_data_t(C_NBPIPE-1 downto 0);    -- Pipelines for memory
signal mem_en_pipe_reg : pipe_en_t(C_NBPIPE downto 0);     -- Pipelines for memory enable  

attribute ram_style : string;
attribute ram_style of mem : signal is "ultra";

begin

-- RAM : Read has one latency, Write has one latency as well.
process(clk)
begin
  if(clk'event and clk='1')then
    if(mem_en = '1') then
      if(we = '1') then
        mem(to_integer(unsigned(addr))) &lt;= din;
      else
        memreg &lt;= mem(to_integer(unsigned(addr)));
      end if;
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    mem_en_pipe_reg(0) &lt;= mem_en;
    for i in 0 to C_NBPIPE-1 loop
      mem_en_pipe_reg(i+1) &lt;= mem_en_pipe_reg(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    if(mem_en_pipe_reg(0) = '1') then
      mem_pipe_reg(0) &lt;= memreg;
    end if;
  end if;
end process;

process(clk)
begin
  if(clk'event and clk = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(mem_en_pipe_reg(i+1) = '1') then
        mem_pipe_reg(i+1) &lt;= mem_pipe_reg(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(clk)
begin
  if(clk'event and clk = '1') then
    if(rst = '1') then
      dout &lt;= (others =&gt; '0');
    elsif(mem_en_pipe_reg(C_NBPIPE) = '1' and regce = '1' ) then
      dout &lt;= mem_pipe_reg(C_NBPIPE-1);
    end if;
  end if;    
end process;

end rtl;

-- The following is an instantiation template for xilinx_ultraram_single_port_no_change 
-- Component Declaration
-- Uncomment the below component declaration when using
-- component xilinx_ultraram_single_port_no_change
--generic (
--         AWIDTH : integer := 12;  -- Address Width
--         DWIDTH : integer := 72;  -- Data Width
--         NBPIPE : integer := 3    -- Number of pipeline Registers
--        );
--port    (
--         clk : in std_logic;                                  -- Clock 
--         rst : in std_logic;                                  -- Reset
--         we : in std_logic;                                   -- Write Enable
--         regce : in std_logic;                                -- Output Register Enable
--         mem_en : in std_logic;                               -- Memory Enable
--         din : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
--         addr : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
--         dout : out std_logic_vector(DWIDTH-1 downto 0)       -- Data Output
--        );
-- end component;
-- Instantiation
-- Uncomment the below component declaration when using
-- &lt;your_instance_name&gt; : xilinx_ultraram_single_port_no_change 
-- generic map (
--		AWIDTH =&gt; AWIDTH, 
--		DWIDTH =&gt; DWIDTH, 
--	    NBPIPE =&gt; NBPIPE	
--       )
-- port map (
--         clk =&gt; clk, 
--         rst =&gt; rst, 
--         we =&gt; we, 
--         regce =&gt; regce, 
--         mem_en =&gt; mem_en, 
--         din =&gt; din, 
--         addr =&gt; addr, 
--         dout =&gt; dout
--         );
 
						</Template>
						<Template label="Read First Mode" treetype="template">
-- Xilinx UltraRAM Single Port Read First.  This code implements 
-- a parameterizable UltraRAM block in Read First mode. The behavior of this RAM is 
-- when data is written, the old memory contents at the write address is
-- presented on the output port.
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity xilinx_ultraram_single_port_read_first is
generic (
         AWIDTH : integer := 12;  -- Address Width
         DWIDTH : integer := 72;  -- Data Width
         NBPIPE : integer := 3    -- Number of pipeline Registers
        );
port    (
         clk : in std_logic;                                  -- Clock 
         rst : in std_logic;                                  -- Reset
         we : in std_logic;                                   -- Write Enable
         regce : in std_logic;                                -- Output Register Enable
         mem_en : in std_logic;                               -- Memory Enable
         din : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
         addr : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
         dout : out std_logic_vector(DWIDTH-1 downto 0)       -- Data Output
        );
end xilinx_ultraram_single_port_read_first;

architecture rtl of xilinx_ultraram_single_port_read_first is

constant C_AWIDTH : integer := AWIDTH;
constant C_DWIDTH : integer := DWIDTH;
constant C_NBPIPE : integer := NBPIPE;

-- Internal Signals
type mem_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_data_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_en_t is array(natural range&lt;&gt;) of std_logic;

signal mem : mem_t(2**C_AWIDTH-1 downto 0);                -- Memory Declaration
signal memreg : std_logic_vector(C_DWIDTH-1 downto 0);              
signal mem_pipe_reg : pipe_data_t(C_NBPIPE-1 downto 0);    -- Pipelines for memory
signal mem_en_pipe_reg : pipe_en_t(C_NBPIPE downto 0);     -- Pipelines for memory enable  

attribute ram_style : string;
attribute ram_style of mem : signal is "ultra";
begin

-- RAM : Read has one latency, Write has one latency as well.
process(clk)
begin
  if(clk'event and clk='1')then
    if(mem_en = '1') then
      if(we = '1') then
        mem(to_integer(unsigned(addr))) &lt;= din;
      end if;
      memreg &lt;= mem(to_integer(unsigned(addr)));
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    mem_en_pipe_reg(0) &lt;= mem_en;
    for i in 0 to C_NBPIPE-1 loop
      mem_en_pipe_reg(i+1) &lt;= mem_en_pipe_reg(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    if(mem_en_pipe_reg(0) = '1') then
      mem_pipe_reg(0) &lt;= memreg;
    end if;
  end if;
end process;

process(clk)
begin
  if(clk'event and clk = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(mem_en_pipe_reg(i+1) = '1') then
        mem_pipe_reg(i+1) &lt;= mem_pipe_reg(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(clk)
begin
  if(clk'event and clk = '1') then
    if(rst = '1') then
      dout &lt;= (others =&gt; '0');
    elsif(mem_en_pipe_reg(C_NBPIPE) = '1' and regce = '1' ) then
      dout &lt;= mem_pipe_reg(C_NBPIPE-1);
    end if;
  end if;    
end process;

end rtl;

-- The following is an instantiation template for xilinx_ultraram_single_port_read_first 
-- Component Declaration
-- Uncomment the below component declaration when using
-- component xilinx_ultraram_single_port_read_first
--generic (
--         AWIDTH : integer := 12;  -- Address Width
--         DWIDTH : integer := 72;  -- Data Width
--         NBPIPE : integer := 3    -- Number of pipeline Registers
--        );
--port    (
--         clk : in std_logic;                                  -- Clock 
--         rst : in std_logic;                                  -- Reset
--         we : in std_logic;                                   -- Write Enable
--         regce : in std_logic;                                -- Output Register Enable
--         mem_en : in std_logic;                               -- Memory Enable
--         din : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
--         addr : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
--         dout : out std_logic_vector(DWIDTH-1 downto 0)       -- Data Output
--        );
-- end component;
-- Instantiation
-- Uncomment the below component declaration when using
-- &lt;your_instance_name&gt; : xilinx_ultraram_single_port_read_first 
-- generic map (
--		AWIDTH =&gt; AWIDTH, 
--		DWIDTH =&gt; DWIDTH, 
--	    NBPIPE =&gt; NBPIPE	
--       )
-- port map (
--         clk =&gt; clk, 
--         rst =&gt; rst, 
--         we =&gt; we, 
--         regce =&gt; regce, 
--         mem_en =&gt; mem_en, 
--         din =&gt; din, 
--         addr =&gt; addr, 
--         dout =&gt; dout
--         );

						</Template>
						<Template label="Write First Mode" treetype="template">
-- Xilinx UltraRAM Single Port Write First Mode.  This code implements 
-- a parameterizable UltraRAM block in Write First mode. The behavior of this RAM is 
-- when data is written, the new memory contents at the write address is
-- presented on the output port.
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity xilinx_ultraram_single_port_write_first is
generic (
         AWIDTH : integer := 12;  -- Address Width
         DWIDTH : integer := 72;  -- Data Width
         NBPIPE : integer := 3    -- Number of pipeline Registers
        );
port    (
         clk : in std_logic;                                  -- Clock 
         rst : in std_logic;                                  -- Reset
         we : in std_logic;                                   -- Write Enable
         regce : in std_logic;                                -- Output Register Enable
         mem_en : in std_logic;                               -- Memory Enable
         din : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
         addr : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
         dout : out std_logic_vector(DWIDTH-1 downto 0)       -- Data Output
        );
end xilinx_ultraram_single_port_write_first;

architecture rtl of xilinx_ultraram_single_port_write_first is

constant C_AWIDTH : integer := AWIDTH;
constant C_DWIDTH : integer := DWIDTH;
constant C_NBPIPE : integer := NBPIPE;

-- Internal Signals
type mem_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_data_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_en_t is array(natural range&lt;&gt;) of std_logic;

signal mem : mem_t(2**C_AWIDTH-1 downto 0);                -- Memory Declaration
signal memreg : std_logic_vector(C_DWIDTH-1 downto 0);              
signal mem_pipe_reg : pipe_data_t(C_NBPIPE-1 downto 0);    -- Pipelines for memory
signal mem_en_pipe_reg : pipe_en_t(C_NBPIPE downto 0);     -- Pipelines for memory enable 
attribute ram_style : string;
attribute ram_style of mem : signal is "ultra";

begin

-- RAM : Read has one latency, Write has one latency as well.
process(clk)
begin
  if(clk'event and clk='1')then
    if(mem_en = '1') then
      if(we = '1') then
        mem(to_integer(unsigned(addr))) &lt;= din;
        memreg &lt;= din;
      else
        memreg &lt;= mem(to_integer(unsigned(addr)));
      end if;
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    mem_en_pipe_reg(0) &lt;= mem_en;
    for i in 0 to C_NBPIPE-1 loop
      mem_en_pipe_reg(i+1) &lt;= mem_en_pipe_reg(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    if(mem_en_pipe_reg(0) = '1') then
      mem_pipe_reg(0) &lt;= memreg;
    end if;
  end if;
end process;

process(clk)
begin
  if(clk'event and clk = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(mem_en_pipe_reg(i+1) = '1') then
        mem_pipe_reg(i+1) &lt;= mem_pipe_reg(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(clk)
begin
  if(clk'event and clk = '1') then
    if(rst = '1') then
      dout &lt;= (others =&gt; '0');
    elsif(mem_en_pipe_reg(C_NBPIPE) = '1' and regce = '1' ) then
      dout &lt;= mem_pipe_reg(C_NBPIPE-1);
    end if;
  end if;    
end process;

end rtl;

-- The following is an instantiation template for xilinx_ultraram_single_port_write_first 
-- Component Declaration
-- Uncomment the below component declaration when using
-- component xilinx_ultraram_single_port_write_first
--generic (
--         AWIDTH : integer := 12;  -- Address Width
--         DWIDTH : integer := 72;  -- Data Width
--         NBPIPE : integer := 3    -- Number of pipeline Registers
--        );
--port    (
--         clk : in std_logic;                                  -- Clock 
--         rst : in std_logic;                                  -- Reset
--         we : in std_logic;                                   -- Write Enable
--         regce : in std_logic;                                -- Output Register Enable
--         mem_en : in std_logic;                               -- Memory Enable
--         din : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
--         addr : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
--         dout : out std_logic_vector(DWIDTH-1 downto 0)       -- Data Output
--        );
-- end component;
-- Instantiation
-- Uncomment the below component declaration when using
-- &lt;your_instance_name&gt; : xilinx_ultraram_single_port_write_first 
-- generic map (
--		AWIDTH =&gt; AWIDTH, 
--		DWIDTH =&gt; DWIDTH, 
--	    NBPIPE =&gt; NBPIPE	
--       )
-- port map (
--         clk =&gt; clk, 
--         rst =&gt; rst, 
--         we =&gt; we, 
--         regce =&gt; regce, 
--         mem_en =&gt; mem_en, 
--         din =&gt; din, 
--         addr =&gt; addr, 
--         dout =&gt; dout
--         );
						</Template>
					</SubFolder>
					<SubFolder label="True Dual Port" treetype="folder">
						<Template label="Non Byte-write" treetype="template">
--  Xilinx UltraRAM True Dual Port Mode.  This code implements 
--  a parameterizable UltraRAM block with write/read on both ports in 
--  No change behavior on both the ports . The behavior of this RAM is 
--  when data is written, the output of RAM is unchanged w.r.t each port. 
--  Only when write is inactive data corresponding to the address is 
--  presented on the output port.
--
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity xilinx_ultraram_true_dual_port is
generic (
         AWIDTH : integer := 12;  -- Address Width
         DWIDTH : integer := 72;  -- Data Width
         NBPIPE : integer := 3    -- Number of pipeline Registers
        );
port    (
         clk : in std_logic;                                  -- Clock 
         -- Port A
         rsta : in std_logic;                                  -- Reset
         wea : in std_logic;                                   -- Write Enable
         regcea : in std_logic;                                -- Output Register Enable
         mem_ena : in std_logic;                               -- Memory Enable
         dina : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
         addra : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
         douta : out std_logic_vector(DWIDTH-1 downto 0);      -- Data Output
         -- Port B
         rstb : in std_logic;                                  -- Reset
         web : in std_logic;                                   -- Write Enable
         regceb : in std_logic;                                -- Output Register Enable
         mem_enb : in std_logic;                               -- Memory Enable
         dinb : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
         addrb : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
         doutb : out std_logic_vector(DWIDTH-1 downto 0)       -- Data Output
        );
end xilinx_ultraram_true_dual_port;

architecture rtl of xilinx_ultraram_true_dual_port is

constant C_AWIDTH : integer := AWIDTH;
constant C_DWIDTH : integer := DWIDTH;
constant C_NBPIPE : integer := NBPIPE;

-- Internal Signals
type mem_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_data_t is array(natural range&lt;&gt;) of std_logic_vector(C_DWIDTH-1 downto 0);
type pipe_en_t is array(natural range&lt;&gt;) of std_logic;

signal mem : mem_t(2**C_AWIDTH-1 downto 0);                -- Memory Declaration

signal memrega : std_logic_vector(C_DWIDTH-1 downto 0);              
signal mem_pipe_rega : pipe_data_t(C_NBPIPE-1 downto 0);    -- Pipelines for memory
signal mem_en_pipe_rega : pipe_en_t(C_NBPIPE downto 0);     -- Pipelines for memory enable  

signal memregb : std_logic_vector(C_DWIDTH-1 downto 0);              
signal mem_pipe_regb : pipe_data_t(C_NBPIPE-1 downto 0);    -- Pipelines for memory
signal mem_en_pipe_regb : pipe_en_t(C_NBPIPE downto 0);     -- Pipelines for memory enable 

attribute ram_style : string;
attribute ram_style of mem : signal is "ultra";

begin

-- RAM : Read has one latency, Write has one latency as well.
process(clk)
begin
  if(clk'event and clk='1')then
    if(mem_ena = '1') then
      if(wea = '1') then
        mem(to_integer(unsigned(addra))) &lt;= dina;
      else
        memrega &lt;= mem(to_integer(unsigned(addra)));
      end if;
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    mem_en_pipe_rega(0) &lt;= mem_ena;
    for i in 0 to C_NBPIPE-1 loop
      mem_en_pipe_rega(i+1) &lt;= mem_en_pipe_rega(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    if(mem_en_pipe_rega(0) = '1') then
      mem_pipe_rega(0) &lt;= memrega;
    end if;
  end if;
end process;

process(clk)
begin
  if(clk'event and clk = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(mem_en_pipe_rega(i+1) = '1') then
        mem_pipe_rega(i+1) &lt;= mem_pipe_rega(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(clk)
begin
  if(clk'event and clk = '1') then
    if(rsta = '1') then
      douta &lt;= (others =&gt; '0');
    elsif(mem_en_pipe_rega(C_NBPIPE) = '1' and regcea = '1' ) then
      douta &lt;= mem_pipe_rega(C_NBPIPE-1);
    end if;
  end if;    
end process;


-- RAM : Read has one latency, Write has one latency as well.
process(clk)
begin
  if(clk'event and clk='1')then
    if(mem_enb = '1') then
      if(web = '1') then
        mem(to_integer(unsigned(addrb))) &lt;= dinb;
      else
        memregb &lt;= mem(to_integer(unsigned(addrb)));
      end if;
    end if;
  end if;
end process;

-- The enable of the RAM goes through a pipeline to produce a
-- series of pipelined enable signals required to control the data
-- pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    mem_en_pipe_regb(0) &lt;= mem_enb;
    for i in 0 to C_NBPIPE-1 loop
      mem_en_pipe_regb(i+1) &lt;= mem_en_pipe_regb(i);
    end loop;
  end if;
end process;

-- RAM output data goes through a pipeline.
process(clk)
begin
  if(clk'event and clk = '1') then
    if(mem_en_pipe_regb(0) = '1') then
      mem_pipe_regb(0) &lt;= memregb;
    end if;
  end if;
end process;

process(clk)
begin
  if(clk'event and clk = '1') then
    for i in 0 to C_NBPIPE-2 loop
      if(mem_en_pipe_regb(i+1) = '1') then
        mem_pipe_regb(i+1) &lt;= mem_pipe_regb(i);
      end if;
    end loop;
  end if;
end process;

-- Final output register gives user the option to add a reset and
-- an additional enable signal just for the data ouptut

process(clk)
begin
  if(clk'event and clk = '1') then
    if(rstb = '1') then
      doutb &lt;= (others =&gt; '0');
    elsif(mem_en_pipe_regb(C_NBPIPE) = '1' and regceb = '1' ) then
      doutb &lt;= mem_pipe_regb(C_NBPIPE-1);
    end if;
  end if;    
end process;

end rtl;

-- The following is an instantiation template for xilinx_ultraram_true_dual_port 
-- Component Declaration
-- Uncomment the below component declaration when using
-- component xilinx_ultraram_true_dual_port
--generic (
--         AWIDTH : integer := 12;  -- Address Width
--         DWIDTH : integer := 72;  -- Data Width
--         NBPIPE : integer := 3    -- Number of pipeline Registers
--        );
--port    (
--         clk : in std_logic;                                  -- Clock 

--         rsta : in std_logic;                                  -- Reset
--         wea : in std_logic;                                   -- Write Enable
--         regcea : in std_logic;                                -- Output Register Enable
--         mem_ena : in std_logic;                               -- Memory Enable
--         dina : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
--         addra : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
--         douta : out std_logic_vector(DWIDTH-1 downto 0);       -- Data Output

--         rstb : in std_logic;                                  -- Reset
--         web : in std_logic;                                   -- Write Enable
--         regceb : in std_logic;                                -- Output Register Enable
--         mem_enb : in std_logic;                               -- Memory Enable
--         dinb : in std_logic_vector(DWIDTH-1 downto 0);        -- Data Input  
--         addrb : in std_logic_vector(AWIDTH-1 downto 0);       -- Address Input
--         doutb : out std_logic_vector(DWIDTH-1 downto 0)       -- Data Output

--        );
-- end component;
-- Instantiation
-- Uncomment the below component declaration when using
-- &lt;your_instance_name&gt; : xilinx_ultraram_true_dual_port 
-- generic map (
--		AWIDTH =&gt; AWIDTH, 
--		DWIDTH =&gt; DWIDTH, 
--	    NBPIPE =&gt; NBPIPE	
--       )
-- port map (
--         clk =&gt; clk, 
--         rsta =&gt; rsta, 
--         wea =&gt; wea, 
--         regcea =&gt; regcea, 
--         mem_ena =&gt; mem_ena, 
--         dina =&gt; dina, 
--         addra =&gt; addra, 
--         douta =&gt; douta,

--         rstb =&gt; rstb, 
--         web =&gt; web, 
--         regceb =&gt; regceb, 
--         mem_enb =&gt; mem_enb, 
--         dinb =&gt; dinb, 
--         addrb =&gt; addrb, 
--         doutb =&gt; doutb
--         );
						</Template>
					</SubFolder>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Generate" treetype="folder">
			<Template label="Conditional Instances" treetype="template">
&lt;LABEL_1&gt;:
   if &lt;condition&gt; generate
      begin
         &lt;statement&gt;;
   end generate;
			</Template>
			<Template label="Generate Multiple Instances" treetype="template">
&lt;LABEL_1&gt;:
   for &lt;name&gt; in &lt;lower_limit&gt; to &lt;upper_limit&gt; generate
      begin
         &lt;statement&gt;;
         &lt;statement&gt;;
   end generate;
			</Template>
		</SubFolder>
		<SubFolder label="Loops" treetype="folder">
			<Template label="For-Loop" treetype="template">
   for &lt;name&gt; in &lt;lower_limit&gt; to &lt;upper_limit&gt; loop
      &lt;statement&gt;;
      &lt;statement&gt;;
   end loop;
			</Template>
			<Template label="While-Loop" treetype="template">
   while &lt;condition&gt; loop
      &lt;statement&gt;;
      &lt;statement&gt;;
   end loop;
			</Template>
		</SubFolder>
		<SubFolder label="Process" treetype="folder">
			<Template label="Combinatorial" treetype="template">
process (&lt;all_input_signals_separated_by_commas&gt;)
begin
   &lt;statements&gt;;
end process;
			</Template>
			<SubFolder label="Negedge Clocked" treetype="folder">
				<Template label="/w Sync High Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; = '0'&gt;) then
      if &lt;reset&gt; = '1' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
				<Template label="/w Sync Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; = '0'&gt;) then
      if &lt;reset&gt; = '0' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
			</SubFolder>
			<SubFolder label="Posedge Clocked" treetype="folder">
				<Template label="/w Sync Low Reset" treetype="template">
process (&lt;clock&gt;)
begin
   if (&lt;clock&gt;'event and &lt;clock&gt; = '1'&gt;) then
      if &lt;reset&gt; = '0' then
         &lt;statements&gt;;
      else
         &lt;statements&gt;;
      end if;
   end if;
end process;
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Signal, Constant &amp; Variable declaration" treetype="folder">
			<Template label="Constant Declaration" treetype="template">
constant &lt;name&gt;: &lt;type&gt; := &lt;value&gt;;
			</Template>
			<Template label="Signal Declaration" treetype="template">
signal &lt;name&gt;: &lt;type&gt; := &lt;value&gt;;
			</Template>
			<SubFolder label="Signal Declaration(Multiple)" treetype="folder">
				<SubFolder label="Initialized" treetype="folder">
					<Template label="1-bit" treetype="template">
   signal &lt;name&gt;: std_logic:= '0';
					</Template>
					<Template label="2-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(1 downto 0):= "00";
					</Template>
					<Template label="3-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(2 downto 0):= "000";
					</Template>
					<Template label="4-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(3 downto 0):= "0000";
					</Template>
					<Template label="8-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(7 downto 0):= "00000000";
					</Template>
					<Template label="16-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(15 downto 0):= x"0000";
					</Template>
					<Template label="32-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(31 downto 0):= x"00000000";
					</Template>
					<Template label="64-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(63 downto 0):= x"0000000000000000";
					</Template>
				</SubFolder>
				<SubFolder label="Unitialized" treetype="folder">
					<Template label="1-bit" treetype="template">
   signal &lt;name&gt;: std_logic;
					</Template>
					<Template label="2-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(1 downto 0);
					</Template>
					<Template label="3-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(2 downto 0);
					</Template>
					<Template label="4-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(3 downto 0);
					</Template>
					<Template label="8-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(7 downto 0);
					</Template>
					<Template label="16-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(15 downto 0);
					</Template>
					<Template label="32-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(31 downto 0);
					</Template>
					<Template label="64-bit" treetype="template">
   signal &lt;name&gt;: std_logic_vector(63 downto 0);
					</Template>
				</SubFolder>
			</SubFolder>
			<Template label="Variable Declaration" treetype="template">
variable &lt;name&gt;: &lt;type&gt; := &lt;value&gt;;
			</Template>
			<SubFolder label="Variable Declaration(Multiple)" treetype="folder">
				<SubFolder label="Initialized" treetype="folder">
					<Template label="1-bit" treetype="template">
   variable &lt;name&gt;: std_logic:= '0';
					</Template>
					<Template label="2-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(1 downto 0):= "00";
					</Template>
					<Template label="3-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(2 downto 0):= "000";
					</Template>
					<Template label="4-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(3 downto 0):= "0000";
					</Template>
					<Template label="8-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(7 downto 0):= "00000000";
					</Template>
					<Template label="16-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(15 downto 0):= x"0000";
					</Template>
					<Template label="32-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(31 downto 0):= x"00000000";
					</Template>
					<Template label="64-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(63 downto 0):= x"0000000000000000";
					</Template>
				</SubFolder>
				<SubFolder label="Unitialized" treetype="folder">
					<Template label="1-bit" treetype="template">
   variable &lt;name&gt;: std_logic;
					</Template>
					<Template label="2-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(1 downto 0);
					</Template>
					<Template label="3-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(2 downto 0);
					</Template>
					<Template label="4-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(3 downto 0);
					</Template>
					<Template label="8-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(7 downto 0);
					</Template>
					<Template label="16-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(15 downto 0);
					</Template>
					<Template label="32-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(31 downto 0);
					</Template>
					<Template label="64-bit" treetype="template">
   variable &lt;name&gt;: std_logic_vector(63 downto 0);
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Type &amp; Subtype" treetype="folder">
			<SubFolder label="Subtype Declaration" treetype="folder">
				<Template label="Array" treetype="template">
subtype &lt;subtype_name&gt; is array range &lt;lower_limit&gt; to &lt;upper_limit&gt;;
				</Template>
				<Template label="General" treetype="template">
subtype &lt;subtype_name&gt; is subtype &lt;subtype_definition&gt;;
				</Template>
				<Template label="Subtype of Integer" treetype="template">
subtype &lt;subtype_name&gt; is integer range &lt;lower_limit&gt; to &lt;upper_limit&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="Type Declaration" treetype="folder">
				<Template label="Array of Integers" treetype="template">
type &lt;type_name&gt; is array integer range &lt;lower_limit&gt; to &lt;upper_limit&gt;;
				</Template>
				<Template label="Enumeration" treetype="template">
type &lt;type_name&gt; is (&lt;string1&gt;, &lt;string2&gt;, ...);
				</Template>
				<Template label="General" treetype="template">
type &lt;type_name&gt; is type &lt;type_definition&gt;;
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="VHDL2008" treetype="folder">
			<Template label="Block Comments" treetype="template">
-- The following is a VHDL2008 construct and should not be used if using a tool that does not support this standard
-- VHDL2008 Supports Block comments similar to Verilog using /* */
-- 
/*
Block Comment section
*/
			</Template>
			<Template label="Condition Operator" treetype="template">
-- The following is a VHDL2008 construct and should not be used if using a tool that does not support this standard
-- VHDL2008 supports new Condition operator ?? This converts std_logic expression to a boolean value

-- Example below can be coded as
-- if A = '1' and B = '1' then 

if ?? A and B then
   
			</Template>
			<Template label="Enhanced bit string literals" treetype="template">
-- The following is a VHDL2008 construct and should not be used if using a tool that does not support this standard
-- VHDL2008 enhances bit string literals to include:
-- explicit width
-- Signed/unsigned
-- Meta values ('U','X', etc)

-- Example
variable T : std_logic_vector(7 downto 0);
  begin
    T := 8x"0f";  -- width 8
    T := 8x"XA";  -- "XXXX1010" 
    T := 8SX"F";  -- "11111111" (sign extension)
    T := 8Ux"f";  -- "00001111" (zero extension)
    T := 8sb"11"; -- "11111111" (binary format)
    T := 8uO"7";  -- "00000111" (octal format)

			</Template>
			<Template label="Extensions to the generate statement" treetype="template">
-- The following is a VHDL2008 construct and should not be used if using a tool that does not support this standard
-- VHDL2008 enhanced generate statement and supports if-elsif and  case

-- Using if-elsif
g1 : if G = 1 generate
  a1 : entity work.sub(arch1) port map (din =&gt; din,dout=&gt; dout);    
elsif G2 = 2 generate
  a2 : entity work.sub(arch2) port map (din =&gt; din,dout=&gt; dout);    
end generate;

-- Using case generate
G1 : 
case G generate
  when 1 =&gt; a1 : entity work.sub(arch1) port map (din =&gt; din,dout=&gt; dout);    
  when 2 =&gt; a2 : entity work.sub(arch2) port map (din =&gt; din,dout=&gt; dout);    
  when others  =&gt; a3 : entity work.sub(arch2) port map (din =&gt; din,dout=&gt; dout);    
end generate;

			</Template>
			<Template label="Matching case statement" treetype="template">
-- The following is a VHDL2008 construct and should not be used if using a tool that does not support this standard
-- VHDL2008 introduced Matching case statement to handle dont_care values
-- Example
case? sel is
    when "1---" =&gt; out &lt;= "01";
    when "01--" =&gt; out &lt;= "10";
    when "001-" =&gt; out &lt;= "11";
    when "0001" =&gt; out &lt;= "00";
    when others =&gt; null;
end case;

			</Template>
			<Template label="Matching Relational Operators" treetype="template">
-- The following is a VHDL2008 construct and should not be used if using a tool that does not support this standard
-- VHDL2008 supports Matching Relational operators ?=  ?/=  ?&lt; ?&lt;= ?&gt;  ?&gt;=  which return bit/std_ulogic
-- These relational operators also understand dont_care "-" 
-- Example
dout1 &lt;= sig1 and sig2 and sig3 ?= "1100--";
dout2 &lt;= sig1 and sig2 and sig3 ?/= "1100--";
dout3 &lt;= sig1 and sig2 and sig3 ?&lt;= "1100--";
dout4 &lt;= sig1 and sig2 and sig3 ?&gt;= "1100--";
			</Template>
			<Template label="Simplified sensitivity lists" treetype="template">
-- The following is a VHDL2008 construct and should not be used if using a tool that does not support this standard
-- VHDL2008 introduced simplified sensitivity lists
-- Example (all) can be specfied to implicitly indicate that all the signals read in the process are included  
process(all) 
begin
-- Other assignments
end process;
			</Template>
			<Template label="Unconstrained Types" treetype="template">
-- The following is a VHDL2008 construct and should not be used if using a tool that does not support this standard
-- VHDL2008 allows us to have unconstrained elements with Composite types (Arrays/records)
-- These need to be constrained appropriately during the usage 
-- Array Example
type array_T is array (natural range&lt;&gt;) of std_logic_vector;

-- Record Example
type Record_T is
record
  a : std_logic_vector;
  b : std_logic_vector;
end record;
			</Template>
		</SubFolder>
	</Folder>
	<Folder label="Xilinx Parameterized Macros (XPM)" treetype="folder">
		<Template label="0_Info (Usage Instructions)" treetype="template">
--
-- The following instructions describe how to prepare Vivado to use the XPM libraries:
-- 1. Create or open a Vivado project
-- 2. Set the property to enable XPMs
--    set_property XPM_LIBRARIES {XPM_CDC XPM_MEMORY XPM_FIFO} [current_project]
--
-- Note: This is a project property and as such you will need to specify it for each new project created.
--
-- 2. Select the XPM template that you wish to use from below
-- 3. Copy the contents of the template and paste into your own source file.
--    Set parameters/generics, and wire ports according to the documentation provided as code comments.
--
-- Note: Be sure to read and comply with all code comments to properly use the XPMs.
--
--

		</Template>
		<SubFolder label="Clock Domain Crossing Synchronizers (XPM_CDC)" treetype="folder">
			<Template label="Asynchronous Reset Synchronizer" treetype="template">
-- XPM_CDC instantiation template for Asynchronous Reset Synchronizer
-- Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DEST_SYNC_FF         | Integer            | Valid range : 2 - 10. Default value = 4.                                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of register stages used to synchronize signal in the destination clock domain.                               |
-- | This parameter also determines the minimum width of the asserted reset signal.                                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | RST_ACTIVE_HIGH      | Integer            | Must be 0 or 1. Default value = 0.                                      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Defines the polarity of the asynchronous reset signal.                                                              |
-- | 0: Active low asynchronous reset signal                                                                             |
-- | 1: Active high asynchronous reset signal                                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_arst       | Input     | 1                                     |           |             | Required             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Source asynchronous reset signal.                                                                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_clk       | Input     | 1                                     |           | Rising-edge | Required             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Destination clock.                                                                                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_arst      | Output    | 1                                     | dest_clk* |             | Required             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | src_arst asynchronous reset signal synchronized to destination clock domain.  This output is registered.            |
-- | * Signal asserts asynchronously but deasserts synchronously to dest_clk.  Width of the reset signal is at least     |
-- |  (DEST_SYNC_FF*dest_clk) period.                                                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+

--   xpm_cdc_async_rst  : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_cdc_async_rst_inst)
--      declaration     : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

-- Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_cdc_async_rst: Clock Domain Crossing Asynchronous Reset Synchronizer
-- Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_async_rst_inst: xpm_cdc_async_rst
  generic map (

    -- Common module parameters
     DEST_SYNC_FF    =&gt; 4, -- integer; range: 2-10
     RST_ACTIVE_HIGH =&gt; 0  -- integer; 0=active low reset, 1=active high reset
  )
  port map (

     src_arst  =&gt; src_arst,
     dest_clk  =&gt; dest_clk,
     dest_arst =&gt; dest_arst
  );

-- End of xpm_cdc_async_rst_inst instance declaration
			</Template>
			<Template label="Bus Synchronizer with Full Handshake" treetype="template">
-- XPM_CDC instantiation template for Bus Synchronizer with Full Handshake
-- Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DEST_EXT_HSK         | Integer            | Must be 0 or 1. Default value = 1.                                      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: An internal handshake will be implemented in the macro to acknowledge receipt of data on the destination clock   |
-- |    domain.                                                                                                          |
-- |    When using this option, the valid dest_out output must be consumed immediately to avoid any data loss.           |
-- | 1: External handshake logic must be implemented by the user to knowledge receipt of data on the destination clock   |
-- |    domain.                                                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DEST_SYNC_FF         | Integer            | Valid range: 2 - 10. Default value = 4.                                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of register stages used to synchronize signal in the destination clock domain.                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
-- | 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SRC_SYNC_FF          | Integer            | Valid range: 2 - 10. Default value = 4.                                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of register stages used to synchronize signal in the source clock domain.                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WIDTH                | Integer            | Valid range: 1 - 1024.  Default value = 1.                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Width of bus that will be synchronized to destination clock domain.                                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_clk        | Input     | 1                                     |          | Rising-edge | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Source clock.                                                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_in         | Input     | WIDTH                                 | src_clk  |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Input bus that will be synchronized to the destination clock domain.                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_send       | Input     | 1                                     | src_clk  | Active-high | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Assertion of this signal allows the src_in bus to be synchronized to the destination clock domain.                  |
-- | This signal should only be asserted when src_rcv is deasserted, indicating that the previous data transfer          |
-- | is complete.                                                                                                        |
-- | This signal should only be deasserted once src_rcv is asserted, acknowledging that the src_in has been received by  |
-- | the destination logic.                                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_rcv        | Output    | 1                                     | src_clk  | Active-high | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Acknowledgement from destination logic that src_in has been received.  This signal will be deasserted once          |
-- | destination handshake has fully completed, thus completing a full data transfer.  This output is registered.        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_clk       | Input     | 1                                     |          | Rising-edge |  Required             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Destination clock.                                                                                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_out       | Output    | WIDTH                                 | dest_clk |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Input bus (src_in) synchronized to destination clock domain.  This output is registered.                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_req       | Output    | 1                                     | dest_clk | Active-high | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Assertion of this signal indicates that new dest_out data has been received and is ready to be used or captured     |
-- | by the destination logic.                                                                                           |
-- | When DEST_EXT_HSK = 1, this signal will deassert once the source handshake acknowledges that the destination clock  |
-- | domain has received the transferred data.                                                                           |
-- | When DEST_EXT_HSK = 0, this signal asserts for one clock period when dest_out bus is valid.                         |
-- | This output is registered.                                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_ack       | Input     | 1                                     | dest_clk | Active-high | Tie to 1'b0           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Destination logic acknowledgement if DEST_EXT_HSK = 1.  Unused when DEST_EXT_HSK = 0.                               |
-- | Asserting this signal indicates that data on dest_out has been captured by the destination logic.                   |
-- | This signal should be deasserted once dest_req is deasserted, completing the handshake on the destination clock     |
-- | domain and indicating that the destination logic is ready for a new data transfer.                                  |
-- +---------------------------------------------------------------------------------------------------------------------+

--   xpm_cdc_handshake  : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_cdc_handshake_inst)
--      declaration     : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

-- Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_cdc_handshake: Clock Domain Crossing Bus Synchronizer with Full Handshake
-- Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_handshake_inst:  xpm_cdc_handshake
  generic map (

    -- Common module generics
    DEST_EXT_HSK   =&gt; 1, -- integer; 0=user handshake, 1=internal handshake
    DEST_SYNC_FF   =&gt; 4, -- integer; range: 2-10
    SIM_ASSERT_CHK =&gt; 0, -- integer; 0=disable simulation messages, 1=enable simulation messages
    SRC_SYNC_FF    =&gt; 4, -- integer; range: 2-10
    WIDTH          =&gt; 1  -- integer; range: 1-1024
  )
  port map (

    src_clk  =&gt; src_clk,
    src_in   =&gt; src_in,
    src_send =&gt; src_send,
    src_rcv  =&gt; src_rcv,
    dest_clk =&gt; dest_clk,
    dest_req =&gt; dest_req,
    dest_ack =&gt; dest_ack, -- optional; required when DEST_EXT_HSK = 1
    dest_out =&gt; dest_out
 );

-- End of xpm_cdc_handshake_inst instance declaration

			</Template>
			<Template label="Pulse Transfer" treetype="template">
-- XPM_CDC instantiation template for Pulse Transfer
-- Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DEST_SYNC_FF         | Integer            | Valid range : 2 - 10. Default value = 4.                                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of register stages used to synchronize signal in the destination clock domain.                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | REG_OUTPUT           | Integer            | Must be 0 or 1.  Default value = 0.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Disable registered output                                                                                        |
-- | 1: Enable registered output                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | RST_USED             | Integer            | Must be 0 or 1. Default value = 1.                                      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0 : No resets implemented.                                                                                          |
-- | 1 : Resets implemented.                                                                                             |
-- | When RST_USED = 0, src_pulse input must always be defined during simulation since there is no reset logic to        |
-- | recover from an x-propagating through the macro.                                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
-- | 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_clk        | Input     | 1                                     |          | Rising-edge | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Source clock.                                                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_rst        | Input     | 1                                     | src_clk  | Active-high |  Tie to 1'b0          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Unused when RST_USED = 0. Source reset signal if RST_USED = 1. Resets all logic in source clock domain.             |
-- | To fully reset the macro, src_rst and dest_rst must be asserted simultaneously for at least                         |
-- | ((DEST_SYNC_FF+2)*dest_clk_period) + (2*src_clk_period).                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_pulse      | Input     | 1                                     | src_clk  | Rising-edge | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Rising edge of this signal initiates a pulse transfer to the destination clock domain.                              |
-- | The minimum gap between each pulse transfer must be at the minimum 2*(larger(src_clk period, dest_clk period)).     |
-- | This is measured between the falling edge of a src_pulse to the rising edge of the next src_pulse.  This minimum    |
-- | gap will guarantee that each rising edge of src_pulse will generate a pulse the size of one dest_clk period in the  |
-- | destination clock domain.                                                                                           |
-- | When RST_USED = 1, pulse transfers will not be guaranteed while src_rst and/or dest_rst are asserted.               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_clk       | Input     | 1                                     |          | Rising-edge |  Required             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Destination clock.                                                                                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_rst       | Input     | 1                                     | dest_clk | Active-high |  Tie to 1'b0          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Unused when RST_USED = 0. Destination reset signal if RST_USED = 1. Resets all logic in destination clock domain.   |
-- | To fully reset the macro, src_rst and dest_rst must be asserted simultaneously for at least                         |
-- | ((DEST_SYNC_FF+2)*dest_clk_period) + (2*src_clk_period).                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_pulse     | Output    | 1                                     | dest_clk | Active-high | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Outputs a pulse the size of one dest_clk period when a pulse transfer is correctly initiated on src_pulse input.    |
-- | This output is combinatorial unless REG_OUTPUT is set to 1.                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+

--     xpm_cdc_pulse    : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_cdc_pulse_inst)
--     declaration      : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

-- Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_cdc_pulse: Clock Domain Crossing Pulse Transfer
-- Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_pulse_inst: xpm_cdc_pulse
  generic map (

    -- Common module generics
    DEST_SYNC_FF   =&gt; 4, -- integer; range: 2-10
    REG_OUTPUT     =&gt; 0, -- integer; 0=disable registered output,   1=enable registered output
    RST_USED       =&gt; 1, -- integer; 0=no reset, 1=implement reset
    SIM_ASSERT_CHK =&gt; 0  -- integer; 0=disable simulation messages, 1=enable simulation messages

  )
  port map (

    src_clk    =&gt; src_clk,
    src_rst    =&gt; src_rst,   -- optional; required when RST_USED = 1
    src_pulse  =&gt; src_pulse,
    dest_clk   =&gt; dest_clk,
    dest_rst   =&gt; dest_rst,  -- optional; required when RST_USED = 1
    dest_pulse =&gt; dest_pulse
  );

-- End of xpm_cdc_pulse_inst instance declaration

			</Template>
			<Template label="Single-bit Array Synchronizer" treetype="template">
-- XPM_CDC instantiation template for Single-bit Array Synchronizer
-- Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DEST_SYNC_FF         | Integer            | Valid range : 2 - 10. Default value = 4.                                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of register stages used to synchronize signal in the destination clock domain.                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
-- | 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SRC_INPUT_REG        | Integer            | Must be 0 or 1.  Default value = 1.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Do not register input (src_in)                                                                                   |
-- | 1: Register input (src_in) once using src_clk                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WIDTH                | Integer            | Valid range: 1-1024.  Default value = 2.                                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Width of single-bit array (src_in) that will be synchronized to destination clock domain.                           |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_clk        | Input     | 1                                     |          | Rising-edge |  Tie to 1'b0          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Unused when SRC_INPUT_REG = 0.  Input clock signal for src_in if SRC_INPUT_REG = 1.                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_in         | Input     | WIDTH                                 | src_clk  |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Input single-bit array to be synchronized to destination clock domain. It is assumed that each bit of the array is  |
-- | unrelated to the others.  This is reflected in the constraints applied to this macro.                               |
-- | To transfer a binary value losslessly across the two clock domains, use the xpm_cdc_gray macro instead.             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_clk       | Input     | 1                                     |          | Rising-edge |  Required             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for the destination clock domain.                                                                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_out       | Output    | WIDTH                                 | dest_clk |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | src_in synchronized to the destination clock domain.  This output is registered.                                    |
-- +---------------------------------------------------------------------------------------------------------------------+

-- xpm_cdc_array_single : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_cdc_array_single
--      declaration     : _inst) and/or the port declarations after the "=&gt;" declaration may be changed to properly
--         code         : reference and connect this function to the design.  All inputs and outputs must be connected,
--                      : unless otherwise specified.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

-- Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_cdc_array_single: Clock Domain Crossing Single-bit Array Synchronizer
-- Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_array_single_inst: xpm_cdc_array_single
  generic map (

    -- Common module generics
    DEST_SYNC_FF   =&gt; 4, -- integer; range: 2-10
    SIM_ASSERT_CHK =&gt; 0, -- integer; 0=disable simulation messages, 1=enable simulation messages
    SRC_INPUT_REG  =&gt; 1, -- integer; 0=do not register input, 1=register input
    WIDTH          =&gt; 2  -- integer; range: 1-1024

  )
  port map (

    src_clk  =&gt; src_clk,  -- optional; required when SRC_INPUT_REG = 1
    src_in   =&gt; src_in,
    dest_clk =&gt; dest_clk,
    dest_out =&gt; dest_out
  );

-- End of xpm_cdc_array_single_inst instance declaration

			</Template>
			<Template label="Single-bit Synchronizer" treetype="template">
-- XPM_CDC instantiation template for Single-bit Synchronizer
-- Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DEST_SYNC_FF         | Integer            | Valid range: 2 - 10. Default value = 4.                                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of register stages used to synchronize signal in the destination clock domain.                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
-- | 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SRC_INPUT_REG        | Integer            | Must be 0 or 1.  Default value = 1.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Do not register input (src_in)                                                                                   |
-- | 1: Register input (src_in) once using src_clk                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_clk        | Input     | 1                                     |          | Rising-edge |  Tie to 1'b0          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Input clock signal for src_in if SRC_INPUT_REG = 1.  Unused when SRC_INPUT_REG = 0.                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_in         | Input     | 1                                     | src_clk  |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Input signal to be synchronized to dest_clk domain.                                                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_clk       | Input     | 1                                     |          | Rising-edge | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for the destination clock domain.                                                                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_out       | Output    | 1                                     | dest_clk |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | src_in synchronized to the destination clock domain.  This output is registered.                                    |
-- +---------------------------------------------------------------------------------------------------------------------+

--    xpm_cdc_single    : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_cdc_single_inst)
--      declaration     : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

-- Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_cdc_single: Clock Domain Crossing Single-bit Synchronizer
-- Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_single_inst: xpm_cdc_single
  generic map (
     DEST_SYNC_FF   =&gt; 4, -- integer; range: 2-10
     SIM_ASSERT_CHK =&gt; 0, -- integer; 0=disable simulation messages, 1=enable simulation messages
     SRC_INPUT_REG  =&gt; 1  -- integer; 0=do not register input, 1=register input
  )
  port map (
     src_clk  =&gt; src_clk,  -- optional; required when SRC_INPUT_REG = 1
     src_in   =&gt; src_in,
     dest_clk =&gt; dest_clk,
     dest_out =&gt; dest_out
  );

-- End of xpm_cdc_single_inst instance declaration

			</Template>
			<Template label="Synchronizer via Gray Encoding" treetype="template">
-- XPM_CDC instantiation template for Synchronizer via Gray Encoding
-- Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
=======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DEST_SYNC_FF         | Integer            | Valid range: 2 - 10. Default value = 4.                                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of register stages used to synchronize signal in the destination clock domain.                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | REG_OUTPUT           | Integer            | Must be 0 or 1.  Default value = 0.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Disable registered output                                                                                        |
-- | 1: Enable registered output                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
-- | 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SIM_LOSSLESS_GRAY_CHK| Integer            | Must be 0 or 1.  Default value = 0.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Disable simulation message that reports whether src_in_bin is incrementing or decrementing by one, guaranteeing  |
-- |    lossless synchronization of a gray coded bus.                                                                    |
-- | 1: Enable simulation message that reports whether src_in_bin is incrementing or decrementing by one, guaranteeing   |
-- |    lossless synchronization of a gray coded bus.                                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WIDTH                | Integer            | Valid range: 2 - 32. Default value = 2.                                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Width of binary input bus that will be synchronized to destination clock domain.                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_clk        | Input     | 1                                     |          | Rising-edge | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Source clock.                                                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_in_bin     | Input     | WIDTH                                 | src_clk  |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Binary input bus that will be synchronized to the destination clock domain.                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_clk       | Input     | 1                                     |          | Rising-edge | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Destination clock.                                                                                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_out_bin   | Output    | WIDTH                                 | dest_clk |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Binary input bus (src_in_bin) synchronized to destination clock domain.  This output is combinatorial unless        |
-- | REG_OUTPUT is set to 1.                                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+

--      xpm_cdc_gray    : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_cdc_gray_inst)
--      declaration     : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

-- Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_cdc_gray: Clock Domain Crossing Synchronizer via Gray Encoding
-- Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_gray_inst: xpm_cdc_gray
  generic map (

     -- Common module generics
     DEST_SYNC_FF          =&gt; 4, -- integer; range: 2-10
     REG_OUTPUT            =&gt; 0, -- integer; 0=disable registered output,   1=enable registered output
     SIM_ASSERT_CHK        =&gt; 0, -- integer; 0=disable simulation messages, 1=enable simulation messages
     SIM_LOSSLESS_GRAY_CHK =&gt; 0, -- integer; 0=disable lossless check, 1=enable lossless check
     WIDTH                 =&gt; 2  -- integer; range: 2-32
  )
  port map (

     src_clk      =&gt; src_clk,
     src_in_bin   =&gt; src_in_bin,
     dest_clk     =&gt; dest_clk,
     dest_out_bin =&gt; dest_out_bin
  );

-- End of xpm_cdc_gray_inst instance declaration

			</Template>
			<Template label="Synchronous Reset Synchronizer" treetype="template">
-- XPM_CDC instantiation template for Synchronous Reset Synchronizer
-- Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DEST_SYNC_FF         | Integer            | Valid range : 2 - 10.  Default value = 4.                               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of register stages used to synchronize signal in the destination clock domain.                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | INIT                 | Integer            | Must be 0 or 1.  Default value = 1.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Initializes synchronization registers to 0                                                                       |
-- | 1: Initializes synchronization registers to 1                                                                       |
-- | The option to initialize the synchronization registers means that there is no complete x-propagation behavior       |
-- | modeled in this macro.  For complete x-propagation modelling, use the xpm_cdc_single macro.                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
-- | 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | src_rst        | Input     | 1                                     |          |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Source reset signal.                                                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_clk       | Input     | 1                                     |          | Rising-edge | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Destination clock.                                                                                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dest_rst       | Output    | 1                                     | dest_clk |             | Required              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | src_rst synchronized to the destination clock domain.  This output is registered.                                   |
-- +---------------------------------------------------------------------------------------------------------------------+

--    xpm_cdc_sync_rst  : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_cdc_sync_rst_inst)
--     declaration      : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

-- Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_cdc_sync_rst: Clock Domain Crossing Synchronous Reset Synchronizer
-- Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_sync_rst_inst: xpm_cdc_sync_rst
  generic map (

     -- Common module parameters
     DEST_SYNC_FF    =&gt; 4, -- integer; range: 2-10
     INIT            =&gt; 1, -- integer; 0=initialize synchronization registers to 0,
                           --          1=initialize synchronization registers to 1
     SIM_ASSERT_CHK  =&gt; 0  -- integer; 0=disable simulation messages, 1=enable simulation messages

  )
  port map (

     src_rst  =&gt; src_rst,
     dest_clk =&gt; dest_clk,
     dest_rst =&gt; dest_rst
  );

-- End of xpm_cdc_sync_rst_inst instance declaration

			</Template>
		</SubFolder>
		<SubFolder label="FIFO (XPM_FIFO)" treetype="folder">
			<Template label="Asynchronous FIFO" treetype="template">
-- XPM_FIFO instantiation template for Asynchronous FIFO configurations
-- Refer to the targeted device family architecture libraries guide for XPM_FIFO documentation
-- =======================================================================================================================
--
-- Parameter usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Parameter name          | Data type          | Restrictions, if applicable                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | FIFO_MEMORY_TYPE        | String             | Must be "auto", "block", "distributed" or "ultra"                    |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the fifo memory primitive (resource type) to use:                                                         |
-- |   "auto": Allow Vivado Synthesis to choose                                                                          |
-- |   "block": Block RAM FIFO                                                                                           |
-- |   "distributed": Distributed RAM FIFO                                                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | FIFO_WRITE_DEPTH        | Integer            | Must be between 16 and 4194304                                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Defines the FIFO Write Depth, must be power of two                                                                  |
-- | In standard READ_MODE, the effective depth = FIFO_WRITE_DEPTH-1                                                     |
-- | In First-Word-Fall-Through READ_MODE, the effective depth = FIFO_WRITE_DEPTH+1                                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | RELATED_CLOCKS          | Integer            | Must be 0 or 1                                                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies if the wr_clk and rd_clk are related having the same source but different clock ratios                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_DATA_WIDTH        | Integer            | Must be between 1 and 4096                                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Defines the width of the write data port, din                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WR_DATA_COUNT_WIDTH     | Integer            | Must be between 1 and log2(FIFO_WRITE_DEPTH)+1                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies the width of wr_data_count                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_MODE               | String             | Must be "std" or "fwft"                                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- |  "std": standard read mode                                                                                          |
-- |  "fwft": First-Word-Fall-Through read mode                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | FIFO_READ_LATENCY       | Integer            | Must be &gt;= 0                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- |  Number of output register stages in the read data path                                                             |
-- |  If READ_MODE = "fwft", then the only applicable value is 0.                                                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | FULL_RESET_VALUE        | Integer            | Must be 0 or 1                                                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- |  Sets FULL and PROG_FULL to FULL_RESET_VALUE during reset                                                           |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH         | Integer            | Must be between &gt;= 1                                                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Defines the width of the read data port, dout                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | RD_DATA_COUNT_WIDTH     | Integer            | Must be between 1 and log2(FIFO_READ_DEPTH)+1                        |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies the width of rd_data_count                                                                                |
-- | FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH                                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | CDC_SYNC_STAGES         | Integer            | Must be between 2 to 8                                               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies the number of synchronization stages on the CDC path                                                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ECC_MODE                | String             | Must be "no_ecc" or "en_ecc"                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | "no_ecc" : Disables ECC                                                                                             |
-- | "en_ecc" : Enables both ECC Encoder and Decoder                                                                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | PROG_FULL_THRESH        | Integer            | Must be between "Min_Value" and "Max_Value"                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies the maximum number of write words in the FIFO at or above which prog_full is asserted.                    |
-- | Min_Value = 3 + (READ_MODE*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))+CDC_SYNC_STAGES                                    |
-- | Min_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | PROG_EMPTY_THRESH       | Integer            | Must be between "Min_Value" and "Max_Value"                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies the minimum number of read words in the FIFO at or below which prog_empty is asserted                     |
-- | Min_Value = 3 + (READ_MODE*2)                                                                                       |
-- | Min_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE*2)                                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DOUT_RESET_VALUE        | String             | Must be &gt;="0". Valid hexa decimal value                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset value of read data path.                                                                                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WAKEUP_TIME             | Integer            | Must be 0 or 2                                                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0 : Disable sleep.                                                                                                  |
-- | 2 : Use Sleep Pin.                                                                                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sleep          | Input     | 1                                     |        | Active-high | Tie to 1'b0             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Dynamic power saving: If sleep is High, the memory/fifo block is in power saving mode.                              |
-- | Synchronous to the slower of wr_clk and rd_clk.                                                                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rst            | Input     | 1                                     | wr_clk | Active-high | Required                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wr_clk         | Input     | 1                                     |        | Rising edge | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write clock: Used for write operation.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wr_en          | Input     | 1                                     | wr_clk | Active-high | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write Enable: If the FIFO is not full, asserting this signal causes data (on din) to be written to the FIFO         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | din            | Input     | WRITE_DATA_WIDTH                      | wr_clk |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write Data: The input data bus used when writing the FIFO.                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | full           | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Full Flag: When asserted, this signal indicates that the FIFO is full.                                              |
-- | Write requests are ignored when the FIFO is full, initiating a write when the FIFO is full is not destructive       |
-- | to the contents of the FIFO.                                                                                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | overflow       | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Overflow: This signal indicates that a write request (wren) during the prior clock cycle was rejected,              |
-- | because the FIFO is full. Overflowing the FIFO is not destructive to the contents of the FIFO.                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wr_rst_busy    | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write Reset Busy: Active-High indicator that the FIFO write domain is currently in a reset state.                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rd_clk         | Input     | 1                                     |        | Rising edge | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Read clock: Used for read operation.                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rd_en          | Input     | 1                                     | rd_clk | Active-high | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Read Enable: If the FIFO is not empty, asserting this signal causes data (on dout) to be read from the FIFO         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dout           | Output    | READ_DATA_WIDTH                       | rd_clk |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Read Data: The output data bus is driven when reading the FIFO.                                                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | empty          | Output    | 1                                     | rd_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Empty Flag: When asserted, this signal indicates that the FIFO is empty.                                            |
-- | Read requests are ignored when the FIFO is empty, initiating a read while empty is not destructive to the FIFO.     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | underflow      | Output    | 1                                     | rd_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Underflow: Indicates that the read request (rd_en) during the previous clock cycle was rejected                     |
-- | because the FIFO is empty. Under flowing the FIFO is not destructive to the FIFO.                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rd_rst_busy    | Output    | 1                                     | rd_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Read Reset Busy: Active-High indicator that the FIFO read domain is currently in a reset state.                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | prog_full      | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Programmable Full: This signal is asserted when the number of words in the FIFO is greater than or equal            |
-- | to the programmable full threshold value.                                                                           |
-- | It is de-asserted when the number of words in the FIFO is less than the programmable full threshold value.          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wr_data_count  | Output    | WR_DATA_COUNT_WIDTH                   | wr_clk |             | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write Data Count: This bus indicates the number of words written into the FIFO.                                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | prog_empty     | Output    | 1                                     | rd_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Programmable Empty: This signal is asserted when the number of words in the FIFO is less than or equal              |
-- | to the programmable empty threshold value.                                                                          |
-- | It is de-asserted when the number of words in the FIFO exceeds the programmable empty threshold value.              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rd_data_count  | Output    | RD_DATA_COUNT_WIDTH                   | rd_clk |             | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Read Data Count: This bus indicates the number of words read from the FIFO.                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectsbiterr  | Intput    | 1                                     |        | Active-high | Tie to 1'b0             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Single Bit Error Injection: Injects a single bit error if the ECC feature is used on block RAMs or                  |
-- | built-in FIFO macros.                                                                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectdbiterr  | Intput    | 1                                     |        | Active-high | Tie to 1'b0             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Double Bit Error Injection: Injects a double bit error if the ECC feature is used on block RAMs or                  |
-- | built-in FIFO macros.                                                                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sbiterr        | Output    | 1                                     |        | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Single Bit Error: Indicates that the ECC decoder detected and fixed a single-bit error.                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dbiterr        | Output    | 1                                     |        | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Double Bit Error: Indicates that the ECC decoder detected a double-bit error and data in the FIFO core is corrupted.|
-- +---------------------------------------------------------------------------------------------------------------------+

-- Set generic values and connect ports to instantiate an XPM_FIFO Asynchronous configuration

--   xpm_fifo_async     :
--         VHDL         :
--       component      : In order to incorporate this function into the design, the following component declaration
--      declaration     : needs to be placed in the architecture body of the design code.
--         code         :

--   xpm_fifo_async     : In order to incorporate this function into the design, the following component instantiation
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       component      : generics may be changed to meet design requirements.  The instance name (xpm_fifo_async_inst)
--     instantiation    : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected, unless
--                      : otherwise specified.

--  Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_fifo_async: Asynchronous FIFO
-- Xilinx Parameterized Macro, Version 2016.4
xpm_fifo_async_inst : xpm_fifo_async
  generic map (

    FIFO_MEMORY_TYPE        =&gt; "block",          --string; "auto", "block", or "distributed";
    ECC_MODE                =&gt; "no_ecc",         --string; "no_ecc" or "en_ecc";
    RELATED_CLOCKS          =&gt; 0,                --positive integer; 0 or 1
    FIFO_WRITE_DEPTH        =&gt; 2048,             --positive integer
    WRITE_DATA_WIDTH        =&gt; 32,               --positive integer
    WR_DATA_COUNT_WIDTH     =&gt; 12,               --positive integer
    PROG_FULL_THRESH        =&gt; 10,               --positive integer
    FULL_RESET_VALUE        =&gt; 0,                --positive integer; 0 or 1;
    READ_MODE               =&gt; "std",            --string; "std" or "fwft";
    FIFO_READ_LATENCY       =&gt; 1,                --positive integer;
    READ_DATA_WIDTH         =&gt; 32,               --positive integer
    RD_DATA_COUNT_WIDTH     =&gt; 12,               --positive integer
    PROG_EMPTY_THRESH       =&gt; 10,               --positive integer
    DOUT_RESET_VALUE        =&gt; "0",              --string
    CDC_SYNC_STAGES         =&gt; 2,                --positive integer
    WAKEUP_TIME             =&gt; 0                 --positive integer; 0 or 2;
  )
  port map (

    sleep            =&gt; '0',
    rst              =&gt; rst,
    wr_clk           =&gt; wr_clk,
    wr_en            =&gt; wr_en,
    din              =&gt; din,
    full             =&gt; full,
    overflow         =&gt; overflow,
    wr_rst_busy      =&gt; wr_rst_busy,
    rd_clk           =&gt; rd_clk,
    rd_en            =&gt; rd_en,
    dout             =&gt; dout,
    empty            =&gt; empty,
    underflow        =&gt; underflow,
    rd_rst_busy      =&gt; rd_rst_busy,
    prog_full        =&gt; prog_full,
    wr_data_count    =&gt; wr_data_count,
    prog_empty       =&gt; prog_empty,
    rd_data_count    =&gt; rd_data_count,
    injectsbiterr    =&gt; '0',
    injectdbiterr    =&gt; '0',
    sbiterr          =&gt; open,
    dbiterr          =&gt; open
  );

-- End of xpm_fifo_async_inst instance declaration

			</Template>
			<Template label="Synchronous FIFO" treetype="template">

-- XPM_FIFO instantiation template for Synchronous FIFO configurations
-- Refer to the targeted device family architecture libraries guide for XPM_FIFO documentation
-- =======================================================================================================================
--
-- Parameter usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Parameter name          | Data type          | Restrictions, if applicable                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | FIFO_MEMORY_TYPE        | String             | Must be "auto", "block", "distributed" or "ultra"                    |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the fifo memory primitive (resource type) to use:                                                         |
-- |   "auto": Allow Vivado Synthesis to choose                                                                          |
-- |   "block": Block RAM FIFO                                                                                           |
-- |   "distributed": Distributed RAM FIFO                                                                               |
-- |   "ultra": URAM FIFO                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | FIFO_WRITE_DEPTH        | Integer            | Must be between 16 and 4194304                                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Defines the FIFO Write Depth, must be power of two                                                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_DATA_WIDTH        | Integer            | Must be between 1 and 4096                                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Defines the width of the write data port, din                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WR_DATA_COUNT_WIDTH     | Integer            | Must be between 1 and log2(FIFO_WRITE_DEPTH)+1                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies the width of wr_data_count                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_MODE               | String             | Must be "std" or "fwft"                                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- |  "std": standard read mode                                                                                          |
-- |  "fwft": First-Word-Fall-Through read mode                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | FIFO_READ_LATENCY       | Integer            | Must be &gt;= 0                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- |  Number of output register stages in the read data path                                                             |
-- |  If READ_MODE = "fwft", then the only applicable value is 0.                                                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | FULL_RESET_VALUE        | Integer            | Must be 0 or 1                                                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- |  Sets FULL and PROG_FULL to FULL_RESET_VALUE during reset                                                           |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH         | Integer            | Must be between &gt;= 1                                                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Defines the width of the read data port, dout                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | RD_DATA_COUNT_WIDTH     | Integer            | Must be between 1 and log2(FIFO_READ_DEPTH)+1                        |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies the width of rd_data_count                                                                                |
-- | FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH                                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ECC_MODE                | String             | Must be "no_ecc" or "en_ecc"                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | "no_ecc" : Disables ECC                                                                                             |
-- | "en_ecc" : Enables both ECC Encoder and Decoder                                                                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | PROG_FULL_THRESH        | Integer            | Must be between "Min_Value" and "Max_Value"                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies the maximum number of write words in the FIFO at or above which prog_full is asserted.                    |
-- | Min_Value = 3 + (READ_MODE*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))+CDC_SYNC_STAGES                                    |
-- | Min_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | PROG_EMPTY_THRESH       | Integer            | Must be between "Min_Value" and "Max_Value"                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specifies the minimum number of read words in the FIFO at or below which prog_empty is asserted                     |
-- | Min_Value = 3 + (READ_MODE*2)                                                                                       |
-- | Min_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE*2)                                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | DOUT_RESET_VALUE        | String             | Must be &gt;="0". Valid hexa decimal value                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset value of read data path.                                                                                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WAKEUP_TIME             | Integer            | Must be 0 or 2                                                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | 0 : Disable sleep.                                                                                                  |
-- | 2 : Use Sleep Pin.                                                                                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sleep          | Input     | 1                                     |        | Active-high | Tie to 1'b0             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Dynamic power saving: If sleep is High, the memory/fifo block is in power saving mode.                              |
-- | Synchronous to the slower of wr_clk and rd_clk when COMMON_CLOCK = 0, otherwise synchronous to rd_clk.              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rst            | Input     | 1                                     | wr_clk | Active-high | Required                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wr_clk         | Input     | 1                                     |        | Rising edge | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write clock: Used for write operation.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wr_en          | Input     | 1                                     | wr_clk | Active-high | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write Enable: If the FIFO is not full, asserting this signal causes data (on din) to be written to the FIFO         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | din            | Input     | WRITE_DATA_WIDTH                      | wr_clk |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write Data: The input data bus used when writing the FIFO.                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | full           | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Full Flag: When asserted, this signal indicates that the FIFO is full.                                              |
-- | Write requests are ignored when the FIFO is full, initiating a write when the FIFO is full is not destructive       |
-- | to the contents of the FIFO.                                                                                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | overflow       | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Overflow: This signal indicates that a write request (wren) during the prior clock cycle was rejected,              |
-- | because the FIFO is full. Overflowing the FIFO is not destructive to the contents of the FIFO.                      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wr_rst_busy    | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write Reset Busy: Active-High indicator that the FIFO write domain is currently in a reset state.                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rd_en          | Input     | 1                                     | wr_clk | Active-high | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Read Enable: If the FIFO is not empty, asserting this signal causes data (on dout) to be read from the FIFO         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dout           | Output    | READ_DATA_WIDTH                       | wr_clk |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Read Data: The output data bus is driven when reading the FIFO.                                                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | empty          | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Empty Flag: When asserted, this signal indicates that the FIFO is empty.                                            |
-- | Read requests are ignored when the FIFO is empty, initiating a read while empty is not destructive to the FIFO.     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | underflow      | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Underflow: Indicates that the read request (rd_en) during the previous clock cycle was rejected                     |
-- | because the FIFO is empty. Under flowing the FIFO is not destructive to the FIFO.                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rd_rst_busy    | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Read Reset Busy: Active-High indicator that the FIFO read domain is currently in a reset state.                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | prog_full      | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Programmable Full: This signal is asserted when the number of words in the FIFO is greater than or equal            |
-- | to the programmable full threshold value.                                                                           |
-- | It is de-asserted when the number of words in the FIFO is less than the programmable full threshold value.          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wr_data_count  | Output    | WR_DATA_COUNT_WIDTH                   | wr_clk |             | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write Data Count: This bus indicates the number of words written into the FIFO.                                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | prog_empty     | Output    | 1                                     | wr_clk | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Programmable Empty: This signal is asserted when the number of words in the FIFO is less than or equal              |
-- | to the programmable empty threshold value.                                                                          |
-- | It is de-asserted when the number of words in the FIFO exceeds the programmable empty threshold value.              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rd_data_count  | Output    | RD_DATA_COUNT_WIDTH                   | wr_clk |             | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Read Data Count: This bus indicates the number of words read from the FIFO.                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectsbiterr  | Intput    | 1                                     |        | Active-high | Tie to 1'b0             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Single Bit Error Injection: Injects a single bit error if the ECC feature is used on block RAMs or                  |
-- | built-in FIFO macros.                                                                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectdbiterr  | Intput    | 1                                     |        | Active-high | Tie to 1'b0             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Double Bit Error Injection: Injects a double bit error if the ECC feature is used on block RAMs or                  |
-- | built-in FIFO macros.                                                                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sbiterr        | Output    | 1                                     |        | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Single Bit Error: Indicates that the ECC decoder detected and fixed a single-bit error.                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dbiterr        | Output    | 1                                     |        | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Double Bit Error: Indicates that the ECC decoder detected a double-bit error and data in the FIFO core is corrupted.|
-- +---------------------------------------------------------------------------------------------------------------------+

-- Set generic values and connect ports to instantiate an XPM_FIFO synchronous configuration

--   xpm_fifo_sync      :
--         VHDL         :
--       component      : In order to incorporate this function into the design, the following component declaration
--      declaration     : needs to be placed in the architecture body of the design code.
--         code         :

--   xpm_fifo_sync      : In order to incorporate this function into the design, the following component instantiation
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       component      : generics may be changed to meet design requirements.  The instance name (xpm_fifo_sync_inst)
--     instantiation    : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected, unless
--                      : otherwise specified.

--  Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_fifo_sync: Synchronous FIFO
-- Xilinx Parameterized Macro, Version 2016.4
xpm_fifo_sync_inst : xpm_fifo_sync
  generic map (

    FIFO_MEMORY_TYPE         =&gt; "block",          --string; "auto", "block", "distributed", or "ultra" ;
    ECC_MODE                 =&gt; "no_ecc",         --string; "no_ecc" or "en_ecc";
    FIFO_WRITE_DEPTH         =&gt; 2048,             --positive integer
    WRITE_DATA_WIDTH         =&gt; 32,               --positive integer
    WR_DATA_COUNT_WIDTH      =&gt; 12,               --positive integer
    PROG_FULL_THRESH         =&gt; 10,               --positive integer
    FULL_RESET_VALUE         =&gt; 0,                --positive integer; 0 or 1;
    READ_MODE                =&gt; "std",            --string; "std" or "fwft";
    FIFO_READ_LATENCY        =&gt; 1,                --positive integer;
    READ_DATA_WIDTH          =&gt; 32,               --positive integer
    RD_DATA_COUNT_WIDTH      =&gt; 12,               --positive integer
    PROG_EMPTY_THRESH        =&gt; 10,               --positive integer
    DOUT_RESET_VALUE         =&gt; "0",              --string
    WAKEUP_TIME              =&gt; 0                 --positive integer; 0 or 2;
  )
  port map (

    rst              =&gt; rst,
    wr_clk           =&gt; wr_clk,
    wr_en            =&gt; wr_en,
    din              =&gt; din,
    full             =&gt; full,
    overflow         =&gt; overflow,
    wr_rst_busy      =&gt; wr_rst_busy,
    rd_en            =&gt; rd_en,
    dout             =&gt; dout,
    empty            =&gt; empty,
    underflow        =&gt; underflow,
    rd_rst_busy      =&gt; rd_rst_busy,
    prog_full        =&gt; prog_full,
    wr_data_count    =&gt; wr_data_count,
    prog_empty       =&gt; prog_empty,
    rd_data_count    =&gt; rd_data_count,
    sleep            =&gt; '0',
    injectsbiterr    =&gt; '0',
    injectdbiterr    =&gt; '0',
    sbiterr          =&gt; open,
    dbiterr          =&gt; open
  );

-- End of xpm_fifo_sync_inst instance declaration
			</Template>
		</SubFolder>
		<SubFolder label="Memory (XPM_MEMORY)" treetype="folder">
			<SubFolder label="Memory File (MEM)" treetype="folder">
				<Template label="Info" treetype="template">
// Information on the Memory File (MEM) for initializing memories
// ==============================================================
//
// A Memory (MEM) file is a text file that describes contiguous blocks of data. MEM files
// can be edited directly. XPM_MEMORY allows the free-form use of both // and /*...*/
// commenting styles.
// The format of MEM files is an industry standard, which consists of two basic elements:
// a hexadecimal address specifier and hexadecimal data values. An address specifier is
// indicated by an @ character followed by the hexadecimal address value. There are no
// spaces between the @ character and the first hexadecimal character.
// Hexadecimal data values follow the hexadecimal address value, separated by spaces,
// tabs, or carriage-return characters. Data values can consist of as many hexadecimal
// characters as desired. However, when a value has an odd number of hexadecimal
// characters, the first hexadecimal character is assumed to be a zero.
// For example, hexadecimal values:
//   A, C74, and 84F21
// are interpreted as the values:
//   0A, 0C74, and 084F21
//
// The common 0x hexadecimal prefix is not allowed. Using this prefix on MEM file
// hexadecimal values is flagged as a syntax error.
// There must be at least one data value following an address, up to as many data values
// that belong to the previous address value.
//
// Following is an example of the most common MEM file format:
//   @0000 3A @0001 7B @0002 C4 @0003 56 @0004 02
//   @0005 6F @0006 89...
// A MEM file can have as many contiguous data blocks as required. While the gap of
// address ranges between data blocks can be any size, no two data blocks can overlap
// an address range

				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<Template label="Dual Port Distributed RAM" treetype="template">
-- XPM_MEMORY instantiation template for dual port distributed RAM configurations
-- Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_SIZE          | Integer            | Must be integer multiple of [WRITE|READ]_DATA_WIDTH_[A|B]               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the total memory array size, in bits.                                                                       |
-- | For example, enter 65536 for a 2kx32 RAM.                                                                           |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | CLOCKING_MODE        | String             | Must be "common_clock" or "independent_clock"                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate whether port A and port B are clocked with a common clock or with independent clocks:                     |
-- |   "common_clock": Common clocking; clock both port A and port B with clka                                           |
-- |   "independent_clock": Independent clocking; clock port A with clka and port B with clkb                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
-- |   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
-- |   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
-- |   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
-- |   information on the syntax. Initialization of memory happens through the file name specified only when generic     |
-- |   MEMORY_INIT_PARAM value is equal to "".                                                                           |
-- |   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_PARAM    | String             | Must be exactly "" or the string of hex characters (in quotes)          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
-- | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
-- | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
-- | narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
-- | memory is 8 locations, then the parameter value should be passed as shown below.                                    |
-- |   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
-- |                                  |                   |                                                              |
-- |                                  0th                7th                                                             |
-- |                                location            location                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | USE_MEM_INIT         | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
-- | Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
-- | Parameter.                                                                                                          |
-- |    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
-- |    Initial memory contents will be all 0's                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_DATA_WIDTH_A   | Integer            | Must be &gt; 0 and equal to the value of READ_DATA_WIDTH_A                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A write data input port dina, in bits.                                                |
-- | The values of WRITE_DATA_WIDTH_A and READ_DATA_WIDTH_A must be equal.                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_A                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A read data output port douta, in bits.                                               |
-- | The values of READ_DATA_WIDTH_A and WRITE_DATA_WIDTH_A must be equal.                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | BYTE_WRITE_WIDTH_A   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_A                        |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | To enable byte-wide writes on port A, specify the byte width, in bits:                                              |
-- |   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                              |
-- |   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |
-- | Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A)       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A address port addra, in bits.                                                        |
-- | Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A).|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_RESET_VALUE_A   | String             |                                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_LATENCY_A       | Integer            | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
-- | number of clka cycles.                                                                                              |
-- | To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
-- | output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
-- | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH_B    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_B                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port B read data output port doutb, in bits.                                               |
-- | The values of READ_DATA_WIDTH_B and WRITE_DATA_WIDTH_B must be equal.                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_B         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B)       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port B address port addrb, in bits.                                                        |
-- | Must be large enough to access the entire memory from port B, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B).|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_RESET_VALUE_B   | String             |                                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_LATENCY_B       | Integer            | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |
-- | number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |
-- | To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
-- | output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
-- | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clka           | Input     | 1                                     |        | Rising edge | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port A. Also clocks port B when generic CLOCKING_MODE is 0.                                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rsta           | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset signal for the final port A output register stage.                                                            |
-- | Synchronously resets output port douta to the value specified by generic READ_RESET_VALUE_A.                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ena            | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port A.                                                                                    |
-- | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | regcea         | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Do not change from the provided value.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wea            | Input     | WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A | clka   | Active-high | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |
-- | In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |
-- | For example, to synchronously write only bits [15:8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be "0010".    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port A write and read operations.                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dina           | Input     | WRITE_DATA_WIDTH_A                    | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data input for port A write operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data output for port A read operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clkb           | Input     | 1                                     |        | Rising edge | Tie to 1'b0             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port B when generic CLOCKING_MODE is "independent_clock".                                          |
-- | Unused when generic CLOCKING_MODE is "common_clock".                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rstb           | Input     | 1                                     | *      | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset signal for the final port B output register stage.                                                            |
-- | Synchronously resets output port doutb to the value specified by generic READ_RESET_VALUE_B.                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | enb            | Input     | 1                                     | *      | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port B.                                                                                    |
-- | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | regceb         | Input     | 1                                     | *      | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Do not change from the provided value.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addrb          | Input     | ADDR_WIDTH_B                          | *      |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port B write and read operations.                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | doutb          | Output   | READ_DATA_WIDTH_B                      | *      |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data output for port B read operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | * clka when generic CLOCKING_MODE is "common_clock". clkb when generic CLOCKING_MODE is "independent_clock".        |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Set generic values and connect ports to instantiate an XPM_MEMORY dual port distributed RAM configuration

--   xpm_memory_dpdistram: In order to incorporate this function into the design, the following instance declaration
--         VHDL          : needs to be placed in the architecture body of the design code.  The default values for the
--       instance        : generics may be changed to meet design requirements.  The instance name (xpm_memory_dpdistram_inst)
--      declaration      : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code          : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

--  Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_memory_dpdistram: Dual Port Distributed RAM
-- Xilinx Parameterized Macro, Version 2016.4
xpm_memory_dpdistram_inst : xpm_memory_dpdistram
  generic map (

    -- Common module generics
    MEMORY_SIZE        =&gt; 2048,        --positive integer
    CLOCKING_MODE      =&gt; "common_clock",--string; "common_clock", "independent_clock" 
    MEMORY_INIT_FILE   =&gt; "none",      --string; "none" or "&lt;filename&gt;.mem" 
    MEMORY_INIT_PARAM  =&gt; "",          --string;
    USE_MEM_INIT       =&gt; 1,           --integer; 0,1
    MESSAGE_CONTROL    =&gt; 0,           --integer; 0,1

    -- Port A module generics
    WRITE_DATA_WIDTH_A =&gt; 32,          --positive integer
    READ_DATA_WIDTH_A  =&gt; 32,          --positive integer
    BYTE_WRITE_WIDTH_A =&gt; 32,          --integer; 8, 9, or WRITE_DATA_WIDTH_A value
    ADDR_WIDTH_A       =&gt; 6,           --positive integer
    READ_RESET_VALUE_A =&gt; "0",         --string
    READ_LATENCY_A     =&gt; 2,           --non-negative integer

    -- Port B module generics
    READ_DATA_WIDTH_B  =&gt; 32,          --positive integer
    ADDR_WIDTH_B       =&gt; 6,           --positive integer
    READ_RESET_VALUE_B =&gt; "0",         --string
    READ_LATENCY_B     =&gt; 2            --non-negative integer
  )
  port map (

    -- Port A module ports
    clka   =&gt; clka,
    rsta   =&gt; rsta,
    ena    =&gt; ena,
    regcea =&gt; '1',   --do not change
    wea    =&gt; wea,
    addra  =&gt; addra,
    dina   =&gt; dina,
    douta  =&gt; douta,

    -- Port B module ports
    clkb   =&gt; clkb,
    rstb   =&gt; rstb,
    enb    =&gt; enb,
    regceb =&gt; '1',   --do not change
    addrb  =&gt; addrb,
    doutb  =&gt; doutb
  );

-- End of xpm_memory_dpdistram_inst instance declaration

				</Template>
				<Template label="Simple Dual Port RAM" treetype="template">
-- XPM_MEMORY instantiation template for simple dual port RAM configurations
-- Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_SIZE          | Integer            | Must be integer multiple of [WRITE|READ]_DATA_WIDTH_[A|B]               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the total memory array size, in bits.                                                                       |
-- | For example, enter 65536 for a 2kx32 RAM.                                                                           |
-- | When ECC is enabled and set to "encode_only", then the memory size has to be multiples of READ_DATA_WIDTH_B         |
-- | When ECC is enabled and set to "decode_only", then the memory size has to be multiples of WRITE_DATA_WIDTH_A        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", "block" or "ultra"                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the memory primitive (resource type) to use:                                                              |
-- |   "auto": Allow Vivado Synthesis to choose                                                                          |
-- |   "distributed": Distributed memory                                                                                 |
-- |   "block": Block memory                                                                                             |
-- |   "ultra": Ultra RAM memory                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | CLOCKING_MODE        | String             | Must be "common_clock" or "independent_clock"                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate whether port A and port B are clocked with a common clock or with independent clocks:                     |
-- |   "common_clock": Common clocking; clock both port A and port B with clka                                           |
-- |   "independent_clock": Independent clocking; clock port A with clka and port B with clkb                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
-- |   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
-- |   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
-- |   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
-- |   information on the syntax. Initialization of memory happens through the file name specified only when generic     |
-- |   MEMORY_INIT_PARAM value is equal to "".                                                                           |
-- |   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_PARAM    | String             | Must be exactly "" or the string of hex characters (in quotes)          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
-- | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
-- | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
-- | narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
-- | memory is 8 locations, then the parameter value should be passed as shown below.                                    |
-- |   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
-- |                                  |                   |                                                              |
-- |                                  0th                7th                                                             |
-- |                                location            location                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | USE_MEM_INIT         | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
-- | Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
-- | Parameter.                                                                                                          |
-- |    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
-- |    Initial memory contents will be all 0's                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WAKEUP_TIME          | String             | Must be "disable_sleep" or "use_sleep_pin"                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
-- | dynamic power saving option                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ECC_MODE             | String              | Must be "no_ecc", "encode_only", "decode_only"                         |
-- |                                            | or "both_encode_and_decode".                                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify ECC mode on both ports of the memory primitive                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | AUTO_SLEEP_TIME      | Integer             | Must be 0 or 3-15                                                      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of clka cycles to auto-sleep, if feature is available in architecture                                        |
-- |   0 : Disable auto-sleep feature                                                                                    |
-- |   3-15 : Number of auto-sleep latency cycles                                                                        |
-- |   Do not change from the value provided in the template instantiation                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_DATA_WIDTH_A   | Integer            | Must be &gt; 0                                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A write data input port dina, in bits.                                                |
-- | When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_A has to be         |
-- | multiples of 64-bits                                                                                                |
-- | When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_A has to be multiples of 72-bits                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | BYTE_WRITE_WIDTH_A   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_A                        |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | To enable byte-wide writes on port A, specify the byte width, in bits:                                              |
-- |   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                              |
-- |   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |
-- | Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/WRITE_DATA_WIDTH_A)              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A address port addra, in bits.                                                        |
-- | Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_A).       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH_B    | Integer            | Must be &gt; 0                                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port B read data output port doutb, in bits.                                               |
-- | When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_B has to be multiples of 72-bits                 |
-- | When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_B has to be          |
-- | multiples of 64-bits                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_B         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/READ_DATA_WIDTH_B)               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port B address port addrb, in bits.                                                        |
-- | Must be large enough to access the entire memory from port B, i.e. &gt;= $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B).        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_RESET_VALUE_B   |String              |                                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |
-- | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
-- | If the read data width is 8, then specify READ_RESET_VALUE_B = "EA";                                                |
-- | When ECC is enabled, then reset value is not supported                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_LATENCY_B       | Integer            | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |
-- | number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |
-- | To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
-- | output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
-- | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_MODE_B         | String             | Must be "write_first", "read_first", or "no_change".                    |
-- |                                           | For distributed memory, must be "read_first".                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the write mode of port B:                                                                                 |
-- |   "write_first": Write-first write mode                                                                             |
-- |   "read_first" : Read-first write mode                                                                              |
-- |   "no_change"  : No-change write mode                                                                               |
-- | Distributed memory configurations require read-first write mode.                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sleep          | Input     | 1                                     |        | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | sleep signal to enable the dynamic power saving feature.                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clka           | Input     | 1                                     |        | Rising edge | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port A. Also clocks port B when generic CLOCKING_MODE is "common_clock".                           |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ena            | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port A.                                                                                    |
-- | Must be high on clock cycles when write operations are initiated. Pipelined internally.                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wea            | Input     | WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A | clka   | Active-high | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |
-- | In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |
-- | For example, to synchronously write only bits [15:8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be "0010".    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port A write operations.                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dina           | Input     | WRITE_DATA_WIDTH_A                    | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data input for port A write operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |
-- | "decode_only" mode).                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |
-- | "decode_only" mode).                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clkb           | Input     | 1                                     |        | Rising edge | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port B when generic CLOCKING_MODE is "independent_clock".                                          |
-- | Unused when generic CLOCKING_MODE is "common_clock".                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rstb           | Input     | 1                                     | *      | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset signal for the final port B output register stage.                                                            |
-- | Synchronously resets output port doutb to the value specified by generic READ_RESET_VALUE_B.                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | enb            | Input     | 1                                     | *      | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port B.                                                                                    |
-- | Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | regceb         | Input     | 1                                     | *      | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock Enable for the last register stage on the output data path.                                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addrb          | Input     | ADDR_WIDTH_B                          | *      |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port B read operations.                                                                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | doutb          | Output    | READ_DATA_WIDTH_B                     | *      |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data output for port B read operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sbiterrb       | Output    | 1                                     | *      | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Status signal to indicate single bit error occurrence on the data output of port B                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dbiterrb       | Output    | 1                                     | *      | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Status signal to indicate single bit error occurrence on the data output of port B                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | * clka when generic CLOCKING_MODE is "common_clock". clkb when generic CLOCKING_MODE is "independent_clock".        |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Set generic values and connect ports to instantiate an XPM_MEMORY simple dual port RAM configuration

--   xpm_memory_sdpram  : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_memory_sdpram_inst)
--     declaration      : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

--  Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_memory_sdpram: Simple Dual Port RAM
-- Xilinx Parameterized Macro, Version 2016.4
xpm_memory_sdpram_inst : xpm_memory_sdpram
  generic map (

    -- Common module generics
    MEMORY_SIZE        =&gt; 2048,        --positive integer
    MEMORY_PRIMITIVE   =&gt; "auto",      --string; "auto", "distributed", "block" or "ultra" ;
    CLOCKING_MODE      =&gt; "common_clock",--string; "common_clock", "independent_clock" 
    MEMORY_INIT_FILE   =&gt; "none",      --string; "none" or "&lt;filename&gt;.mem" 
    MEMORY_INIT_PARAM  =&gt; "",          --string;
    USE_MEM_INIT       =&gt; 1,           --integer; 0,1
    WAKEUP_TIME        =&gt; "disable_sleep",--string; "disable_sleep" or "use_sleep_pin" 
    MESSAGE_CONTROL    =&gt; 0,           --integer; 0,1
    ECC_MODE           =&gt; "no_ecc",    --string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
    AUTO_SLEEP_TIME    =&gt; 0,           --Do not Change

    -- Port A module generics
    WRITE_DATA_WIDTH_A =&gt; 32,          --positive integer
    BYTE_WRITE_WIDTH_A =&gt; 32,          --integer; 8, 9, or WRITE_DATA_WIDTH_A value
    ADDR_WIDTH_A       =&gt; 6,           --positive integer

    -- Port B module generics
    READ_DATA_WIDTH_B  =&gt; 32,          --positive integer
    ADDR_WIDTH_B       =&gt; 6,           --positive integer
    READ_RESET_VALUE_B =&gt; "0",         --string
    READ_LATENCY_B     =&gt; 2,           --non-negative integer
    WRITE_MODE_B       =&gt; "no_change"  --string; "write_first", "read_first", "no_change" 
  )
  port map (

    -- Common module ports
    sleep          =&gt; '0',

    -- Port A module ports
    clka           =&gt; clka,
    ena            =&gt; ena,
    wea            =&gt; wea,
    addra          =&gt; addra,
    dina           =&gt; dina,
    injectsbiterra =&gt; '0',
    injectdbiterra =&gt; '0',

    -- Port B module ports
    clkb           =&gt; clkb,
    rstb           =&gt; rstb,
    enb            =&gt; enb,
    regceb         =&gt; regceb,
    addrb          =&gt; addrb,
    doutb          =&gt; doutb,
    sbiterrb       =&gt; open,
    dbiterrb       =&gt; open
  );

-- End of xpm_memory_sdpram_inst instance declaration

				</Template>
				<Template label="Single Port RAM" treetype="template">
-- XPM_MEMORY instantiation template for single port RAM configurations
-- Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_SIZE          | Integer            | Must be integer multiple of [WRITE|READ]_DATA_WIDTH_A                   |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the total memory array size, in bits.                                                                       |
-- | For example, enter 65536 for a 2kx32 RAM.                                                                           |
-- | When ECC is enabled and set to "encode_only", then the memory size has to be multiples of READ_DATA_WIDTH_A         |
-- | When ECC is enabled and set to "decode_only", then the memory size has to be multiples of WRITE_DATA_WIDTH_A        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", "block" or "ultra"                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the memory primitive (resource type) to use:                                                              |
-- |   "auto": Allow Vivado Synthesis to choose                                                                          |
-- |   "distributed": Distributed memory                                                                                 |
-- |   "block": Block memory                                                                                             |
-- |   "ultra": Ultra RAM memory                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
-- |   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
-- |   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
-- |   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
-- |   information on the syntax. Initialization of memory happens through the file name specified only when generic     |
-- |   MEMORY_INIT_PARAM value is equal to "".                                                                           |
-- |   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_PARAM    | String             | Must be exactly "" or the string of hex characters (in quotes)          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
-- | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
-- | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
-- | narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
-- | memory is 8 locations, then the parameter value should be passed as shown below.                                    |
-- |   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
-- |                                  |                   |                                                              |
-- |                                  0th                7th                                                             |
-- |                                location            location                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | USE_MEM_INIT         | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
-- | Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
-- | Parameter.                                                                                                          |
-- |    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
-- |    Initial memory contents will be all 0's                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WAKEUP_TIME          | String             | Must be "disable_sleep" or "use_sleep_pin"                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
-- | dynamic power saving option                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ECC_MODE             | String              | Must be "no_ecc", "encode_only", "decode_only"                         |
-- |                                            | or "both_encode_and_decode".                                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify ECC mode on port A of the memory primitive                                                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | AUTO_SLEEP_TIME      | Integer             | Must be 0 or 3-15                                                      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of clka cycles to auto-sleep, if feature is available in architecture                                        |
-- |   0 : Disable auto-sleep feature                                                                                    |
-- |   3-15 : Number of auto-sleep latency cycles                                                                        |
-- |   Do not change from the value provided in the template instantiation                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_DATA_WIDTH_A   | Integer            | Must be &gt; 0 and equal to the value of READ_DATA_WIDTH_A                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A write data input port dina, in bits.                                                |
-- | The values of WRITE_DATA_WIDTH_A and READ_DATA_WIDTH_A must be equal.                                               |
-- | When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_A has to be         |
-- | multiples of 64-bits                                                                                                |
-- | When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_A has to be multiples of 72-bits                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_A                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A read data output port douta, in bits.                                               |
-- | The values of READ_DATA_WIDTH_A and WRITE_DATA_WIDTH_A must be equal.                                               |
-- | When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_A has to be multiples of 72-bits                 |
-- | When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_A has to be          |
-- | multiples of 64-bits                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | BYTE_WRITE_WIDTH_A   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_A                        |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | To enable byte-wide writes on port A, specify the byte width, in bits:                                              |
-- |   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                              |
-- |   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |
-- | Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A)       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A address port addra, in bits.                                                        |
-- | Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A).|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_RESET_VALUE_A   | String             |                                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
-- | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
-- | If the read data width is 8, then specify READ_RESET_VALUE_A = "EA";                                                |
-- | When ECC is enabled, then reset value is not supported                                                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | READ_LATENCY_A       | Integer            | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
-- | number of clka cycles.                                                                                              |
-- | To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
-- | output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
-- | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_MODE_A         | String             | Must be "write_first", "read_first", or "no_change".                    |
-- |                                           | For distributed memory, must be "read_first".                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the write mode of port A:                                                                                 |
-- |   "write_first": Write-first write mode                                                                             |
-- |   "read_first" : Read-first write mode                                                                              |
-- |   "no_change"  : No-change write mode                                                                               |
-- | Distributed memory configurations require read-first write mode.                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sleep          | Input     | 1                                     |        | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | sleep signal to enable the dynamic power saving feature.                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clka           | Input     | 1                                     |        | Rising edge | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port A.                                                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rsta           | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset signal for the final port A output register stage.                                                            |
-- | Synchronously resets output port douta to the value specified by generic READ_RESET_VALUE_A.                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ena            | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port A.                                                                                    |
-- | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | regcea         | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock Enable for the last register stage on the output data path.                                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wea            | Input     | WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A | clka   | Active-high | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |
-- | In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |
-- | For example, to synchronously write only bits [15:8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be "0010".    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port A write and read operations.                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dina           | Input     | WRITE_DATA_WIDTH_A                    | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data input for port A write operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |
-- | "decode_only" mode).                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |
-- | "decode_only" mode).                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data output for port A read operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Status signal to indicate single bit error occurrence on the data output of port A                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Status signal to indicate double bit error occurrence on the data output of port A                                  |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Set generic values and connect ports to instantiate an XPM_MEMORY single port RAM configuration

--   xpm_memory_spram   : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_memory_spram_inst)
--      declaration     : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

--  Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_memory_spram: Single Port RAM
-- Xilinx Parameterized Macro, Version 2016.4
xpm_memory_spram_inst : xpm_memory_spram
  generic map (

    -- Common module generics
    MEMORY_SIZE        =&gt; 2048,        --positive integer
    MEMORY_PRIMITIVE   =&gt; "auto",      --string; "auto", "distributed", "block" or "ultra" ;
    MEMORY_INIT_FILE   =&gt; "none",      --string; "none" or "&lt;filename&gt;.mem" 
    MEMORY_INIT_PARAM  =&gt; "",          --string;
    USE_MEM_INIT       =&gt; 1,           --integer; 0,1
    WAKEUP_TIME        =&gt; "disable_sleep",--string; "disable_sleep" or "use_sleep_pin" 
    MESSAGE_CONTROL    =&gt; 0,           --integer; 0,1
    ECC_MODE           =&gt; "no_ecc",    --string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
    AUTO_SLEEP_TIME    =&gt; 0,           --Do not Change


    -- Port A module generics
    WRITE_DATA_WIDTH_A =&gt; 32,          --positive integer
    READ_DATA_WIDTH_A  =&gt; 32,          --positive integer
    BYTE_WRITE_WIDTH_A =&gt; 32,          --integer; 8, 9, or WRITE_DATA_WIDTH_A value
    ADDR_WIDTH_A       =&gt; 6,           --positive integer
    READ_RESET_VALUE_A =&gt; "0",         --string
    READ_LATENCY_A     =&gt; 2,           --non-negative integer
    WRITE_MODE_A       =&gt; "read_first" --string; "write_first", "read_first", "no_change" 
  )
  port map (

    -- Common module ports
    sleep          =&gt;  '0',

    -- Port A module ports
    clka           =&gt;  clka,
    rsta           =&gt;  rsta,
    ena            =&gt;  ena,
    regcea         =&gt;  regcea,
    wea            =&gt;  wea,
    addra          =&gt;  addra,
    dina           =&gt;  dina,
    injectsbiterra =&gt;  '0',
    injectdbiterra =&gt;  '0',
    douta          =&gt;  douta,
    sbiterra       =&gt;  open,
    dbiterra       =&gt;  open
  );

-- End of xpm_memory_spram_inst instance declaration

				</Template>
				<Template label="True Dual Port RAM" treetype="template">
-- XPM_MEMORY instantiation template for true dual port RAM configurations
-- Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_SIZE          | Integer            | Must be integer multiple of [WRITE|READ]_DATA_WIDTH_[A|B]               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the total memory array size, in bits.                                                                       |
-- | For example, enter 65536 for a 2kx32 RAM.                                                                           |
-- | When ECC is enabled and set to "encode_only", then the memory size has to be multiples of READ_DATA_WIDTH_[A|B]     |
-- | When ECC is enabled and set to "decode_only", then the memory size has to be multiples of WRITE_DATA_WIDTH_[A|B]    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", "block" or "ultra"                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the memory primitive (resource type) to use:                                                              |
-- |   "auto": Allow Vivado Synthesis to choose                                                                          |
-- |   "distributed": Distributed memory                                                                                 |
-- |   "block": Block memory                                                                                             |
-- |   "ultra": Ultra RAM memory                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | CLOCKING_MODE        | String             | Must be "common_clock" or "independent_clock"                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate whether port A and port B are clocked with a common clock or with independent clocks:                     |
-- |   "common_clock": Common clocking; clock both port A and port B with clka                                           |
-- |   "independent_clock": Independent clocking; clock port A with clka and port B with clkb                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
-- |   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
-- |   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
-- |   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
-- |   information on the syntax. Initialization of memory happens through the file name specified only when generic     |
-- |   MEMORY_INIT_PARAM value is equal to "".                                                                           |
-- |   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_PARAM    | String             | Must be exactly "" or the string of hex characters (in quotes)          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
-- | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
-- | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
-- | narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
-- | memory is 8 locations, then the parameter value should be passed as shown below.                                    |
-- |   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
-- |                                  |                   |                                                              |
-- |                                  0th                7th                                                             |
-- |                                location            location                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | USE_MEM_INIT         | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
-- | Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
-- | Parameter.                                                                                                          |
-- |    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
-- |    Initial memory contents will be all 0's                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WAKEUP_TIME          | String             | Must be "disable_sleep" or "use_sleep_pin"                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
-- | dynamic power saving option                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ECC_MODE             | String              | Must be "no_ecc", "encode_only", "decode_only"                         |
-- |                                            | or "both_encode_and_decode".                                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify ECC mode on both ports of the memory primitive                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | AUTO_SLEEP_TIME      | Integer             | Must be 0 or 3-15                                                      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Number of clka cycles to auto-sleep, if feature is available in architecture                                        |
-- |   0 : Disable auto-sleep feature                                                                                    |
-- |   3-15 : Number of auto-sleep latency cycles                                                                        |
-- |   Do not change from the value provided in the template instantiation                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_DATA_WIDTH_A   | Integer            | Must be &gt; 0 and equal to the value of READ_DATA_WIDTH_A                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A write data input port dina, in bits.                                                |
-- | The values of WRITE_DATA_WIDTH_A and READ_DATA_WIDTH_A must be equal.                                               |
-- | When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_A has to be         |
-- | multiples of 64-bits                                                                                                |
-- | When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_A has to be multiples of 72-bits                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_A                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A read data output port douta, in bits.                                               |
-- | The values of READ_DATA_WIDTH_A and WRITE_DATA_WIDTH_A must be equal.                                               |
-- | When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_A has to be multiples of 72-bits                 |
-- | When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_A has to be          |
-- | multiples of 64-bits                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | BYTE_WRITE_WIDTH_A   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_A                        |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | To enable byte-wide writes on port A, specify the byte width, in bits:                                              |
-- |   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                              |
-- |   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |
-- | Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A)       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A address port addra, in bits.                                                        |
-- | Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A).|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_RESET_VALUE_A   | String             |                                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
-- | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
-- | If the read data width is 8, then specify READ_RESET_VALUE_A = "EA";                                                |
-- | When ECC is enabled, then reset value is not supported                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_LATENCY_A       | Integer            | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
-- | number of clka cycles.                                                                                              |
-- | To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
-- | output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
-- | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_MODE_A         | String             | Must be "write_first", "read_first", or "no_change".                    |
-- |                                           | For distributed memory, must be read_first.                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the write mode of port A:                                                                                 |
-- |   "write_first": Write-first write mode                                                                             |
-- |   "read_first" : Read-first write mode                                                                              |
-- |   "no_change"  : No-change write mode                                                                               |
-- | Distributed memory configurations require read-first write mode.                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_DATA_WIDTH_B   | Integer            | Must be &gt; 0 and equal to the value of READ_DATA_WIDTH_B                 |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port B write data input port dinb, in bits.                                                |
-- | The values of WRITE_DATA_WIDTH_B and READ_DATA_WIDTH_B must be equal.                                               |
-- | When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_B has to be         |
-- | multiples of 64-bits                                                                                                |
-- | When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_B has to be multiples of 72-bits                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH_B    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_B                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port B read data output port doutb, in bits.                                               |
-- | The values of READ_DATA_WIDTH_B and WRITE_DATA_WIDTH_B must be equal.                                               |
-- | When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_B has to be multiples of 72-bits                 |
-- | When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_B has to be          |
-- | multiples of 64-bits                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | BYTE_WRITE_WIDTH_B   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_B                        |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | To enable byte-wide writes on port B, specify the byte width, in bits:                                              |
-- |   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_B is an integer multiple of 8                              |
-- |   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_B is an integer multiple of 9                              |
-- | Or to enable word-wide writes on port B, specify the same value as for WRITE_DATA_WIDTH_B.                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_B         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B)       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port B address port addrb, in bits.                                                        |
-- | Must be large enough to access the entire memory from port B, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B).|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_RESET_VALUE_B   | String             |                                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |
-- | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
-- | If the read data width is 8, then specify READ_RESET_VALUE_B = "EA";                                                |
-- | When ECC is enabled, then reset value is not supported                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_LATENCY_B       | Integer            | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |
-- | number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |
-- | To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
-- | output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
-- | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WRITE_MODE_B         | String             | Must be "write_first", "read_first", or "no_change".                    |
-- |                                           | For distributed memory, must be "read_first".                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the write mode of port B:                                                                                 |
-- |   "write_first": Write-first write mode                                                                             |
-- |   "read_first" : Read-first write mode                                                                              |
-- |   "no_change"  : No-change write mode                                                                               |
-- | Distributed memory configurations require read-first write mode.                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sleep          | Input     | 1                                     |        | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | sleep signal to enable the dynamic power saving feature.                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clka           | Input     | 1                                     |        | Rising edge | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port A. Also clocks port B when generic CLOCKING_MODE is "common_clock".                           |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rsta           | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset signal for the final port A output register stage.                                                            |
-- | Synchronously resets output port douta to the value specified by generic READ_RESET_VALUE_A.                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ena            | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port A.                                                                                    |
-- | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | regcea         | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock Enable for the last register stage on the output data path.                                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | wea            | Input     | WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A | clka   | Active-high | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |
-- | In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |
-- | For example, to synchronously write only bits [15:8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be "0010".    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port A write and read operations.                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dina           | Input     | WRITE_DATA_WIDTH_A                    | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data input for port A write operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |
-- | "decode_only" mode).                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |
-- | "decode_only" mode).                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data output for port A read operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Status signal to indicate single bit error occurrence on the data output of port A.                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Status signal to indicate double bit error occurrence on the data output of port A.                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clkb           | Input     | 1                                     |        | Rising edge | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port B when generic CLOCKING_MODE is "independent_clock".                                          |
-- | Unused when generic CLOCKING_MODE is "common_clock".                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rstb           | Input     | 1                                     | *      | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset signal for the final port B output register stage.                                                            |
-- | Synchronously resets output port doutb to the value specified by generic READ_RESET_VALUE_B.                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | enb            | Input     | 1                                     | *      | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port B.                                                                                    |
-- | Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | regceb         | Input     | 1                                     | *      | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock Enable for the last register stage on the output data path.                                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | web            | Input     | WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B | *      | Active-high | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Write enable vector for port B input data port dinb. 1 bit wide when word-wide writes are used.                     |
-- | In byte-wide write configurations, each bit controls the writing one byte of dinb to address addrb.                 |
-- | For example, to synchronously write only bits [15:8] of dinb when WRITE_DATA_WIDTH_B is 32, web would be "0010".    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addrb          | Input     | ADDR_WIDTH_B                          | *      |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port B write and read operations.                                                                       |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dinb           | Input     | WRITE_DATA_WIDTH_B                    | *      |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data input for port B write operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectsbiterrb | Input     | 1                                     | *      | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |
-- | "decode_only" mode).                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectdbiterrb | Input     | 1                                     | *      | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |
-- | "decode_only" mode).                                                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | doutb          | Output   | READ_DATA_WIDTH_B                      | *      |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data output for port B read operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sbiterrb       | Output   | 1                                      | *      | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Status signal to indicate single bit error occurrence on the data output of port B.                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dbiterrb       | Output   | 1                                      | *      | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Status signal to indicate double bit error occurrence on the data output of port B.                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | * clka when generic CLOCKING_MODE is "common_clock". clkb when generic CLOCKING_MODE is "independent_clock".        |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Set generic values and connect ports to instantiate an XPM_MEMORY true dual port RAM configuration

--   xpm_memory_tdpram  : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_memory_tdpram_inst)
--      declaration     : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

--  Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_memory_tdpram: True Dual Port RAM
-- Xilinx Parameterized Macro, Version 2016.4
xpm_memory_tdpram_inst : xpm_memory_tdpram
  generic map (

    -- Common module generics
    MEMORY_SIZE        =&gt; 2048,        --positive integer
    MEMORY_PRIMITIVE   =&gt; "auto",      --string; "auto", "distributed", "block" or "ultra" ;
    CLOCKING_MODE      =&gt; "common_clock",--string; "common_clock", "independent_clock" 
    MEMORY_INIT_FILE   =&gt; "none",      --string; "none" or "&lt;filename&gt;.mem" 
    MEMORY_INIT_PARAM  =&gt; "",          --string;
    USE_MEM_INIT       =&gt; 1,           --integer; 0,1
    WAKEUP_TIME        =&gt; "disable_sleep",--string; "disable_sleep" or "use_sleep_pin" 
    MESSAGE_CONTROL    =&gt; 0,           --integer;
    ECC_MODE           =&gt; "no_ecc",    --string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
    AUTO_SLEEP_TIME    =&gt; 0,           --Do not Change

    -- Port A module generics
    WRITE_DATA_WIDTH_A =&gt; 32,          --positive integer
    READ_DATA_WIDTH_A  =&gt; 32,          --positive integer
    BYTE_WRITE_WIDTH_A =&gt; 32,          --integer; 8, 9, or WRITE_DATA_WIDTH_A value
    ADDR_WIDTH_A       =&gt; 6,           --positive integer
    READ_RESET_VALUE_A =&gt; "0",         --string
    READ_LATENCY_A     =&gt; 2,           --non-negative integer
    WRITE_MODE_A       =&gt; "no_change", --string; "write_first", "read_first", "no_change" 

    -- Port B module generics
    WRITE_DATA_WIDTH_B =&gt; 32,          --positive integer
    READ_DATA_WIDTH_B  =&gt; 32,          --positive integer
    BYTE_WRITE_WIDTH_B =&gt; 32,          --integer; 8, 9, or WRITE_DATA_WIDTH_B value
    ADDR_WIDTH_B       =&gt; 6,           --positive integer
    READ_RESET_VALUE_B =&gt; "0",         --string
    READ_LATENCY_B     =&gt; 2,           --non-negative integer
    WRITE_MODE_B       =&gt; "no_change"  --string; "write_first", "read_first", "no_change" 
  )
  port map (

    -- Common module ports
    sleep          =&gt; '0',

    -- Port A module ports
    clka           =&gt; clka,
    rsta           =&gt; rsta,
    ena            =&gt; ena,
    regcea         =&gt; regcea,
    wea            =&gt; wea,
    addra          =&gt; addra,
    dina           =&gt; dina,
    injectsbiterra =&gt; '0',
    injectdbiterra =&gt; '0',
    douta          =&gt; douta,
    sbiterra       =&gt; open,
    dbiterra       =&gt; open,

    -- Port B module ports
    clkb           =&gt; clkb,
    rstb           =&gt; rstb,
    enb            =&gt; enb,
    regceb         =&gt; regceb,
    web            =&gt; web,
    addrb          =&gt; addrb,
    dinb           =&gt; dinb,
    injectsbiterrb =&gt; '0',
    injectdbiterrb =&gt; '0',
    doutb          =&gt; doutb,
    sbiterrb       =&gt; open,
    dbiterrb       =&gt; open
  );

-- End of xpm_memory_tdpram_inst instance declaration

				</Template>
			</SubFolder>
			<SubFolder label="ROM" treetype="folder">
				<Template label="Dual Port ROM" treetype="template">
-- XPM_MEMORY instantiation template for dual port ROM configurations
-- Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_SIZE          | Integer            | Must be integer multiple of READ_DATA_WIDTH_[A|B]                       |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the total memory array size, in bits.                                                                       |
-- | For example, enter 65536 for a 2kx32 ROM.                                                                           |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", or "block"                               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the memory primitive (resource type) to use:                                                              |
-- |   "auto": Allow Vivado Synthesis to choose                                                                          |
-- |   "distributed": Distributed memory                                                                                 |
-- |   "block": Block memory                                                                                             |
-- |   "ultra": Ultra RAM memory                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | CLOCKING_MODE        | String            | Must be "common_clock" or "independent_clock"                            |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate whether port A and port B are clocked with a common clock or with independent clocks:                     |
-- |   "common_clock": Common clocking; clock both port A and port B with clka                                           |
-- |   "independent_clock": Independent clocking; clock port A with clka and port B with clkb                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
-- |   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
-- |   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
-- |   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
-- |   information on the syntax. Initialization of memory happens through the file name specified only when generic     |
-- |   MEMORY_INIT_PARAM value is equal to "".                                                                           |
-- |   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_PARAM    | String             | Must be exactly "" or the string of hex characters (in quotes)          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
-- | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
-- | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
-- | narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
-- | memory is 8 locations, then the parameter value should be passed as shown below.                                    |
-- |   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
-- |                                  |                   |                                                              |
-- |                                  0th                7th                                                             |
-- |                                location            location                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | USE_MEM_INIT         | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
-- | Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
-- | Parameter.                                                                                                          |
-- |    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
-- |    Initial memory contents will be all 0's                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WAKEUP_TIME          | String             | Must be "disable_sleep" or "use_sleep_pin"                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
-- | dynamic power saving option                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ECC_MODE             | String              | Must be "no_ecc".                                                      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify ECC mode on all ports of the memory primitive(ECC with initialization is not currently supported)           |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | AUTO_SLEEP_TIME      | Integer             | Must be 0 or 3-15                                                      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Must be set to 0                                                                                                    |
-- |   0 : Disable auto-sleep feature                                                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0                                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A read data output port douta, in bits.                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/READ_DATA_WIDTH_A)               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A address port addra, in bits.                                                        |
-- | Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A).        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_RESET_VALUE_A   | String             |                                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
-- | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
-- | If the read data width is 8, then specify READ_RESET_VALUE_A = "EA";                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_LATENCY_A       | Integer            | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
-- | number of clka cycles.                                                                                              |
-- | To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
-- | output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
-- | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH_B    | Integer            | Must be &gt; 0                                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port B read data output port doutb, in bits.                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_B         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/READ_DATA_WIDTH_B)               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port B address port addrb, in bits.                                                        |
-- | Must be large enough to access the entire memory from port B, i.e. &gt;= $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B).        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_RESET_VALUE_B   | String             |                                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |
-- | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
-- | If the read data width is 8, then specify READ_RESET_VALUE_B = "EA";                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_LATENCY_B       | Integer            | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |
-- | number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |
-- | To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
-- | output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
-- | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sleep          | Input     | 1                                     |        | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | sleep signal to enable the dynamic power saving feature.                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clka           | Input     | 1                                     |        | Rising edge | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port A. Also clocks port B when generic CLOCKING_MODE is 0.                                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rsta           | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset signal for the final port A output register stage.                                                            |
-- | Synchronously resets output port douta to the value specified by generic READ_RESET_VALUE_A.                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ena            | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port A.                                                                                    |
-- | Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | regcea         | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock Enable for the last register stage on the output data path.                                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port A read operations.                                                                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Do not change from the provided value.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Do not change from the provided value.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data output for port A read operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Leave open.                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Leave open.                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clkb           | Input     | 1                                     |        | Rising edge | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port B when generic CLOCKING_MODE is "independent_clock".                                          |
-- | Unused when generic CLOCKING_MODE is "common_clock".                                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rstb           | Input     | 1                                     | *      | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset signal for the final port B output register stage.                                                            |
-- | Synchronously resets output port doutb to the value specified by generic READ_RESET_VALUE_B.                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | enb            | Input     | 1                                     | *      | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port B.                                                                                    |
-- | Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | regceb         | Input     | 1                                     | *      | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock Enable for the last register stage on the output data path.                                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addrb          | Input     | ADDR_WIDTH_B                          | *      |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port B read operations.                                                                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectsbiterrb | Input     | 1                                     | *      | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Do not change from the provided value.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectdbiterrb | Input     | 1                                     | *      | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Do not change from the provided value.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | doutb          | Output   | READ_DATA_WIDTH_B                      | *      |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data output for port B read operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sbiterrb       | Output   | 1                                      | *      | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Leave open.                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dbiterrb       | Output   | 1                                      | *      | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Leave open.                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | * clka when generic CLOCKING_MODE is "common_clock". clkb when generic CLOCKING_MODE is "independent_clock".        |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Set generic values and connect ports to instantiate an XPM_MEMORY dual port ROM configuration

--   xpm_memory_dprom   : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_memory_dprom_inst)
--      declaration     : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

--  Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_memory_dprom: Dual Port ROM
-- Xilinx Parameterized Macro, Version 2016.4
xpm_memory_dprom_inst : xpm_memory_dprom
  generic map (

    -- Common module generics
    MEMORY_SIZE        =&gt; 2048,        --positive integer
    MEMORY_PRIMITIVE   =&gt; "auto",      --string; "auto", "distributed", or "block";
    CLOCKING_MODE      =&gt; "common_clock",--string; "common_clock", "independent_clock" 
    MEMORY_INIT_FILE   =&gt; "none",      --string; "none" or "&lt;filename&gt;.mem" 
    MEMORY_INIT_PARAM  =&gt; "",          --string;
    USE_MEM_INIT       =&gt; 1,           --integer; 0,1
    WAKEUP_TIME        =&gt; "disable_sleep",--string; "disable_sleep" or "use_sleep_pin" 
    MESSAGE_CONTROL    =&gt; 0,           --integer; 0,1
    ECC_MODE           =&gt; "no_ecc",    --string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
    AUTO_SLEEP_TIME    =&gt; 0,           --Do not Change

    -- Port A module generics
    READ_DATA_WIDTH_A  =&gt; 32,          --positive integer
    ADDR_WIDTH_A       =&gt; 6,           --positive integer
    READ_RESET_VALUE_A =&gt; "0",         --string
    READ_LATENCY_A     =&gt; 2,           --non-negative integer

    -- Port B module generics
    READ_DATA_WIDTH_B  =&gt; 32,          --positive integer
    ADDR_WIDTH_B       =&gt; 6,           --positive integer
    READ_RESET_VALUE_B =&gt; "0",         --string
    READ_LATENCY_B     =&gt; 2            --non-negative integer
  )
  port map (

    -- Common module ports
    sleep          =&gt; '0',

    -- Port A module ports
    clka           =&gt; clka,
    rsta           =&gt; rsta,
    ena            =&gt; ena,
    regcea         =&gt; regcea,
    addra          =&gt; addra,
    injectsbiterra =&gt; '0',
    injectdbiterra =&gt; '0',
    douta          =&gt; douta,
    sbiterra       =&gt; open,
    dbiterra       =&gt; open,

    -- Port B module ports
    clkb           =&gt; clkb,
    rstb           =&gt; rstb,
    enb            =&gt; enb,
    regceb         =&gt; regceb,
    addrb          =&gt; addrb,
    injectsbiterrb =&gt; '0',
    injectdbiterrb =&gt; '0',
    doutb          =&gt; doutb,
    sbiterrb       =&gt; open,
    dbiterrb       =&gt; open
  );

-- End of xpm_memory_dprom_inst instance declaration

				</Template>
				<Template label="Single Port ROM" treetype="template">
-- XPM_MEMORY instantiation template for single port ROM configurations
-- Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
-- =======================================================================================================================
--
-- Generic usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Generic name         | Data type          | Restrictions, if applicable                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_SIZE          | Integer            | Must be integer multiple of READ_DATA_WIDTH_A                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the total memory array size, in bits.                                                                       |
-- | For example, enter 65536 for a 2kx32 ROM.                                                                           |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", or "block"                               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Designate the memory primitive (resource type) to use:                                                              |
-- |   "auto": Allow Vivado Synthesis to choose                                                                          |
-- |   "distributed": Distributed memory                                                                                 |
-- |   "block": Block memory                                                                                             |
-- |   "ultra": Ultra RAM memory                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
-- |   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
-- |   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
-- |   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
-- |   information on the syntax. Initialization of memory happens through the file name specified only when generic     |
-- |   MEMORY_INIT_PARAM value is equal to "".                                                                           |
-- |   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MEMORY_INIT_PARAM    | String             | Must be exactly "" or the string of hex characters (in quotes)          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
-- | containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
-- | Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
-- | narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
-- | memory is 8 locations, then the parameter value should be passed as shown below.                                    |
-- |   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
-- |                                  |                   |                                                              |
-- |                                  0th                7th                                                             |
-- |                                location            location                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | USE_MEM_INIT         | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
-- | Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
-- | Parameter.                                                                                                          |
-- |    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
-- |    Initial memory contents will be all 0's                                                                          |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | WAKEUP_TIME          | String             | Must be "disable_sleep" or "use_sleep_pin"                              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
-- | dynamic power saving option                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ECC_MODE             | String              | Must be "no_ecc", "encode_only", "decode_only"                         |
-- |                                            | or "both_encode_and_decode".                                           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify ECC mode on all ports of the memory primitive(ECC with initialization is not currently supported)           |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | AUTO_SLEEP_TIME      | Integer             | Must be 0 or 3-15                                                      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Must be set to 0                                                                                                    |
-- |   0 : Disable auto-sleep feature                                                                                    |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0                                                             |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A read data output port douta, in bits.                                               |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/READ_DATA_WIDTH_A)               |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the width of the port A address port addra, in bits.                                                        |
-- | Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A).        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_RESET_VALUE_A   | String             |                                                                         |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
-- | As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
-- | If the read data width is 8, then specify READ_RESET_VALUE_A = "EA";                                                |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | READ_LATENCY_A       | Integer            | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory           |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
-- | number of clka cycles.                                                                                              |
-- | To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
-- | output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
-- | Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Port usage table, organized as follows:
-- +---------------------------------------------------------------------------------------------------------------------+
-- | Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Description                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sleep          | Input     | 1                                     |        | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | sleep signal to enable the dynamic power saving feature.                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | clka           | Input     | 1                                     |        | Rising edge | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock signal for port A.                                                                                            |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | rsta           | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Reset signal for the final port A output register stage.                                                            |
-- | Synchronously resets output port douta to the value specified by generic READ_RESET_VALUE_A.                        |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | ena            | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Memory enable signal for port A.                                                                                    |
-- | Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | regcea         | Input     | 1                                     | clka   | Active-high | Tie to '1'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Clock Enable for the last register stage on the output data path.                                                   |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Address for port A read operations.                                                                                 |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Do not change from the provided value.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to '0'              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Do not change from the provided value.                                                                              |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Data output for port A read operations.                                                                             |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | sbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Leave open.                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
-- | dbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
-- |---------------------------------------------------------------------------------------------------------------------|
-- | Leave open.                                                                                                         |
-- +---------------------------------------------------------------------------------------------------------------------+
--
-- Set generic values and connect ports to instantiate an XPM_MEMORY single port ROM configuration

--   xpm_memory_sprom   : In order to incorporate this function into the design, the following instance declaration
--         VHDL         : needs to be placed in the architecture body of the design code.  The default values for the
--       instance       : generics may be changed to meet design requirements.  The instance name (xpm_memory_sprom_inst)
--      declaration     : and/or the port declarations after the "=&gt;" declaration may be changed to properly reference
--         code         : and connect this function to the design.  All inputs and outputs must be connected.

--         Library      :
--       declaration    : In addition to adding the instance declaration, a use statement for the XPM.vcomponents
--           for        : library needs to be added before the entity declaration.  This library contains the
--         Xilinx       : component declarations for all Xilinx XPMs.
--          XPMs        :

--  Copy the following two statements and paste them before the Entity declaration, unless they already exist.

Library xpm;
use xpm.vcomponents.all;

-- &lt;--Cut the following instance declaration and paste it into the architecture statement part of the design--&gt;

-- xpm_memory_sprom: Single Port ROM
-- Xilinx Parameterized Macro, Version 2016.4
xpm_memory_sprom_inst : xpm_memory_sprom
  generic map (

    -- Common module generics
    MEMORY_SIZE        =&gt; 2048,        --positive integer
    MEMORY_PRIMITIVE   =&gt; "auto",      --string; "auto", "distributed", or "block";
    MEMORY_INIT_FILE   =&gt; "none",      --string; "none" or "&lt;filename&gt;.mem" 
    MEMORY_INIT_PARAM  =&gt; "",          --string;
    USE_MEM_INIT       =&gt; 1,           --integer; 0,1
    WAKEUP_TIME        =&gt; "disable_sleep",--string; "disable_sleep" or "use_sleep_pin" 
    MESSAGE_CONTROL    =&gt; 0,           --integer; 0,1
    ECC_MODE           =&gt; "no_ecc",    --string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
    AUTO_SLEEP_TIME    =&gt; 0,           --Do not Change

    -- Port A module generics
    READ_DATA_WIDTH_A  =&gt; 32,          --positive integer
    ADDR_WIDTH_A       =&gt; 6,           --positive integer
    READ_RESET_VALUE_A =&gt; "0",         --string
    READ_LATENCY_A     =&gt; 2            --non-negative integer
  )
  port map (

    -- Common module ports
    sleep          =&gt; '0',

    -- Port A module ports
    clka           =&gt; clka,
    rsta           =&gt; rsta,
    ena            =&gt; ena,
    regcea         =&gt; regcea,
    addra          =&gt; addra,
    injectsbiterra =&gt; '0',   --do not change
    injectdbiterra =&gt; '0',   --do not change
    douta          =&gt; douta,
    sbiterra       =&gt; open,  --do not change
    dbiterra       =&gt; open   --do not change
  );

-- End of xpm_memory_sprom_inst instance declaration

				</Template>
			</SubFolder>
		</SubFolder>
	</Folder>
	<Folder label="User Templates" language="VHDL" treetype="folder" utallowed="true">
	</Folder>
</RootFolder>
