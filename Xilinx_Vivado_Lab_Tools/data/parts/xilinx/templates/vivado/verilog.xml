<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="template.xsl"?>
<RootFolder label="Verilog" treetype="folder" language="Verilog">
	<Folder label="Common Constructs" treetype="folder">
		<SubFolder label="Comments" treetype="folder">
			<Template label="Multiple Lines (/*---*/)" treetype="template">
/* Comment here
   Comment here
   Comment here */
			</Template>
			<Template label="Sample File Header" treetype="template">
////////////////////////////////////////////////////////////////////////////////
// Company: &lt;Company Name&gt;
// Engineer: &lt;Engineer Name&gt;
//
// Create Date: &lt;date&gt;
// Design Name: &lt;name_of_top-level_design&gt;
// Module Name: &lt;name_of_this_module&gt;
// Target Device: &lt;target device&gt;
// Tool versions: &lt;tool_versions&gt;
// Description:
//    &lt;Description here&gt;
// Dependencies:
//    &lt;Dependencies here&gt;
// Revision:
//    &lt;Code_revision_information&gt;
// Additional Comments:
//    &lt;Additional_comments&gt;
////////////////////////////////////////////////////////////////////////////////
			</Template>
			<Template label="Single Line (//)" treetype="template">
// Comment here
			</Template>
		</SubFolder>
		<SubFolder label="Compiler directives" treetype="folder">
			<SubFolder label="Define" treetype="folder">
				<Template label="`define" treetype="template">
`define &lt;name&gt; &lt;string&gt;
				</Template>
				<Template label="`ifdef &amp; `elsif &amp; `else" treetype="template">
`ifdef &lt;define_name&gt;
   &lt;statements&gt;;
`elsif &lt;define_name&gt;
   &lt;statements&gt;;
`else
   &lt;statements&gt;;
`endif
				</Template>
				<Template label="`ifndef" treetype="template">
`ifndef &lt;define_name&gt;
   &lt;statements&gt;;
`endif
				</Template>
				<Template label="Info (`define)" treetype="template">
// The `define, `ifdef, `elsif, `else, `ifndef and the `endif compiler directives
// ==============================================================================
//
// `define is a compiler directive that defines a value to a variable. That variable
// can then be called upon in the code by referencing the `name of the specified variable.
//
// `ifdef is a compiler directive that checks for the existence of a specified `define
// and then conditionally includes a section of code during compilation if it exists.
//
// `ifndef is the opposite of `ifdef in that if a `define was not declared, it includes
// a section of code.
//
// `elsif can be used in conjunction with a `ifdef to find the existence of another
// `define and conditionally compile a different section of code if the previous
// conditions were not met and this condition is met.
//
// `else also can be used in conjunction with a `ifdef where it will compile a section
// of code if all previous `ifdef and `elsif conditions were not met.
//
// `endif is used at the end of a `ifdef or `ifndef statement to signify the end of
// the included code.
//
// Example:

`define DATA_WIDTH 16
`define DATA_WIDTH16

reg [`DATA_WIDTH-1:0] data;

`ifdef DATA_WIDTH8
   // If DATA_WIDTH8 was set, this would get compiled
`elsif DATA_WIDTH16
   // Since DATA_WIDTH16 is set, this does get compiled
`else
   // If DATA_WIDTH8 and DATA_WIDTH16 was not defined, this would be compiled
`endif
				</Template>
			</SubFolder>
			<SubFolder label="`include" treetype="folder">
				<Template label="`include" treetype="template">
`include  "&lt;file_name&gt;" 
				</Template>
				<Template label="Info (`include)" treetype="template">
// The `include complier directive
// ===============================
//
// `include can be used to insert the contents of a separate file into a module.
// This is often used to communicate common functions, compiler directives, parameters
// and `defines to multiple files in a project.  The file and path name must be
// specified in quotes and can consist of just the file name (looks in the current
// working directory for the file), a relative path to the file or an absolute path
// to the file.  This directive can be specified both before the module declaration
// as well as within the module directive.
//
// Example:

// Include the contents of the parameters.vh file located in the current working directory.
// Many simulator and synthesis tools also offer a switch/option to allow specification
// of a search directory other than the working directory for files specified in this manner.
`include "parameters.vh" 

// Include the contents of the ram_data.vh file in the relative directory ../data
`include "../data/ram_data.vh" 

// Include the contents of master.vh in the absolute directory /export/vol1/sim_data
`include "/export/vol1/sim_data/master.vh" 

				</Template>
			</SubFolder>
			<SubFolder label="`timescale" treetype="folder">
				<Template label="1ns / 1ns" treetype="template">
`timescale 1 ns / 1 ns
				</Template>
				<Template label="1ns / 1ps" treetype="template">
`timescale 1 ns / 1 ps
				</Template>
				<Template label="1ns / 10ps" treetype="template">
`timescale 1 ns / 10 ps
				</Template>
				<Template label="1ns / 100ps" treetype="template">
`timescale 1 ns / 100 ps
				</Template>
				<Template label="1ps / 1ps" treetype="template">
`timescale 1 ps / 1 ps
				</Template>
				<Template label="100ps / 1ps" treetype="template">
`timescale 100 ps / 1 ps
				</Template>
				<Template label="Info (`timescale)" treetype="template">
// The `timescale compile directive information
// ============================================
//
// `timescale is a compiler directive that indicates to the simulator the time units
// and precision to be used during simulation.  The format is the following:
//
// `timescale &lt;units&gt; / &lt;precision&gt;
//
// The units should be set to the base value in which time will be communicated to
// the simulator for that module.
// The precision is the minimum time units you wish the simulator to resolve. The
// smallest resolution value in all files and models compiled for simulation dictates
// the overall simulation resolution. In general for Xilinx FPGAs, a simulator
// resolution of 1ps is recommended since some components like the DCM require this
// resolution for proper operation and 1 ps is the resolution used for timing simulation.
//
// In general, this directive should appear at the top of the testbench, simulation models
// and all design files for a Verilog project.
//
// Example:

`timescale 1 ns / 1ps

#1;           // Delays for 1 ns
#1.111;       // Delays for 1111 ps
#1.111111111; // Delays for 1111 ps since the resolution is more course than
              //    what is specified, the delay amount is truncated
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Operators" treetype="folder">
			<Template label="Arithmetic" treetype="template">
// The following are the arithmetic operators as defined by the Verilog language.
//
//    + .... Addition
//    - .... Subtraction
//    * .... Multiplication
//    / .... Divide
//    % .... Modulus
//    ** ... Power Operator (i.e. 2**8 returns 256)
			</Template>
			<Template label="Bitwise" treetype="template">
// The following operators can be used on two single bits to produce a single bit
// output or two equivalent sized bused signals where the operations are performed
// on each bit of the bus. In the case of the Invert, only one signal or bus is
// provided and the operation occurs on each bit of the signal.
//
//    ~ .... Invert a single-bit signal or each bit in a bus
//    &amp; .... AND two single bits or each bit between two buses
//    | .... OR two single bits or each bit between two buses
//    ^ .... XOR two single bits or each bit between two buses
//    ~^ ... XNOR two single bits or each bit between two buses
			</Template>
			<Template label="Logical" treetype="template">
// The following logical operators are used in conditional TRUE/FALSE statements
// such as an if statement in order to specify the condition for the operation.
//
//    ! .... Not True
//    &amp;&amp; ... Both Inputs True
//    || ... Either Input True
//    == ... Inputs Equal
//    === .. Inputs Equal including X and Z (simulation only)
//    != ... Inputs Not Equal
//    !== .. Inputs Not Equal including X and Z (simulation only)
//    &lt; .... Less-than
//    &lt;= ... Less-than or Equal
//    &gt; .... Greater-than
//    &gt;= ... Greater-than or Equal
			</Template>
			<Template label="Replicate/Concatenate" treetype="template">
// The following operators either concatenates several bits into a bus or replicate
// a bit or combination of bits multiple times.
//
//    {a, b, c} .... Concatenate a, b and c into a bus
//    {3{a}} ....... Replicate a, 3 times
//    {{5{a}}, b} .. Replicate a, 5 times and concatenate to b
//
			</Template>
			<Template label="Shift" treetype="template">
// The following operators will shift a bus right or left a number of bits.
//
//    &lt;&lt; .... Left shift (i.e. a &lt;&lt; 2 shifts a two bits to the left)
//    &lt;&lt;&lt; ... Left shift and fill with zeroes
//    &gt;&gt; .... Right shift (i.e. b &gt;&gt; 1 shifts b one bits to the right)
//    &gt;&gt;&gt; ... Right shift and maintain sign bit
			</Template>
			<Template label="Unary Reduction" treetype="template">
// The following operators can be used on a bussed signal where all bits in the bus
// are used to perform the operation and a single bit output is resolved.
//
//    &amp; .... AND all bits together to make single bit output
//    ~&amp; ... NAND all bits together to make single bit output
//    | .... OR all bits together to make single bit output
//    ~| ... NOR all bits together to make single bit output
//    ^ .... XOR all bits together to make single bit output
//    ~^ ... XNOR all bits together to make single bit output
			</Template>
		</SubFolder>
		<SubFolder label="User Defined Functions &amp; Tasks" treetype="folder">
			<Template label="Calling a Function" treetype="template">
   &lt;signal&gt; = &lt;function_name&gt;(&lt;comma_separated _inputs&gt;);
			</Template>
			<Template label="Calling a Task" treetype="template">
   &lt;task_name&gt;(&lt;comma_separated _inputs&gt;, &lt;comma_separated _outputs&gt;);
			</Template>
			<Template label="Function Declaration" treetype="template">
   function  [&lt;lower&gt;:&lt;upper&gt;] &lt;output_name&gt; ;
      input &lt;name&gt;;
      begin
         &lt;statements&gt;
      end
   endfunction
			</Template>
			<Template label="Info (Functions and Tasks)" treetype="template">
// User defined function and task information
// ==========================================
//
// A user defined function is a set of Verilog statements that
// can be called from elsewhere within the body of the code by
// an assignment.  A function can have multiple inputs however
// can return only a single output.  No timing information can
// be specified within a function.
//
// A user defined task is a subroutine that can be executed by
// a single call from elsewhere within the body of the code.
// A task can have any number of inputs, outputs and inouts as
// well as contain timing information.
//
// Example of a function declaration:

   function  [9:0] gray_encode;
      input [9:0] binary_input;
      begin
         gray_encode[9] = binary_input[9];
         for (k=8; k&gt;=0; k=k-1) begin
            gray_encode[k] = binary_input[k+1] ^ binary_input[k];
         end
      end
   endfunction

// Example of calling a function:

   // write_count is the binary input being passed to the function gray_encode.
   // The output of the function gray_encode is then passed to the signal FIFO_ADDR
   FIFO_ADDR = gray_encode(write_count);

// Example of a task declaration:

   task error_action;
      input read_write;
      input correct_value;
      input actual_value;
      input [8*11:0] output_string;
      begin
         if (ERROR_CHECK) begin
            if (read_write)
               $display("Error: %s value incorrect during write %d at time %t\nExpecting %b, got %b",
                         output_string, write_attempt, $realtime, correct_value, actual_value);
            else
               $display("Error: %s value incorrect during read %d at time %t\nExpecting %b, got %b",
                         output_string, read_attempt, $realtime, correct_value, actual_value);
            if (ON_ERROR=="FINISH")
               $finish;
            else if (ON_ERROR=="STOP")
               $stop;
         end
      end
      endtask

// Example of calling a task:

   // The task error_action is called by name and passed the four input values
   //    in the order they are declared in the task
   error_action(1'b1, wr_ready_value, WR_READY, "WR_READY");
			</Template>
			<Template label="Task Declaration" treetype="template">
   // A task is a subroutine with any number of input, output or inout
   // arguments and may contain timing controls

   task &lt;task_name&gt;;
      input &lt;input_name&gt;;
      &lt;more_inputs&gt;

      output &lt;output_name&gt;;
      &lt;more_outputs&gt;

      begin
         &lt;statements&gt;;
      end
   endtask
			</Template>
		</SubFolder>
	</Folder>
	<Folder label="Device Macro Instantiation" treetype="folder">
		<SubFolder label="Artix-7" treetype="folder">
			<SubFolder label="DSP48" treetype="folder">
				<Template label="Add / Multiply Accumulate (ADDMACC_MACRO)" treetype="template">
//   ADDMACC_MACRO  : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (ADDMACC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ADDMACC_MACRO: Variable width &amp; latency - Pre-Add -&gt; Multiplier -&gt; Accumulate
   //                function implemented in a DSP48E
   //                Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   ADDMACC_MACRO #(
      .DEVICE("7SERIES"),    // Target Device: "7SERIES" 
      .LATENCY(4),           // Desired clock cycle latency, 0-4
      .WIDTH_PREADD(25),     // Pre-adder input width, 1-25
      .WIDTH_MULTIPLIER(18), // Multiplier input width, 1-18
      .WIDTH_PRODUCT(48)     // MACC output width, 1-48
   ) ADDMACC_MACRO_inst (
      .PRODUCT(PRODUCT),   // MACC result output, width defined by WIDTH_PRODUCT parameter
      .CARRYIN(CARRYIN),   // 1-bit carry-in input
      .CLK(CLK),           // 1-bit clock input
      .CE(CE),             // 1-bit clock enable input
      .LOAD(LOAD),         // 1-bit accumulator load input
      .LOAD_DATA(LOAD_DATA),   // Accumulator load data input, width defined by WIDTH_PRODUCT parameter
      .MULTIPLIER(MULTIPLIER), // Multiplier data input, width defined by WIDTH_MULTIPLIER parameter
      .PREADD2(PREADD2),   // Preadder data input, width defined by WIDTH_PREADD parameter
      .PREADD1(PREADD1),   // Preadder data input, width defined by WIDTH_PREADD parameter
      .RST(RST)            // 1-bit active high synchronous reset
   );
   
   // End of ADDMACC_MACRO_inst instantiation
				</Template>
				<Template label="Add / Subtract (ADDSUB_MACRO)" treetype="template">
//   ADDSUB_MACRO   : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (ADDSUB_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ADDSUB_MACRO: Variable width &amp; latency - Adder / Subtracter implemented in a DSP48E
   //               Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   ADDSUB_MACRO #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .LATENCY(2),        // Desired clock cycle latency, 0-2
      .WIDTH(48)          // Input / output bus width, 1-48
   ) ADDSUB_MACRO_inst (
      .CARRYOUT(CARRYOUT), // 1-bit carry-out output signal
      .RESULT(RESULT),     // Add/sub result output, width defined by WIDTH parameter
      .A(A),               // Input A bus, width defined by WIDTH parameter
      .ADD_SUB(ADD_SUB),   // 1-bit add/sub input, high selects add, low selects subtract
      .B(B),               // Input B bus, width defined by WIDTH parameter
      .CARRYIN(CARRYIN),   // 1-bit carry-in input
      .CE(CE),             // 1-bit clock enable input
      .CLK(CLK),           // 1-bit clock input
      .RST(RST)            // 1-bit active high synchronous reset
   );
   
   // End of ADDSUB_MACRO_inst instantiation
				</Template>
				<Template label="Counter w/ Terminal Count (COUNTER_TC_MACRO)" treetype="template">
// COUNTER_TC_MACRO : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (COUNTER_TC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // COUNTER_TC_MACRO: Counter with terminal count implemented in a DSP48E
   //                   Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   COUNTER_TC_MACRO #(
      .COUNT_BY(48'h000000000001), // Count by value
      .DEVICE("7SERIES"),          // Target Device: "7SERIES" 
      .DIRECTION("UP"),            // Counter direction, "UP" or "DOWN" 
      .RESET_UPON_TC("FALSE"), // Reset counter upon terminal count, "TRUE" or "FALSE" 
      .TC_VALUE(48'h000000000000), // Terminal count value
      .WIDTH_DATA(48)              // Counter output bus width, 1-48
   ) COUNTER_TC_MACRO_inst (
      .Q(Q),     // Counter output bus, width determined by WIDTH_DATA parameter 
      .TC(TC),   // 1-bit terminal count output, high = terminal count is reached
      .CLK(CLK), // 1-bit positive edge clock input
      .CE(CE),   // 1-bit active high clock enable input
      .RST(RST)  // 1-bit active high synchronous reset
   );
   
   // End of COUNTER_TC_MACRO_inst instantiation
				</Template>
				<Template label="Equality Comparator (EQ_COMPARE_MACRO)" treetype="template">
// EQ_COMPARE_MACRO : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (EQ_COMPARE_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EQ_COMPARE_MACRO: Equality Comparator implemented in a DSP48E
   //                   Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   EQ_COMPARE_MACRO #(
      .DEVICE("7SERIES"),       // Target Device: "7SERIES" 
      .LATENCY(2),              // Desired clock cycle latency, 0-2
      .MASK(48'h000000000000),  // Select bits to be masked, must set SEL_MASK="MASK" 
      .SEL_MASK("MASK"),        // "MASK" = use MASK parameter,
                                //   "DYNAMIC_PATTERN" = use DYNAMIC_PATTERN input bus
      .SEL_PATTERN("STATIC_PATTERN"), // "STATIC_PATTERN" = use STATIC_PATTERN parameter,
                                      //   "DYNAMIC_PATTERN = use DYNAMIC_PATTERN input bus
      .STATIC_PATTERN(48'h000000000000), // Specify static pattern, must set SEL_PATTERN = "STATIC_PATTERN" 
      .WIDTH(48)                // Comparator output bus width, 1-48
   ) EQ_COMPARE_MACRO_inst (
      .Q(Q),     // 1-bit output indicating a match
      .CE(CE),   // 1-bit active high input clock enable
      .CLK(CLK), // 1-bit positive edge clock input
      .DATA_IN(DATA_IN), // Input Data Bus, width determined by WIDTH parameter 
      .DYNAMIC_PATTERN(DYNAMIC_PATTERN), // Input Dynamic Match/Mask Bus, width determined by WIDTH parameter 
      .RST(RST)  // 1-bit input active high reset
   );
   
   // End of EQ_COMPARE_MACRO_inst instantiation
				</Template>
				<Template label="Loadable Counter (COUNTER_LOAD_MACRO)" treetype="template">
// COUNTER_LOAD_MACRO : In order to incorporate this function into the design,
//     Verilog        : the following instance declaration needs to be placed
//    instance        : in the body of the design code.  The instance name
//   declaration      : (COUNTER_LOAD_MACRO_inst) and/or the port declarations within the
//      code          : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // COUNTER_LOAD_MACRO: Loadable variable counter implemented in a DSP48E
   //                     Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   COUNTER_LOAD_MACRO #(
      .COUNT_BY(48'h000000000001), // Count by value
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .WIDTH_DATA(48)     // Counter output bus width, 1-48
   ) COUNTER_LOAD_MACRO_inst (
      .Q(Q),                 // Counter output, width determined by WIDTH_DATA parameter 
      .CLK(CLK),             // 1-bit clock input
      .CE(CE),               // 1-bit clock enable input
      .DIRECTION(DIRECTION), // 1-bit up/down count direction input, high is count up
      .LOAD(LOAD),           // 1-bit active high load input
      .LOAD_DATA(LOAD_DATA), // Counter load data, width determined by WIDTH_DATA parameter 
      .RST(RST)              // 1-bit active high synchronous reset
   );
   
   // End of COUNTER_LOAD_MACRO_inst instantiation
				</Template>
				<Template label="Multiplier (MULT_MACRO)" treetype="template">
//   MULT_MACRO     : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (MULT_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MULT_MACRO: Multiply Function implemented in a DSP48E
   //             Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   MULT_MACRO #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .LATENCY(3),        // Desired clock cycle latency, 0-4
      .WIDTH_A(18),       // Multiplier A-input bus width, 1-25
      .WIDTH_B(18)        // Multiplier B-input bus width, 1-18
   ) MULT_MACRO_inst (
      .P(P),     // Multiplier output bus, width determined by WIDTH_P parameter 
      .A(A),     // Multiplier input A bus, width determined by WIDTH_A parameter 
      .B(B),     // Multiplier input B bus, width determined by WIDTH_B parameter 
      .CE(CE),   // 1-bit active high input clock enable
      .CLK(CLK), // 1-bit positive edge clock input
      .RST(RST)  // 1-bit input active high reset
   );
   
   // End of MULT_MACRO_inst instantiation
				</Template>
				<Template label="Multiply Accumulate (MACC_MACRO)" treetype="template">
//   MACC_MACRO     : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (MACC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MACC_MACRO: Multiply Accumulate Function implemented in a DSP48E
   //             Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   MACC_MACRO #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .LATENCY(3),        // Desired clock cycle latency, 1-4
      .WIDTH_A(25),       // Multiplier A-input bus width, 1-25
      .WIDTH_B(18),       // Multiplier B-input bus width, 1-18
      .WIDTH_P(48)        // Accumulator output bus width, 1-48
   ) MACC_MACRO_inst (
      .P(P),     // MACC output bus, width determined by WIDTH_P parameter 
      .A(A),     // MACC input A bus, width determined by WIDTH_A parameter 
      .ADDSUB(ADDSUB), // 1-bit add/sub input, high selects add, low selects subtract
      .B(B),     // MACC input B bus, width determined by WIDTH_B parameter 
      .CARRYIN(CARRYIN), // 1-bit carry-in input to accumulator
      .CE(CE),     // 1-bit active high input clock enable
      .CLK(CLK),   // 1-bit positive edge clock input
      .LOAD(LOAD), // 1-bit active high input load accumulator enable
      .LOAD_DATA(LOAD_DATA), // Load accumulator input data, width determined by WIDTH_P parameter
      .RST(RST)    // 1-bit input active high reset
   );
   
   // End of MACC_MACRO_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<Template label="Dual Clock FIFO (FIFO_DUALCLOCK_MACRO)" treetype="template">
// FIFO_DUALCLOCK_MACRO : In order to incorporate this function into the design,
//     Verilog          : the following instance declaration needs to be placed
//    instance          : in the body of the design code.  The instance name
//   declaration        : (FIFO_DUALCLOCK_MACRO_inst) and/or the port declarations within the
//      code            : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO_DUALCLOCK_MACRO: Dual Clock First-In, First-Out (FIFO) RAM Buffer
   //                       Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   /////////////////////////////////////////////////////////////////
   // DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width //
   // ===========|===========|============|=======================//
   //   37-72    |  "36Kb"   |     512    |         9-bit         //
   //   19-36    |  "36Kb"   |    1024    |        10-bit         //
   //   19-36    |  "18Kb"   |     512    |         9-bit         //
   //   10-18    |  "36Kb"   |    2048    |        11-bit         //
   //   10-18    |  "18Kb"   |    1024    |        10-bit         //
   //    5-9     |  "36Kb"   |    4096    |        12-bit         //
   //    5-9     |  "18Kb"   |    2048    |        11-bit         //
   //    1-4     |  "36Kb"   |    8192    |        13-bit         //
   //    1-4     |  "18Kb"   |    4096    |        12-bit         //
   /////////////////////////////////////////////////////////////////

   FIFO_DUALCLOCK_MACRO  #(
      .ALMOST_EMPTY_OFFSET(9'h080), // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(9'h080),  // Sets almost full threshold
      .DATA_WIDTH(0),   // Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      .DEVICE("7SERIES"),  // Target device: "7SERIES" 
      .FIFO_SIZE ("18Kb"), // Target BRAM: "18Kb" or "36Kb" 
      .FIRST_WORD_FALL_THROUGH ("FALSE") // Sets the FIFO FWFT to "TRUE" or "FALSE" 
   ) FIFO_DUALCLOCK_MACRO_inst (
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output almost empty
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output almost full
      .DO(DO),                   // Output data, width defined by DATA_WIDTH parameter
      .EMPTY(EMPTY),             // 1-bit output empty
      .FULL(FULL),               // 1-bit output full
      .RDCOUNT(RDCOUNT),         // Output read count, width determined by FIFO depth
      .RDERR(RDERR),             // 1-bit output read error
      .WRCOUNT(WRCOUNT),         // Output write count, width determined by FIFO depth
      .WRERR(WRERR),             // 1-bit output write error
      .DI(DI),                   // Input data, width defined by DATA_WIDTH parameter
      .RDCLK(RDCLK),             // 1-bit input read clock
      .RDEN(RDEN),               // 1-bit input read enable
      .RST(RST),                 // 1-bit input reset
      .WRCLK(WRCLK),             // 1-bit input write clock
      .WREN(WREN)                // 1-bit input write enable
   );

   // End of FIFO_DUALCLOCK_MACRO_inst instantiation
				</Template>
				<Template label="Simple Dual Port RAM (BRAM_SDP_MACRO)" treetype="template">
// BRAM_SDP_MACRO : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BRAM_SDP_MACRO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BRAM_SDP_MACRO: Simple Dual Port RAM
   //                 Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   ///////////////////////////////////////////////////////////////////////
   //  READ_WIDTH | BRAM_SIZE | READ Depth  | RDADDR Width |            //
   // WRITE_WIDTH |           | WRITE Depth | WRADDR Width |  WE Width  //
   // ============|===========|=============|==============|============//
   //    37-72    |  "36Kb"   |      512    |     9-bit    |    8-bit   //
   //    19-36    |  "36Kb"   |     1024    |    10-bit    |    4-bit   //
   //    19-36    |  "18Kb"   |      512    |     9-bit    |    4-bit   //
   //    10-18    |  "36Kb"   |     2048    |    11-bit    |    2-bit   //
   //    10-18    |  "18Kb"   |     1024    |    10-bit    |    2-bit   //
   //     5-9     |  "36Kb"   |     4096    |    12-bit    |    1-bit   //
   //     5-9     |  "18Kb"   |     2048    |    11-bit    |    1-bit   //
   //     3-4     |  "36Kb"   |     8192    |    13-bit    |    1-bit   //
   //     3-4     |  "18Kb"   |     4096    |    12-bit    |    1-bit   //
   //       2     |  "36Kb"   |    16384    |    14-bit    |    1-bit   //
   //       2     |  "18Kb"   |     8192    |    13-bit    |    1-bit   //
   //       1     |  "36Kb"   |    32768    |    15-bit    |    1-bit   //
   //       1     |  "18Kb"   |    16384    |    14-bit    |    1-bit   //
   ///////////////////////////////////////////////////////////////////////

   BRAM_SDP_MACRO #(
      .BRAM_SIZE("18Kb"), // Target BRAM, "18Kb" or "36Kb" 
      .DEVICE("7SERIES"), // Target device: "7SERIES" 
      .WRITE_WIDTH(0),    // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .READ_WIDTH(0),     // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .DO_REG(0),         // Optional output register (0 or 1)
      .INIT_FILE ("NONE"),
      .SIM_COLLISION_CHECK ("ALL"), // Collision check enable "ALL", "WARNING_ONLY", 
                                    //   "GENERATE_X_ONLY" or "NONE" 
      .SRVAL(72'h000000000000000000), // Set/Reset value for port output
      .INIT(72'h000000000000000000),  // Initial values on output port
      .WRITE_MODE("WRITE_FIRST"),  // Specify "READ_FIRST" for same clock or synchronous clocks
                                   //   Specify "WRITE_FIRST for asynchronous clocks on ports
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are for the parity bits
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are valid when configured as 36Kb
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) BRAM_SDP_MACRO_inst (
      .DO(DO),         // Output read data port, width defined by READ_WIDTH parameter
      .DI(DI),         // Input write data port, width defined by WRITE_WIDTH parameter
      .RDADDR(RDADDR), // Input read address, width defined by read port depth
      .RDCLK(RDCLK),   // 1-bit input read clock
      .RDEN(RDEN),     // 1-bit input read port enable
      .REGCE(REGCE),   // 1-bit input read output register enable
      .RST(RST),       // 1-bit input reset      
      .WE(WE),         // Input write enable, width defined by write port depth
      .WRADDR(WRADDR), // Input write address, width defined by write port depth
      .WRCLK(WRCLK),   // 1-bit input write clock
      .WREN(WREN)      // 1-bit input write port enable
   );

   // End of BRAM_SDP_MACRO_inst instantiation
				</Template>
				<Template label="Single Port RAM (BRAM_SINGLE_MACRO)" treetype="template">
// BRAM_SINGLE_MACRO : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BRAM_SINGLE_MACRO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BRAM_SINGLE_MACRO: Single Port RAM
   //                    Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   /////////////////////////////////////////////////////////////////////
   //  READ_WIDTH | BRAM_SIZE | READ Depth  | ADDR Width |            //
   // WRITE_WIDTH |           | WRITE Depth |            |  WE Width  //
   // ============|===========|=============|============|============//
   //    37-72    |  "36Kb"   |      512    |    9-bit   |    8-bit   //
   //    19-36    |  "36Kb"   |     1024    |   10-bit   |    4-bit   //
   //    19-36    |  "18Kb"   |      512    |    9-bit   |    4-bit   //
   //    10-18    |  "36Kb"   |     2048    |   11-bit   |    2-bit   //
   //    10-18    |  "18Kb"   |     1024    |   10-bit   |    2-bit   //
   //     5-9     |  "36Kb"   |     4096    |   12-bit   |    1-bit   //
   //     5-9     |  "18Kb"   |     2048    |   11-bit   |    1-bit   //
   //     3-4     |  "36Kb"   |     8192    |   13-bit   |    1-bit   //
   //     3-4     |  "18Kb"   |     4096    |   12-bit   |    1-bit   //
   //       2     |  "36Kb"   |    16384    |   14-bit   |    1-bit   //
   //       2     |  "18Kb"   |     8192    |   13-bit   |    1-bit   //
   //       1     |  "36Kb"   |    32768    |   15-bit   |    1-bit   //
   //       1     |  "18Kb"   |    16384    |   14-bit   |    1-bit   //
   /////////////////////////////////////////////////////////////////////

   BRAM_SINGLE_MACRO #(
      .BRAM_SIZE("18Kb"), // Target BRAM, "18Kb" or "36Kb" 
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .DO_REG(0), // Optional output register (0 or 1)
      .INIT(36'h000000000), // Initial values on output port
      .INIT_FILE ("NONE"),
      .WRITE_WIDTH(0), // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .READ_WIDTH(0),  // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .SRVAL(36'h000000000), // Set/Reset value for port output
      .WRITE_MODE("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE" 
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are for the parity bits
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) BRAM_SINGLE_MACRO_inst (
      .DO(DO),       // Output data, width defined by READ_WIDTH parameter
      .ADDR(ADDR),   // Input address, width defined by read/write port depth
      .CLK(CLK),     // 1-bit input clock
      .DI(DI),       // Input data port, width defined by WRITE_WIDTH parameter
      .EN(EN),       // 1-bit input RAM enable
      .REGCE(REGCE), // 1-bit input output register enable
      .RST(RST),     // 1-bit input reset
      .WE(WE)        // Input write enable, width defined by write port depth
   );

   // End of BRAM_SINGLE_MACRO_inst instantiation
				</Template>
				<Template label="Synchronous FIFO (FIFO_SYNC_MACRO)" treetype="template">
// FIFO_SYNC_MACRO : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (FIFO_SYNC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO_SYNC_MACRO: Synchronous First-In, First-Out (FIFO) RAM Buffer
   //                  Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   /////////////////////////////////////////////////////////////////
   // DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width //
   // ===========|===========|============|=======================//
   //   37-72    |  "36Kb"   |     512    |         9-bit         //
   //   19-36    |  "36Kb"   |    1024    |        10-bit         //
   //   19-36    |  "18Kb"   |     512    |         9-bit         //
   //   10-18    |  "36Kb"   |    2048    |        11-bit         //
   //   10-18    |  "18Kb"   |    1024    |        10-bit         //
   //    5-9     |  "36Kb"   |    4096    |        12-bit         //
   //    5-9     |  "18Kb"   |    2048    |        11-bit         //
   //    1-4     |  "36Kb"   |    8192    |        13-bit         //
   //    1-4     |  "18Kb"   |    4096    |        12-bit         //
   /////////////////////////////////////////////////////////////////

   FIFO_SYNC_MACRO  #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .ALMOST_EMPTY_OFFSET(9'h080), // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(9'h080),  // Sets almost full threshold
      .DATA_WIDTH(0), // Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      .DO_REG(0),     // Optional output register (0 or 1)
      .FIFO_SIZE ("18Kb")  // Target BRAM: "18Kb" or "36Kb" 
   ) FIFO_SYNC_MACRO_inst (
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output almost empty
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output almost full
      .DO(DO),                   // Output data, width defined by DATA_WIDTH parameter
      .EMPTY(EMPTY),             // 1-bit output empty
      .FULL(FULL),               // 1-bit output full
      .RDCOUNT(RDCOUNT),         // Output read count, width determined by FIFO depth
      .RDERR(RDERR),             // 1-bit output read error
      .WRCOUNT(WRCOUNT),         // Output write count, width determined by FIFO depth
      .WRERR(WRERR),             // 1-bit output write error
      .CLK(CLK),                 // 1-bit input clock
      .DI(DI),                   // Input data, width defined by DATA_WIDTH parameter
      .RDEN(RDEN),               // 1-bit input read enable
      .RST(RST),                 // 1-bit input reset
      .WREN(WREN)                // 1-bit input write enable
    );

   // End of FIFO_SYNC_MACRO_inst instantiation
				</Template>
				<Template label="True Dual Port RAM (BRAM_TDP_MACRO)" treetype="template">
// BRAM_TDP_MACRO : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BRAM_TDP_MACRO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BRAM_TDP_MACRO: True Dual Port RAM
   //                 Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   //////////////////////////////////////////////////////////////////////////
   // DATA_WIDTH_A/B | BRAM_SIZE | RAM Depth | ADDRA/B Width | WEA/B Width //
   // ===============|===========|===========|===============|=============//
   //     19-36      |  "36Kb"   |    1024   |    10-bit     |    4-bit    //
   //     10-18      |  "36Kb"   |    2048   |    11-bit     |    2-bit    //
   //     10-18      |  "18Kb"   |    1024   |    10-bit     |    2-bit    //
   //      5-9       |  "36Kb"   |    4096   |    12-bit     |    1-bit    //
   //      5-9       |  "18Kb"   |    2048   |    11-bit     |    1-bit    //
   //      3-4       |  "36Kb"   |    8192   |    13-bit     |    1-bit    //
   //      3-4       |  "18Kb"   |    4096   |    12-bit     |    1-bit    //
   //        2       |  "36Kb"   |   16384   |    14-bit     |    1-bit    //
   //        2       |  "18Kb"   |    8192   |    13-bit     |    1-bit    //
   //        1       |  "36Kb"   |   32768   |    15-bit     |    1-bit    //
   //        1       |  "18Kb"   |   16384   |    14-bit     |    1-bit    //
   //////////////////////////////////////////////////////////////////////////

   BRAM_TDP_MACRO #(
      .BRAM_SIZE("18Kb"), // Target BRAM: "18Kb" or "36Kb" 
      .DEVICE("7SERIES"), // Target device: "7SERIES" 
      .DOA_REG(0),        // Optional port A output register (0 or 1)
      .DOB_REG(0),        // Optional port B output register (0 or 1)
      .INIT_A(36'h0000000),  // Initial values on port A output port
      .INIT_B(36'h00000000), // Initial values on port B output port
      .INIT_FILE ("NONE"),
      .READ_WIDTH_A (0),   // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .READ_WIDTH_B (0),   // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .SIM_COLLISION_CHECK ("ALL"), // Collision check enable "ALL", "WARNING_ONLY", 
                                    //   "GENERATE_X_ONLY" or "NONE" 
      .SRVAL_A(36'h00000000), // Set/Reset value for port A output
      .SRVAL_B(36'h00000000), // Set/Reset value for port B output
      .WRITE_MODE_A("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE" 
      .WRITE_MODE_B("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE" 
      .WRITE_WIDTH_A(0), // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .WRITE_WIDTH_B(0), // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
     
      // The next set of INITP_xx are for the parity bits
      .INIT_FF(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are valid when configured as 36Kb
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) BRAM_TDP_MACRO_inst (
      .DOA(DOA),       // Output port-A data, width defined by READ_WIDTH_A parameter
      .DOB(DOB),       // Output port-B data, width defined by READ_WIDTH_B parameter
      .ADDRA(ADDRA),   // Input port-A address, width defined by Port A depth
      .ADDRB(ADDRB),   // Input port-B address, width defined by Port B depth
      .CLKA(CLKA),     // 1-bit input port-A clock
      .CLKB(CLKB),     // 1-bit input port-B clock
      .DIA(DIA),       // Input port-A data, width defined by WRITE_WIDTH_A parameter
      .DIB(DIB),       // Input port-B data, width defined by WRITE_WIDTH_B parameter
      .ENA(ENA),       // 1-bit input port-A enable
      .ENB(ENB),       // 1-bit input port-B enable
      .REGCEA(REGCEA), // 1-bit input port-A output register enable
      .REGCEB(REGCEB), // 1-bit input port-B output register enable
      .RSTA(RSTA),     // 1-bit input port-A reset
      .RSTB(RSTB),     // 1-bit input port-B reset
      .WEA(WEA),       // Input port-A write enable, width defined by Port A depth
      .WEB(WEB)        // Input port-B write enable, width defined by Port B depth
   );

   // End of BRAM_TDP_MACRO_inst instantiation
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Kintex-7" treetype="folder">
			<SubFolder label="DSP48" treetype="folder">
				<Template label="Add / Multiply Accumulate (ADDMACC_MACRO)" treetype="template">
//   ADDMACC_MACRO  : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (ADDMACC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ADDMACC_MACRO: Variable width &amp; latency - Pre-Add -&gt; Multiplier -&gt; Accumulate
   //                function implemented in a DSP48E
   //                Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   ADDMACC_MACRO #(
      .DEVICE("7SERIES"),    // Target Device: "7SERIES" 
      .LATENCY(4),           // Desired clock cycle latency, 0-4
      .WIDTH_PREADD(25),     // Pre-adder input width, 1-25
      .WIDTH_MULTIPLIER(18), // Multiplier input width, 1-18
      .WIDTH_PRODUCT(48)     // MACC output width, 1-48
   ) ADDMACC_MACRO_inst (
      .PRODUCT(PRODUCT),   // MACC result output, width defined by WIDTH_PRODUCT parameter
      .CARRYIN(CARRYIN),   // 1-bit carry-in input
      .CLK(CLK),           // 1-bit clock input
      .CE(CE),             // 1-bit clock enable input
      .LOAD(LOAD),         // 1-bit accumulator load input
      .LOAD_DATA(LOAD_DATA),   // Accumulator load data input, width defined by WIDTH_PRODUCT parameter
      .MULTIPLIER(MULTIPLIER), // Multiplier data input, width defined by WIDTH_MULTIPLIER parameter
      .PREADD2(PREADD2),   // Preadder data input, width defined by WIDTH_PREADD parameter
      .PREADD1(PREADD1),   // Preadder data input, width defined by WIDTH_PREADD parameter
      .RST(RST)            // 1-bit active high synchronous reset
   );
   
   // End of ADDMACC_MACRO_inst instantiation
				</Template>
				<Template label="Add / Subtract (ADDSUB_MACRO)" treetype="template">
//   ADDSUB_MACRO   : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (ADDSUB_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ADDSUB_MACRO: Variable width &amp; latency - Adder / Subtracter implemented in a DSP48E
   //               Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   ADDSUB_MACRO #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .LATENCY(2),        // Desired clock cycle latency, 0-2
      .WIDTH(48)          // Input / output bus width, 1-48
   ) ADDSUB_MACRO_inst (
      .CARRYOUT(CARRYOUT), // 1-bit carry-out output signal
      .RESULT(RESULT),     // Add/sub result output, width defined by WIDTH parameter
      .A(A),               // Input A bus, width defined by WIDTH parameter
      .ADD_SUB(ADD_SUB),   // 1-bit add/sub input, high selects add, low selects subtract
      .B(B),               // Input B bus, width defined by WIDTH parameter
      .CARRYIN(CARRYIN),   // 1-bit carry-in input
      .CE(CE),             // 1-bit clock enable input
      .CLK(CLK),           // 1-bit clock input
      .RST(RST)            // 1-bit active high synchronous reset
   );
   
   // End of ADDSUB_MACRO_inst instantiation
				</Template>
				<Template label="Counter w/ Terminal Count (COUNTER_TC_MACRO)" treetype="template">
// COUNTER_TC_MACRO : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (COUNTER_TC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // COUNTER_TC_MACRO: Counter with terminal count implemented in a DSP48E
   //                   Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   COUNTER_TC_MACRO #(
      .COUNT_BY(48'h000000000001), // Count by value
      .DEVICE("7SERIES"),          // Target Device: "7SERIES" 
      .DIRECTION("UP"),            // Counter direction, "UP" or "DOWN" 
      .RESET_UPON_TC("FALSE"), // Reset counter upon terminal count, "TRUE" or "FALSE" 
      .TC_VALUE(48'h000000000000), // Terminal count value
      .WIDTH_DATA(48)              // Counter output bus width, 1-48
   ) COUNTER_TC_MACRO_inst (
      .Q(Q),     // Counter output bus, width determined by WIDTH_DATA parameter 
      .TC(TC),   // 1-bit terminal count output, high = terminal count is reached
      .CLK(CLK), // 1-bit positive edge clock input
      .CE(CE),   // 1-bit active high clock enable input
      .RST(RST)  // 1-bit active high synchronous reset
   );
   
   // End of COUNTER_TC_MACRO_inst instantiation
				</Template>
				<Template label="Equality Comparator (EQ_COMPARE_MACRO)" treetype="template">
// EQ_COMPARE_MACRO : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (EQ_COMPARE_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EQ_COMPARE_MACRO: Equality Comparator implemented in a DSP48E
   //                   Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   EQ_COMPARE_MACRO #(
      .DEVICE("7SERIES"),       // Target Device: "7SERIES" 
      .LATENCY(2),              // Desired clock cycle latency, 0-2
      .MASK(48'h000000000000),  // Select bits to be masked, must set SEL_MASK="MASK" 
      .SEL_MASK("MASK"),        // "MASK" = use MASK parameter,
                                //   "DYNAMIC_PATTERN" = use DYNAMIC_PATTERN input bus
      .SEL_PATTERN("STATIC_PATTERN"), // "STATIC_PATTERN" = use STATIC_PATTERN parameter,
                                      //   "DYNAMIC_PATTERN = use DYNAMIC_PATTERN input bus
      .STATIC_PATTERN(48'h000000000000), // Specify static pattern, must set SEL_PATTERN = "STATIC_PATTERN" 
      .WIDTH(48)                // Comparator output bus width, 1-48
   ) EQ_COMPARE_MACRO_inst (
      .Q(Q),     // 1-bit output indicating a match
      .CE(CE),   // 1-bit active high input clock enable
      .CLK(CLK), // 1-bit positive edge clock input
      .DATA_IN(DATA_IN), // Input Data Bus, width determined by WIDTH parameter 
      .DYNAMIC_PATTERN(DYNAMIC_PATTERN), // Input Dynamic Match/Mask Bus, width determined by WIDTH parameter 
      .RST(RST)  // 1-bit input active high reset
   );
   
   // End of EQ_COMPARE_MACRO_inst instantiation
				</Template>
				<Template label="Loadable Counter (COUNTER_LOAD_MACRO)" treetype="template">
// COUNTER_LOAD_MACRO : In order to incorporate this function into the design,
//     Verilog        : the following instance declaration needs to be placed
//    instance        : in the body of the design code.  The instance name
//   declaration      : (COUNTER_LOAD_MACRO_inst) and/or the port declarations within the
//      code          : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // COUNTER_LOAD_MACRO: Loadable variable counter implemented in a DSP48E
   //                     Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   COUNTER_LOAD_MACRO #(
      .COUNT_BY(48'h000000000001), // Count by value
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .WIDTH_DATA(48)     // Counter output bus width, 1-48
   ) COUNTER_LOAD_MACRO_inst (
      .Q(Q),                 // Counter output, width determined by WIDTH_DATA parameter 
      .CLK(CLK),             // 1-bit clock input
      .CE(CE),               // 1-bit clock enable input
      .DIRECTION(DIRECTION), // 1-bit up/down count direction input, high is count up
      .LOAD(LOAD),           // 1-bit active high load input
      .LOAD_DATA(LOAD_DATA), // Counter load data, width determined by WIDTH_DATA parameter 
      .RST(RST)              // 1-bit active high synchronous reset
   );
   
   // End of COUNTER_LOAD_MACRO_inst instantiation
				</Template>
				<Template label="Multiplier (MULT_MACRO)" treetype="template">
//   MULT_MACRO     : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (MULT_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MULT_MACRO: Multiply Function implemented in a DSP48E
   //             Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   MULT_MACRO #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .LATENCY(3),        // Desired clock cycle latency, 0-4
      .WIDTH_A(18),       // Multiplier A-input bus width, 1-25
      .WIDTH_B(18)        // Multiplier B-input bus width, 1-18
   ) MULT_MACRO_inst (
      .P(P),     // Multiplier output bus, width determined by WIDTH_P parameter 
      .A(A),     // Multiplier input A bus, width determined by WIDTH_A parameter 
      .B(B),     // Multiplier input B bus, width determined by WIDTH_B parameter 
      .CE(CE),   // 1-bit active high input clock enable
      .CLK(CLK), // 1-bit positive edge clock input
      .RST(RST)  // 1-bit input active high reset
   );
   
   // End of MULT_MACRO_inst instantiation
				</Template>
				<Template label="Multiply Accumulate (MACC_MACRO)" treetype="template">
//   MACC_MACRO     : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (MACC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MACC_MACRO: Multiply Accumulate Function implemented in a DSP48E
   //             Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   MACC_MACRO #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .LATENCY(3),        // Desired clock cycle latency, 1-4
      .WIDTH_A(25),       // Multiplier A-input bus width, 1-25
      .WIDTH_B(18),       // Multiplier B-input bus width, 1-18
      .WIDTH_P(48)        // Accumulator output bus width, 1-48
   ) MACC_MACRO_inst (
      .P(P),     // MACC output bus, width determined by WIDTH_P parameter 
      .A(A),     // MACC input A bus, width determined by WIDTH_A parameter 
      .ADDSUB(ADDSUB), // 1-bit add/sub input, high selects add, low selects subtract
      .B(B),     // MACC input B bus, width determined by WIDTH_B parameter 
      .CARRYIN(CARRYIN), // 1-bit carry-in input to accumulator
      .CE(CE),     // 1-bit active high input clock enable
      .CLK(CLK),   // 1-bit positive edge clock input
      .LOAD(LOAD), // 1-bit active high input load accumulator enable
      .LOAD_DATA(LOAD_DATA), // Load accumulator input data, width determined by WIDTH_P parameter
      .RST(RST)    // 1-bit input active high reset
   );
   
   // End of MACC_MACRO_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<Template label="Dual Clock FIFO (FIFO_DUALCLOCK_MACRO)" treetype="template">
// FIFO_DUALCLOCK_MACRO : In order to incorporate this function into the design,
//     Verilog          : the following instance declaration needs to be placed
//    instance          : in the body of the design code.  The instance name
//   declaration        : (FIFO_DUALCLOCK_MACRO_inst) and/or the port declarations within the
//      code            : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO_DUALCLOCK_MACRO: Dual Clock First-In, First-Out (FIFO) RAM Buffer
   //                       Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   /////////////////////////////////////////////////////////////////
   // DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width //
   // ===========|===========|============|=======================//
   //   37-72    |  "36Kb"   |     512    |         9-bit         //
   //   19-36    |  "36Kb"   |    1024    |        10-bit         //
   //   19-36    |  "18Kb"   |     512    |         9-bit         //
   //   10-18    |  "36Kb"   |    2048    |        11-bit         //
   //   10-18    |  "18Kb"   |    1024    |        10-bit         //
   //    5-9     |  "36Kb"   |    4096    |        12-bit         //
   //    5-9     |  "18Kb"   |    2048    |        11-bit         //
   //    1-4     |  "36Kb"   |    8192    |        13-bit         //
   //    1-4     |  "18Kb"   |    4096    |        12-bit         //
   /////////////////////////////////////////////////////////////////

   FIFO_DUALCLOCK_MACRO  #(
      .ALMOST_EMPTY_OFFSET(9'h080), // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(9'h080),  // Sets almost full threshold
      .DATA_WIDTH(0),   // Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      .DEVICE("7SERIES"),  // Target device: "7SERIES" 
      .FIFO_SIZE ("18Kb"), // Target BRAM: "18Kb" or "36Kb" 
      .FIRST_WORD_FALL_THROUGH ("FALSE") // Sets the FIFO FWFT to "TRUE" or "FALSE" 
   ) FIFO_DUALCLOCK_MACRO_inst (
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output almost empty
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output almost full
      .DO(DO),                   // Output data, width defined by DATA_WIDTH parameter
      .EMPTY(EMPTY),             // 1-bit output empty
      .FULL(FULL),               // 1-bit output full
      .RDCOUNT(RDCOUNT),         // Output read count, width determined by FIFO depth
      .RDERR(RDERR),             // 1-bit output read error
      .WRCOUNT(WRCOUNT),         // Output write count, width determined by FIFO depth
      .WRERR(WRERR),             // 1-bit output write error
      .DI(DI),                   // Input data, width defined by DATA_WIDTH parameter
      .RDCLK(RDCLK),             // 1-bit input read clock
      .RDEN(RDEN),               // 1-bit input read enable
      .RST(RST),                 // 1-bit input reset
      .WRCLK(WRCLK),             // 1-bit input write clock
      .WREN(WREN)                // 1-bit input write enable
   );

   // End of FIFO_DUALCLOCK_MACRO_inst instantiation
				</Template>
				<Template label="Simple Dual Port RAM (BRAM_SDP_MACRO)" treetype="template">
// BRAM_SDP_MACRO : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BRAM_SDP_MACRO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BRAM_SDP_MACRO: Simple Dual Port RAM
   //                 Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   ///////////////////////////////////////////////////////////////////////
   //  READ_WIDTH | BRAM_SIZE | READ Depth  | RDADDR Width |            //
   // WRITE_WIDTH |           | WRITE Depth | WRADDR Width |  WE Width  //
   // ============|===========|=============|==============|============//
   //    37-72    |  "36Kb"   |      512    |     9-bit    |    8-bit   //
   //    19-36    |  "36Kb"   |     1024    |    10-bit    |    4-bit   //
   //    19-36    |  "18Kb"   |      512    |     9-bit    |    4-bit   //
   //    10-18    |  "36Kb"   |     2048    |    11-bit    |    2-bit   //
   //    10-18    |  "18Kb"   |     1024    |    10-bit    |    2-bit   //
   //     5-9     |  "36Kb"   |     4096    |    12-bit    |    1-bit   //
   //     5-9     |  "18Kb"   |     2048    |    11-bit    |    1-bit   //
   //     3-4     |  "36Kb"   |     8192    |    13-bit    |    1-bit   //
   //     3-4     |  "18Kb"   |     4096    |    12-bit    |    1-bit   //
   //       2     |  "36Kb"   |    16384    |    14-bit    |    1-bit   //
   //       2     |  "18Kb"   |     8192    |    13-bit    |    1-bit   //
   //       1     |  "36Kb"   |    32768    |    15-bit    |    1-bit   //
   //       1     |  "18Kb"   |    16384    |    14-bit    |    1-bit   //
   ///////////////////////////////////////////////////////////////////////

   BRAM_SDP_MACRO #(
      .BRAM_SIZE("18Kb"), // Target BRAM, "18Kb" or "36Kb" 
      .DEVICE("7SERIES"), // Target device: "7SERIES" 
      .WRITE_WIDTH(0),    // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .READ_WIDTH(0),     // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .DO_REG(0),         // Optional output register (0 or 1)
      .INIT_FILE ("NONE"),
      .SIM_COLLISION_CHECK ("ALL"), // Collision check enable "ALL", "WARNING_ONLY", 
                                    //   "GENERATE_X_ONLY" or "NONE" 
      .SRVAL(72'h000000000000000000), // Set/Reset value for port output
      .INIT(72'h000000000000000000),  // Initial values on output port
      .WRITE_MODE("WRITE_FIRST"),  // Specify "READ_FIRST" for same clock or synchronous clocks
                                   //   Specify "WRITE_FIRST for asynchronous clocks on ports
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are for the parity bits
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are valid when configured as 36Kb
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) BRAM_SDP_MACRO_inst (
      .DO(DO),         // Output read data port, width defined by READ_WIDTH parameter
      .DI(DI),         // Input write data port, width defined by WRITE_WIDTH parameter
      .RDADDR(RDADDR), // Input read address, width defined by read port depth
      .RDCLK(RDCLK),   // 1-bit input read clock
      .RDEN(RDEN),     // 1-bit input read port enable
      .REGCE(REGCE),   // 1-bit input read output register enable
      .RST(RST),       // 1-bit input reset      
      .WE(WE),         // Input write enable, width defined by write port depth
      .WRADDR(WRADDR), // Input write address, width defined by write port depth
      .WRCLK(WRCLK),   // 1-bit input write clock
      .WREN(WREN)      // 1-bit input write port enable
   );

   // End of BRAM_SDP_MACRO_inst instantiation
				</Template>
				<Template label="Single Port RAM (BRAM_SINGLE_MACRO)" treetype="template">
// BRAM_SINGLE_MACRO : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BRAM_SINGLE_MACRO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BRAM_SINGLE_MACRO: Single Port RAM
   //                    Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   /////////////////////////////////////////////////////////////////////
   //  READ_WIDTH | BRAM_SIZE | READ Depth  | ADDR Width |            //
   // WRITE_WIDTH |           | WRITE Depth |            |  WE Width  //
   // ============|===========|=============|============|============//
   //    37-72    |  "36Kb"   |      512    |    9-bit   |    8-bit   //
   //    19-36    |  "36Kb"   |     1024    |   10-bit   |    4-bit   //
   //    19-36    |  "18Kb"   |      512    |    9-bit   |    4-bit   //
   //    10-18    |  "36Kb"   |     2048    |   11-bit   |    2-bit   //
   //    10-18    |  "18Kb"   |     1024    |   10-bit   |    2-bit   //
   //     5-9     |  "36Kb"   |     4096    |   12-bit   |    1-bit   //
   //     5-9     |  "18Kb"   |     2048    |   11-bit   |    1-bit   //
   //     3-4     |  "36Kb"   |     8192    |   13-bit   |    1-bit   //
   //     3-4     |  "18Kb"   |     4096    |   12-bit   |    1-bit   //
   //       2     |  "36Kb"   |    16384    |   14-bit   |    1-bit   //
   //       2     |  "18Kb"   |     8192    |   13-bit   |    1-bit   //
   //       1     |  "36Kb"   |    32768    |   15-bit   |    1-bit   //
   //       1     |  "18Kb"   |    16384    |   14-bit   |    1-bit   //
   /////////////////////////////////////////////////////////////////////

   BRAM_SINGLE_MACRO #(
      .BRAM_SIZE("18Kb"), // Target BRAM, "18Kb" or "36Kb" 
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .DO_REG(0), // Optional output register (0 or 1)
      .INIT(36'h000000000), // Initial values on output port
      .INIT_FILE ("NONE"),
      .WRITE_WIDTH(0), // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .READ_WIDTH(0),  // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .SRVAL(36'h000000000), // Set/Reset value for port output
      .WRITE_MODE("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE" 
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are for the parity bits
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) BRAM_SINGLE_MACRO_inst (
      .DO(DO),       // Output data, width defined by READ_WIDTH parameter
      .ADDR(ADDR),   // Input address, width defined by read/write port depth
      .CLK(CLK),     // 1-bit input clock
      .DI(DI),       // Input data port, width defined by WRITE_WIDTH parameter
      .EN(EN),       // 1-bit input RAM enable
      .REGCE(REGCE), // 1-bit input output register enable
      .RST(RST),     // 1-bit input reset
      .WE(WE)        // Input write enable, width defined by write port depth
   );

   // End of BRAM_SINGLE_MACRO_inst instantiation
				</Template>
				<Template label="Synchronous FIFO (FIFO_SYNC_MACRO)" treetype="template">
// FIFO_SYNC_MACRO : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (FIFO_SYNC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO_SYNC_MACRO: Synchronous First-In, First-Out (FIFO) RAM Buffer
   //                  Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   /////////////////////////////////////////////////////////////////
   // DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width //
   // ===========|===========|============|=======================//
   //   37-72    |  "36Kb"   |     512    |         9-bit         //
   //   19-36    |  "36Kb"   |    1024    |        10-bit         //
   //   19-36    |  "18Kb"   |     512    |         9-bit         //
   //   10-18    |  "36Kb"   |    2048    |        11-bit         //
   //   10-18    |  "18Kb"   |    1024    |        10-bit         //
   //    5-9     |  "36Kb"   |    4096    |        12-bit         //
   //    5-9     |  "18Kb"   |    2048    |        11-bit         //
   //    1-4     |  "36Kb"   |    8192    |        13-bit         //
   //    1-4     |  "18Kb"   |    4096    |        12-bit         //
   /////////////////////////////////////////////////////////////////

   FIFO_SYNC_MACRO  #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .ALMOST_EMPTY_OFFSET(9'h080), // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(9'h080),  // Sets almost full threshold
      .DATA_WIDTH(0), // Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      .DO_REG(0),     // Optional output register (0 or 1)
      .FIFO_SIZE ("18Kb")  // Target BRAM: "18Kb" or "36Kb" 
   ) FIFO_SYNC_MACRO_inst (
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output almost empty
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output almost full
      .DO(DO),                   // Output data, width defined by DATA_WIDTH parameter
      .EMPTY(EMPTY),             // 1-bit output empty
      .FULL(FULL),               // 1-bit output full
      .RDCOUNT(RDCOUNT),         // Output read count, width determined by FIFO depth
      .RDERR(RDERR),             // 1-bit output read error
      .WRCOUNT(WRCOUNT),         // Output write count, width determined by FIFO depth
      .WRERR(WRERR),             // 1-bit output write error
      .CLK(CLK),                 // 1-bit input clock
      .DI(DI),                   // Input data, width defined by DATA_WIDTH parameter
      .RDEN(RDEN),               // 1-bit input read enable
      .RST(RST),                 // 1-bit input reset
      .WREN(WREN)                // 1-bit input write enable
    );

   // End of FIFO_SYNC_MACRO_inst instantiation
				</Template>
				<Template label="True Dual Port RAM (BRAM_TDP_MACRO)" treetype="template">
// BRAM_TDP_MACRO : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BRAM_TDP_MACRO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BRAM_TDP_MACRO: True Dual Port RAM
   //                 Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   //////////////////////////////////////////////////////////////////////////
   // DATA_WIDTH_A/B | BRAM_SIZE | RAM Depth | ADDRA/B Width | WEA/B Width //
   // ===============|===========|===========|===============|=============//
   //     19-36      |  "36Kb"   |    1024   |    10-bit     |    4-bit    //
   //     10-18      |  "36Kb"   |    2048   |    11-bit     |    2-bit    //
   //     10-18      |  "18Kb"   |    1024   |    10-bit     |    2-bit    //
   //      5-9       |  "36Kb"   |    4096   |    12-bit     |    1-bit    //
   //      5-9       |  "18Kb"   |    2048   |    11-bit     |    1-bit    //
   //      3-4       |  "36Kb"   |    8192   |    13-bit     |    1-bit    //
   //      3-4       |  "18Kb"   |    4096   |    12-bit     |    1-bit    //
   //        2       |  "36Kb"   |   16384   |    14-bit     |    1-bit    //
   //        2       |  "18Kb"   |    8192   |    13-bit     |    1-bit    //
   //        1       |  "36Kb"   |   32768   |    15-bit     |    1-bit    //
   //        1       |  "18Kb"   |   16384   |    14-bit     |    1-bit    //
   //////////////////////////////////////////////////////////////////////////

   BRAM_TDP_MACRO #(
      .BRAM_SIZE("18Kb"), // Target BRAM: "18Kb" or "36Kb" 
      .DEVICE("7SERIES"), // Target device: "7SERIES" 
      .DOA_REG(0),        // Optional port A output register (0 or 1)
      .DOB_REG(0),        // Optional port B output register (0 or 1)
      .INIT_A(36'h0000000),  // Initial values on port A output port
      .INIT_B(36'h00000000), // Initial values on port B output port
      .INIT_FILE ("NONE"),
      .READ_WIDTH_A (0),   // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .READ_WIDTH_B (0),   // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .SIM_COLLISION_CHECK ("ALL"), // Collision check enable "ALL", "WARNING_ONLY", 
                                    //   "GENERATE_X_ONLY" or "NONE" 
      .SRVAL_A(36'h00000000), // Set/Reset value for port A output
      .SRVAL_B(36'h00000000), // Set/Reset value for port B output
      .WRITE_MODE_A("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE" 
      .WRITE_MODE_B("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE" 
      .WRITE_WIDTH_A(0), // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .WRITE_WIDTH_B(0), // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
     
      // The next set of INITP_xx are for the parity bits
      .INIT_FF(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are valid when configured as 36Kb
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) BRAM_TDP_MACRO_inst (
      .DOA(DOA),       // Output port-A data, width defined by READ_WIDTH_A parameter
      .DOB(DOB),       // Output port-B data, width defined by READ_WIDTH_B parameter
      .ADDRA(ADDRA),   // Input port-A address, width defined by Port A depth
      .ADDRB(ADDRB),   // Input port-B address, width defined by Port B depth
      .CLKA(CLKA),     // 1-bit input port-A clock
      .CLKB(CLKB),     // 1-bit input port-B clock
      .DIA(DIA),       // Input port-A data, width defined by WRITE_WIDTH_A parameter
      .DIB(DIB),       // Input port-B data, width defined by WRITE_WIDTH_B parameter
      .ENA(ENA),       // 1-bit input port-A enable
      .ENB(ENB),       // 1-bit input port-B enable
      .REGCEA(REGCEA), // 1-bit input port-A output register enable
      .REGCEB(REGCEB), // 1-bit input port-B output register enable
      .RSTA(RSTA),     // 1-bit input port-A reset
      .RSTB(RSTB),     // 1-bit input port-B reset
      .WEA(WEA),       // Input port-A write enable, width defined by Port A depth
      .WEB(WEB)        // Input port-B write enable, width defined by Port B depth
   );

   // End of BRAM_TDP_MACRO_inst instantiation
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Virtex-7" treetype="folder">
			<SubFolder label="DSP48" treetype="folder">
				<Template label="Add / Multiply Accumulate (ADDMACC_MACRO)" treetype="template">
//   ADDMACC_MACRO  : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (ADDMACC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ADDMACC_MACRO: Variable width &amp; latency - Pre-Add -&gt; Multiplier -&gt; Accumulate
   //                function implemented in a DSP48E
   //                Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   ADDMACC_MACRO #(
      .DEVICE("7SERIES"),    // Target Device: "7SERIES" 
      .LATENCY(4),           // Desired clock cycle latency, 0-4
      .WIDTH_PREADD(25),     // Pre-adder input width, 1-25
      .WIDTH_MULTIPLIER(18), // Multiplier input width, 1-18
      .WIDTH_PRODUCT(48)     // MACC output width, 1-48
   ) ADDMACC_MACRO_inst (
      .PRODUCT(PRODUCT),   // MACC result output, width defined by WIDTH_PRODUCT parameter
      .CARRYIN(CARRYIN),   // 1-bit carry-in input
      .CLK(CLK),           // 1-bit clock input
      .CE(CE),             // 1-bit clock enable input
      .LOAD(LOAD),         // 1-bit accumulator load input
      .LOAD_DATA(LOAD_DATA),   // Accumulator load data input, width defined by WIDTH_PRODUCT parameter
      .MULTIPLIER(MULTIPLIER), // Multiplier data input, width defined by WIDTH_MULTIPLIER parameter
      .PREADD2(PREADD2),   // Preadder data input, width defined by WIDTH_PREADD parameter
      .PREADD1(PREADD1),   // Preadder data input, width defined by WIDTH_PREADD parameter
      .RST(RST)            // 1-bit active high synchronous reset
   );
   
   // End of ADDMACC_MACRO_inst instantiation
				</Template>
				<Template label="Add / Subtract (ADDSUB_MACRO)" treetype="template">
//   ADDSUB_MACRO   : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (ADDSUB_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ADDSUB_MACRO: Variable width &amp; latency - Adder / Subtracter implemented in a DSP48E
   //               Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   ADDSUB_MACRO #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .LATENCY(2),        // Desired clock cycle latency, 0-2
      .WIDTH(48)          // Input / output bus width, 1-48
   ) ADDSUB_MACRO_inst (
      .CARRYOUT(CARRYOUT), // 1-bit carry-out output signal
      .RESULT(RESULT),     // Add/sub result output, width defined by WIDTH parameter
      .A(A),               // Input A bus, width defined by WIDTH parameter
      .ADD_SUB(ADD_SUB),   // 1-bit add/sub input, high selects add, low selects subtract
      .B(B),               // Input B bus, width defined by WIDTH parameter
      .CARRYIN(CARRYIN),   // 1-bit carry-in input
      .CE(CE),             // 1-bit clock enable input
      .CLK(CLK),           // 1-bit clock input
      .RST(RST)            // 1-bit active high synchronous reset
   );
   
   // End of ADDSUB_MACRO_inst instantiation
				</Template>
				<Template label="Counter w/ Terminal Count (COUNTER_TC_MACRO)" treetype="template">
// COUNTER_TC_MACRO : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (COUNTER_TC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // COUNTER_TC_MACRO: Counter with terminal count implemented in a DSP48E
   //                   Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   COUNTER_TC_MACRO #(
      .COUNT_BY(48'h000000000001), // Count by value
      .DEVICE("7SERIES"),          // Target Device: "7SERIES" 
      .DIRECTION("UP"),            // Counter direction, "UP" or "DOWN" 
      .RESET_UPON_TC("FALSE"), // Reset counter upon terminal count, "TRUE" or "FALSE" 
      .TC_VALUE(48'h000000000000), // Terminal count value
      .WIDTH_DATA(48)              // Counter output bus width, 1-48
   ) COUNTER_TC_MACRO_inst (
      .Q(Q),     // Counter output bus, width determined by WIDTH_DATA parameter 
      .TC(TC),   // 1-bit terminal count output, high = terminal count is reached
      .CLK(CLK), // 1-bit positive edge clock input
      .CE(CE),   // 1-bit active high clock enable input
      .RST(RST)  // 1-bit active high synchronous reset
   );
   
   // End of COUNTER_TC_MACRO_inst instantiation
				</Template>
				<Template label="Equality Comparator (EQ_COMPARE_MACRO)" treetype="template">
// EQ_COMPARE_MACRO : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (EQ_COMPARE_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EQ_COMPARE_MACRO: Equality Comparator implemented in a DSP48E
   //                   Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   EQ_COMPARE_MACRO #(
      .DEVICE("7SERIES"),       // Target Device: "7SERIES" 
      .LATENCY(2),              // Desired clock cycle latency, 0-2
      .MASK(48'h000000000000),  // Select bits to be masked, must set SEL_MASK="MASK" 
      .SEL_MASK("MASK"),        // "MASK" = use MASK parameter,
                                //   "DYNAMIC_PATTERN" = use DYNAMIC_PATTERN input bus
      .SEL_PATTERN("STATIC_PATTERN"), // "STATIC_PATTERN" = use STATIC_PATTERN parameter,
                                      //   "DYNAMIC_PATTERN = use DYNAMIC_PATTERN input bus
      .STATIC_PATTERN(48'h000000000000), // Specify static pattern, must set SEL_PATTERN = "STATIC_PATTERN" 
      .WIDTH(48)                // Comparator output bus width, 1-48
   ) EQ_COMPARE_MACRO_inst (
      .Q(Q),     // 1-bit output indicating a match
      .CE(CE),   // 1-bit active high input clock enable
      .CLK(CLK), // 1-bit positive edge clock input
      .DATA_IN(DATA_IN), // Input Data Bus, width determined by WIDTH parameter 
      .DYNAMIC_PATTERN(DYNAMIC_PATTERN), // Input Dynamic Match/Mask Bus, width determined by WIDTH parameter 
      .RST(RST)  // 1-bit input active high reset
   );
   
   // End of EQ_COMPARE_MACRO_inst instantiation
				</Template>
				<Template label="Loadable Counter (COUNTER_LOAD_MACRO)" treetype="template">
// COUNTER_LOAD_MACRO : In order to incorporate this function into the design,
//     Verilog        : the following instance declaration needs to be placed
//    instance        : in the body of the design code.  The instance name
//   declaration      : (COUNTER_LOAD_MACRO_inst) and/or the port declarations within the
//      code          : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // COUNTER_LOAD_MACRO: Loadable variable counter implemented in a DSP48E
   //                     Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   COUNTER_LOAD_MACRO #(
      .COUNT_BY(48'h000000000001), // Count by value
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .WIDTH_DATA(48)     // Counter output bus width, 1-48
   ) COUNTER_LOAD_MACRO_inst (
      .Q(Q),                 // Counter output, width determined by WIDTH_DATA parameter 
      .CLK(CLK),             // 1-bit clock input
      .CE(CE),               // 1-bit clock enable input
      .DIRECTION(DIRECTION), // 1-bit up/down count direction input, high is count up
      .LOAD(LOAD),           // 1-bit active high load input
      .LOAD_DATA(LOAD_DATA), // Counter load data, width determined by WIDTH_DATA parameter 
      .RST(RST)              // 1-bit active high synchronous reset
   );
   
   // End of COUNTER_LOAD_MACRO_inst instantiation
				</Template>
				<Template label="Multiplier (MULT_MACRO)" treetype="template">
//   MULT_MACRO     : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (MULT_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MULT_MACRO: Multiply Function implemented in a DSP48E
   //             Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   MULT_MACRO #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .LATENCY(3),        // Desired clock cycle latency, 0-4
      .WIDTH_A(18),       // Multiplier A-input bus width, 1-25
      .WIDTH_B(18)        // Multiplier B-input bus width, 1-18
   ) MULT_MACRO_inst (
      .P(P),     // Multiplier output bus, width determined by WIDTH_P parameter 
      .A(A),     // Multiplier input A bus, width determined by WIDTH_A parameter 
      .B(B),     // Multiplier input B bus, width determined by WIDTH_B parameter 
      .CE(CE),   // 1-bit active high input clock enable
      .CLK(CLK), // 1-bit positive edge clock input
      .RST(RST)  // 1-bit input active high reset
   );
   
   // End of MULT_MACRO_inst instantiation
				</Template>
				<Template label="Multiply Accumulate (MACC_MACRO)" treetype="template">
//   MACC_MACRO     : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (MACC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MACC_MACRO: Multiply Accumulate Function implemented in a DSP48E
   //             Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   MACC_MACRO #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .LATENCY(3),        // Desired clock cycle latency, 1-4
      .WIDTH_A(25),       // Multiplier A-input bus width, 1-25
      .WIDTH_B(18),       // Multiplier B-input bus width, 1-18
      .WIDTH_P(48)        // Accumulator output bus width, 1-48
   ) MACC_MACRO_inst (
      .P(P),     // MACC output bus, width determined by WIDTH_P parameter 
      .A(A),     // MACC input A bus, width determined by WIDTH_A parameter 
      .ADDSUB(ADDSUB), // 1-bit add/sub input, high selects add, low selects subtract
      .B(B),     // MACC input B bus, width determined by WIDTH_B parameter 
      .CARRYIN(CARRYIN), // 1-bit carry-in input to accumulator
      .CE(CE),     // 1-bit active high input clock enable
      .CLK(CLK),   // 1-bit positive edge clock input
      .LOAD(LOAD), // 1-bit active high input load accumulator enable
      .LOAD_DATA(LOAD_DATA), // Load accumulator input data, width determined by WIDTH_P parameter
      .RST(RST)    // 1-bit input active high reset
   );
   
   // End of MACC_MACRO_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<Template label="Dual Clock FIFO (FIFO_DUALCLOCK_MACRO)" treetype="template">
// FIFO_DUALCLOCK_MACRO : In order to incorporate this function into the design,
//     Verilog          : the following instance declaration needs to be placed
//    instance          : in the body of the design code.  The instance name
//   declaration        : (FIFO_DUALCLOCK_MACRO_inst) and/or the port declarations within the
//      code            : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO_DUALCLOCK_MACRO: Dual Clock First-In, First-Out (FIFO) RAM Buffer
   //                       Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   /////////////////////////////////////////////////////////////////
   // DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width //
   // ===========|===========|============|=======================//
   //   37-72    |  "36Kb"   |     512    |         9-bit         //
   //   19-36    |  "36Kb"   |    1024    |        10-bit         //
   //   19-36    |  "18Kb"   |     512    |         9-bit         //
   //   10-18    |  "36Kb"   |    2048    |        11-bit         //
   //   10-18    |  "18Kb"   |    1024    |        10-bit         //
   //    5-9     |  "36Kb"   |    4096    |        12-bit         //
   //    5-9     |  "18Kb"   |    2048    |        11-bit         //
   //    1-4     |  "36Kb"   |    8192    |        13-bit         //
   //    1-4     |  "18Kb"   |    4096    |        12-bit         //
   /////////////////////////////////////////////////////////////////

   FIFO_DUALCLOCK_MACRO  #(
      .ALMOST_EMPTY_OFFSET(9'h080), // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(9'h080),  // Sets almost full threshold
      .DATA_WIDTH(0),   // Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      .DEVICE("7SERIES"),  // Target device: "7SERIES" 
      .FIFO_SIZE ("18Kb"), // Target BRAM: "18Kb" or "36Kb" 
      .FIRST_WORD_FALL_THROUGH ("FALSE") // Sets the FIFO FWFT to "TRUE" or "FALSE" 
   ) FIFO_DUALCLOCK_MACRO_inst (
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output almost empty
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output almost full
      .DO(DO),                   // Output data, width defined by DATA_WIDTH parameter
      .EMPTY(EMPTY),             // 1-bit output empty
      .FULL(FULL),               // 1-bit output full
      .RDCOUNT(RDCOUNT),         // Output read count, width determined by FIFO depth
      .RDERR(RDERR),             // 1-bit output read error
      .WRCOUNT(WRCOUNT),         // Output write count, width determined by FIFO depth
      .WRERR(WRERR),             // 1-bit output write error
      .DI(DI),                   // Input data, width defined by DATA_WIDTH parameter
      .RDCLK(RDCLK),             // 1-bit input read clock
      .RDEN(RDEN),               // 1-bit input read enable
      .RST(RST),                 // 1-bit input reset
      .WRCLK(WRCLK),             // 1-bit input write clock
      .WREN(WREN)                // 1-bit input write enable
   );

   // End of FIFO_DUALCLOCK_MACRO_inst instantiation
				</Template>
				<Template label="Simple Dual Port RAM (BRAM_SDP_MACRO)" treetype="template">
// BRAM_SDP_MACRO : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BRAM_SDP_MACRO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BRAM_SDP_MACRO: Simple Dual Port RAM
   //                 Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   ///////////////////////////////////////////////////////////////////////
   //  READ_WIDTH | BRAM_SIZE | READ Depth  | RDADDR Width |            //
   // WRITE_WIDTH |           | WRITE Depth | WRADDR Width |  WE Width  //
   // ============|===========|=============|==============|============//
   //    37-72    |  "36Kb"   |      512    |     9-bit    |    8-bit   //
   //    19-36    |  "36Kb"   |     1024    |    10-bit    |    4-bit   //
   //    19-36    |  "18Kb"   |      512    |     9-bit    |    4-bit   //
   //    10-18    |  "36Kb"   |     2048    |    11-bit    |    2-bit   //
   //    10-18    |  "18Kb"   |     1024    |    10-bit    |    2-bit   //
   //     5-9     |  "36Kb"   |     4096    |    12-bit    |    1-bit   //
   //     5-9     |  "18Kb"   |     2048    |    11-bit    |    1-bit   //
   //     3-4     |  "36Kb"   |     8192    |    13-bit    |    1-bit   //
   //     3-4     |  "18Kb"   |     4096    |    12-bit    |    1-bit   //
   //       2     |  "36Kb"   |    16384    |    14-bit    |    1-bit   //
   //       2     |  "18Kb"   |     8192    |    13-bit    |    1-bit   //
   //       1     |  "36Kb"   |    32768    |    15-bit    |    1-bit   //
   //       1     |  "18Kb"   |    16384    |    14-bit    |    1-bit   //
   ///////////////////////////////////////////////////////////////////////

   BRAM_SDP_MACRO #(
      .BRAM_SIZE("18Kb"), // Target BRAM, "18Kb" or "36Kb" 
      .DEVICE("7SERIES"), // Target device: "7SERIES" 
      .WRITE_WIDTH(0),    // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .READ_WIDTH(0),     // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .DO_REG(0),         // Optional output register (0 or 1)
      .INIT_FILE ("NONE"),
      .SIM_COLLISION_CHECK ("ALL"), // Collision check enable "ALL", "WARNING_ONLY", 
                                    //   "GENERATE_X_ONLY" or "NONE" 
      .SRVAL(72'h000000000000000000), // Set/Reset value for port output
      .INIT(72'h000000000000000000),  // Initial values on output port
      .WRITE_MODE("WRITE_FIRST"),  // Specify "READ_FIRST" for same clock or synchronous clocks
                                   //   Specify "WRITE_FIRST for asynchronous clocks on ports
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are for the parity bits
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are valid when configured as 36Kb
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) BRAM_SDP_MACRO_inst (
      .DO(DO),         // Output read data port, width defined by READ_WIDTH parameter
      .DI(DI),         // Input write data port, width defined by WRITE_WIDTH parameter
      .RDADDR(RDADDR), // Input read address, width defined by read port depth
      .RDCLK(RDCLK),   // 1-bit input read clock
      .RDEN(RDEN),     // 1-bit input read port enable
      .REGCE(REGCE),   // 1-bit input read output register enable
      .RST(RST),       // 1-bit input reset      
      .WE(WE),         // Input write enable, width defined by write port depth
      .WRADDR(WRADDR), // Input write address, width defined by write port depth
      .WRCLK(WRCLK),   // 1-bit input write clock
      .WREN(WREN)      // 1-bit input write port enable
   );

   // End of BRAM_SDP_MACRO_inst instantiation
				</Template>
				<Template label="Single Port RAM (BRAM_SINGLE_MACRO)" treetype="template">
// BRAM_SINGLE_MACRO : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BRAM_SINGLE_MACRO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BRAM_SINGLE_MACRO: Single Port RAM
   //                    Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   /////////////////////////////////////////////////////////////////////
   //  READ_WIDTH | BRAM_SIZE | READ Depth  | ADDR Width |            //
   // WRITE_WIDTH |           | WRITE Depth |            |  WE Width  //
   // ============|===========|=============|============|============//
   //    37-72    |  "36Kb"   |      512    |    9-bit   |    8-bit   //
   //    19-36    |  "36Kb"   |     1024    |   10-bit   |    4-bit   //
   //    19-36    |  "18Kb"   |      512    |    9-bit   |    4-bit   //
   //    10-18    |  "36Kb"   |     2048    |   11-bit   |    2-bit   //
   //    10-18    |  "18Kb"   |     1024    |   10-bit   |    2-bit   //
   //     5-9     |  "36Kb"   |     4096    |   12-bit   |    1-bit   //
   //     5-9     |  "18Kb"   |     2048    |   11-bit   |    1-bit   //
   //     3-4     |  "36Kb"   |     8192    |   13-bit   |    1-bit   //
   //     3-4     |  "18Kb"   |     4096    |   12-bit   |    1-bit   //
   //       2     |  "36Kb"   |    16384    |   14-bit   |    1-bit   //
   //       2     |  "18Kb"   |     8192    |   13-bit   |    1-bit   //
   //       1     |  "36Kb"   |    32768    |   15-bit   |    1-bit   //
   //       1     |  "18Kb"   |    16384    |   14-bit   |    1-bit   //
   /////////////////////////////////////////////////////////////////////

   BRAM_SINGLE_MACRO #(
      .BRAM_SIZE("18Kb"), // Target BRAM, "18Kb" or "36Kb" 
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .DO_REG(0), // Optional output register (0 or 1)
      .INIT(36'h000000000), // Initial values on output port
      .INIT_FILE ("NONE"),
      .WRITE_WIDTH(0), // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .READ_WIDTH(0),  // Valid values are 1-72 (37-72 only valid when BRAM_SIZE="36Kb")
      .SRVAL(36'h000000000), // Set/Reset value for port output
      .WRITE_MODE("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE" 
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are for the parity bits
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) BRAM_SINGLE_MACRO_inst (
      .DO(DO),       // Output data, width defined by READ_WIDTH parameter
      .ADDR(ADDR),   // Input address, width defined by read/write port depth
      .CLK(CLK),     // 1-bit input clock
      .DI(DI),       // Input data port, width defined by WRITE_WIDTH parameter
      .EN(EN),       // 1-bit input RAM enable
      .REGCE(REGCE), // 1-bit input output register enable
      .RST(RST),     // 1-bit input reset
      .WE(WE)        // Input write enable, width defined by write port depth
   );

   // End of BRAM_SINGLE_MACRO_inst instantiation
				</Template>
				<Template label="Synchronous FIFO (FIFO_SYNC_MACRO)" treetype="template">
// FIFO_SYNC_MACRO : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//    instance      : in the body of the design code.  The instance name
//   declaration    : (FIFO_SYNC_MACRO_inst) and/or the port declarations within the
//      code        : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO_SYNC_MACRO: Synchronous First-In, First-Out (FIFO) RAM Buffer
   //                  Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   /////////////////////////////////////////////////////////////////
   // DATA_WIDTH | FIFO_SIZE | FIFO Depth | RDCOUNT/WRCOUNT Width //
   // ===========|===========|============|=======================//
   //   37-72    |  "36Kb"   |     512    |         9-bit         //
   //   19-36    |  "36Kb"   |    1024    |        10-bit         //
   //   19-36    |  "18Kb"   |     512    |         9-bit         //
   //   10-18    |  "36Kb"   |    2048    |        11-bit         //
   //   10-18    |  "18Kb"   |    1024    |        10-bit         //
   //    5-9     |  "36Kb"   |    4096    |        12-bit         //
   //    5-9     |  "18Kb"   |    2048    |        11-bit         //
   //    1-4     |  "36Kb"   |    8192    |        13-bit         //
   //    1-4     |  "18Kb"   |    4096    |        12-bit         //
   /////////////////////////////////////////////////////////////////

   FIFO_SYNC_MACRO  #(
      .DEVICE("7SERIES"), // Target Device: "7SERIES" 
      .ALMOST_EMPTY_OFFSET(9'h080), // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(9'h080),  // Sets almost full threshold
      .DATA_WIDTH(0), // Valid values are 1-72 (37-72 only valid when FIFO_SIZE="36Kb")
      .DO_REG(0),     // Optional output register (0 or 1)
      .FIFO_SIZE ("18Kb")  // Target BRAM: "18Kb" or "36Kb" 
   ) FIFO_SYNC_MACRO_inst (
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output almost empty
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output almost full
      .DO(DO),                   // Output data, width defined by DATA_WIDTH parameter
      .EMPTY(EMPTY),             // 1-bit output empty
      .FULL(FULL),               // 1-bit output full
      .RDCOUNT(RDCOUNT),         // Output read count, width determined by FIFO depth
      .RDERR(RDERR),             // 1-bit output read error
      .WRCOUNT(WRCOUNT),         // Output write count, width determined by FIFO depth
      .WRERR(WRERR),             // 1-bit output write error
      .CLK(CLK),                 // 1-bit input clock
      .DI(DI),                   // Input data, width defined by DATA_WIDTH parameter
      .RDEN(RDEN),               // 1-bit input read enable
      .RST(RST),                 // 1-bit input reset
      .WREN(WREN)                // 1-bit input write enable
    );

   // End of FIFO_SYNC_MACRO_inst instantiation
				</Template>
				<Template label="True Dual Port RAM (BRAM_TDP_MACRO)" treetype="template">
// BRAM_TDP_MACRO : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BRAM_TDP_MACRO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BRAM_TDP_MACRO: True Dual Port RAM
   //                 Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   //////////////////////////////////////////////////////////////////////////
   // DATA_WIDTH_A/B | BRAM_SIZE | RAM Depth | ADDRA/B Width | WEA/B Width //
   // ===============|===========|===========|===============|=============//
   //     19-36      |  "36Kb"   |    1024   |    10-bit     |    4-bit    //
   //     10-18      |  "36Kb"   |    2048   |    11-bit     |    2-bit    //
   //     10-18      |  "18Kb"   |    1024   |    10-bit     |    2-bit    //
   //      5-9       |  "36Kb"   |    4096   |    12-bit     |    1-bit    //
   //      5-9       |  "18Kb"   |    2048   |    11-bit     |    1-bit    //
   //      3-4       |  "36Kb"   |    8192   |    13-bit     |    1-bit    //
   //      3-4       |  "18Kb"   |    4096   |    12-bit     |    1-bit    //
   //        2       |  "36Kb"   |   16384   |    14-bit     |    1-bit    //
   //        2       |  "18Kb"   |    8192   |    13-bit     |    1-bit    //
   //        1       |  "36Kb"   |   32768   |    15-bit     |    1-bit    //
   //        1       |  "18Kb"   |   16384   |    14-bit     |    1-bit    //
   //////////////////////////////////////////////////////////////////////////

   BRAM_TDP_MACRO #(
      .BRAM_SIZE("18Kb"), // Target BRAM: "18Kb" or "36Kb" 
      .DEVICE("7SERIES"), // Target device: "7SERIES" 
      .DOA_REG(0),        // Optional port A output register (0 or 1)
      .DOB_REG(0),        // Optional port B output register (0 or 1)
      .INIT_A(36'h0000000),  // Initial values on port A output port
      .INIT_B(36'h00000000), // Initial values on port B output port
      .INIT_FILE ("NONE"),
      .READ_WIDTH_A (0),   // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .READ_WIDTH_B (0),   // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .SIM_COLLISION_CHECK ("ALL"), // Collision check enable "ALL", "WARNING_ONLY", 
                                    //   "GENERATE_X_ONLY" or "NONE" 
      .SRVAL_A(36'h00000000), // Set/Reset value for port A output
      .SRVAL_B(36'h00000000), // Set/Reset value for port B output
      .WRITE_MODE_A("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE" 
      .WRITE_MODE_B("WRITE_FIRST"), // "WRITE_FIRST", "READ_FIRST", or "NO_CHANGE" 
      .WRITE_WIDTH_A(0), // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .WRITE_WIDTH_B(0), // Valid values are 1-36 (19-36 only valid when BRAM_SIZE="36Kb")
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INIT_xx are valid when configured as 36Kb
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
     
      // The next set of INITP_xx are for the parity bits
      .INIT_FF(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      
      // The next set of INITP_xx are valid when configured as 36Kb
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) BRAM_TDP_MACRO_inst (
      .DOA(DOA),       // Output port-A data, width defined by READ_WIDTH_A parameter
      .DOB(DOB),       // Output port-B data, width defined by READ_WIDTH_B parameter
      .ADDRA(ADDRA),   // Input port-A address, width defined by Port A depth
      .ADDRB(ADDRB),   // Input port-B address, width defined by Port B depth
      .CLKA(CLKA),     // 1-bit input port-A clock
      .CLKB(CLKB),     // 1-bit input port-B clock
      .DIA(DIA),       // Input port-A data, width defined by WRITE_WIDTH_A parameter
      .DIB(DIB),       // Input port-B data, width defined by WRITE_WIDTH_B parameter
      .ENA(ENA),       // 1-bit input port-A enable
      .ENB(ENB),       // 1-bit input port-B enable
      .REGCEA(REGCEA), // 1-bit input port-A output register enable
      .REGCEB(REGCEB), // 1-bit input port-B output register enable
      .RSTA(RSTA),     // 1-bit input port-A reset
      .RSTB(RSTB),     // 1-bit input port-B reset
      .WEA(WEA),       // Input port-A write enable, width defined by Port A depth
      .WEB(WEB)        // Input port-B write enable, width defined by Port B depth
   );

   // End of BRAM_TDP_MACRO_inst instantiation
				</Template>
			</SubFolder>
		</SubFolder>
	</Folder>
	<Folder label="Device Primitive Instantiation" treetype="folder">
		<SubFolder label="Artix-7" treetype="folder">
			<SubFolder label="Advanced" treetype="folder">
				<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE2)" treetype="template">
// IBUFDS_GTE2 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_GTE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_GTE2: Gigabit Transceiver Buffer
   //              Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE2 #(
      .CLKCM_CFG("TRUE"),   // Refer to Transceiver User Guide
      .CLKRCV_TRST("TRUE"), // Refer to Transceiver User Guide
      .CLKSWING_CFG(2'b11)  // Refer to Transceiver User Guide
   )
   IBUFDS_GTE2_inst (
      .O(O),         // 1-bit output: Refer to Transceiver User Guide
      .ODIV2(ODIV2), // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),     // 1-bit input: Refer to Transceiver User Guide
      .I(I),         // 1-bit input: Refer to Transceiver User Guide
      .IB(IB)        // 1-bit input: Refer to Transceiver User Guide
   );

   // End of IBUFDS_GTE2_inst instantiation
				</Template>
				<Template label="XADC Simulation File" treetype="template">
// Must use valid headers on all columns
// Comments can be added to the stimulus file using '//'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

// Time stamp data is in nano seconds (ns)
// Temperature is recorded in C (degrees centigrade)
// All other channels are recorded as V (Volts)
// Valid column headers are:
// TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
// VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
// External analog inputs are differential so VP = 0.5 and VN = 0.1 the
// input on channel VP/VN in 0.5 - 0.1 = 0.4V
				</Template>
				<Template label="Xilinx Analog-to-Digital Converter (XADC)" treetype="template">
//    XADC     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (XADC_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // XADC: Dual 12-Bit 1MSPS Analog-to-Digital Converter
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   XADC #(
      // INIT_40 - INIT_42: XADC configuration registers
      .INIT_40(16'h0000),
      .INIT_41(16'h0000),
      .INIT_42(16'h0800),
      // INIT_48 - INIT_4F: Sequence Registers
      .INIT_48(16'h0000),
      .INIT_49(16'h0000),
      .INIT_4A(16'h0000),
      .INIT_4B(16'h0000),
      .INIT_4C(16'h0000),
      .INIT_4D(16'h0000),
      .INIT_4F(16'h0000),
      .INIT_4E(16'h0000),                // Sequence register 6
      // INIT_50 - INIT_58, INIT5C: Alarm Limit Registers
      .INIT_50(16'h0000),
      .INIT_51(16'h0000),
      .INIT_52(16'h0000),
      .INIT_53(16'h0000),
      .INIT_54(16'h0000),
      .INIT_55(16'h0000),
      .INIT_56(16'h0000),
      .INIT_57(16'h0000),
      .INIT_58(16'h0000),
      .INIT_5C(16'h0000),
      // Simulation attributes: Set for proper simulation behavior
      .SIM_DEVICE("7SERIES"),            // Select target device (values)
      .SIM_MONITOR_FILE("design.txt")  // Analog simulation data file name
   )
   XADC_inst (
      // ALARMS: 8-bit (each) output: ALM, OT
      .ALM(ALM),                   // 8-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      .OT(OT),                     // 1-bit output: Over-Temperature alarm
      // Dynamic Reconfiguration Port (DRP): 16-bit (each) output: Dynamic Reconfiguration Ports
      .DO(DO),                     // 16-bit output: DRP output data bus
      .DRDY(DRDY),                 // 1-bit output: DRP data ready
      // STATUS: 1-bit (each) output: XADC status ports
      .BUSY(BUSY),                 // 1-bit output: ADC busy output
      .CHANNEL(CHANNEL),           // 5-bit output: Channel selection outputs
      .EOC(EOC),                   // 1-bit output: End of Conversion
      .EOS(EOS),                   // 1-bit output: End of Sequence
      .JTAGBUSY(JTAGBUSY),         // 1-bit output: JTAG DRP transaction in progress output
      .JTAGLOCKED(JTAGLOCKED),     // 1-bit output: JTAG requested DRP port lock
      .JTAGMODIFIED(JTAGMODIFIED), // 1-bit output: JTAG Write to the DRP has occurred
      .MUXADDR(MUXADDR),           // 5-bit output: External MUX channel decode
      // Auxiliary Analog-Input Pairs: 16-bit (each) input: VAUXP[15:0], VAUXN[15:0]
      .VAUXN(VAUXN),               // 16-bit input: N-side auxiliary analog input
      .VAUXP(VAUXP),               // 16-bit input: P-side auxiliary analog input
      // CONTROL and CLOCK: 1-bit (each) input: Reset, conversion start and clock inputs
      .CONVST(CONVST),             // 1-bit input: Convert start input
      .CONVSTCLK(CONVSTCLK),       // 1-bit input: Convert start input
      .RESET(RESET),               // 1-bit input: Active-high reset
      // Dedicated Analog Input Pair: 1-bit (each) input: VP/VN
      .VN(VN),                     // 1-bit input: N-side analog input
      .VP(VP),                     // 1-bit input: P-side analog input
      // Dynamic Reconfiguration Port (DRP): 7-bit (each) input: Dynamic Reconfiguration Ports
      .DADDR(DADDR),               // 7-bit input: DRP address bus
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable signal
      .DI(DI),                     // 16-bit input: DRP input data bus
      .DWE(DWE)                    // 1-bit input: DRP write enable
   );

   // End of XADC_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Arithmetic Functions" treetype="folder">
				<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E1)" treetype="template">
//   DSP48E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DSP48E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DSP48E1: 48-bit Multi-Functional Arithmetic Block
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   DSP48E1 #(
      // Feature Control Attributes: Data Path Selection
      .A_INPUT("DIRECT"),               // Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      .B_INPUT("DIRECT"),               // Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      .USE_DPORT("FALSE"),              // Select D port usage (TRUE or FALSE)
      .USE_MULT("MULTIPLY"),            // Select multiplier usage ("MULTIPLY", "DYNAMIC", or "NONE")
      .USE_SIMD("ONE48"),               // SIMD selection ("ONE48", "TWO24", "FOUR12")
      // Pattern Detector Attributes: Pattern Detection Configuration
      .AUTORESET_PATDET("NO_RESET"),    // "NO_RESET", "RESET_MATCH", "RESET_NOT_MATCH" 
      .MASK(48'h3fffffffffff),          // 48-bit mask value for pattern detect (1=ignore)
      .PATTERN(48'h000000000000),       // 48-bit pattern match for pattern detect
      .SEL_MASK("MASK"),                // "C", "MASK", "ROUNDING_MODE1", "ROUNDING_MODE2" 
      .SEL_PATTERN("PATTERN"),          // Select pattern value ("PATTERN" or "C")
      .USE_PATTERN_DETECT("NO_PATDET"), // Enable pattern detect ("PATDET" or "NO_PATDET")
      // Register Control Attributes: Pipeline Register Configuration
      .ACASCREG(1),                     // Number of pipeline stages between A/ACIN and ACOUT (0, 1 or 2)
      .ADREG(1),                        // Number of pipeline stages for pre-adder (0 or 1)
      .ALUMODEREG(1),                   // Number of pipeline stages for ALUMODE (0 or 1)
      .AREG(1),                         // Number of pipeline stages for A (0, 1 or 2)
      .BCASCREG(1),                     // Number of pipeline stages between B/BCIN and BCOUT (0, 1 or 2)
      .BREG(1),                         // Number of pipeline stages for B (0, 1 or 2)
      .CARRYINREG(1),                   // Number of pipeline stages for CARRYIN (0 or 1)
      .CARRYINSELREG(1),                // Number of pipeline stages for CARRYINSEL (0 or 1)
      .CREG(1),                         // Number of pipeline stages for C (0 or 1)
      .DREG(1),                         // Number of pipeline stages for D (0 or 1)
      .INMODEREG(1),                    // Number of pipeline stages for INMODE (0 or 1)
      .MREG(1),                         // Number of multiplier pipeline stages (0 or 1)
      .OPMODEREG(1),                    // Number of pipeline stages for OPMODE (0 or 1)
      .PREG(1)                          // Number of pipeline stages for P (0 or 1)
   )
   DSP48E1_inst (
      // Cascade: 30-bit (each) output: Cascade Ports
      .ACOUT(ACOUT),                   // 30-bit output: A port cascade output
      .BCOUT(BCOUT),                   // 18-bit output: B port cascade output
      .CARRYCASCOUT(CARRYCASCOUT),     // 1-bit output: Cascade carry output
      .MULTSIGNOUT(MULTSIGNOUT),       // 1-bit output: Multiplier sign cascade output
      .PCOUT(PCOUT),                   // 48-bit output: Cascade output
      // Control: 1-bit (each) output: Control Inputs/Status Bits
      .OVERFLOW(OVERFLOW),             // 1-bit output: Overflow in add/acc output
      .PATTERNBDETECT(PATTERNBDETECT), // 1-bit output: Pattern bar detect output
      .PATTERNDETECT(PATTERNDETECT),   // 1-bit output: Pattern detect output
      .UNDERFLOW(UNDERFLOW),           // 1-bit output: Underflow in add/acc output
      // Data: 4-bit (each) output: Data Ports
      .CARRYOUT(CARRYOUT),             // 4-bit output: Carry output
      .P(P),                           // 48-bit output: Primary data output
      // Cascade: 30-bit (each) input: Cascade Ports
      .ACIN(ACIN),                     // 30-bit input: A cascade data input
      .BCIN(BCIN),                     // 18-bit input: B cascade input
      .CARRYCASCIN(CARRYCASCIN),       // 1-bit input: Cascade carry input
      .MULTSIGNIN(MULTSIGNIN),         // 1-bit input: Multiplier sign input
      .PCIN(PCIN),                     // 48-bit input: P cascade input
      // Control: 4-bit (each) input: Control Inputs/Status Bits
      .ALUMODE(ALUMODE),               // 4-bit input: ALU control input
      .CARRYINSEL(CARRYINSEL),         // 3-bit input: Carry select input
      .CLK(CLK),                       // 1-bit input: Clock input
      .INMODE(INMODE),                 // 5-bit input: INMODE control input
      .OPMODE(OPMODE),                 // 7-bit input: Operation mode input
      // Data: 30-bit (each) input: Data Ports
      .A(A),                           // 30-bit input: A data input
      .B(B),                           // 18-bit input: B data input
      .C(C),                           // 48-bit input: C data input
      .CARRYIN(CARRYIN),               // 1-bit input: Carry input signal
      .D(D),                           // 25-bit input: D data input
      // Reset/Clock Enable: 1-bit (each) input: Reset/Clock Enable Inputs
      .CEA1(CEA1),                     // 1-bit input: Clock enable input for 1st stage AREG
      .CEA2(CEA2),                     // 1-bit input: Clock enable input for 2nd stage AREG
      .CEAD(CEAD),                     // 1-bit input: Clock enable input for ADREG
      .CEALUMODE(CEALUMODE),           // 1-bit input: Clock enable input for ALUMODE
      .CEB1(CEB1),                     // 1-bit input: Clock enable input for 1st stage BREG
      .CEB2(CEB2),                     // 1-bit input: Clock enable input for 2nd stage BREG
      .CEC(CEC),                       // 1-bit input: Clock enable input for CREG
      .CECARRYIN(CECARRYIN),           // 1-bit input: Clock enable input for CARRYINREG
      .CECTRL(CECTRL),                 // 1-bit input: Clock enable input for OPMODEREG and CARRYINSELREG
      .CED(CED),                       // 1-bit input: Clock enable input for DREG
      .CEINMODE(CEINMODE),             // 1-bit input: Clock enable input for INMODEREG
      .CEM(CEM),                       // 1-bit input: Clock enable input for MREG
      .CEP(CEP),                       // 1-bit input: Clock enable input for PREG
      .RSTA(RSTA),                     // 1-bit input: Reset input for AREG
      .RSTALLCARRYIN(RSTALLCARRYIN),   // 1-bit input: Reset input for CARRYINREG
      .RSTALUMODE(RSTALUMODE),         // 1-bit input: Reset input for ALUMODEREG
      .RSTB(RSTB),                     // 1-bit input: Reset input for BREG
      .RSTC(RSTC),                     // 1-bit input: Reset input for CREG
      .RSTCTRL(RSTCTRL),               // 1-bit input: Reset input for OPMODEREG and CARRYINSELREG
      .RSTD(RSTD),                     // 1-bit input: Reset input for DREG and ADREG
      .RSTINMODE(RSTINMODE),           // 1-bit input: Reset input for INMODEREG
      .RSTM(RSTM),                     // 1-bit input: Reset input for MREG
      .RSTP(RSTP)                      // 1-bit input: Reset input for PREG
   );

   // End of DSP48E1_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Clock Components" treetype="folder">
				<SubFolder label="Clock Buffers" treetype="folder">
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
//  BUFGCE_1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_1: Global Clock Buffer with Clock Enable and Output State 1
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_1 BUFGCE_1_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock enable input for I0
      .I(I)    // 1-bit input: Primary clock
   );

   // End of BUFGCE_1_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
//   BUFGCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE: Global Clock Buffer with Clock Enable
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE BUFGCE_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock enable input for I0
      .I(I)    // 1-bit input: Primary clock
   );

   // End of BUFGCE_inst instantiation
					</Template>
					<Template label="Global Clock Simple Buffer (BUFG)" treetype="template">
//    BUFG     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG: Global Clock Simple Buffer
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFG BUFG_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFG_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer (BUFH)" treetype="template">
//    BUFH     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFH_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFH: HROW Clock Buffer for a Single Clocking Region
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFH BUFH_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFH_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer with Clock Enable (BUFHCE)" treetype="template">
//   BUFHCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFHCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFHCE: HROW Clock Buffer for a Single Clocking Region with Clock Enable
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFHCE #(
      .CE_TYPE("SYNC"), // "SYNC" (glitchless switching) or "ASYNC" (immediate switch)
      .INIT_OUT(0)      // Initial output value (0-1)
   )
   BUFHCE_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Active high enable
      .I(I)    // 1-bit input: Clock input
   );

   // End of BUFHCE_inst instantiation
					</Template>
					<Template label="I/O Clock Buffer (BUFIO)" treetype="template">
//    BUFIO    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFIO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFIO: Local Clock Buffer for I/O
   //        Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFIO BUFIO_inst (
      .O(O), // 1-bit output: Clock output (connect to I/O clock loads).
      .I(I)  // 1-bit input: Clock input (connect to an IBUF or BUFMR).
   );

   // End of BUFIO_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer (BUFMR)" treetype="template">
//    BUFMR    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFMR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFMR: Multi-Region Clock Buffer
   //        Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFMR BUFMR_inst (
      .O(O), // 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      .I(I)  // 1-bit input: Clock input (Connect to IBUF)
   );

   // End of BUFMR_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer with Clock Enable (BUFMRCE)" treetype="template">
//   BUFMRCE   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFMRCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFMRCE: Multi-Region Clock Buffer with Clock Enable
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFMRCE #(
      .CE_TYPE("SYNC"), // SYNC, ASYNC
      .INIT_OUT(0)      // Initial output and stopped polarity, (0-1)
   )
   BUFMRCE_inst (
      .O(O),   // 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      .CE(CE), // 1-bit input: Active high buffer enable
      .I(I)    // 1-bit input: Clock input (Connect to IBUF)
   );

   // End of BUFMRCE_inst instantiation
					</Template>
					<Template label="Regional Clock Buffer (BUFR)" treetype="template">
//    BUFR     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFR: Regional Clock Buffer for I/O and Logic Resources within a Clock Region
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFR #(
      .BUFR_DIVIDE("BYPASS"),   // Values: "BYPASS, 1, 2, 3, 4, 5, 6, 7, 8" 
      .SIM_DEVICE("7SERIES")  // Must be set to "7SERIES" 
   )
   BUFR_inst (
      .O(O),     // 1-bit output: Clock output port
      .CE(CE),   // 1-bit input: Active high, clock enable (Divided modes only)
      .CLR(CLR), // 1-bit input: Active high, asynchronous clear (Divided modes only)
      .I(I)      // 1-bit input: Clock buffer input driven by an IBUF, MMCM or local interconnect
   );

   // End of BUFR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Clock MUXes" treetype="folder">
					<Template label="2-to-1 Global Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
// BUFGMUX_CTRL : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_CTRL: 2-to-1 Global Clock MUX Buffer
   //               Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL BUFGMUX_CTRL_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="Global Clock Control Buffer (BUFGCTRL)" treetype="template">
//  BUFGCTRL   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCTRL: Global Clock Control Buffer
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGCTRL #(
      .INIT_OUT(0),           // Initial value of BUFGCTRL output ($VALUES;)
      .PRESELECT_I0("FALSE"), // BUFGCTRL output uses I0 input ($VALUES;)
      .PRESELECT_I1("FALSE")  // BUFGCTRL output uses I1 input ($VALUES;)
   )
   BUFGCTRL_inst (
      .O(O),             // 1-bit output: Clock output
      .CE0(CE0),         // 1-bit input: Clock enable input for I0
      .CE1(CE1),         // 1-bit input: Clock enable input for I1
      .I0(I0),           // 1-bit input: Primary clock
      .I1(I1),           // 1-bit input: Secondary clock
      .IGNORE0(IGNORE0), // 1-bit input: Clock ignore input for I0
      .IGNORE1(IGNORE1), // 1-bit input: Clock ignore input for I1
      .S0(S0),           // 1-bit input: Clock select for I0
      .S1(S1)            // 1-bit input: Clock select for I1
   );

   // End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer (BUFGMUX)" treetype="template">
//   BUFGMUX   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX: Global Clock Mux Buffer
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX #(
   )
   BUFGMUX_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
//  BUFGMUX_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_1: Global Clock Mux Buffer with Output State 1
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1 #(
   )
   BUFGMUX_1_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MMCM / PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCME2_ADV)" treetype="template">
// MMCME2_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME2_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME2_ADV: Advanced Mixed Mode Clock Manager
   //             Artix-7
   // Xilinx HDL Language Template, version 2016.4

   MMCME2_ADV #(
      .BANDWIDTH("OPTIMIZED"),        // Jitter programming (OPTIMIZED, HIGH, LOW)
      .CLKFBOUT_MULT_F(5.0),          // Multiply value for all CLKOUT (2.000-64.000).
      .CLKFBOUT_PHASE(0.0),           // Phase offset in degrees of CLKFB (-360.000-360.000).
      // CLKIN_PERIOD: Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      // CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT0_DIVIDE_F(1.0),         // Divide amount for CLKOUT0 (1.000-128.000).
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.01-0.99).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      .CLKOUT4_CASCADE("FALSE"),      // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .COMPENSATION("ZHOLD"),         // ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      .DIVCLK_DIVIDE(1),              // Master division value (1-106)
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE"),         // Delays DONE until MMCM is locked (FALSE, TRUE)
      // Spread Spectrum: Spread Spectrum Attributes
      .SS_EN("FALSE"),                // Enables spread spectrum (FALSE, TRUE)
      .SS_MODE("CENTER_HIGH"),        // CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      .SS_MOD_PERIOD(10000),          // Spread spectrum modulation period (ns) (VALUES)
      // USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      .CLKFBOUT_USE_FINE_PS("FALSE"),
      .CLKOUT0_USE_FINE_PS("FALSE"),
      .CLKOUT1_USE_FINE_PS("FALSE"),
      .CLKOUT2_USE_FINE_PS("FALSE"),
      .CLKOUT3_USE_FINE_PS("FALSE"),
      .CLKOUT4_USE_FINE_PS("FALSE"),
      .CLKOUT5_USE_FINE_PS("FALSE"),
      .CLKOUT6_USE_FINE_PS("FALSE") 
   )
   MMCME2_ADV_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),           // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),         // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),           // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),         // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),           // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),         // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),           // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),         // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),           // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),           // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),           // 1-bit output: CLKOUT6
      // DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      .DO(DO),                     // 16-bit output: DRP data
      .DRDY(DRDY),                 // 1-bit output: DRP ready
      // Dynamic Phase Shift Ports: 1-bit (each) output: Ports used for dynamic phase shifting of the outputs
      .PSDONE(PSDONE),             // 1-bit output: Phase shift done
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),         // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB),       // 1-bit output: Inverted CLKFBOUT
      // Status Ports: 1-bit (each) output: MMCM status ports
      .CLKFBSTOPPED(CLKFBSTOPPED), // 1-bit output: Feedback clock stopped
      .CLKINSTOPPED(CLKINSTOPPED), // 1-bit output: Input clock stopped
      .LOCKED(LOCKED),             // 1-bit output: LOCK
      // Clock Inputs: 1-bit (each) input: Clock inputs
      .CLKIN1(CLKIN1),             // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),             // 1-bit input: Secondary clock
      // Control Ports: 1-bit (each) input: MMCM control ports
      .CLKINSEL(CLKINSEL),         // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),             // 1-bit input: Power-down
      .RST(RST),                   // 1-bit input: Reset
      // DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      .DADDR(DADDR),               // 7-bit input: DRP address
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable
      .DI(DI),                     // 16-bit input: DRP data
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // Dynamic Phase Shift Ports: 1-bit (each) input: Ports used for dynamic phase shifting of the outputs
      .PSCLK(PSCLK),               // 1-bit input: Phase shift clock
      .PSEN(PSEN),                 // 1-bit input: Phase shift enable
      .PSINCDEC(PSINCDEC),         // 1-bit input: Phase shift increment/decrement
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)            // 1-bit input: Feedback clock
   );

   // End of MMCME2_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase Locked Loop (PLLE2_ADV)" treetype="template">
//  PLLE2_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE2_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE2_ADV: Advanced Phase Locked Loop (PLL)
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   PLLE2_ADV #(
      .BANDWIDTH("OPTIMIZED"),  // OPTIMIZED, HIGH, LOW
      .CLKFBOUT_MULT(5),        // Multiply value for all CLKOUT, (2-64)
      .CLKFBOUT_PHASE(0.0),     // Phase offset in degrees of CLKFB, (-360.000-360.000).
      // CLKIN_PERIOD: Input clock period in nS to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      // CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT0_DIVIDE(1),
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      // CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .COMPENSATION("ZHOLD"),   // ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      .DIVCLK_DIVIDE(1),        // Master division value (1-56)
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE")    // Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   PLLE2_ADV_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),   // 1-bit output: CLKOUT0
      .CLKOUT1(CLKOUT1),   // 1-bit output: CLKOUT1
      .CLKOUT2(CLKOUT2),   // 1-bit output: CLKOUT2
      .CLKOUT3(CLKOUT3),   // 1-bit output: CLKOUT3
      .CLKOUT4(CLKOUT4),   // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),   // 1-bit output: CLKOUT5
      // DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      .DO(DO),             // 16-bit output: DRP data
      .DRDY(DRDY),         // 1-bit output: DRP ready
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT), // 1-bit output: Feedback clock
      .LOCKED(LOCKED),     // 1-bit output: LOCK
      // Clock Inputs: 1-bit (each) input: Clock inputs
      .CLKIN1(CLKIN1),     // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),     // 1-bit input: Secondary clock
      // Control Ports: 1-bit (each) input: PLL control ports
      .CLKINSEL(CLKINSEL), // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),     // 1-bit input: Power-down
      .RST(RST),           // 1-bit input: Reset
      // DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      .DADDR(DADDR),       // 7-bit input: DRP address
      .DCLK(DCLK),         // 1-bit input: DRP clock
      .DEN(DEN),           // 1-bit input: DRP enable
      .DI(DI),             // 16-bit input: DRP data
      .DWE(DWE),           // 1-bit input: DRP write enable
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)    // 1-bit input: Feedback clock
   );

   // End of PLLE2_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCME2_BASE)" treetype="template">
// MMCME2_BASE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME2_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME2_BASE: Base Mixed Mode Clock Manager
   //              Artix-7
   // Xilinx HDL Language Template, version 2016.4

   MMCME2_BASE #(
      .BANDWIDTH("OPTIMIZED"),   // Jitter programming (OPTIMIZED, HIGH, LOW)
      .CLKFBOUT_MULT_F(5.0),     // Multiply value for all CLKOUT (2.000-64.000).
      .CLKFBOUT_PHASE(0.0),      // Phase offset in degrees of CLKFB (-360.000-360.000).
      .CLKIN1_PERIOD(0.0),       // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT0_DIVIDE_F(1.0),    // Divide amount for CLKOUT0 (1.000-128.000).
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.01-0.99).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      .CLKOUT4_CASCADE("FALSE"), // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .DIVCLK_DIVIDE(1),         // Master division value (1-106)
      .REF_JITTER1(0.0),         // Reference input jitter in UI (0.000-0.999).
      .STARTUP_WAIT("FALSE")     // Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   MMCME2_BASE_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),     // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),     // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),   // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT
      // Status Ports: 1-bit (each) output: MMCM status ports
      .LOCKED(LOCKED),       // 1-bit output: LOCK
      // Clock Inputs: 1-bit (each) input: Clock input
      .CLKIN1(CLKIN1),       // 1-bit input: Clock
      // Control Ports: 1-bit (each) input: MMCM control ports
      .PWRDWN(PWRDWN),       // 1-bit input: Power-down
      .RST(RST),             // 1-bit input: Reset
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)      // 1-bit input: Feedback clock
   );

   // End of MMCME2_BASE_inst instantiation
					</Template>
					<Template label="Base Phase Locked Loop (PLLE2_BASE)" treetype="template">
// PLLE2_BASE  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE2_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE2_BASE: Base Phase Locked Loop (PLL)
   //             Artix-7
   // Xilinx HDL Language Template, version 2016.4

   PLLE2_BASE #(
      .BANDWIDTH("OPTIMIZED"),  // OPTIMIZED, HIGH, LOW
      .CLKFBOUT_MULT(5),        // Multiply value for all CLKOUT, (2-64)
      .CLKFBOUT_PHASE(0.0),     // Phase offset in degrees of CLKFB, (-360.000-360.000).
      .CLKIN1_PERIOD(0.0),      // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT0_DIVIDE(1),
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      // CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .DIVCLK_DIVIDE(1),        // Master division value, (1-56)
      .REF_JITTER1(0.0),        // Reference input jitter in UI, (0.000-0.999).
      .STARTUP_WAIT("FALSE")    // Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   PLLE2_BASE_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),   // 1-bit output: CLKOUT0
      .CLKOUT1(CLKOUT1),   // 1-bit output: CLKOUT1
      .CLKOUT2(CLKOUT2),   // 1-bit output: CLKOUT2
      .CLKOUT3(CLKOUT3),   // 1-bit output: CLKOUT3
      .CLKOUT4(CLKOUT4),   // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),   // 1-bit output: CLKOUT5
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT), // 1-bit output: Feedback clock
      .LOCKED(LOCKED),     // 1-bit output: LOCK
      .CLKIN1(CLKIN1),     // 1-bit input: Input clock
      // Control Ports: 1-bit (each) input: PLL control ports
      .PWRDWN(PWRDWN),     // 1-bit input: Power-down
      .RST(RST),           // 1-bit input: Reset
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)    // 1-bit input: Feedback clock
   );

   // End of PLLE2_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Config/BSCAN Components" treetype="folder">
				<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
//  EFUSE_USR  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (EFUSE_USR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EFUSE_USR: 32-bit non-volatile design ID
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   EFUSE_USR #(
      .SIM_EFUSE_VALUE(32'h00000000)  // Value of the 32-bit non-volatile value used in simulation
   )
   EFUSE_USR_inst (
      .EFUSEUSR(EFUSEUSR)  // 32-bit output: User eFUSE register value output
   );

   // End of EFUSE_USR_inst instantiation
				</Template>
				<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
//   BSCANE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BSCANE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BSCANE2: Boundary-Scan User Instruction
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   BSCANE2 #(
      .JTAG_CHAIN(1)  // Value for USER command.
   )
   BSCANE2_inst (
      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.
      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                         // SHIFT are asserted.

      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.
      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      .SEL(SEL),         // 1-bit output: USER instruction active output.
      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.
      .TCK(TCK),         // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.
      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.
      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller
      .TDO(TDO)          // 1-bit input: Test Data Output (TDO) input for USER function.
   );

   // End of BSCANE2_inst instantiation
				</Template>
				<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
// USR_ACCESSE2 : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (USR_ACCESSE2_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // USR_ACCESSE2: Configuration Data Access
   //               Artix-7
   // Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2 USR_ACCESSE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration Clock output
      .DATA(DATA),           // 32-bit output: Configuration Data output
      .DATAVALID(DATAVALID)  // 1-bit output: Active high data valid output
   );

   // End of USR_ACCESSE2_inst instantiation
				</Template>
				<Template label="Configuration Frame Error Correction (FRAME_ECCE2)" treetype="template">
// FRAME_ECCE2 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FRAME_ECCE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FRAME_ECCE2: Configuration Frame Error Correction
   //              Artix-7
   // Xilinx HDL Language Template, version 2016.4

   FRAME_ECCE2 #(
      .FARSRC("EFAR"),                // Determines if the output of FAR[25:0] configuration register points to
                                      // the FAR or EFAR. Sets configuration option register bit CTL0[7].
      .FRAME_RBT_IN_FILENAME("None")  // This file is output by the ICAP_E2 model and it contains Frame Data
                                      // information for the Raw Bitstream (RBT) file. The FRAME_ECCE2 model
                                      // will parse this file, calculate ECC and output any error conditions.
   )
   FRAME_ECCE2_inst (
      .CRCERROR(CRCERROR),             // 1-bit output: Output indicating a CRC error.
      .ECCERROR(ECCERROR),             // 1-bit output: Output indicating an ECC error.
      .ECCERRORSINGLE(ECCERRORSINGLE), // 1-bit output: Output Indicating single-bit Frame ECC error detected.
      .FAR(FAR),                       // 26-bit output: Frame Address Register Value output.
      .SYNBIT(SYNBIT),                 // 5-bit output: Output bit address of error.
      .SYNDROME(SYNDROME),             // 13-bit output: Output location of erroneous bit.
      .SYNDROMEVALID(SYNDROMEVALID),   // 1-bit output: Frame ECC output indicating the SYNDROME output is
                                       // valid.

      .SYNWORD(SYNWORD)                // 7-bit output: Word output in the frame where an ECC error has been
                                       // detected.

   );

   // End of FRAME_ECCE2_inst instantiation
				</Template>
				<Template label="Device DNA Access Port (DNA_PORT)" treetype="template">
//  DNA_PORT   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DNA_PORT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DNA_PORT: Device DNA Access Port
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   DNA_PORT #(
      .SIM_DNA_VALUE(57'h000000000000000)  // Specifies a sample 57-bit DNA value for simulation
   )
   DNA_PORT_inst (
      .DOUT(DOUT),   // 1-bit output: DNA output data.
      .CLK(CLK),     // 1-bit input: Clock input.
      .DIN(DIN),     // 1-bit input: User data input pin.
      .READ(READ),   // 1-bit input: Active high load DNA, active low read input.
      .SHIFT(SHIFT)  // 1-bit input: Active high shift enable input.
   );

   // End of DNA_PORT_inst instantiation
				</Template>
				<Template label="Internal Configuration Access Port (ICAPE2)" treetype="template">
//   ICAPE2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ICAPE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ICAPE2: Internal Configuration Access Port
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   ICAPE2 #(
      .DEVICE_ID(0'h3651093),     // Specifies the pre-programmed Device ID value to be used for simulation
                                  // purposes.
      .ICAP_WIDTH("X32"),         // Specifies the input and output data width.
      .SIM_CFG_FILE_NAME("None")  // Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                  // model.
   )
   ICAPE2_inst (
      .O(O),         // 32-bit output: Configuration data output bus
      .CLK(CLK),     // 1-bit input: Clock Input
      .CSIB(CSIB),   // 1-bit input: Active-Low ICAP Enable
      .I(I),         // 32-bit input: Configuration data input bus
      .RDWRB(RDWRB)  // 1-bit input: Read/Write Select input
   );

   // End of ICAPE2_inst instantiation
				</Template>
				<Template label="Register Capture (CAPTUREE2)" treetype="template">
//  CAPTUREE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CAPTUREE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CAPTUREE2: Register Capture
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   CAPTUREE2 #(
      .ONESHOT("TRUE")  // Specifies the procedure for performing single readback per CAP trigger.
   )
   CAPTUREE2_inst (
      .CAP(CAP), // 1-bit input: Capture Input
      .CLK(CLK)  // 1-bit input: Clock Input
   );

   // End of CAPTUREE2_inst instantiation
				</Template>
				<Template label="STARTUP Block (STARTUPE2)" treetype="template">
//  STARTUPE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (STARTUPE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // STARTUPE2: STARTUP Block
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   STARTUPE2 #(
      .PROG_USR("FALSE"),  // Activate program event security feature. Requires encrypted bitstreams.
      .SIM_CCLK_FREQ(0.0)  // Set the Configuration Clock Frequency(ns) for simulation.
   )
   STARTUPE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration main clock output
      .CFGMCLK(CFGMCLK),     // 1-bit output: Configuration internal oscillator clock output
      .EOS(EOS),             // 1-bit output: Active high output signal indicating the End Of Startup.
      .PREQ(PREQ),           // 1-bit output: PROGRAM request to fabric output
      .CLK(CLK),             // 1-bit input: User start-up clock input
      .GSR(GSR),             // 1-bit input: Global Set/Reset input (GSR cannot be used for the port name)
      .GTS(GTS),             // 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      .KEYCLEARB(KEYCLEARB), // 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      .PACK(PACK),           // 1-bit input: PROGRAM acknowledge input
      .USRCCLKO(USRCCLKO),   // 1-bit input: User CCLK input
      .USRCCLKTS(USRCCLKTS), // 1-bit input: User CCLK 3-state enable input
      .USRDONEO(USRDONEO),   // 1-bit input: User DONE pin output control
      .USRDONETS(USRDONETS)  // 1-bit input: User DONE 3-state enable output
   );

   // End of STARTUPE2_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="I/O Components" treetype="folder">
				<SubFolder label="Bi-directional Buffers" treetype="folder">
					<Template label="Differential Buffer (IOBUFDS)" treetype="template">
//     IOBUFDS   : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IOBUFDS_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS: Differential Bi-directional Buffer
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .SLEW("SLOW")            // Specify the output slew rate
   ) IOBUFDS_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ input and input termination disable (IOBUFDS_INTERMDISABLE)" treetype="template">
// IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_INTERMDISABLE: Differential Bi-directional Buffer with Input Termination
   //                        and Input path enable/disable
   //                        May only be placed in High Range (HR) Banks
   //                        Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_INTERMDISABLE #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .SLEW("SLOW"),           // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUFDS_INTERMDISABLE_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // Input disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // Input termination disable input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output (IOBUFDS_DIFF_OUT)" treetype="template">
// IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//      Verilog     : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//    declaration   : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  Delete or comment
//                  : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT: Differential Bi-directional Buffer with Differential Output
   //                   Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT #(
      .DIFF_TERM("FALSE"),    // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25") // Specify the I/O standard
   ) IOBUFDS_DIFF_OUT_inst (
      .O(O),     // Buffer p-side output
      .OB(OB),   // Buffer n-side output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .TM(TM),   // 3-state enable input, high=input, low=output
      .TS(TS)    // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Global Clock Buffer w/ Differential Output, INTERM and IBUF disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog             : the following instance declaration needs to be placed
//           instance             : in the body of the design code.  The instance name
//          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code               : parenthesis may be changed to properly reference and
//                                : connect this function to the design.  All inputs
//                                : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Global Clock Buffer with Differential Output
   //                                 Input Termination and Input Path Disable
   //                                 May only be placed in High Range (HR) Banks
   //                                 Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DIFF_TERM("FALSE"),     // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"),   // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IOBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),     // Buffer p-side output
      .OB(OB),   // Buffer n-side output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .INTERMDISABLE(INTERMDISABLE), //  Input termination disable input
      .IBUFDISABLE(IBUFDISABLE),     // Input disable input, high=disable
      .TM(TM),   // 3-state enable input, high=input, low=output
      .TS(TS)    // 3-state enable input, high=input, low=output
   );

   // End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Single-ended Buffer (IOBUF)" treetype="template">
//      IOBUF      : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IOBUF_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF: Single-ended Bi-directional Buffer
   //        All devices
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUF #(
      .DRIVE(12), // Specify the output drive strength
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("DEFAULT"), // Specify the I/O standard
      .SLEW("SLOW") // Specify the output slew rate
   ) IOBUF_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Buffer inout port (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUF_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ input and INTERM disable (IOBUF_INTERMDISABLE)" treetype="template">
// IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog       : the following instance declaration needs to be placed
//      instance       : in the body of the design code.  The instance name
//     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code         : parenthesis may be changed to properly reference and
//                     : connect this function to the design.  Delete or comment
//                     : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_INTERMDISABLE: Single-ended Bi-directional Buffer with Input Termination
   //                      and Input path enable/disable
   //                      May only be placed in High Range (HR) Banks
   //                      Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUF_INTERMDISABLE #(
      .DRIVE(12), // Specify the output drive strength
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("DEFAULT"), // Specify the I/O standard
      .SLEW("SLOW"),          // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUF_INTERMDISABLE_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Buffer inout port (connect directly to top-level port)
      .I(I),     // Buffer input
      .IBUFDISABLE(IBUFDISABLE), // Input disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // Input termination disable input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DDR Registers" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
//    IDDR_2CLK  : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   //            Set, Reset and Clock Enable.
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_2CLK_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit primary clock input
      .CB(CB), // 1-bit secondary clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_2CLK_inst instantiation
					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
//      IDDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR: Input Double Data Rate Input Register with Set, Reset
   //       and Clock Enable.
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_inst instantiation
					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
//      ODDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (ODDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // ODDR: Output Double Data Rate Output Register with Set, Reset
   //       and Clock Enable.
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   ODDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE" or "SAME_EDGE" 
      .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) ODDR_inst (
      .Q(Q),   // 1-bit DDR output
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D1(D1), // 1-bit data input (positive edge)
      .D2(D2), // 1-bit data input (negative edge)
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of ODDR_inst instantiation
					</Template>
				</SubFolder>
				<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
//  DCIRESET   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DCIRESET_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DCIRESET: Digitally Controlled Impedance Reset Component
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   DCIRESET DCIRESET_inst (
      .LOCKED(LOCKED), // 1-bit output: LOCK status output
      .RST(RST)        // 1-bit input: Active-high asynchronous reset input
   );

   // End of DCIRESET_inst instantiation
				</Template>
				<SubFolder label="FIFOs" treetype="folder">
					<Template label="Input FIFO (IN_FIFO)" treetype="template">
//   IN_FIFO   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IN_FIFO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IN_FIFO: Input First-In, First-Out (FIFO)
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IN_FIFO #(
      .ALMOST_EMPTY_VALUE(1),          // Almost empty offset (1-2)
      .ALMOST_FULL_VALUE(1),           // Almost full offset (1-2)
      .ARRAY_MODE("ARRAY_MODE_4_X_8"), // ARRAY_MODE_4_X_8, ARRAY_MODE_4_X_4
      .SYNCHRONOUS_MODE("FALSE")       // Clock synchronous (FALSE)
   )
   IN_FIFO_inst (
      // FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output: Almost empty
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output: Almost full
      .EMPTY(EMPTY),             // 1-bit output: Empty
      .FULL(FULL),               // 1-bit output: Full
      // Q0-Q9: 8-bit (each) output: FIFO Outputs
      .Q0(Q0),                   // 8-bit output: Channel 0
      .Q1(Q1),                   // 8-bit output: Channel 1
      .Q2(Q2),                   // 8-bit output: Channel 2
      .Q3(Q3),                   // 8-bit output: Channel 3
      .Q4(Q4),                   // 8-bit output: Channel 4
      .Q5(Q5),                   // 8-bit output: Channel 5
      .Q6(Q6),                   // 8-bit output: Channel 6
      .Q7(Q7),                   // 8-bit output: Channel 7
      .Q8(Q8),                   // 8-bit output: Channel 8
      .Q9(Q9),                   // 8-bit output: Channel 9
      // D0-D9: 4-bit (each) input: FIFO inputs
      .D0(D0),                   // 4-bit input: Channel 0
      .D1(D1),                   // 4-bit input: Channel 1
      .D2(D2),                   // 4-bit input: Channel 2
      .D3(D3),                   // 4-bit input: Channel 3
      .D4(D4),                   // 4-bit input: Channel 4
      .D5(D5),                   // 8-bit input: Channel 5
      .D6(D6),                   // 8-bit input: Channel 6
      .D7(D7),                   // 4-bit input: Channel 7
      .D8(D8),                   // 4-bit input: Channel 8
      .D9(D9),                   // 4-bit input: Channel 9
      // FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      .RDCLK(RDCLK),             // 1-bit input: Read clock
      .RDEN(RDEN),               // 1-bit input: Read enable
      .RESET(RESET),             // 1-bit input: Reset
      .WRCLK(WRCLK),             // 1-bit input: Write clock
      .WREN(WREN)                // 1-bit input: Write enable
   );

   // End of IN_FIFO_inst instantiation
					</Template>
					<Template label="Output FIFO (OUT_FIFO)" treetype="template">
//  OUT_FIFO   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OUT_FIFO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OUT_FIFO: Output First-In, First-Out (FIFO) Buffer
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   OUT_FIFO #(
      .ALMOST_EMPTY_VALUE(1),          // Almost empty offset (1-2)
      .ALMOST_FULL_VALUE(1),           // Almost full offset (1-2)
      .ARRAY_MODE("ARRAY_MODE_8_X_4"), // ARRAY_MODE_8_X_4, ARRAY_MODE_4_X_4
      .OUTPUT_DISABLE("FALSE"),        // Disable output (FALSE, TRUE)
      .SYNCHRONOUS_MODE("FALSE")       // Must always be set to false.
   )
   OUT_FIFO_inst (
      // FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output: Almost empty flag
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output: Almost full flag
      .EMPTY(EMPTY),             // 1-bit output: Empty flag
      .FULL(FULL),               // 1-bit output: Full flag
      // Q0-Q9: 4-bit (each) output: FIFO Outputs
      .Q0(Q0),                   // 4-bit output: Channel 0 output bus
      .Q1(Q1),                   // 4-bit output: Channel 1 output bus
      .Q2(Q2),                   // 4-bit output: Channel 2 output bus
      .Q3(Q3),                   // 4-bit output: Channel 3 output bus
      .Q4(Q4),                   // 4-bit output: Channel 4 output bus
      .Q5(Q5),                   // 8-bit output: Channel 5 output bus
      .Q6(Q6),                   // 8-bit output: Channel 6 output bus
      .Q7(Q7),                   // 4-bit output: Channel 7 output bus
      .Q8(Q8),                   // 4-bit output: Channel 8 output bus
      .Q9(Q9),                   // 4-bit output: Channel 9 output bus
      // D0-D9: 8-bit (each) input: FIFO inputs
      .D0(D0),                   // 8-bit input: Channel 0 input bus
      .D1(D1),                   // 8-bit input: Channel 1 input bus
      .D2(D2),                   // 8-bit input: Channel 2 input bus
      .D3(D3),                   // 8-bit input: Channel 3 input bus
      .D4(D4),                   // 8-bit input: Channel 4 input bus
      .D5(D5),                   // 8-bit input: Channel 5 input bus
      .D6(D6),                   // 8-bit input: Channel 6 input bus
      .D7(D7),                   // 8-bit input: Channel 7 input bus
      .D8(D8),                   // 8-bit input: Channel 8 input bus
      .D9(D9),                   // 8-bit input: Channel 9 input bus
      // FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      .RDCLK(RDCLK),             // 1-bit input: Read clock
      .RDEN(RDEN),               // 1-bit input: Read enable
      .RESET(RESET),             // 1-bit input: Active high reset
      .WRCLK(WRCLK),             // 1-bit input: Write clock
      .WREN(WREN)                // 1-bit input: Write enable
   );

   // End of OUT_FIFO_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Input Buffers" treetype="folder">
					<Template label="Differential Buffer (IBUFDS)" treetype="template">
//   IBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS: Differential Input Buffer
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS #(
      .DIFF_TERM("FALSE"),       // Differential Termination
      .IBUF_LOW_PWR("TRUE"),     // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT")     // Specify the input I/O standard
   ) IBUFDS_inst (
      .O(O),  // Buffer output
      .I(I),  // Diff_p buffer input (connect directly to top-level port)
      .IB(IB) // Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ Disable (IBUFDS_IBUFDISABLE)" treetype="template">
// IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//     instance       : in the body of the design code.  The instance name
//    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations within the
//       code         : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_IBUFDISABLE: Differential Input Buffer with Input Disable
   //                     Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE #(
      .DIFF_TERM("FALSE"),      // Differential Termination
      .IBUF_LOW_PWR("TRUE"),    // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),   // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE")  // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_IBUFDISABLE_inst (
      .O(O),   // Buffer output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE) // Buffer disable input, high=disable
   );

   // End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output (IBUFDS_DIFF_OUT)" treetype="template">
// IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT: Differential Input Buffer with Differential Output
   //                  Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT #(
      .DIFF_TERM("FALSE"),   // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"), // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT") // Specify the input I/O standard
   ) IBUFDS_DIFF_OUT_inst (
      .O(O),   // Buffer diff_p output
      .OB(OB), // Buffer diff_n output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output w/ Input Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
//           Verilog           : the following instance declaration needs to be placed
//          instance           : in the body of the design code.  The instance name
//         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations within the
//            code             : parenthesis may be changed to properly reference and
//                             : connect this function to the design.  All inputs
//                             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer with Differential Output with Input Disable
   //                              Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE #(
      .DIFF_TERM("FALSE"),     // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"),   // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_DIFF_OUT_IBUFDISABLE_inst (
      .O(O),   // Buffer diff_p output
      .OB(OB), // Buffer diff_n output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // Buffer disable input, high=disable
   );

   // End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output w/ Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog            : the following instance declaration needs to be placed
//           instance            : in the body of the design code.  The instance name
//          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code              : parenthesis may be changed to properly reference and
//                               : connect this function to the design.  All inputs
//                               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Differential Output with Input Termination Disable
   //                                May only be placed in High Range (HR) Banks
   //                                Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE  #(
      .DIFF_TERM("FALSE"),     // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"),   // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),   // Buffer diff_p output
      .OB(OB), // Buffer diff_n output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),    // Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE) // Input Termination Disable
   );

   // End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
// IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog        : the following instance declaration needs to be placed
//      instance        : in the body of the design code.  The instance name
//     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//        code          : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_INTERMDISABLE: Differential Input Buffer with Input Termination Disable
   //                       May only be placed in High Range (HR) Banks
   //                       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE #(
      .DIFF_TERM("FALSE"),      // Differential Termination
      .IBUF_LOW_PWR("TRUE"),    // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),   // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE")  // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_INTERMDISABLE_inst (
      .O(O),   // Buffer output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),    // Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE) // Input Termination Disable
   );

   // End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Single-ended Buffer (IBUF)" treetype="template">
//      IBUF       : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUF_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IBUF: Single-ended Input Buffer
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   IBUF #(
      .IBUF_LOW_PWR("TRUE"),  // Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards 
      .IOSTANDARD("DEFAULT")  // Specify the input I/O standard
   ) IBUF_inst (
      .O(O),     // Buffer output
      .I(I)      // Buffer input (connect directly to top-level port)
   );
  
   // End of IBUF_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ Disable (IBUF_IBUFDISABLE)" treetype="template">
//  IBUF_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog      : the following instance declaration needs to be placed
//     instance      : in the body of the design code.  The instance name
//    declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations within the
//       code        : parenthesis may be changed to properly reference and
//                   : connect this function to the design.  Delete or comment
//                   : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_IBUFDISABLE: Single-ended Input Buffer with Disable
   //                   Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   IBUF_IBUFDISABLE #(
      .IBUF_LOW_PWR("TRUE"),   // Low power ("TRUE") vs. performance ("FALSE") for referenced I/O standards 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUF_IBUFDISABLE_inst (
      .O(O),                    // Buffer output
      .I(I),                    // Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE) // Buffer disable input, high=disable
   );
  
   // End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
//  IBUF_INTERMDISABLE : In order to incorporate this function into the design,
//      Verilog      : the following instance declaration needs to be placed
//     instance      : in the body of the design code.  The instance name
//    declaration    : (IBUF_INTERMDISABLE_inst) and/or the port declarations within the
//       code        : parenthesis may be changed to properly reference and
//                   : connect this function to the design.  Delete or comment
//                   : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_INTERMDISABLE: Single-ended Input Buffer with Termination Input Disable
   //                     May only be placed in High Range (HR) Banks
   //                     Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   IBUF_INTERMDISABLE #(
      .IBUF_LOW_PWR("TRUE"),   // Low power ("TRUE") vs. performance ("FALSE") for referenced I/O standards 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUF_INTERMDISABLE_inst (
      .O(O),                    // Buffer output
      .I(I),                    // Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),    // Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE) // Input Termination Disable
   );
  
   // End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="I/O Delay Components" treetype="folder">
					<Template label="Delay Calibration (IDELAYCTRL)" treetype="template">
// IDELAYCTRL  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYCTRL: IDELAYE2/ODELAYE2 Tap Delay Value Control
   //             Artix-7
   // Xilinx HDL Language Template, version 2016.4

   (* IODELAY_GROUP = &lt;iodelay_group_name&gt; *) // Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

   IDELAYCTRL IDELAYCTRL_inst (
      .RDY(RDY),       // 1-bit output: Ready output
      .REFCLK(REFCLK), // 1-bit input: Reference clock input
      .RST(RST)        // 1-bit input: Active high reset input
   );

   // End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE2)" treetype="template">
//  IDELAYE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYE2: Input Fixed or Variable Delay Element
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   (* IODELAY_GROUP = &lt;iodelay_group_name&gt; *) // Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

   IDELAYE2 #(
      .CINVCTRL_SEL("FALSE"),          // Enable dynamic clock inversion (FALSE, TRUE)
      .DELAY_SRC("IDATAIN"),           // Delay input (IDATAIN, DATAIN)
      .HIGH_PERFORMANCE_MODE("FALSE"), // Reduced jitter ("TRUE"), Reduced power ("FALSE")
      .IDELAY_TYPE("FIXED"),           // FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      .IDELAY_VALUE(0),                // Input delay tap setting (0-31)
      .PIPE_SEL("FALSE"),              // Select pipelined mode, FALSE, TRUE
      .REFCLK_FREQUENCY(200.0),        // IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      .SIGNAL_PATTERN("DATA")          // DATA, CLOCK input signal
   )
   IDELAYE2_inst (
      .CNTVALUEOUT(CNTVALUEOUT), // 5-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data output
      .C(C),                     // 1-bit input: Clock input
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CINVCTRL(CINVCTRL),       // 1-bit input: Dynamic clock inversion input
      .CNTVALUEIN(CNTVALUEIN),   // 5-bit input: Counter value input
      .DATAIN(DATAIN),           // 1-bit input: Internal delay data input
      .IDATAIN(IDATAIN),         // 1-bit input: Data input from the I/O
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LD(LD),                   // 1-bit input: Load IDELAY_VALUE input
      .LDPIPEEN(LDPIPEEN),       // 1-bit input: Enable PIPELINE register to load data input
      .REGRST(REGRST)            // 1-bit input: Active-high reset tap-delay input
   );

   // End of IDELAYE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="I/O SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer with Bitslip (ISERDESE2)" treetype="template">
//  ISERDESE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ISERDESE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ISERDESE2: Input SERial/DESerializer with Bitslip
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   ISERDESE2 #(
      .DATA_RATE("DDR"),           // DDR, SDR
      .DATA_WIDTH(4),              // Parallel data width (2-8,10,14)
      .DYN_CLKDIV_INV_EN("FALSE"), // Enable DYNCLKDIVINVSEL inversion (FALSE, TRUE)
      .DYN_CLK_INV_EN("FALSE"),    // Enable DYNCLKINVSEL inversion (FALSE, TRUE)
      // INIT_Q1 - INIT_Q4: Initial value on the Q outputs (0/1)
      .INIT_Q1(1'b0),
      .INIT_Q2(1'b0),
      .INIT_Q3(1'b0),
      .INIT_Q4(1'b0),
      .INTERFACE_TYPE("MEMORY"),   // MEMORY, MEMORY_DDR3, MEMORY_QDR, NETWORKING, OVERSAMPLE
      .IOBDELAY("NONE"),           // NONE, BOTH, IBUF, IFD
      .NUM_CE(2),                  // Number of clock enables (1,2)
      .OFB_USED("FALSE"),          // Select OFB path (FALSE, TRUE)
      .SERDES_MODE("MASTER"),      // MASTER, SLAVE
      // SRVAL_Q1 - SRVAL_Q4: Q output values when SR is used (0/1)
      .SRVAL_Q1(1'b0),
      .SRVAL_Q2(1'b0),
      .SRVAL_Q3(1'b0),
      .SRVAL_Q4(1'b0) 
   )
   ISERDESE2_inst (
      .O(O),                       // 1-bit output: Combinatorial output
      // Q1 - Q8: 1-bit (each) output: Registered data outputs
      .Q1(Q1),
      .Q2(Q2),
      .Q3(Q3),
      .Q4(Q4),
      .Q5(Q5),
      .Q6(Q6),
      .Q7(Q7),
      .Q8(Q8),
      // SHIFTOUT1, SHIFTOUT2: 1-bit (each) output: Data width expansion output ports
      .SHIFTOUT1(SHIFTOUT1),
      .SHIFTOUT2(SHIFTOUT2),
      .BITSLIP(BITSLIP),           // 1-bit input: The BITSLIP pin performs a Bitslip operation synchronous to
                                   // CLKDIV when asserted (active High). Subsequently, the data seen on the Q1
                                   // to Q8 output ports will shift, as in a barrel-shifter operation, one
                                   // position every time Bitslip is invoked (DDR operation is different from
                                   // SDR).

      // CE1, CE2: 1-bit (each) input: Data register clock enable inputs
      .CE1(CE1),
      .CE2(CE2),
      .CLKDIVP(CLKDIVP),           // 1-bit input: TBD
      // Clocks: 1-bit (each) input: ISERDESE2 clock input ports
      .CLK(CLK),                   // 1-bit input: High-speed clock
      .CLKB(CLKB),                 // 1-bit input: High-speed secondary clock
      .CLKDIV(CLKDIV),             // 1-bit input: Divided clock
      .OCLK(OCLK),                 // 1-bit input: High speed output clock used when INTERFACE_TYPE="MEMORY" 
      // Dynamic Clock Inversions: 1-bit (each) input: Dynamic clock inversion pins to switch clock polarity
      .DYNCLKDIVSEL(DYNCLKDIVSEL), // 1-bit input: Dynamic CLKDIV inversion
      .DYNCLKSEL(DYNCLKSEL),       // 1-bit input: Dynamic CLK/CLKB inversion
      // Input Data: 1-bit (each) input: ISERDESE2 data input ports
      .D(D),                       // 1-bit input: Data input
      .DDLY(DDLY),                 // 1-bit input: Serial data from IDELAYE2
      .OFB(OFB),                   // 1-bit input: Data feedback from OSERDESE2
      .OCLKB(OCLKB),               // 1-bit input: High speed negative edge output clock
      .RST(RST),                   // 1-bit input: Active high asynchronous reset
      // SHIFTIN1, SHIFTIN2: 1-bit (each) input: Data width expansion input ports
      .SHIFTIN1(SHIFTIN1),
      .SHIFTIN2(SHIFTIN2) 
   );

   // End of ISERDESE2_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer with bitslip (OSERDESE2)" treetype="template">
//  OSERDESE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OSERDESE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OSERDESE2: Output SERial/DESerializer with bitslip
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   OSERDESE2 #(
      .DATA_RATE_OQ("DDR"),   // DDR, SDR
      .DATA_RATE_TQ("DDR"),   // DDR, BUF, SDR
      .DATA_WIDTH(4),         // Parallel data width (2-8,10,14)
      .INIT_OQ(1'b0),         // Initial value of OQ output (1'b0,1'b1)
      .INIT_TQ(1'b0),         // Initial value of TQ output (1'b0,1'b1)
      .SERDES_MODE("MASTER"), // MASTER, SLAVE
      .SRVAL_OQ(1'b0),        // OQ output value when SR is used (1'b0,1'b1)
      .SRVAL_TQ(1'b0),        // TQ output value when SR is used (1'b0,1'b1)
      .TBYTE_CTL("FALSE"),    // Enable tristate byte operation (FALSE, TRUE)
      .TBYTE_SRC("FALSE"),    // Tristate byte source (FALSE, TRUE)
      .TRISTATE_WIDTH(4)      // 3-state converter width (1,4)
   )
   OSERDESE2_inst (
      .OFB(OFB),             // 1-bit output: Feedback path for data
      .OQ(OQ),               // 1-bit output: Data path output
      // SHIFTOUT1 / SHIFTOUT2: 1-bit (each) output: Data output expansion (1-bit each)
      .SHIFTOUT1(SHIFTOUT1),
      .SHIFTOUT2(SHIFTOUT2),
      .TBYTEOUT(TBYTEOUT),   // 1-bit output: Byte group tristate
      .TFB(TFB),             // 1-bit output: 3-state control
      .TQ(TQ),               // 1-bit output: 3-state control
      .CLK(CLK),             // 1-bit input: High speed clock
      .CLKDIV(CLKDIV),       // 1-bit input: Divided clock
      // D1 - D8: 1-bit (each) input: Parallel data inputs (1-bit each)
      .D1(D1),
      .D2(D2),
      .D3(D3),
      .D4(D4),
      .D5(D5),
      .D6(D6),
      .D7(D7),
      .D8(D8),
      .OCE(OCE),             // 1-bit input: Output data clock enable
      .RST(RST),             // 1-bit input: Reset
      // SHIFTIN1 / SHIFTIN2: 1-bit (each) input: Data input expansion (1-bit each)
      .SHIFTIN1(SHIFTIN1),
      .SHIFTIN2(SHIFTIN2),
      // T1 - T4: 1-bit (each) input: Parallel 3-state inputs
      .T1(T1),
      .T2(T2),
      .T3(T3),
      .T4(T4),
      .TBYTEIN(TBYTEIN),     // 1-bit input: Byte group tristate
      .TCE(TCE)              // 1-bit input: 3-state clock enable
   );

   // End of OSERDESE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Output Buffers" treetype="folder">
					<Template label="Differential Buffer (OBUFDS)" treetype="template">

//     OBUFDS      : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFDS_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS: Differential Output Buffer
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   OBUFDS #(
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW")           // Specify the output slew rate
   ) OBUFDS_inst (
      .O(O),     // Diff_p output (connect directly to top-level port)
      .OB(OB),   // Diff_n output (connect directly to top-level port)
      .I(I)      // Buffer input 
   );
  
   // End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential 3-state Buffer (OBUFTDS)" treetype="template">
//     OBUFTDS   : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (OBUFTDS_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUFTDS: Differential 3-state Output Buffer
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   OBUFTDS #(
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW")           // Specify the output slew rate
   ) OBUFTDS_inst (
      .O(O),     // Diff_p output (connect directly to top-level port)
      .OB(OB),   // Diff_n output (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input
   );
  
   // End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Single-ended Buffer (OBUF)" treetype="template">
//      OBUF       : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUF_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUF: Single-ended Output Buffer
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   OBUF #(
      .DRIVE(12),   // Specify the output drive strength
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW") // Specify the output slew rate
   ) OBUF_inst (
      .O(O),     // Buffer output (connect directly to top-level port)
      .I(I)      // Buffer input 
   );
  
   // End of OBUF_inst instantiation
					</Template>
					<Template label="Single-ended 3-state Buffer (OBUFT)" treetype="template">
//      OBUFT      : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUFT: Single-ended 3-state Output Buffer
   //        All devices
   // Xilinx HDL Language Template, version 2016.4
   
   OBUFT #(
      .DRIVE(12),   // Specify the output drive strength
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW") // Specify the output slew rate
   ) OBUFT_inst (
      .O(O),     // Buffer output (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input 
   );
  
  // End of OBUFT_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Weak drivers" treetype="folder">
					<Template label="KEEPER" treetype="template">
//     KEEPER    : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (KEEPER_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.

//  &lt;-----Cut code below this line----&gt;

   // KEEPER: I/O Buffer Weak Keeper
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   KEEPER KEEPER_inst (
      .O(O)     // Keeper output (connect directly to top-level port)
   );
  
   // End of KEEPER_inst instantiation
					</Template>
					<Template label="PULLDOWN" treetype="template">
//    PULLDOWN   : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (PULLDOWN_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.

//  &lt;-----Cut code below this line----&gt;

   // PULLDOWN: I/O Buffer Weak Pull-down
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   PULLDOWN PULLDOWN_inst (
      .O(O)     // Pulldown output (connect directly to top-level port)
   );
  
   // End of PULLDOWN_inst instantiation
					</Template>
					<Template label="PULLUP" treetype="template">
//     PULLUP    : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (PULLUP_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.


//  &lt;-----Cut code below this line----&gt;

   // PULLUP: I/O Buffer Weak Pull-up
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   PULLUP PULLUP_inst (
      .O(O)     // Pullup output (connect directly to top-level port)
   );
  
   // End of PULLUP_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="RAM/ROM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E1)" treetype="template">
//  RAMB18E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB18E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB18E1: 18K-bit Configurable Synchronous Block RAM
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAMB18E1 #(
      // Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      .RDADDR_COLLISION_HWCONFIG("DELAYED_WRITE"),
      // Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0 or 1)
      .DOA_REG(0),
      .DOB_REG(0),
      // INITP_00 to INITP_07: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_3F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(18'h00000),
      .INIT_B(18'h00000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // RAM Mode: "SDP" or "TDP" 
      .RAM_MODE("TDP"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-72
      .READ_WIDTH_B(0),                                                                 // 0-18
      .WRITE_WIDTH_A(0),                                                                // 0-18
      .WRITE_WIDTH_B(0),                                                                // 0-72
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(18'h00000),
      .SRVAL_B(18'h00000),
      // Simulation Device: Must be set to "7SERIES" for simulation behavior
      .SIM_DEVICE("7SERIES"),
      // WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      .WRITE_MODE_A("WRITE_FIRST"),
      .WRITE_MODE_B("WRITE_FIRST") 
   )
   RAMB18E1_inst (
      // Port A Data: 16-bit (each) output: Port A data
      .DOADO(DOADO),                 // 16-bit output: A port data/LSB data
      .DOPADOP(DOPADOP),             // 2-bit output: A port parity/LSB parity
      // Port B Data: 16-bit (each) output: Port B data
      .DOBDO(DOBDO),                 // 16-bit output: B port data/MSB data
      .DOPBDOP(DOPBDOP),             // 2-bit output: B port parity/MSB parity
      // Port A Address/Control Signals: 14-bit (each) input: Port A address and control signals (read port
      // when RAM_MODE="SDP")
      .ADDRARDADDR(ADDRARDADDR),     // 14-bit input: A port address/Read address
      .CLKARDCLK(CLKARDCLK),         // 1-bit input: A port clock/Read clock
      .ENARDEN(ENARDEN),             // 1-bit input: A port enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),     // 1-bit input: A port register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM), // 1-bit input: A port set/reset
      .RSTREGARSTREG(RSTREGARSTREG), // 1-bit input: A port register set/reset
      .WEA(WEA),                     // 2-bit input: A port write enable
      // Port A Data: 16-bit (each) input: Port A data
      .DIADI(DIADI),                 // 16-bit input: A port data/LSB data
      .DIPADIP(DIPADIP),             // 2-bit input: A port parity/LSB parity
      // Port B Address/Control Signals: 14-bit (each) input: Port B address and control signals (write port
      // when RAM_MODE="SDP")
      .ADDRBWRADDR(ADDRBWRADDR),     // 14-bit input: B port address/Write address
      .CLKBWRCLK(CLKBWRCLK),         // 1-bit input: B port clock/Write clock
      .ENBWREN(ENBWREN),             // 1-bit input: B port enable/Write enable
      .REGCEB(REGCEB),               // 1-bit input: B port register enable
      .RSTRAMB(RSTRAMB),             // 1-bit input: B port set/reset
      .RSTREGB(RSTREGB),             // 1-bit input: B port register set/reset
      .WEBWE(WEBWE),                 // 4-bit input: B port write enable/Write enable
      // Port B Data: 16-bit (each) input: Port B data
      .DIBDI(DIBDI),                 // 16-bit input: B port data/MSB data
      .DIPBDIP(DIPBDIP)              // 2-bit input: B port parity/MSB parity
   );

   // End of RAMB18E1_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E1)" treetype="template">
//  RAMB36E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB36E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB36E1: 36K-bit Configurable Synchronous Block RAM
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAMB36E1 #(
      // Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      .RDADDR_COLLISION_HWCONFIG("DELAYED_WRITE"),
      // Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0 or 1)
      .DOA_REG(0),
      .DOB_REG(0),
      .EN_ECC_READ("FALSE"),                                                            // Enable ECC decoder,
                                                                                        // FALSE, TRUE
      .EN_ECC_WRITE("FALSE"),                                                           // Enable ECC encoder,
                                                                                        // FALSE, TRUE
      // INITP_00 to INITP_0F: Initial contents of the parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_7F: Initial contents of the data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(36'h000000000),
      .INIT_B(36'h000000000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // RAM Mode: "SDP" or "TDP" 
      .RAM_MODE("TDP"),
      // RAM_EXTENSION_A, RAM_EXTENSION_B: Selects cascade mode ("UPPER", "LOWER", or "NONE")
      .RAM_EXTENSION_A("NONE"),
      .RAM_EXTENSION_B("NONE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-72
      .READ_WIDTH_B(0),                                                                 // 0-36
      .WRITE_WIDTH_A(0),                                                                // 0-36
      .WRITE_WIDTH_B(0),                                                                // 0-72
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(36'h000000000),
      .SRVAL_B(36'h000000000),
      // Simulation Device: Must be set to "7SERIES" for simulation behavior
      .SIM_DEVICE("7SERIES"),
      // WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      .WRITE_MODE_A("WRITE_FIRST"),
      .WRITE_MODE_B("WRITE_FIRST") 
   )
   RAMB36E1_inst (
      // Cascade Signals: 1-bit (each) output: BRAM cascade ports (to create 64kx1)
      .CASCADEOUTA(CASCADEOUTA),     // 1-bit output: A port cascade
      .CASCADEOUTB(CASCADEOUTB),     // 1-bit output: B port cascade
      // ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .RDADDRECC(RDADDRECC),         // 9-bit output: ECC read address
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Port A Data: 32-bit (each) output: Port A data
      .DOADO(DOADO),                 // 32-bit output: A port data/LSB data
      .DOPADOP(DOPADOP),             // 4-bit output: A port parity/LSB parity
      // Port B Data: 32-bit (each) output: Port B data
      .DOBDO(DOBDO),                 // 32-bit output: B port data/MSB data
      .DOPBDOP(DOPBDOP),             // 4-bit output: B port parity/MSB parity
      // Cascade Signals: 1-bit (each) input: BRAM cascade ports (to create 64kx1)
      .CASCADEINA(CASCADEINA),       // 1-bit input: A port cascade
      .CASCADEINB(CASCADEINB),       // 1-bit input: B port cascade
      // ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR), // 1-bit input: Inject a single bit error
      // Port A Address/Control Signals: 16-bit (each) input: Port A address and control signals (read port
      // when RAM_MODE="SDP")
      .ADDRARDADDR(ADDRARDADDR),     // 16-bit input: A port address/Read address
      .CLKARDCLK(CLKARDCLK),         // 1-bit input: A port clock/Read clock
      .ENARDEN(ENARDEN),             // 1-bit input: A port enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),     // 1-bit input: A port register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM), // 1-bit input: A port set/reset
      .RSTREGARSTREG(RSTREGARSTREG), // 1-bit input: A port register set/reset
      .WEA(WEA),                     // 4-bit input: A port write enable
      // Port A Data: 32-bit (each) input: Port A data
      .DIADI(DIADI),                 // 32-bit input: A port data/LSB data
      .DIPADIP(DIPADIP),             // 4-bit input: A port parity/LSB parity
      // Port B Address/Control Signals: 16-bit (each) input: Port B address and control signals (write port
      // when RAM_MODE="SDP")
      .ADDRBWRADDR(ADDRBWRADDR),     // 16-bit input: B port address/Write address
      .CLKBWRCLK(CLKBWRCLK),         // 1-bit input: B port clock/Write clock
      .ENBWREN(ENBWREN),             // 1-bit input: B port enable/Write enable
      .REGCEB(REGCEB),               // 1-bit input: B port register enable
      .RSTRAMB(RSTRAMB),             // 1-bit input: B port set/reset
      .RSTREGB(RSTREGB),             // 1-bit input: B port register set/reset
      .WEBWE(WEBWE),                 // 8-bit input: B port write enable/Write enable
      // Port B Data: 32-bit (each) input: Port B data
      .DIBDI(DIBDI),                 // 32-bit input: B port data/MSB data
      .DIPBDIP(DIPBDIP)              // 4-bit input: B port parity/MSB parity
   );

   // End of RAMB36E1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Distributed RAM" treetype="folder">
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 X 1 negedge write (RAM32X1D_1)" treetype="template">
//  RAM32X1D_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_1_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D_1: 32 x 1 negative edge write, asynchronous read dual-port
   //             distributed RAM (Mapped to a SliceM LUT6)
   //             Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1 #(
      .INIT(32'h00000000) // Initial contents of RAM
   ) RAM32X1D_1_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_1_inst instantiation
						</Template>
						<Template label="32 X 1 posedge write (RAM32X1D)" treetype="template">
//   RAM32X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D: 32 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to a SliceM LUT6)
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D #(
      .INIT(32'h00000000) // Initial contents of RAM
   ) RAM32X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_inst instantiation
						</Template>
						<Template label="64 X 1 posedge write (RAM64X1D)" treetype="template">
//   RAM64X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM64X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1D: 64 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to a SliceM LUT6)
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1D #(
      .INIT(64'h0000000000000000) // Initial contents of RAM
   ) RAM64X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .A5(A5),       // Rw/ address[5] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .DPRA5(DPRA5), // Read-only address[5] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM64X1D_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">
//  RAM128X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM128X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read  (Mapped to two SliceM LUT6s)
   //            dual-port distributed LUT RAM
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   RAM128X1D #(
      .INIT(128'h00000000000000000000000000000000)
   ) RAM128X1D_inst (
      .DPO(DPO),   // Read port 1-bit output
      .SPO(SPO),   // Read/write port 1-bit output
      .A(A),       // Read/write port 7-bit address input
      .D(D),       // RAM data input
      .DPRA(DPRA), // Read port 7-bit address input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM128X1D_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">
//   RAM32M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32M: 32-deep by 8-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4
      
   RAM32M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000)  // Initial contents of D Port
   ) RAM32M_inst (
      .DOA(DOA),     // Read port A 2-bit output
      .DOB(DOB),     // Read port B 2-bit output
      .DOC(DOC),     // Read port C 2-bit output
      .DOD(DOD),     // Read/write port D 2-bit output
      .ADDRA(ADDRA), // Read port A 5-bit address input
      .ADDRB(ADDRB), // Read port B 5-bit address input
      .ADDRC(ADDRC), // Read port C 5-bit address input
      .ADDRD(ADDRD), // Read/write port D 5-bit address input
      .DIA(DIA),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );
   
   // End of RAM32M_inst instantiation
						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">
//   RAM64M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64M: 64-deep by 4-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   RAM64M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000)  // Initial contents of D Port
   ) RAM64M_inst (
      .DOA(DOA),     // Read port A 1-bit output
      .DOB(DOB),     // Read port B 1-bit output
      .DOC(DOC),     // Read port C 1-bit output
      .DOD(DOD),     // Read/write port D 1-bit output
      .DIA(DIA),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .ADDRA(ADDRA), // Read port A 6-bit address input
      .ADDRB(ADDRB), // Read port B 6-bit address input
      .ADDRC(ADDRC), // Read port C 6-bit address input
      .ADDRD(ADDRD), // Read/write port D 6-bit address input
      .WE(WE),       // Write enable input
      .WCLK(WCLK)    // Write clock input
   );

   // End of RAM64M_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<SubFolder label="32 Deep (5-bit address)" treetype="folder">
							<Template label="32 x 1 negedge write (RAM32X1S_1)" treetype="template">
// RAM32X1S_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1S_1: 32 x 1 negedge write distributed (LUT) RAM (Mapped to a SliceM LUT6)
   //             Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1S_1 #(
      .INIT(32'h00000000)  // Initial contents of RAM
   )RAM32X1S_1_inst (
      .O(O),       // RAM output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D(D),       // RAM data input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X1S_1_inst instantiation
							</Template>
							<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">
//  RAM32X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM (Mapped to a SliceM LUT6)
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1S #(
      .INIT(32'h00000000)  // Initial contents of RAM
   ) RAM32X1S_inst (
      .O(O),       // RAM output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D(D),       // RAM data input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X1S_inst instantiation
							</Template>
							<Template label="32 x 2 posedge write (RAM32X2S)" treetype="template">
//  RAM32X2S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM16X2S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X2S: 32 x 2 posedge write distributed (LUT) RAM (Mapped to a SliceM LUT6)
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X2S #(
      .INIT_00(32'h00000000), // INIT for bit 0 of RAM
      .INIT_01(32'h00000000)  // INIT for bit 1 of RAM
   ) RAM32X2S_inst (
      .O0(O0),     // RAM data[0] output
      .O1(O1),     // RAM data[1] output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D0(D0),     // RAM data[0] input
      .D1(D1),     // RAM data[1] input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X2S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="64 Deep (6-bit address)" treetype="folder">
							<Template label="64 X 1 negedge write (RAM64X1S_1)" treetype="template">
//  RAM64X1S_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1S_1: 64 x 1 negative edge write, asynchronous read single-port
   //             distributed RAM (Mapped to a SliceM LUT6)
   //             Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1S_1 #(
      .INIT(64'h0000000000000000) // Initial contents of RAM
   ) RAM64X1S_1_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM64X1S_1_inst instantiation
							</Template>
							<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">
//  RAM64X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port
   //           distributed RAM (Mapped to a SliceM LUT6)
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1S #(
      .INIT(64'h0000000000000000) // Initial contents of RAM
   ) RAM64X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM64X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="128 Deep (7-bit address)" treetype="folder">
							<Template label="128 X 1 negedge write (RAM128X1S_1)" treetype="template">
// RAM128X1S_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S_1: 128 x 1 negative edge write, asynchronous read single-port
   //              distributed RAM (Mapped to two SliceM LUT6s)
   //              Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1 #(
      .INIT(128'h00000000000000000000000000000000)  // Initial contents of RAM
   ) RAM128X1S_1_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_1_inst instantiation
							</Template>
							<Template label="128 X 1 posedge write (RAM128X1S)" treetype="template">
//  RAM128X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S: 128 x 1 positive edge write, asynchronous read single-port
   //            distributed RAM (Mapped to two SliceM LUT6s)
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S #(
      .INIT(128'h00000000000000000000000000000000) // Initial contents of RAM
   ) RAM128X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="256 Deep (8-bit address)" treetype="folder">
							<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">
//  RAM256X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM256X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read  (Mapped to four SliceM LUT6s)
   //            single-port distributed LUT RAM
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   RAM256X1S #( 
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) RAM256X1S_inst (
      .O(O),       // Read/write port 1-bit output
      .A(A),       // Read/write port 8-bit address input
      .WE(WE),     // Write enable input
      .WCLK(WCLK), // Write clock input
      .D(D)        // RAM data input
   );

   // End of RAM256X1S_inst instantiation
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Distributed ROM" treetype="folder">
					<Template label="32 X 1 (ROM32X1)" treetype="template">
//   ROM32X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM32X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM32X1: 32 x 1 Asynchronous Distributed (LUT) ROM (Mapped to a SliceM LUT6)
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   ROM32X1 #(
      .INIT(32'h00000000) // Contents of ROM
   ) ROM32X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4)  // ROM address[4]
   );

   // End of ROM32X1_inst instantiation
					</Template>
					<Template label="64 X 1 (ROM64X1)" treetype="template">
//   ROM64X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM64X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM64X1: 64 x 1 Asynchronous Distributed (LUT) ROM (Mapped to a SliceM LUT6)
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   ROM64X1 #(
      .INIT(64'h0000000000000000) // Contents of ROM
   ) ROM64X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4), // ROM address[4]
      .A5(A5)  // ROM address[5]
   );

   // End of ROM64X1_inst instantiation
					</Template>
					<Template label="128 X 1 (ROM128X1)" treetype="template">
//   ROM128X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM128X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM128X1: 128 x 1 Asynchronous Distributed (LUT) ROM (Mapped to two SliceM LUT6s)
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   ROM128X1 #(
      .INIT(128'h00000000000000000000000000000000) // Contents of ROM
   ) ROM128X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4), // ROM address[4]
      .A5(A5), // ROM address[5]
      .A6(A6)  // ROM address[6]
   );

   // End of ROM128X1_inst instantiation
					</Template>
					<Template label="256 X 1 (ROM256X1)" treetype="template">
//   ROM256X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM256X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM256X1: 256 x 1 Asynchronous Distributed (LUT) ROM (Mapped to four SliceM LUT6s)
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   ROM256X1 #(
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000) // Contents of ROM
   ) ROM256X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4), // ROM address[4]
      .A5(A5), // ROM address[5]
      .A6(A6), // ROM address[6]
      .A7(A7)  // ROM address[7]
   );

   // End of ROM256X1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E1)" treetype="template">
//  FIFO18E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO18E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO18E1: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   FIFO18E1 #(
      .ALMOST_EMPTY_OFFSET(13'h0080),    // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(13'h0080),     // Sets almost full threshold
      .DATA_WIDTH(4),                    // Sets data width to 4-36
      .DO_REG(1),                        // Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      .EN_SYN("FALSE"),                  // Specifies FIFO as dual-clock (FALSE) or Synchronous (TRUE)
      .FIFO_MODE("FIFO18"),              // Sets mode to FIFO18 or FIFO18_36
      .FIRST_WORD_FALL_THROUGH("FALSE"), // Sets the FIFO FWFT to FALSE, TRUE
      .INIT(36'h000000000),              // Initial values on output port
      .SIM_DEVICE("7SERIES"),            // Must be set to "7SERIES" for simulation behavior
      .SRVAL(36'h000000000)              // Set/Reset value for output port
   )
   FIFO18E1_inst (
      // Read Data: 32-bit (each) output: Read output data
      .DO(DO),                   // 32-bit output: Data output
      .DOP(DOP),                 // 4-bit output: Parity data output
      // Status: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output: Almost empty flag
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output: Almost full flag
      .EMPTY(EMPTY),             // 1-bit output: Empty flag
      .FULL(FULL),               // 1-bit output: Full flag
      .RDCOUNT(RDCOUNT),         // 12-bit output: Read count
      .RDERR(RDERR),             // 1-bit output: Read error
      .WRCOUNT(WRCOUNT),         // 12-bit output: Write count
      .WRERR(WRERR),             // 1-bit output: Write error
      // Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      .RDCLK(RDCLK),             // 1-bit input: Read clock
      .RDEN(RDEN),               // 1-bit input: Read enable
      .REGCE(REGCE),             // 1-bit input: Clock enable
      .RST(RST),                 // 1-bit input: Asynchronous Reset
      .RSTREG(RSTREG),           // 1-bit input: Output register set/reset
      // Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      .WRCLK(WRCLK),             // 1-bit input: Write clock
      .WREN(WREN),               // 1-bit input: Write enable
      // Write Data: 32-bit (each) input: Write input data
      .DI(DI),                   // 32-bit input: Data input
      .DIP(DIP)                  // 4-bit input: Parity input
   );

   // End of FIFO18E1_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E1)" treetype="template">
//  FIFO36E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO36E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO36E1: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Artix-7
   // Xilinx HDL Language Template, version 2016.4

   FIFO36E1 #(
      .ALMOST_EMPTY_OFFSET(13'h0080),    // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(13'h0080),     // Sets almost full threshold
      .DATA_WIDTH(4),                    // Sets data width to 4-72
      .DO_REG(1),                        // Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      .EN_ECC_READ("FALSE"),             // Enable ECC decoder, FALSE, TRUE
      .EN_ECC_WRITE("FALSE"),            // Enable ECC encoder, FALSE, TRUE
      .EN_SYN("FALSE"),                  // Specifies FIFO as Asynchronous (FALSE) or Synchronous (TRUE)
      .FIFO_MODE("FIFO36"),              // Sets mode to "FIFO36" or "FIFO36_72" 
      .FIRST_WORD_FALL_THROUGH("FALSE"), // Sets the FIFO FWFT to FALSE, TRUE
      .INIT(72'h000000000000000000),     // Initial values on output port
      .SIM_DEVICE("7SERIES"),            // Must be set to "7SERIES" for simulation behavior
      .SRVAL(72'h000000000000000000)     // Set/Reset value for output port
   )
   FIFO36E1_inst (
      // ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Read Data: 64-bit (each) output: Read output data
      .DO(DO),                       // 64-bit output: Data output
      .DOP(DOP),                     // 8-bit output: Parity data output
      // Status: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY),     // 1-bit output: Almost empty flag
      .ALMOSTFULL(ALMOSTFULL),       // 1-bit output: Almost full flag
      .EMPTY(EMPTY),                 // 1-bit output: Empty flag
      .FULL(FULL),                   // 1-bit output: Full flag
      .RDCOUNT(RDCOUNT),             // 13-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .WRCOUNT(WRCOUNT),             // 13-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write error
      // ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error input
      .INJECTSBITERR(INJECTSBITERR),
      // Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Clock enable
      .RST(RST),                     // 1-bit input: Reset
      .RSTREG(RSTREG),               // 1-bit input: Output register set/reset
      // Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      .WRCLK(WRCLK),                 // 1-bit input: Rising edge write clock.
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data: 64-bit (each) input: Write input data
      .DI(DI),                       // 64-bit input: Data input
      .DIP(DIP)                      // 8-bit input: Parity input
   );

   // End of FIFO36E1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Registers &amp; Latches" treetype="folder">
				<SubFolder label="Double Data Rate" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
//    IDDR_2CLK  : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   //            Set, Reset and Clock Enable.
   //            Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_2CLK_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit primary clock input
      .CB(CB), // 1-bit secondary clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_2CLK_inst instantiation
					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
//      IDDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR: Input Double Data Rate Input Register with Set, Reset
   //       and Clock Enable.
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_inst instantiation
					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
//      ODDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (ODDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // ODDR: Output Double Data Rate Output Register with Set, Reset
   //       and Clock Enable.
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   ODDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE" or "SAME_EDGE" 
      .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) ODDR_inst (
      .Q(Q),   // 1-bit DDR output
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D1(D1), // 1-bit data input (positive edge)
      .D2(D2), // 1-bit data input (negative edge)
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of ODDR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Single Data Rate" treetype="folder">
					<Template label="Posedge D-FF w/ Async Clear and CE (FDCE)" treetype="template">
//     FDCE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDCE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and
   //       Clock Enable (posedge clk).
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDCE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDCE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .CLR(CLR),  // 1-bit Asynchronous clear input
      .D(D)       // 1-bit Data input
   );

   // End of FDCE_inst instantiation
					</Template>
					<Template label="Posedge D-FF w/ Async Preset and CE (FDPE)" treetype="template">
//     FDPE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDPE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDPE: Single Data Rate D Flip-Flop with Asynchronous Preset and
   //       Clock Enable (posedge clk).
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDPE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDPE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .PRE(PRE),  // 1-bit Asynchronous preset input
      .D(D)       // 1-bit Data input
   );

   // End of FDPE_inst instantiation
					</Template>
					<Template label="Posedge D-FF w/ Sync Reset and CE (FDRE)" treetype="template">
//     FDRE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDRE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
   //       Clock Enable (posedge clk).
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDRE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDRE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .R(R),      // 1-bit Synchronous reset input
      .D(D)       // 1-bit Data input
   );

   // End of FDRE_inst instantiation
					</Template>
					<Template label="Posedge D-FF w/ Sync Set and CE (FDSE)" treetype="template">
//     FDSE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDSE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDSE: Single Data Rate D Flip-Flop with Synchronous Set and
   //       Clock Enable (posedge clk).
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDSE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDSE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .S(S),      // 1-bit Synchronous set input
      .D(D)       // 1-bit Data input
   );

   // End of FDSE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Transparent Latch" treetype="folder">
					<Template label="Latch with Async Reset and Gate Enable (LDCE)" treetype="template">
//     LDCE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (LDCE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // LDCE:  Transparent latch with Asynchronous Reset and Gate Enable.
   //        Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   LDCE #(
      .INIT(1'b0) // Initial value of latch (1'b0 or 1'b1)
   ) LDCE_inst (
      .Q(Q),      // Data output
      .CLR(CLR),  // Asynchronous clear/reset input
      .D(D),      // Data input
      .G(G),      // Gate input
      .GE(GE)     // Gate enable input
   );
  
   // End of LDCE_inst instantiation
					</Template>
					<Template label="Latch with Async Set and Gate Enable (LDPE)" treetype="template">
//     LDPE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (LDPE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // LDPE:  Transparent latch with Asynchronous Preset and Gate Enable.
   //        Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   LDPE #(
      .INIT(1'b1) // Initial value of latch (1'b0 or 1'b1)
   ) LDPE_inst (
      .Q(Q),      // Data output
      .PRE(PRE),  // Asynchronous preset/set input
      .D(D),      // Data input
      .G(G),      // Gate input
      .GE(GE)     // Gate enable input
   );
  
   // End of LDPE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Slice/CLB Primitives" treetype="folder">
				<Template label="Carry (CARRY4)" treetype="template">
//   CARRY4    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CARRY4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design. All inputs and
//             : and outputs of this primitive should be connected.

//  &lt;-----Cut code below this line----&gt;

   // CARRY4: Fast Carry Logic Component
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   CARRY4 CARRY4_inst (
      .CO(CO),         // 4-bit carry out
      .O(O),           // 4-bit carry chain XOR data out
      .CI(CI),         // 1-bit carry cascade input
      .CYINIT(CYINIT), // 1-bit carry initialization
      .DI(DI),         // 4-bit carry-MUX data in
      .S(S)            // 4-bit carry-MUX select input
   );

   // End of CARRY4_inst instantiation
				</Template>
				<SubFolder label="LUTs" treetype="folder">
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
// The INIT parameter for the FPGA LUT primitive is what gives the LUT its 
// logical value. By default this value is zero thus driving the output to a  
// zero regardless of the input values (acting as a ground) however in most 
// cases an new INIT value must be determined in order to specify the logic 
// function for the LUT primitive.  There are a few methods in which the LUT 
// value can be determined and two of those methods will be discussed here.
//
// The Truth Table Method
// ----------------------
//
//  A common method to determine the desired INIT value for a LUT is using a 
// truth table.  To do so, simply create a binary truth table of all possible 
// inputs, specify the desired logic value of the output and then create the 
// INIT string from those output values.  An example is shown below:
//
// Example of determining an XOR INIT equation for a LUT4:
//
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | 0 |\
//     |  0  0  0  1 | 1 | \ = 4'b0110 = 4'h6 ---------------+
//     |  0  0  1  0 | 1 | /                                 |
//     |  0  0  1  1 | 0 |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | 1 |\                                  |
//     |  0  1  0  1 | 0 | \ = 4'b1001 = 4'h9                |
//     |  0  1  1  0 | 0 | /                                 |
//     |  0  1  1  1 | 1 |/                                  |                     
//     |-------------|---|                     INIT = 16'h6996
//     |  1  0  0  0 | 1 |\                               |
//     |  1  0  0  1 | 0 | \ = 4'b0110 = 4'h9             |
//     |  1  0  1  0 | 0 | /                              |
//     |  1  0  1  1 | 1 |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | 0 |\                               |
//     |  1  1  0  1 | 1 | \ = 4'b1001 = 4'h6 ------------+
//     |  1  1  1  0 | 1 | /
//     |  1  1  1  1 | 0 |/
//     -------------------
//
// Example of determining a 3-input AND gate:
//
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | 0 |\
//     |  0  0  1 | 0 | \ = 4'b0000 = 4'h0 --------------+
//     |  0  1  0 | 0 | /                                |
//     |  0  1  1 | 0 |/                                 |
//     |----------|---|                       INIT = 8'h80 
//     |  1  0  0 | 0 |\                                |
//     |  1  0  1 | 0 | \ = 4'b1000 = 4'h8 -------------+
//     |  1  1  0 | 0 | / 
//     |  1  1  1 | 1 |/                      
//     ----------------
//
// The Equation Method
// -------------------
//
// Another method to determine the LUT value is to define parameters for each 
// input to the LUT that correspond to their listed truth value and use those to
// build the logic equation you are after.  This method is easier to understand 
// once you have grasped the concept and more self-documenting that the above 
// method however does require the code to first specify the appropriate 
// parameters.  See the example below.
//
// Example of specifying the equation (A and B) or (C and D) for a LUT4:
//
   // The following parameters are defined to allow for
   //   equation-based INIT specification.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;

   // LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT((I0&amp;I1)|(I2&amp;I3))  // Specify LUT Contents
   ) LUT4_inst (
      .O(O_LUT), // LUT general output
      .I0(A),    // LUT input
      .I1(B),    // LUT input
      .I2(C),    // LUT input
      .I3(D)     // LUT input
   );

   // End of LUT4_inst instantiation

// With the parameters specifying all possible cases for the truth table, a 
// Verilog equation can be written to determine the end INIT value.
						</Template>
						<SubFolder label="INIT Parameters" treetype="folder">
							<Template label="LUT1" treetype="template">
   // The following parameter is defined to allow for
   //   equation-based INIT specification for a LUT1.
   parameter I0 = 2'b10;
							</Template>
							<Template label="LUT2" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT2.
   parameter I0 = 4'ha;
   parameter I1 = 4'hc;
							</Template>
							<Template label="LUT3" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT3.
   parameter I0 = 8'haa;
   parameter I1 = 8'hcc;
   parameter I2 = 8'hf0;
							</Template>
							<Template label="LUT4" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT4.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;
							</Template>
							<Template label="LUT5" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT5.
   parameter I0 = 32'haaaaaaaa;
   parameter I1 = 32'hcccccccc;
   parameter I2 = 32'hf0f0f0f0;
   parameter I3 = 32'hff00ff00;
   parameter I4 = 32'hffff0000;
							</Template>
							<Template label="LUT6" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT6.
   parameter I0 = 64'haaaaaaaaaaaaaaaa;
   parameter I1 = 64'hcccccccccccccccc;
   parameter I2 = 64'hf0f0f0f0f0f0f0f0;
   parameter I3 = 64'hff00ff00ff00ff00;
   parameter I4 = 64'hffff0000ffff0000;
   parameter I5 = 64'hffffffff00000000;
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
//  Truth Table to determine INIT value for a LUT1
//      ________
//     | I0 | O |
//     |--------|
//     |  0 | ? |\
//     |  1 | ? |/ = 2'b??
//     ----------
							</Template>
							<Template label="LUT2" treetype="template">
//  Truth Table to determine INIT value for a LUT2
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
//     |  0  1  0 | ? | /
//     |  0  1  1 | ? |/ 
//      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
//  Truth Table to determine INIT value for a LUT3
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
//     |  0  1  0 | ? | /                                |
//     |  0  1  1 | ? |/                                 |
//     |----------|---|                       INIT = 8'h?? 
//     |  1  0  0 | ? |\                                |
//     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
//     |  1  1  0 | ? | / 
//     |  1  1  1 | ? |/                      
//     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
//  Truth Table to determine INIT value for a LUT4
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | ? |\
//     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
//     |  0  0  1  0 | ? | /                                 |
//     |  0  0  1  1 | ? |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | ? |\                                  |
//     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
//     |  0  1  1  0 | ? | /                                 |
//     |  0  1  1  1 | ? |/                                  |                     
//     |-------------|---|                     INIT = 16'h????
//     |  1  0  0  0 | ? |\                               |
//     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  0 | ? | /                              |
//     |  1  0  1  1 | ? |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | ? |\                               |
//     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  0 | ? | /
//     |  1  1  1  1 | ? |/
//     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
//  Truth Table to determine INIT value for a LUT5
//      ____________________
//     | I4 I3 I2 I1 I0 | O |
//     |--------------------|
//     |  0  0  0  0  0 | ? |\
//     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  0  1  0  0 | ? |\                                      |
//     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1 | ? |/                                      |                     
//     |----------------|---|                                       |
//     |  0  1  0  0  0 | ? |\                                      |
//     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  0 | ? | /                                     |
//     |  0  1  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  1  1  0  0 | ? |\                                      |
//     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1 | ? |/                                      |
//     ----------------------                     INIT = 32'h????????
//     |  1  0  0  0  0 | ? |\                               |
//     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  0  1  0 | ? | /                              |
//     |  1  0  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  0  1  0  0 | ? |\                               |
//     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  1  0 | ? | /                              |
//     |  1  0  1  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  0  0  0 | ? |\                               |
//     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  1  0  1  0 | ? | /                              |
//     |  1  1  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  1  0  0 | ? |\                               |
//     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1 | ? |/
//     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
//  Truth Table to determine INIT value for a LUT6
//      _______________________
//     | I5 I4 I3 I2 I1 I0 | O |
//     |-----------------------|
//     |  0  0  0  0  0  0 | ? |\
//     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  0  1  0  0 | ? |\                                      |
//     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  0  1  1  0 | ? | /                                     |
//     |  0  0  0  1  1  1 | ? |/                                      |                     
//     |-------------------|---|                                       |
//     |  0  0  1  0  0  0 | ? |\                                      |
//     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  0  1  0 | ? | /                                     |
//     |  0  0  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  1  1  0  0 | ? |\                                      |
//     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1  1 | ? |/                                      |
//     -------------------------                                       |
//     |  0  1  0  0  0  0 | ? |\                                      |
//     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  0  1  0 | ? | /                                     |
//     |  0  1  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  0  1  0  0 | ? |\                                      |
//     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  1  0 | ? | /                                     |
//     |  0  1  0  1  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  0  0  0 | ? |\                                      |
//     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  0  1  0 | ? | /                                     |
//     |  0  1  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  1  0  0 | ? |\                                      |
//     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1  1 | ? |/                                      |
//     ------------------------              INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
							<Template label="LUT6_2" treetype="template">
//  Truth Table to determine INIT value for a LUT6_2
//      _____________________________
//     | I5 I4 I3 I2 I1 I0 | O6 | O5 |
//     |-----------------------------|
//     |  0  0  0  0  0  0 |    ?    |\
//     |  0  0  0  0  0  1 |    ?    | \ = 4'b???? = 4'h? -------------+
//     |  0  0  0  0  1  0 |    ?    | /                               |
//     |  0  0  0  0  1  1 |	?    |/				       |
//     |-------------------|---------|                                 |
//     |  0  0  0  1  0  0 |	?    |\                                |
//     |  0  0  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  0  1  1  0 |	?    | /                               |
//     |  0  0  0  1  1  1 |	?    |/                                |                     
//     |-------------------|---------|                                 |
//     |  0  0  1  0  0  0 |	?    |\                                |
//     |  0  0  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  0  1  0 |	?    | /                               |
//     |  0  0  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  0  1  1  0  0 |	?    |\                                |
//     |  0  0  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  1  1  0 |	?    | /                               |
//     |  0  0  1  1  1  1 |	?    |/                                |
//     -------------------------------                                 |
//     |  0  1  0  0  0  0 |	?    |\                                |
//     |  0  1  0  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  0  1  0 |	?    | /                               |
//     |  0  1  0  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  0  1  0  0 |	?    |\                                |
//     |  0  1  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  1  1  0 |	?    | /                               |
//     |  0  1  0  1  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  0  0  0 |	?    |\                                |
//     |  0  1  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  0  1  0 |	?    | /                               |
//     |  0  1  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  1  0  0 |	?    |\                                |
//     |  0  1  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  1  1  0 |	?    | /                               |
//     |  0  1  1  1  1  1 |	?    |/                                |
//     ------------------------------        INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT1" treetype="template">
//     LUT1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1: 1-input Look-Up Table with general output (Mapped to a LUT6)
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT1 #(
      .INIT(2'b00)  // Specify LUT Contents
   ) LUT1_inst (
      .O(O),   // LUT general output
      .I0(I0)  // LUT input
   );

   // End of LUT1_inst instantiation
					</Template>
					<Template label="LUT1_D" treetype="template">
//   LUT1_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1_D: 1-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT1_D #(
      .INIT(2'b00)  // Specify LUT Contents
   ) LUT1_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0)  // LUT input
   );

   // End of LUT1_D_inst instantiation
					</Template>
					<Template label="LUT1_L" treetype="template">
//   LUT1_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1_L: 1-input Look-Up Table with local output (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT1_L #(
      .INIT(2'b00)  // Specify LUT Contents
   ) LUT1_L_inst (
      .LO(LO), // LUT local output
      .I0(I0)  // LUT input
   );

   // End of LUT1_L_inst instantiation
					</Template>
					<Template label="LUT2" treetype="template">
//     LUT2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2: 2-input Look-Up Table with general output (Mapped to a LUT6)
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT2 #(
      .INIT(4'h0)  // Specify LUT Contents
   ) LUT2_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1)  // LUT input
   );

   // End of LUT2_inst instantiation
					</Template>
					<Template label="LUT2_D" treetype="template">
//   LUT2_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2_D: 2-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT2_D #(
      .INIT(4'h0)  // Specify LUT Contents
   ) LUT2_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1)  // LUT input
   );

   // End of LUT2_L_inst instantiation
					</Template>
					<Template label="LUT2_L" treetype="template">
//   LUT2_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2_L: 2-input Look-Up Table with local output (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT2_L #(
      .INIT(4'h0)  // Specify LUT Contents
   ) LUT2_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1)  // LUT input
   );

   // End of LUT2_L_inst instantiation
					</Template>
					<Template label="LUT3" treetype="template">
//     LUT3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3: 3-input Look-Up Table with general output (Mapped to a LUT6)
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT3 #(
      .INIT(8'h00)  // Specify LUT Contents
   ) LUT3_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2)  // LUT input
   );

   // End of LUT3_inst instantiation
					</Template>
					<Template label="LUT3_D" treetype="template">
//   LUT3_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3_D: 3-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT3_D #(
      .INIT(8'h00)  // Specify LUT Contents
   ) LUT3_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0),   // LUT input
      .I1(I1),   // LUT input
      .I2(I2)    // LUT input
   );

   // End of LUT3_D_inst instantiation
					</Template>
					<Template label="LUT3_L" treetype="template">
//   LUT3_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3_L: 3-input Look-Up Table with local output (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT3_L #(
      .INIT(8'h00)  // Specify LUT Contents
   ) LUT3_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2)  // LUT input
   );

   // End of LUT3_L_inst instantiation
					</Template>
					<Template label="LUT4" treetype="template">
//     LUT4    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT(16'h0000)  // Specify LUT Contents
   ) LUT4_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3)  // LUT input
   );

   // End of LUT4_inst instantiation
					</Template>
					<Template label="LUT4_D" treetype="template">
//   LUT4_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4_D: 4-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4_D #(
      .INIT(16'h0000)  // Specify LUT Contents
   ) LUT4_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3)  // LUT input
   );

   // End of LUT4_D_inst instantiation
					</Template>
					<Template label="LUT4_L" treetype="template">
//   LUT4_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4_L: 4-input Look-Up Table with local output (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4_L #(
      .INIT(16'h0000)  // Specify LUT Contents
   ) LUT4_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3)  // LUT input
   );

   // End of LUT4_L_inst instantiation
					</Template>
					<Template label="LUT5" treetype="template">
//    LUT5     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5: 5-input Look-Up Table with general output (Mapped to a LUT6)
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT5 #(
      .INIT(32'h00000000)  // Specify LUT Contents
   ) LUT5_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4)  // LUT input
   );

   // End of LUT5_inst instantiation
					</Template>
					<Template label="LUT5_D" treetype="template">
//   LUT5_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5_D: 5-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT5_D #(
      .INIT(32'h0000000)  // Specify LUT Contents
   ) LUT5_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4)  // LUT input
   );

   // End of LUT5_D_inst instantiation
					</Template>
					<Template label="LUT5_L" treetype="template">
//   LUT5_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5_L: 5-input Look-Up Table with local output (Mapped to a LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT5_L #(
      .INIT(32'h0000000)  // Specify LUT Contents
   ) LUT5_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4)  // LUT input
   );

   // End of LUT5_L_inst instantiation
					</Template>
					<Template label="LUT6" treetype="template">
//    LUT6     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6: 6-input Look-Up Table with general output
   //       Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6 #(
      .INIT(64'h0000000000000000)  // Specify LUT Contents
   ) LUT6_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4), // LUT input
      .I5(I5)  // LUT input
   );

   // End of LUT6_inst instantiation
					</Template>
					<Template label="LUT6_D" treetype="template">
//   LUT6_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_D: 6-input Look-Up Table with general and local outputs
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6_D #(
      .INIT(64'h0000000000000000)  // Specify LUT Contents
   ) LUT6_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4), // LUT input
      .I5(I5)  // LUT input
   );

   // End of LUT6_D_inst instantiation
					</Template>
					<Template label="LUT6_L" treetype="template">
//   LUT6_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_L: 6-input Look-Up Table with local output
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6_L #(
      .INIT(64'h0000000000000000)  // Specify LUT Contents
   ) LUT6_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4), // LUT input
      .I5(I5)  // LUT input
   );

   // End of LUT6_L_inst instantiation
					</Template>
					<Template label="LUT6_2" treetype="template">
//   LUT6_2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_2: 6-input, 2 output Look-Up Table
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6_2 #(
      .INIT(64'h0000000000000000) // Specify LUT Contents
   ) LUT6_2_inst (
      .O6(O6), // 1-bit LUT6 output
      .O5(O5), // 1-bit lower LUT5 output
      .I0(I0), // 1-bit LUT input
      .I1(I1), // 1-bit LUT input
      .I2(I2), // 1-bit LUT input
      .I3(I3), // 1-bit LUT input
      .I4(I4), // 1-bit LUT input
      .I5(I5)  // 1-bit LUT input (fast MUX select only available to O6 output)
   );

   // End of LUT6_2_inst instantiation
					</Template>
					<Template label="Reconfigurable LUT (CFGLUT5)" treetype="template">
//   CFGLUT5   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CFGLUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CFGLUT5: Reconfigurable 5-input LUT  (Mapped to a SliceM LUT6)
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   CFGLUT5 #(
      .INIT(32'h00000000) // Specify initial LUT contents
   ) CFGLUT5_inst (
      .CDO(CDO), // Reconfiguration cascade output
      .O5(O5),   // 4-LUT output
      .O6(O6),   // 5-LUT output
      .CDI(CDI), // Reconfiguration data input
      .CE(CE),   // Reconfiguration enable input
      .CLK(CLK), // Clock input
      .I0(I0),   // Logic data input
      .I1(I1),   // Logic data input
      .I2(I2),   // Logic data input
      .I3(I3),   // Logic data input
      .I4(I4)    // Logic data input
   );

   // End of CFGLUT5_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUXFx" treetype="folder">
					<Template label="MUXF7" treetype="template">
//    MUXF7    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7: CLB MUX to tie two LUT6's together with general output
   //        Artix-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF7 MUXF7_inst (
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to LUT6 O6 pin)
      .I1(I1),  // Input (tie to LUT6 O6 pin)
      .S(S)     // Input select to MUX
   );

   // End of MUXF7_inst instantiation
					</Template>
					<Template label="MUXF7_D" treetype="template">
//   MUXF7_D   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7_D: CLB MUX to tie two LUT6's together with general and local outputs
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF7_D MUXF7_D_inst (
      .LO(LO),  // Output of MUX to local routing
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to LUT6 O6 pin)
      .I1(I1),  // Input (tie to LUT6 O6 pin)
      .S(S)     // Input select to MUX
   );

   // End of MUXF7_D_inst instantiation
					</Template>
					<Template label="MUXF7_L" treetype="template">
//   MUXF7_L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7_L: CLB MUX to tie two LUT6's together with local output
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF7_L MUXF7_L_inst (
      .LO(LO),  // Output of MUX to local routing
      .I0(I0),  // Input (tie to LUT6 O6 pin)
      .I1(I1),  // Input (tie to LUT6 O6 pin)
      .S(S)     // Input select to MUX
   );

   // End of MUXF7_L_inst instantiation
					</Template>
					<Template label="MUXF8" treetype="template">
//    MUXF8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8: CLB MUX to tie two MUXF7's together with general output
   //        Artix-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF8 MUXF8_inst (
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to MUXF7 L/LO out)
      .I1(I1),  // Input (tie to MUXF7 L/LO out)
      .S(S)     // Input select to MUX
   );

   // End of MUXF8_inst instantiation
					</Template>
					<Template label="MUXF8_D" treetype="template">
//   MUXF8_D   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8_D: CLB MUX to tie two MUXF7's together with general and local outputs
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF8_D MUXF8_D_inst (
      .LO(LO),  // Output of MUX to local routing
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to MUXF7 L/LO out)
      .I1(I1),  // Input (tie to MUXF7 L/LO out)
      .S(S)     // Input select to MUX
   );

   // End of MUXF8_D_inst instantiation
					</Template>
					<Template label="MUXF8_L" treetype="template">
//   MUXF8_L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8_L: CLB MUX to tie two MUXF7's together with local output
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF8_L MUXF8_L_inst (
      .LO(LO),  // Output of MUX to local routing
      .I0(I0),  // Input (tie to MUXF7 L/LO out)
      .I1(I1),  // Input (tie to MUXF7 L/LO out)
      .S(S)     // Input select to MUX
   );

   // End of MUXF8_L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Shift Register LUT" treetype="folder">
					<Template label="16-bit w/ CE posedge SR (SRL16E)" treetype="template">
//  SRL16E     : In order to incorporate this function into the design,
//  Verilog    : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL16E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRL16E: 16-bit shift register LUT with clock enable operating
   //         on posedge of clock (Mapped to a SliceM LUT6)
   //         Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   SRL16E #(
      .INIT(16'h0000) // Initial Value of Shift Register
   ) SRL16E_inst (
      .Q(Q),       // SRL data output
      .A0(A0),     // Select[0] input
      .A1(A1),     // Select[1] input
      .A2(A2),     // Select[2] input
      .A3(A3),     // Select[3] input
      .CE(CE),     // Clock enable input
      .CLK(CLK),   // Clock input
      .D(D)        // SRL data input
   );

   // End of SRL16E_inst instantiation
					</Template>
					<Template label="32-bit w/ CE posedge SR (SRLC32E)" treetype="template">
//  SRLC32E     : In order to incorporate this function into the design,
//  Verilog    : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL32E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRLC32E: 32-bit variable length cascadable shift register LUT  (Mapped to a SliceM LUT6)
   //          with clock enable
   //          Artix-7
   // Xilinx HDL Language Template, version 2016.4
   
   SRLC32E #(
      .INIT(32'h00000000) // Initial Value of Shift Register
   ) SRLC32E_inst (
      .Q(Q),     // SRL data output
      .Q31(Q31), // SRL cascade output pin
      .A(A),     // 5-bit shift depth select input
      .CE(CE),   // Clock enable input
      .CLK(CLK), // Clock input
      .D(D)      // SRL data input
   );

   // End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Kintex UltraScale" treetype="folder">
			<SubFolder label="ADVANCED" treetype="folder">
				<SubFolder label="GT" treetype="folder">
					<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE3)" treetype="template">
// IBUFDS_GTE3 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_GTE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_GTE3: Gigabit Transceiver Buffer
   //              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE3 #(
      .REFCLK_EN_TX_PATH(1'b0),   // Refer to Transceiver User Guide
      .REFCLK_HROW_CK_SEL(2'b00), // Refer to Transceiver User Guide
      .REFCLK_ICNTL_RX(2'b00)     // Refer to Transceiver User Guide
   )
   IBUFDS_GTE3_inst (
      .O(O),         // 1-bit output: Refer to Transceiver User Guide
      .ODIV2(ODIV2), // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),     // 1-bit input: Refer to Transceiver User Guide
      .I(I),         // 1-bit input: Refer to Transceiver User Guide
      .IB(IB)        // 1-bit input: Refer to Transceiver User Guide
   );

   // End of IBUFDS_GTE3_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE3_ADV)" treetype="template">
// OBUFDS_GTE3_ADV : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFDS_GTE3_ADV_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_GTE3_ADV: Gigabit Transceiver Buffer
   //                  Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE3_ADV #(
      .REFCLK_EN_TX_PATH(1'b1),   // Refer to Transceiver User Guide
      .REFCLK_ICNTL_TX(5'b00000)  // Refer to Transceiver User Guide
   )
   OBUFDS_GTE3_ADV_inst (
      .O(O),                       // 1-bit output: Refer to Transceiver User Guide
      .OB(OB),                     // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),                   // 1-bit input: Refer to Transceiver User Guide
      .I(I),                       // 4-bit input: Refer to Transceiver User Guide
      .RXRECCLK_SEL(RXRECCLK_SEL)  // 2-bit input: Refer to Transceiver User Guide
   );

   // End of OBUFDS_GTE3_ADV_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE3)" treetype="template">
// OBUFDS_GTE3 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_GTE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_GTE3: Gigabit Transceiver Buffer
   //              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE3 #(
      .REFCLK_EN_TX_PATH(1'b1),   // Refer to Transceiver User Guide
      .REFCLK_ICNTL_TX(5'b00000)  // Refer to Transceiver User Guide
   )
   OBUFDS_GTE3_inst (
      .O(O),     // 1-bit output: Refer to Transceiver User Guide
      .OB(OB),   // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB), // 1-bit input: Refer to Transceiver User Guide
      .I(I)      // 1-bit input: Refer to Transceiver User Guide
   );

   // End of OBUFDS_GTE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SYSMON" treetype="folder">
					<Template label="SYSMON Simulation File" treetype="template">
// Must use valid headers on all columns
// Comments can be added to the stimulus file using '//' or '#'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

// Time stamp data is in nano seconds (ns)
// Temperature is recorded in C (degrees centigrade)
// All other channels are recorded as V (Volts)
// Valid column headers are:
// TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
// VUSER0, VUSER1, VUSER2, VUSER3,
// VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
// External analog inputs are differential so VP = 0.5 and VN = 0.1 the
// input on channel VP/VN in 0.5 - 0.1 = 0.4V
// Must use valid headers on all columns
// Comments can be added to the stimulus file using '//' or '#'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

// Time stamp data is in nano seconds (ns)
// Temperature is recorded in C (degrees centigrade)
// All other channels are recorded as V (Volts)
// Valid column headers are:
// TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
// VUSER0, VUSER1, VUSER2, VUSER3,
// VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
// External analog inputs are differential so VP = 0.5 and VN = 0.1 the
// input on channel VP/VN in 0.5 - 0.1 = 0.4V
					</Template>
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE1)" treetype="template">
//  SYSMONE1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SYSMONE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SYSMONE1: Xilinx Analog-to-Digital Converter and System Monitor
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   SYSMONE1 #(
      // INIT_40 - INIT_44: SYSMON configuration registers
      .INIT_40(16'h0000),
      .INIT_41(16'h0000),
      .INIT_42(16'h0000),
      .INIT_43(16'h0000),
      .INIT_44(16'h0000),
      .INIT_45(16'h0000),              // Analog Bus Register
      // INIT_46 - INIT_4F: Sequence Registers
      .INIT_46(16'h0000),
      .INIT_47(16'h0000),
      .INIT_48(16'h0000),
      .INIT_49(16'h0000),
      .INIT_4A(16'h0000),
      .INIT_4B(16'h0000),
      .INIT_4C(16'h0000),
      .INIT_4D(16'h0000),
      .INIT_4E(16'h0000),
      .INIT_4F(16'h0000),
      // INIT_50 - INIT_5F: Alarm Limit Registers
      .INIT_50(16'h0000),
      .INIT_51(16'h0000),
      .INIT_52(16'h0000),
      .INIT_53(16'h0000),
      .INIT_54(16'h0000),
      .INIT_55(16'h0000),
      .INIT_56(16'h0000),
      .INIT_57(16'h0000),
      .INIT_58(16'h0000),
      .INIT_59(16'h0000),
      .INIT_5A(16'h0000),
      .INIT_5B(16'h0000),
      .INIT_5C(16'h0000),
      .INIT_5D(16'h0000),
      .INIT_5E(16'h0000),
      .INIT_5F(16'h0000),
      // INIT_60 - INIT_6F: User Supply Alarms
      .INIT_60(16'h0000),
      .INIT_61(16'h0000),
      .INIT_62(16'h0000),
      .INIT_63(16'h0000),
      .INIT_64(16'h0000),
      .INIT_65(16'h0000),
      .INIT_66(16'h0000),
      .INIT_67(16'h0000),
      .INIT_68(16'h0000),
      .INIT_69(16'h0000),
      .INIT_6A(16'h0000),
      .INIT_6B(16'h0000),
      .INIT_6C(16'h0000),
      .INIT_6D(16'h0000),
      .INIT_6E(16'h0000),
      .INIT_6F(16'h0000),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      // specific pins
      .IS_CONVSTCLK_INVERTED(1'b0),    // Optional inversion for CONVSTCLK, 0-1
      .IS_DCLK_INVERTED(1'b0),         // Optional inversion for DCLK, 0-1
      // Simulation attributes: Set for proper simulation behavior
      .SIM_MONITOR_FILE("design.txt"), // Analog simulation data file name
      // User Voltage Monitor: SYSMON User voltage monitor
      .SYSMON_VUSER0_BANK(0),          // Specify IO Bank for User0
      .SYSMON_VUSER0_MONITOR("NONE"),  // Specify Voltage for User0
      .SYSMON_VUSER1_BANK(0),          // Specify IO Bank for User1
      .SYSMON_VUSER1_MONITOR("NONE"),  // Specify Voltage for User1
      .SYSMON_VUSER2_BANK(0),          // Specify IO Bank for User2
      .SYSMON_VUSER2_MONITOR("NONE"),  // Specify Voltage for User2
      .SYSMON_VUSER3_MONITOR("NONE")   // Specify Voltage for User3
   )
   SYSMONE1_inst (
      // ALARMS outputs: ALM, OT
      .ALM(ALM),                   // 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      .OT(OT),                     // 1-bit output: Over-Temperature alarm
      // Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      .DO(DO),                     // 16-bit output: DRP output data bus
      .DRDY(DRDY),                 // 1-bit output: DRP data ready
      // I2C Interface outputs: Ports used with the I2C DRP interface
      .I2C_SCLK_TS(I2C_SCLK_TS),   // 1-bit output: I2C_SCLK output port
      .I2C_SDA_TS(I2C_SDA_TS),     // 1-bit output: I2C_SDA_TS output port
      // STATUS outputs: SYSMON status ports
      .BUSY(BUSY),                 // 1-bit output: System Monitor busy output
      .CHANNEL(CHANNEL),           // 6-bit output: Channel selection outputs
      .EOC(EOC),                   // 1-bit output: End of Conversion
      .EOS(EOS),                   // 1-bit output: End of Sequence
      .JTAGBUSY(JTAGBUSY),         // 1-bit output: JTAG DRP transaction in progress output
      .JTAGLOCKED(JTAGLOCKED),     // 1-bit output: JTAG requested DRP port lock
      .JTAGMODIFIED(JTAGMODIFIED), // 1-bit output: JTAG Write to the DRP has occurred
      .MUXADDR(MUXADDR),           // 5-bit output: External MUX channel decode
      // Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      .VAUXN(VAUXN),               // 16-bit input: N-side auxiliary analog input
      .VAUXP(VAUXP),               // 16-bit input: P-side auxiliary analog input
      // CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      .CONVST(CONVST),             // 1-bit input: Convert start input
      .CONVSTCLK(CONVSTCLK),       // 1-bit input: Convert start input
      .RESET(RESET),               // 1-bit input: Active-High reset
      // Dedicated Analog Input Pair inputs: VP/VN
      .VN(VN),                     // 1-bit input: N-side analog input
      .VP(VP),                     // 1-bit input: P-side analog input
      // Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      .DADDR(DADDR),               // 8-bit input: DRP address bus
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable signal
      .DI(DI),                     // 16-bit input: DRP input data bus
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // I2C Interface inputs: Ports used with the I2C DRP interface
      .I2C_SCLK(I2C_SCLK),         // 1-bit input: I2C_SCLK input port
      .I2C_SDA(I2C_SDA)            // 1-bit input: I2C_SDA input port
   );

   // End of SYSMONE1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="ARITHMETIC" treetype="folder">
				<SubFolder label="DSP" treetype="folder">
					<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E2)" treetype="template">
//   DSP48E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DSP48E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DSP48E2: 48-bit Multi-Functional Arithmetic Block
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   DSP48E2 #(
      // Feature Control Attributes: Data Path Selection
      .AMULTSEL("A"),                    // Selects A input to multiplier (A, AD)
      .A_INPUT("DIRECT"),                // Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      .BMULTSEL("B"),                    // Selects B input to multiplier (AD, B)
      .B_INPUT("DIRECT"),                // Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      .PREADDINSEL("A"),                 // Selects input to pre-adder (A, B)
      .RND(48'h000000000000),            // Rounding Constant
      .USE_MULT("MULTIPLY"),             // Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
      .USE_SIMD("ONE48"),                // SIMD selection (FOUR12, ONE48, TWO24)
      .USE_WIDEXOR("FALSE"),             // Use the Wide XOR function (FALSE, TRUE)
      .XORSIMD("XOR24_48_96"),           // Mode of operation for the Wide XOR (XOR12, XOR24_48_96)
      // Pattern Detector Attributes: Pattern Detection Configuration
      .AUTORESET_PATDET("NO_RESET"),     // NO_RESET, RESET_MATCH, RESET_NOT_MATCH
      .AUTORESET_PRIORITY("RESET"),      // Priority of AUTORESET vs. CEP (CEP, RESET).
      .MASK(48'h3fffffffffff),           // 48-bit mask value for pattern detect (1=ignore)
      .PATTERN(48'h000000000000),        // 48-bit pattern match for pattern detect
      .SEL_MASK("MASK"),                 // C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
      .SEL_PATTERN("PATTERN"),           // Select pattern value (C, PATTERN)
      .USE_PATTERN_DETECT("NO_PATDET"),  // Enable pattern detect (NO_PATDET, PATDET)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_ALUMODE_INVERTED(4'b0000),     // Optional inversion for ALUMODE
      .IS_CARRYIN_INVERTED(1'b0),        // Optional inversion for CARRYIN
      .IS_CLK_INVERTED(1'b0),            // Optional inversion for CLK
      .IS_INMODE_INVERTED(5'b00000),     // Optional inversion for INMODE
      .IS_OPMODE_INVERTED(9'b000000000), // Optional inversion for OPMODE
      .IS_RSTALLCARRYIN_INVERTED(1'b0),  // Optional inversion for RSTALLCARRYIN
      .IS_RSTALUMODE_INVERTED(1'b0),     // Optional inversion for RSTALUMODE
      .IS_RSTA_INVERTED(1'b0),           // Optional inversion for RSTA
      .IS_RSTB_INVERTED(1'b0),           // Optional inversion for RSTB
      .IS_RSTCTRL_INVERTED(1'b0),        // Optional inversion for RSTCTRL
      .IS_RSTC_INVERTED(1'b0),           // Optional inversion for RSTC
      .IS_RSTD_INVERTED(1'b0),           // Optional inversion for RSTD
      .IS_RSTINMODE_INVERTED(1'b0),      // Optional inversion for RSTINMODE
      .IS_RSTM_INVERTED(1'b0),           // Optional inversion for RSTM
      .IS_RSTP_INVERTED(1'b0),           // Optional inversion for RSTP
      // Register Control Attributes: Pipeline Register Configuration
      .ACASCREG(1),                      // Number of pipeline stages between A/ACIN and ACOUT (0-2)
      .ADREG(1),                         // Pipeline stages for pre-adder (0-1)
      .ALUMODEREG(1),                    // Pipeline stages for ALUMODE (0-1)
      .AREG(1),                          // Pipeline stages for A (0-2)
      .BCASCREG(1),                      // Number of pipeline stages between B/BCIN and BCOUT (0-2)
      .BREG(1),                          // Pipeline stages for B (0-2)
      .CARRYINREG(1),                    // Pipeline stages for CARRYIN (0-1)
      .CARRYINSELREG(1),                 // Pipeline stages for CARRYINSEL (0-1)
      .CREG(1),                          // Pipeline stages for C (0-1)
      .DREG(1),                          // Pipeline stages for D (0-1)
      .INMODEREG(1),                     // Pipeline stages for INMODE (0-1)
      .MREG(1),                          // Multiplier pipeline stages (0-1)
      .OPMODEREG(1),                     // Pipeline stages for OPMODE (0-1)
      .PREG(1)                           // Number of pipeline stages for P (0-1)
   )
   DSP48E2_inst (
      // Cascade outputs: Cascade Ports
      .ACOUT(ACOUT),                   // 30-bit output: A port cascade
      .BCOUT(BCOUT),                   // 18-bit output: B cascade
      .CARRYCASCOUT(CARRYCASCOUT),     // 1-bit output: Cascade carry
      .MULTSIGNOUT(MULTSIGNOUT),       // 1-bit output: Multiplier sign cascade
      .PCOUT(PCOUT),                   // 48-bit output: Cascade output
      // Control outputs: Control Inputs/Status Bits
      .OVERFLOW(OVERFLOW),             // 1-bit output: Overflow in add/acc
      .PATTERNBDETECT(PATTERNBDETECT), // 1-bit output: Pattern bar detect
      .PATTERNDETECT(PATTERNDETECT),   // 1-bit output: Pattern detect
      .UNDERFLOW(UNDERFLOW),           // 1-bit output: Underflow in add/acc
      // Data outputs: Data Ports
      .CARRYOUT(CARRYOUT),             // 4-bit output: Carry
      .P(P),                           // 48-bit output: Primary data
      .XOROUT(XOROUT),                 // 8-bit output: XOR data
      // Cascade inputs: Cascade Ports
      .ACIN(ACIN),                     // 30-bit input: A cascade data
      .BCIN(BCIN),                     // 18-bit input: B cascade
      .CARRYCASCIN(CARRYCASCIN),       // 1-bit input: Cascade carry
      .MULTSIGNIN(MULTSIGNIN),         // 1-bit input: Multiplier sign cascade
      .PCIN(PCIN),                     // 48-bit input: P cascade
      // Control inputs: Control Inputs/Status Bits
      .ALUMODE(ALUMODE),               // 4-bit input: ALU control
      .CARRYINSEL(CARRYINSEL),         // 3-bit input: Carry select
      .CLK(CLK),                       // 1-bit input: Clock
      .INMODE(INMODE),                 // 5-bit input: INMODE control
      .OPMODE(OPMODE),                 // 9-bit input: Operation mode
      // Data inputs: Data Ports
      .A(A),                           // 30-bit input: A data
      .B(B),                           // 18-bit input: B data
      .C(C),                           // 48-bit input: C data
      .CARRYIN(CARRYIN),               // 1-bit input: Carry-in
      .D(D),                           // 27-bit input: D data
      // Reset/Clock Enable inputs: Reset/Clock Enable Inputs
      .CEA1(CEA1),                     // 1-bit input: Clock enable for 1st stage AREG
      .CEA2(CEA2),                     // 1-bit input: Clock enable for 2nd stage AREG
      .CEAD(CEAD),                     // 1-bit input: Clock enable for ADREG
      .CEALUMODE(CEALUMODE),           // 1-bit input: Clock enable for ALUMODE
      .CEB1(CEB1),                     // 1-bit input: Clock enable for 1st stage BREG
      .CEB2(CEB2),                     // 1-bit input: Clock enable for 2nd stage BREG
      .CEC(CEC),                       // 1-bit input: Clock enable for CREG
      .CECARRYIN(CECARRYIN),           // 1-bit input: Clock enable for CARRYINREG
      .CECTRL(CECTRL),                 // 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
      .CED(CED),                       // 1-bit input: Clock enable for DREG
      .CEINMODE(CEINMODE),             // 1-bit input: Clock enable for INMODEREG
      .CEM(CEM),                       // 1-bit input: Clock enable for MREG
      .CEP(CEP),                       // 1-bit input: Clock enable for PREG
      .RSTA(RSTA),                     // 1-bit input: Reset for AREG
      .RSTALLCARRYIN(RSTALLCARRYIN),   // 1-bit input: Reset for CARRYINREG
      .RSTALUMODE(RSTALUMODE),         // 1-bit input: Reset for ALUMODEREG
      .RSTB(RSTB),                     // 1-bit input: Reset for BREG
      .RSTC(RSTC),                     // 1-bit input: Reset for CREG
      .RSTCTRL(RSTCTRL),               // 1-bit input: Reset for OPMODEREG and CARRYINSELREG
      .RSTD(RSTD),                     // 1-bit input: Reset for DREG and ADREG
      .RSTINMODE(RSTINMODE),           // 1-bit input: Reset for INMODEREG
      .RSTM(RSTM),                     // 1-bit input: Reset for MREG
      .RSTP(RSTP)                      // 1-bit input: Reset for PREG
   );

   // End of DSP48E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="BLOCKRAM" treetype="folder">
				<SubFolder label="BRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E2)" treetype="template">
//  RAMB18E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB18E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB18E2: 18K-bit Configurable Synchronous Block RAM
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAMB18E2 #(
      // CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      .CASCADE_ORDER_A("NONE"),
      .CASCADE_ORDER_B("NONE"),
      // CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      .CLOCK_DOMAINS("INDEPENDENT"),
      // Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0, 1)
      .DOA_REG(1),
      .DOB_REG(1),
      // ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      .ENADDRENA("FALSE"),
      .ENADDRENB("FALSE"),
      // INITP_00 to INITP_07: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_3F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(18'h00000),
      .INIT_B(18'h00000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLKARDCLK_INVERTED(1'b0),
      .IS_CLKBWRCLK_INVERTED(1'b0),
      .IS_ENARDEN_INVERTED(1'b0),
      .IS_ENBWREN_INVERTED(1'b0),
      .IS_RSTRAMARSTRAM_INVERTED(1'b0),
      .IS_RSTRAMB_INVERTED(1'b0),
      .IS_RSTREGARSTREG_INVERTED(1'b0),
      .IS_RSTREGB_INVERTED(1'b0),
      // RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      .RDADDRCHANGEA("FALSE"),
      .RDADDRCHANGEB("FALSE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-9
      .READ_WIDTH_B(0),                                                                 // 0-9
      .WRITE_WIDTH_A(0),                                                                // 0-9
      .WRITE_WIDTH_B(0),                                                                // 0-9
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(18'h00000),
      .SRVAL_B(18'h00000),
      // Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      .SLEEP_ASYNC("FALSE"),
      // WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      .WRITE_MODE_A("NO_CHANGE"),
      .WRITE_MODE_B("NO_CHANGE") 
   )
   RAMB18E2_inst (
      // Cascade Signals outputs: Multi-BRAM cascade signals
      .CASDOUTA(CASDOUTA),               // 16-bit output: Port A cascade output data
      .CASDOUTB(CASDOUTB),               // 16-bit output: Port B cascade output data
      .CASDOUTPA(CASDOUTPA),             // 2-bit output: Port A cascade output parity data
      .CASDOUTPB(CASDOUTPB),             // 2-bit output: Port B cascade output parity data
      // Port A Data outputs: Port A data
      .DOUTADOUT(DOUTADOUT),             // 16-bit output: Port A data/LSB data
      .DOUTPADOUTP(DOUTPADOUTP),         // 2-bit output: Port A parity/LSB parity
      // Port B Data outputs: Port B data
      .DOUTBDOUT(DOUTBDOUT),             // 16-bit output: Port B data/MSB data
      .DOUTPBDOUTP(DOUTPBDOUTP),         // 2-bit output: Port B parity/MSB parity
      // Cascade Signals inputs: Multi-BRAM cascade signals
      .CASDIMUXA(CASDIMUXA),             // 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      .CASDIMUXB(CASDIMUXB),             // 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      .CASDINA(CASDINA),                 // 16-bit input: Port A cascade input data
      .CASDINB(CASDINB),                 // 16-bit input: Port B cascade input data
      .CASDINPA(CASDINPA),               // 2-bit input: Port A cascade input parity data
      .CASDINPB(CASDINPB),               // 2-bit input: Port B cascade input parity data
      .CASDOMUXA(CASDOMUXA),             // 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      .CASDOMUXB(CASDOMUXB),             // 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      .CASDOMUXEN_A(CASDOMUXEN_A),       // 1-bit input: Port A unregistered output data enable
      .CASDOMUXEN_B(CASDOMUXEN_B),       // 1-bit input: Port B unregistered output data enable
      .CASOREGIMUXA(CASOREGIMUXA),       // 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      .CASOREGIMUXB(CASOREGIMUXB),       // 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      .CASOREGIMUXEN_A(CASOREGIMUXEN_A), // 1-bit input: Port A registered output data enable
      .CASOREGIMUXEN_B(CASOREGIMUXEN_B), // 1-bit input: Port B registered output data enable
      // Port A Address/Control Signals inputs: Port A address and control signals
      .ADDRARDADDR(ADDRARDADDR),         // 14-bit input: A/Read port address
      .ADDRENA(ADDRENA),                 // 1-bit input: Active-High A/Read port address enable
      .CLKARDCLK(CLKARDCLK),             // 1-bit input: A/Read port clock
      .ENARDEN(ENARDEN),                 // 1-bit input: Port A enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),         // 1-bit input: Port A register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM),     // 1-bit input: Port A set/reset
      .RSTREGARSTREG(RSTREGARSTREG),     // 1-bit input: Port A register set/reset
      .WEA(WEA),                         // 2-bit input: Port A write enable
      // Port A Data inputs: Port A data
      .DINADIN(DINADIN),                 // 16-bit input: Port A data/LSB data
      .DINPADINP(DINPADINP),             // 2-bit input: Port A parity/LSB parity
      // Port B Address/Control Signals inputs: Port B address and control signals
      .ADDRBWRADDR(ADDRBWRADDR),         // 14-bit input: B/Write port address
      .ADDRENB(ADDRENB),                 // 1-bit input: Active-High B/Write port address enable
      .CLKBWRCLK(CLKBWRCLK),             // 1-bit input: B/Write port clock
      .ENBWREN(ENBWREN),                 // 1-bit input: Port B enable/Write enable
      .REGCEB(REGCEB),                   // 1-bit input: Port B register enable
      .RSTRAMB(RSTRAMB),                 // 1-bit input: Port B set/reset
      .RSTREGB(RSTREGB),                 // 1-bit input: Port B register set/reset
      .SLEEP(SLEEP),                     // 1-bit input: Sleep Mode
      .WEBWE(WEBWE),                     // 4-bit input: Port B write enable/Write enable
      // Port B Data inputs: Port B data
      .DINBDIN(DINBDIN),                 // 16-bit input: Port B data/MSB data
      .DINPBDINP(DINPBDINP)              // 2-bit input: Port B parity/MSB parity
   );

   // End of RAMB18E2_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E2)" treetype="template">
//  RAMB36E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB36E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB36E2: 36K-bit Configurable Synchronous Block RAM
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAMB36E2 #(
      // CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      .CASCADE_ORDER_A("NONE"),
      .CASCADE_ORDER_B("NONE"),
      // CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      .CLOCK_DOMAINS("INDEPENDENT"),
      .DOB_REG(1),
      // Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0, 1)
      .DOA_REG(1),
      // ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      .ENADDRENA("FALSE"),
      .ENADDRENB("FALSE"),
      // EN_ECC_PIPE: ECC pipeline register, "TRUE"/"FALSE" 
      .EN_ECC_PIPE("FALSE"),
      // EN_ECC_READ: Enable ECC decoder, "TRUE"/"FALSE" 
      .EN_ECC_READ("FALSE"),
      // EN_ECC_WRITE: Enable ECC encoder, "TRUE"/"FALSE" 
      .EN_ECC_WRITE("FALSE"),
      // INITP_00 to INITP_0F: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_7F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(36'h000000000),
      .INIT_B(36'h000000000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLKARDCLK_INVERTED(1'b0),
      .IS_CLKBWRCLK_INVERTED(1'b0),
      .IS_ENARDEN_INVERTED(1'b0),
      .IS_ENBWREN_INVERTED(1'b0),
      .IS_RSTRAMARSTRAM_INVERTED(1'b0),
      .IS_RSTRAMB_INVERTED(1'b0),
      .IS_RSTREGARSTREG_INVERTED(1'b0),
      .IS_RSTREGB_INVERTED(1'b0),
      // RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      .RDADDRCHANGEA("FALSE"),
      .RDADDRCHANGEB("FALSE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-9
      .READ_WIDTH_B(0),                                                                 // 0-9
      .WRITE_WIDTH_A(0),                                                                // 0-9
      .WRITE_WIDTH_B(0),                                                                // 0-9
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(36'h000000000),
      .SRVAL_B(36'h000000000),
      // Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      .SLEEP_ASYNC("FALSE"),
      // WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      .WRITE_MODE_A("NO_CHANGE"),
      .WRITE_MODE_B("NO_CHANGE") 
   )
   RAMB36E2_inst (
      // Cascade Signals outputs: Multi-BRAM cascade signals
      .CASDOUTA(CASDOUTA),               // 32-bit output: Port A cascade output data
      .CASDOUTB(CASDOUTB),               // 32-bit output: Port B cascade output data
      .CASDOUTPA(CASDOUTPA),             // 4-bit output: Port A cascade output parity data
      .CASDOUTPB(CASDOUTPB),             // 4-bit output: Port B cascade output parity data
      .CASOUTDBITERR(CASOUTDBITERR),     // 1-bit output: DBITERR cascade output
      .CASOUTSBITERR(CASOUTSBITERR),     // 1-bit output: SBITERR cascade output
      // ECC Signals outputs: Error Correction Circuitry ports
      .DBITERR(DBITERR),                 // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),             // 8-bit output: Generated error correction parity
      .RDADDRECC(RDADDRECC),             // 9-bit output: ECC Read Address
      .SBITERR(SBITERR),                 // 1-bit output: Single bit error status
      // Port A Data outputs: Port A data
      .DOUTADOUT(DOUTADOUT),             // 32-bit output: Port A ata/LSB data
      .DOUTPADOUTP(DOUTPADOUTP),         // 4-bit output: Port A parity/LSB parity
      // Port B Data outputs: Port B data
      .DOUTBDOUT(DOUTBDOUT),             // 32-bit output: Port B data/MSB data
      .DOUTPBDOUTP(DOUTPBDOUTP),         // 4-bit output: Port B parity/MSB parity
      // Cascade Signals inputs: Multi-BRAM cascade signals
      .CASDIMUXA(CASDIMUXA),             // 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      .CASDIMUXB(CASDIMUXB),             // 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      .CASDINA(CASDINA),                 // 32-bit input: Port A cascade input data
      .CASDINB(CASDINB),                 // 32-bit input: Port B cascade input data
      .CASDINPA(CASDINPA),               // 4-bit input: Port A cascade input parity data
      .CASDINPB(CASDINPB),               // 4-bit input: Port B cascade input parity data
      .CASDOMUXA(CASDOMUXA),             // 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      .CASDOMUXB(CASDOMUXB),             // 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      .CASDOMUXEN_A(CASDOMUXEN_A),       // 1-bit input: Port A unregistered output data enable
      .CASDOMUXEN_B(CASDOMUXEN_B),       // 1-bit input: Port B unregistered output data enable
      .CASINDBITERR(CASINDBITERR),       // 1-bit input: DBITERR cascade input
      .CASINSBITERR(CASINSBITERR),       // 1-bit input: SBITERR cascade input
      .CASOREGIMUXA(CASOREGIMUXA),       // 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      .CASOREGIMUXB(CASOREGIMUXB),       // 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      .CASOREGIMUXEN_A(CASOREGIMUXEN_A), // 1-bit input: Port A registered output data enable
      .CASOREGIMUXEN_B(CASOREGIMUXEN_B), // 1-bit input: Port B registered output data enable
      // ECC Signals inputs: Error Correction Circuitry ports
      .ECCPIPECE(ECCPIPECE),             // 1-bit input: ECC Pipeline Register Enable
      .INJECTDBITERR(INJECTDBITERR),     // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR),
      // Port A Address/Control Signals inputs: Port A address and control signals
      .ADDRARDADDR(ADDRARDADDR),         // 15-bit input: A/Read port address
      .ADDRENA(ADDRENA),                 // 1-bit input: Active-High A/Read port address enable
      .CLKARDCLK(CLKARDCLK),             // 1-bit input: A/Read port clock
      .ENARDEN(ENARDEN),                 // 1-bit input: Port A enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),         // 1-bit input: Port A register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM),     // 1-bit input: Port A set/reset
      .RSTREGARSTREG(RSTREGARSTREG),     // 1-bit input: Port A register set/reset
      .SLEEP(SLEEP),                     // 1-bit input: Sleep Mode
      .WEA(WEA),                         // 4-bit input: Port A write enable
      // Port A Data inputs: Port A data
      .DINADIN(DINADIN),                 // 32-bit input: Port A data/LSB data
      .DINPADINP(DINPADINP),             // 4-bit input: Port A parity/LSB parity
      // Port B Address/Control Signals inputs: Port B address and control signals
      .ADDRBWRADDR(ADDRBWRADDR),         // 15-bit input: B/Write port address
      .ADDRENB(ADDRENB),                 // 1-bit input: Active-High B/Write port address enable
      .CLKBWRCLK(CLKBWRCLK),             // 1-bit input: B/Write port clock
      .ENBWREN(ENBWREN),                 // 1-bit input: Port B enable/Write enable
      .REGCEB(REGCEB),                   // 1-bit input: Port B register enable
      .RSTRAMB(RSTRAMB),                 // 1-bit input: Port B set/reset
      .RSTREGB(RSTREGB),                 // 1-bit input: Port B register set/reset
      .WEBWE(WEBWE),                     // 8-bit input: Port B write enable/Write enable
      // Port B Data inputs: Port B data
      .DINBDIN(DINBDIN),                 // 32-bit input: Port B data/MSB data
      .DINPBDINP(DINPBDINP)              // 4-bit input: Port B parity/MSB parity
   );

   // End of RAMB36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E2)" treetype="template">
//  FIFO18E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO18E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO18E2: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FIFO18E2 #(
      .CASCADE_ORDER("NONE"),            // FIRST, LAST, MIDDLE, NONE, PARALLEL
      .CLOCK_DOMAINS("INDEPENDENT"),     // COMMON, INDEPENDENT
      .FIRST_WORD_FALL_THROUGH("FALSE"), // FALSE, TRUE
      .INIT(36'h000000000),              // Initial values on output port
      .PROG_EMPTY_THRESH(256),           // Programmable Empty Threshold
      .PROG_FULL_THRESH(256),            // Programmable Full Threshold
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_RDCLK_INVERTED(1'b0),          // Optional inversion for RDCLK
      .IS_RDEN_INVERTED(1'b0),           // Optional inversion for RDEN
      .IS_RSTREG_INVERTED(1'b0),         // Optional inversion for RSTREG
      .IS_RST_INVERTED(1'b0),            // Optional inversion for RST
      .IS_WRCLK_INVERTED(1'b0),          // Optional inversion for WRCLK
      .IS_WREN_INVERTED(1'b0),           // Optional inversion for WREN
      .RDCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .READ_WIDTH(4),                    // 18-9
      .REGISTER_MODE("UNREGISTERED"),    // DO_PIPELINED, REGISTERED, UNREGISTERED
      .RSTREG_PRIORITY("RSTREG"),        // REGCE, RSTREG
      .SLEEP_ASYNC("FALSE"),             // FALSE, TRUE
      .SRVAL(36'h000000000),             // SET/reset value of the FIFO outputs
      .WRCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .WRITE_WIDTH(4)                    // 18-9
   )
   FIFO18E2_inst (
      // Cascade Signals outputs: Multi-FIFO cascade signals
      .CASDOUT(CASDOUT),             // 32-bit output: Data cascade output bus
      .CASDOUTP(CASDOUTP),           // 4-bit output: Parity data cascade output bus
      .CASNXTEMPTY(CASNXTEMPTY),     // 1-bit output: Cascade next empty
      .CASPRVRDEN(CASPRVRDEN),       // 1-bit output: Cascade previous read enable
      // Read Data outputs: Read output data
      .DOUT(DOUT),                   // 32-bit output: FIFO data output bus
      .DOUTP(DOUTP),                 // 4-bit output: FIFO parity output bus.
      // Status outputs: Flags and other FIFO status outputs
      .EMPTY(EMPTY),                 // 1-bit output: Empty
      .FULL(FULL),                   // 1-bit output: Full
      .PROGEMPTY(PROGEMPTY),         // 1-bit output: Programmable empty
      .PROGFULL(PROGFULL),           // 1-bit output: Programmable full
      .RDCOUNT(RDCOUNT),             // 13-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .RDRSTBUSY(RDRSTBUSY),         // 1-bit output: Reset busy (sync to RDCLK)
      .WRCOUNT(WRCOUNT),             // 13-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write Error
      .WRRSTBUSY(WRRSTBUSY),         // 1-bit output: Reset busy (sync to WRCLK)
      // Cascade Signals inputs: Multi-FIFO cascade signals
      .CASDIN(CASDIN),               // 32-bit input: Data cascade input bus
      .CASDINP(CASDINP),             // 4-bit input: Parity data cascade input bus
      .CASDOMUX(CASDOMUX),           // 1-bit input: Cascade MUX select
      .CASDOMUXEN(CASDOMUXEN),       // 1-bit input: Enable for cascade MUX select
      .CASNXTRDEN(CASNXTRDEN),       // 1-bit input: Cascade next read enable
      .CASOREGIMUX(CASOREGIMUX),     // 1-bit input: Cascade output MUX select
      .CASOREGIMUXEN(CASOREGIMUXEN), // 1-bit input: Cascade output MUX select enable
      .CASPRVEMPTY(CASPRVEMPTY),     // 1-bit input: Cascade previous empty
      // Read Control Signals inputs: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Output register clock enable
      .RSTREG(RSTREG),               // 1-bit input: Output register reset
      .SLEEP(SLEEP),                 // 1-bit input: Sleep Mode
      // Write Control Signals inputs: Write clock and enable input signals
      .RST(RST),                     // 1-bit input: Reset
      .WRCLK(WRCLK),                 // 1-bit input: Write clock
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data inputs: Write input data
      .DIN(DIN),                     // 32-bit input: FIFO data input bus
      .DINP(DINP)                    // 4-bit input: FIFO parity input bus
   );

   // End of FIFO18E2_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E2)" treetype="template">
//  FIFO36E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO36E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO36E2: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FIFO36E2 #(
      .CASCADE_ORDER("NONE"),            // FIRST, LAST, MIDDLE, NONE, PARALLEL
      .CLOCK_DOMAINS("INDEPENDENT"),     // COMMON, INDEPENDENT
      .EN_ECC_PIPE("FALSE"),             // ECC pipeline register, (FALSE, TRUE)
      .EN_ECC_READ("FALSE"),             // Enable ECC decoder, (FALSE, TRUE)
      .EN_ECC_WRITE("FALSE"),            // Enable ECC encoder, (FALSE, TRUE)
      .FIRST_WORD_FALL_THROUGH("FALSE"), // FALSE, TRUE
      .INIT(72'h000000000000000000),     // Initial values on output port
      .PROG_EMPTY_THRESH(256),           // Programmable Empty Threshold
      .PROG_FULL_THRESH(256),            // Programmable Full Threshold
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_RDCLK_INVERTED(1'b0),          // Optional inversion for RDCLK
      .IS_RDEN_INVERTED(1'b0),           // Optional inversion for RDEN
      .IS_RSTREG_INVERTED(1'b0),         // Optional inversion for RSTREG
      .IS_RST_INVERTED(1'b0),            // Optional inversion for RST
      .IS_WRCLK_INVERTED(1'b0),          // Optional inversion for WRCLK
      .IS_WREN_INVERTED(1'b0),           // Optional inversion for WREN
      .RDCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .READ_WIDTH(4),                    // 18-9
      .REGISTER_MODE("UNREGISTERED"),    // DO_PIPELINED, REGISTERED, UNREGISTERED
      .RSTREG_PRIORITY("RSTREG"),        // REGCE, RSTREG
      .SLEEP_ASYNC("FALSE"),             // FALSE, TRUE
      .SRVAL(72'h000000000000000000),    // SET/reset value of the FIFO outputs
      .WRCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .WRITE_WIDTH(4)                    // 18-9
   )
   FIFO36E2_inst (
      // Cascade Signals outputs: Multi-FIFO cascade signals
      .CASDOUT(CASDOUT),             // 64-bit output: Data cascade output bus
      .CASDOUTP(CASDOUTP),           // 8-bit output: Parity data cascade output bus
      .CASNXTEMPTY(CASNXTEMPTY),     // 1-bit output: Cascade next empty
      .CASPRVRDEN(CASPRVRDEN),       // 1-bit output: Cascade previous read enable
      // ECC Signals outputs: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Read Data outputs: Read output data
      .DOUT(DOUT),                   // 64-bit output: FIFO data output bus
      .DOUTP(DOUTP),                 // 8-bit output: FIFO parity output bus.
      // Status outputs: Flags and other FIFO status outputs
      .EMPTY(EMPTY),                 // 1-bit output: Empty
      .FULL(FULL),                   // 1-bit output: Full
      .PROGEMPTY(PROGEMPTY),         // 1-bit output: Programmable empty
      .PROGFULL(PROGFULL),           // 1-bit output: Programmable full
      .RDCOUNT(RDCOUNT),             // 14-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .RDRSTBUSY(RDRSTBUSY),         // 1-bit output: Reset busy (sync to RDCLK)
      .WRCOUNT(WRCOUNT),             // 14-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write Error
      .WRRSTBUSY(WRRSTBUSY),         // 1-bit output: Reset busy (sync to WRCLK)
      // Cascade Signals inputs: Multi-FIFO cascade signals
      .CASDIN(CASDIN),               // 64-bit input: Data cascade input bus
      .CASDINP(CASDINP),             // 8-bit input: Parity data cascade input bus
      .CASDOMUX(CASDOMUX),           // 1-bit input: Cascade MUX select input
      .CASDOMUXEN(CASDOMUXEN),       // 1-bit input: Enable for cascade MUX select
      .CASNXTRDEN(CASNXTRDEN),       // 1-bit input: Cascade next read enable
      .CASOREGIMUX(CASOREGIMUX),     // 1-bit input: Cascade output MUX select
      .CASOREGIMUXEN(CASOREGIMUXEN), // 1-bit input: Cascade output MUX select enable
      .CASPRVEMPTY(CASPRVEMPTY),     // 1-bit input: Cascade previous empty
      // ECC Signals inputs: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR), // 1-bit input: Inject a single bit error
      // Read Control Signals inputs: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Output register clock enable
      .RSTREG(RSTREG),               // 1-bit input: Output register reset
      .SLEEP(SLEEP),                 // 1-bit input: Sleep Mode
      // Write Control Signals inputs: Write clock and enable input signals
      .RST(RST),                     // 1-bit input: Reset
      .WRCLK(WRCLK),                 // 1-bit input: Write clock
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data inputs: Write input data
      .DIN(DIN),                     // 64-bit input: FIFO data input bus
      .DINP(DINP)                    // 8-bit input: FIFO parity input bus
   );

   // End of FIFO36E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLB" treetype="folder">
				<SubFolder label="CARRY" treetype="folder">
					<Template label="Fast Carry Logic with Look Ahead (CARRY8)" treetype="template">
//   CARRY8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CARRY8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CARRY8: Fast Carry Logic with Look Ahead
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   CARRY8 #(
      .CARRY_TYPE("SINGLE_CY8")  // 8-bit or dual 4-bit carry (DUAL_CY4, SINGLE_CY8)
   )
   CARRY8_inst (
      .CO(CO),         // 8-bit output: Carry-out
      .O(O),           // 8-bit output: Carry chain XOR data out
      .CI(CI),         // 1-bit input: Lower Carry-In
      .CI_TOP(CI_TOP), // 1-bit input: Upper Carry-In
      .DI(DI),         // 8-bit input: Carry-MUX data in
      .S(S)            // 8-bit input: Carry-mux select
   );

   // End of CARRY8_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Two input AND gate implemented in place of a CLB Latch (AND2B1L)" treetype="template">
//   AND2B1L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (AND2B1L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // AND2B1L: Two input AND gate implemented in place of a CLB Latch
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   AND2B1L #(
      .IS_SRI_INVERTED(1'b0)  // Optional inversion for SRI
   )
   AND2B1L_inst (
      .O(O),     // 1-bit output: AND gate output
      .DI(DI),   // 1-bit input: Data input connected to LUT logic
      .SRI(SRI)  // 1-bit input: External CLB data
   );

   // End of AND2B1L_inst instantiation
					</Template>
					<Template label="Two input OR gate implemented in place of a CLB Latch (OR2L)" treetype="template">
//    OR2L     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OR2L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OR2L: Two input OR gate implemented in place of a CLB Latch
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OR2L #(
      .IS_SRI_INVERTED(1'b0)  // Optional inversion for SRI
   )
   OR2L_inst (
      .O(O),     // 1-bit output: OR gate output
      .DI(DI),   // 1-bit input: Data input connected to LUT logic
      .SRI(SRI)  // 1-bit input: External CLB data
   );

   // End of OR2L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUT" treetype="folder">
					<Template label="1-Bit Look-Up Table (LUT1)" treetype="template">
//    LUT1     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1: 1-Bit Look-Up Table
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT1 #(
      .INIT(2'h0)  // Logic function
   )
   LUT1_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0)  // 1-bit input: LUT
   );

   // End of LUT1_inst instantiation
					</Template>
					<Template label="2-Bit Look-Up Table (LUT2)" treetype="template">
//    LUT2     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2: 2-Bit Look-Up Table
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT2 #(
      .INIT(4'h0)  // Logic function
   )
   LUT2_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1)  // 1-bit input: LUT
   );

   // End of LUT2_inst instantiation
					</Template>
					<Template label="3-Bit Look-Up Table (LUT3)" treetype="template">
//    LUT3     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3: 3-Bit Look-Up Table
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT3 #(
      .INIT(8'h00)  // Logic function
   )
   LUT3_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2)  // 1-bit input: LUT
   );

   // End of LUT3_inst instantiation
					</Template>
					<Template label="4-Bit Look-Up Table (LUT4)" treetype="template">
//    LUT4     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4: 4-Bit Look-Up Table
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT(16'h0000)  // Logic function
   )
   LUT4_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3)  // 1-bit input: LUT
   );

   // End of LUT4_inst instantiation
					</Template>
					<Template label="5-Bit Look-Up Table (LUT5)" treetype="template">
//    LUT5     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5: 5-Bit Look-Up Table
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT5 #(
      .INIT(32'h00000000)  // Logic function
   )
   LUT5_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3), // 1-bit input: LUT
      .I4(I4)  // 1-bit input: LUT
   );

   // End of LUT5_inst instantiation
					</Template>
					<Template label="5-input Dynamically Reconfigurable Look-Up Table (LUT) (CFGLUT5)" treetype="template">
//   CFGLUT5   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CFGLUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CFGLUT5: 5-input Dynamically Reconfigurable Look-Up Table (LUT)
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   CFGLUT5 #(
      .INIT(32'h00000000),    // Initial logic function
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   CFGLUT5_inst (
      .CDO(CDO), // 1-bit output: Reconfiguration cascade
      .O5(O5),   // 1-bit output: 4-LUT
      .O6(O6),   // 1-bit output: 5-LUT
      .CDI(CDI), // 1-bit input: Reconfiguration data
      .CE(CE),   // 1-bit input: Reconfiguration enable
      .CLK(CLK), // 1-bit input: Clock
      // LUT Inputs inputs: Logic inputs
      .I0(I0),
      .I1(I1),
      .I2(I2),
      .I3(I3),
      .I4(I4) 
   );

   // End of CFGLUT5_inst instantiation
					</Template>
					<Template label="6-Bit Look-Up Table (LUT6)" treetype="template">
//    LUT6     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6: 6-Bit Look-Up Table
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT6 #(
      .INIT(64'h0000000000000000)  // Logic function
   )
   LUT6_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3), // 1-bit input: LUT
      .I4(I4), // 1-bit input: LUT
      .I5(I5)  // 1-bit input: LUT
   );

   // End of LUT6_inst instantiation
					</Template>
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
// The INIT parameter for the FPGA LUT primitive is what gives the LUT its 
// logical value. By default this value is zero thus driving the output to a  
// zero regardless of the input values (acting as a ground) however in most 
// cases an new INIT value must be determined in order to specify the logic 
// function for the LUT primitive.  There are a few methods in which the LUT 
// value can be determined and two of those methods will be discussed here.
//
// The Truth Table Method
// ----------------------
//
//  A common method to determine the desired INIT value for a LUT is using a 
// truth table.  To do so, simply create a binary truth table of all possible 
// inputs, specify the desired logic value of the output and then create the 
// INIT string from those output values.  An example is shown below:
//
// Example of determining an XOR INIT equation for a LUT4:
//
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | 0 |\
//     |  0  0  0  1 | 1 | \ = 4'b0110 = 4'h6 ---------------+
//     |  0  0  1  0 | 1 | /                                 |
//     |  0  0  1  1 | 0 |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | 1 |\                                  |
//     |  0  1  0  1 | 0 | \ = 4'b1001 = 4'h9                |
//     |  0  1  1  0 | 0 | /                                 |
//     |  0  1  1  1 | 1 |/                                  |                     
//     |-------------|---|                     INIT = 16'h6996
//     |  1  0  0  0 | 1 |\                               |
//     |  1  0  0  1 | 0 | \ = 4'b0110 = 4'h9             |
//     |  1  0  1  0 | 0 | /                              |
//     |  1  0  1  1 | 1 |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | 0 |\                               |
//     |  1  1  0  1 | 1 | \ = 4'b1001 = 4'h6 ------------+
//     |  1  1  1  0 | 1 | /
//     |  1  1  1  1 | 0 |/
//     -------------------
//
// Example of determining a 3-input AND gate:
//
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | 0 |\
//     |  0  0  1 | 0 | \ = 4'b0000 = 4'h0 --------------+
//     |  0  1  0 | 0 | /                                |
//     |  0  1  1 | 0 |/                                 |
//     |----------|---|                       INIT = 8'h80 
//     |  1  0  0 | 0 |\                                |
//     |  1  0  1 | 0 | \ = 4'b1000 = 4'h8 -------------+
//     |  1  1  0 | 0 | / 
//     |  1  1  1 | 1 |/                      
//     ----------------
//
// The Equation Method
// -------------------
//
// Another method to determine the LUT value is to define parameters for each 
// input to the LUT that correspond to their listed truth value and use those to
// build the logic equation you are after.  This method is easier to understand 
// once you have grasped the concept and more self-documenting that the above 
// method however does require the code to first specify the appropriate 
// parameters.  See the example below.
//
// Example of specifying the equation (A and B) or (C and D) for a LUT4:
//
   // The following parameters are defined to allow for
   //   equation-based INIT specification.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;

   // LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT((I0&amp;I1)|(I2&amp;I3))  // Specify LUT Contents
   ) LUT4_inst (
      .O(O_LUT), // LUT general output
      .I0(A),    // LUT input
      .I1(B),    // LUT input
      .I2(C),    // LUT input
      .I3(D)     // LUT input
   );

   // End of LUT4_inst instantiation

// With the parameters specifying all possible cases for the truth table, a 
// Verilog equation can be written to determine the end INIT value.
						</Template>
						<SubFolder label="INIT Parameters" treetype="folder">
							<Template label="LUT1" treetype="template">
   // The following parameter is defined to allow for
   //   equation-based INIT specification for a LUT1.
   parameter I0 = 2'b10;
							</Template>
							<Template label="LUT2" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT2.
   parameter I0 = 4'ha;
   parameter I1 = 4'hc;
							</Template>
							<Template label="LUT3" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT3.
   parameter I0 = 8'haa;
   parameter I1 = 8'hcc;
   parameter I2 = 8'hf0;
							</Template>
							<Template label="LUT4" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT4.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;
							</Template>
							<Template label="LUT5" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT5.
   parameter I0 = 32'haaaaaaaa;
   parameter I1 = 32'hcccccccc;
   parameter I2 = 32'hf0f0f0f0;
   parameter I3 = 32'hff00ff00;
   parameter I4 = 32'hffff0000;
							</Template>
							<Template label="LUT6" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT6.
   parameter I0 = 64'haaaaaaaaaaaaaaaa;
   parameter I1 = 64'hcccccccccccccccc;
   parameter I2 = 64'hf0f0f0f0f0f0f0f0;
   parameter I3 = 64'hff00ff00ff00ff00;
   parameter I4 = 64'hffff0000ffff0000;
   parameter I5 = 64'hffffffff00000000;
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
//  Truth Table to determine INIT value for a LUT1
//      ________
//     | I0 | O |
//     |--------|
//     |  0 | ? |\
//     |  1 | ? |/ = 2'b??
//     ----------
							</Template>
							<Template label="LUT2" treetype="template">
//  Truth Table to determine INIT value for a LUT2
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
//     |  0  1  0 | ? | /
//     |  0  1  1 | ? |/ 
//      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
//  Truth Table to determine INIT value for a LUT3
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
//     |  0  1  0 | ? | /                                |
//     |  0  1  1 | ? |/                                 |
//     |----------|---|                       INIT = 8'h?? 
//     |  1  0  0 | ? |\                                |
//     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
//     |  1  1  0 | ? | / 
//     |  1  1  1 | ? |/                      
//     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
//  Truth Table to determine INIT value for a LUT4
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | ? |\
//     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
//     |  0  0  1  0 | ? | /                                 |
//     |  0  0  1  1 | ? |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | ? |\                                  |
//     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
//     |  0  1  1  0 | ? | /                                 |
//     |  0  1  1  1 | ? |/                                  |                     
//     |-------------|---|                     INIT = 16'h????
//     |  1  0  0  0 | ? |\                               |
//     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  0 | ? | /                              |
//     |  1  0  1  1 | ? |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | ? |\                               |
//     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  0 | ? | /
//     |  1  1  1  1 | ? |/
//     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
//  Truth Table to determine INIT value for a LUT5
//      ____________________
//     | I4 I3 I2 I1 I0 | O |
//     |--------------------|
//     |  0  0  0  0  0 | ? |\
//     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  0  1  0  0 | ? |\                                      |
//     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1 | ? |/                                      |                     
//     |----------------|---|                                       |
//     |  0  1  0  0  0 | ? |\                                      |
//     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  0 | ? | /                                     |
//     |  0  1  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  1  1  0  0 | ? |\                                      |
//     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1 | ? |/                                      |
//     ----------------------                     INIT = 32'h????????
//     |  1  0  0  0  0 | ? |\                               |
//     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  0  1  0 | ? | /                              |
//     |  1  0  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  0  1  0  0 | ? |\                               |
//     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  1  0 | ? | /                              |
//     |  1  0  1  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  0  0  0 | ? |\                               |
//     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  1  0  1  0 | ? | /                              |
//     |  1  1  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  1  0  0 | ? |\                               |
//     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1 | ? |/
//     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
//  Truth Table to determine INIT value for a LUT6
//      _______________________
//     | I5 I4 I3 I2 I1 I0 | O |
//     |-----------------------|
//     |  0  0  0  0  0  0 | ? |\
//     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  0  1  0  0 | ? |\                                      |
//     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  0  1  1  0 | ? | /                                     |
//     |  0  0  0  1  1  1 | ? |/                                      |                     
//     |-------------------|---|                                       |
//     |  0  0  1  0  0  0 | ? |\                                      |
//     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  0  1  0 | ? | /                                     |
//     |  0  0  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  1  1  0  0 | ? |\                                      |
//     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1  1 | ? |/                                      |
//     -------------------------                                       |
//     |  0  1  0  0  0  0 | ? |\                                      |
//     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  0  1  0 | ? | /                                     |
//     |  0  1  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  0  1  0  0 | ? |\                                      |
//     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  1  0 | ? | /                                     |
//     |  0  1  0  1  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  0  0  0 | ? |\                                      |
//     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  0  1  0 | ? | /                                     |
//     |  0  1  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  1  0  0 | ? |\                                      |
//     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1  1 | ? |/                                      |
//     ------------------------              INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
							<Template label="LUT6_2" treetype="template">
//  Truth Table to determine INIT value for a LUT6_2
//      _____________________________
//     | I5 I4 I3 I2 I1 I0 | O6 | O5 |
//     |-----------------------------|
//     |  0  0  0  0  0  0 |    ?    |\
//     |  0  0  0  0  0  1 |    ?    | \ = 4'b???? = 4'h? -------------+
//     |  0  0  0  0  1  0 |    ?    | /                               |
//     |  0  0  0  0  1  1 |	?    |/				       |
//     |-------------------|---------|                                 |
//     |  0  0  0  1  0  0 |	?    |\                                |
//     |  0  0  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  0  1  1  0 |	?    | /                               |
//     |  0  0  0  1  1  1 |	?    |/                                |                     
//     |-------------------|---------|                                 |
//     |  0  0  1  0  0  0 |	?    |\                                |
//     |  0  0  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  0  1  0 |	?    | /                               |
//     |  0  0  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  0  1  1  0  0 |	?    |\                                |
//     |  0  0  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  1  1  0 |	?    | /                               |
//     |  0  0  1  1  1  1 |	?    |/                                |
//     -------------------------------                                 |
//     |  0  1  0  0  0  0 |	?    |\                                |
//     |  0  1  0  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  0  1  0 |	?    | /                               |
//     |  0  1  0  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  0  1  0  0 |	?    |\                                |
//     |  0  1  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  1  1  0 |	?    | /                               |
//     |  0  1  0  1  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  0  0  0 |	?    |\                                |
//     |  0  1  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  0  1  0 |	?    | /                               |
//     |  0  1  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  1  0  0 |	?    |\                                |
//     |  0  1  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  1  1  0 |	?    | /                               |
//     |  0  1  1  1  1  1 |	?    |/                                |
//     ------------------------------        INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT6_2" treetype="template">
//   LUT6_2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_2: 6-input, 2 output Look-Up Table
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT6_2 #(
      .INIT(64'h0000000000000000) // Specify LUT Contents
   ) LUT6_2_inst (
      .O6(O6), // 1-bit LUT6 output
      .O5(O5), // 1-bit lower LUT5 output
      .I0(I0), // 1-bit LUT input
      .I1(I1), // 1-bit LUT input
      .I2(I2), // 1-bit LUT input
      .I3(I3), // 1-bit LUT input
      .I4(I4), // 1-bit LUT input
      .I5(I5)  // 1-bit LUT input (fast MUX select only available to O6 output)
   );

   // End of LUT6_2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUTRAM" treetype="folder">
					<Template label="64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM) (RAM64X8SW)" treetype="template">
//  RAM64X8SW  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X8SW_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X8SW: 64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM)
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM64X8SW #(
      .INIT_A(64'h0000000000000000), // Initial contents of the RAM for Bit 7
      .INIT_B(64'h0000000000000000), // Initial contents of the RAM for Bit 6
      .INIT_C(64'h0000000000000000), // Initial contents of the RAM for Bit 5
      .INIT_D(64'h0000000000000000), // Initial contents of the RAM for Bit 4
      .INIT_E(64'h0000000000000000), // Initial contents of the RAM for Bit 3
      .INIT_F(64'h0000000000000000), // Initial contents of the RAM for Bit 2
      .INIT_G(64'h0000000000000000), // Initial contents of the RAM for Bit 1
      .INIT_H(64'h0000000000000000), // Initial contents of the RAM for Bit 0
      .IS_WCLK_INVERTED(1'b0)        // Optional inversion for WCLK
   )
   RAM64X8SW_inst (
      .O(O),       // 8-bit data output
      .A(A),       // 6-bit address input
      .D(D),       // 1-bit input: Write data input
      .WCLK(WCLK), // 1-bit input: Write clock input
      .WE(WE),     // 1-bit input: Write enable input
      .WSEL(WSEL)  // 3-bit write select
   );

   // End of RAM64X8SW_inst instantiation
					</Template>
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 X 1 negedge write (RAM32X1D_1)" treetype="template">
//  RAM32X1D_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_1_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D_1: 32 x 1 negative edge write, asynchronous read dual-port
   //             distributed RAM (Mapped to two LUT6s)
   //             Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1 #(
      .INIT(32'h00000000),    // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0) // Specifies active high/low WCLK
   ) RAM32X1D_1_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_1_inst instantiation
						</Template>
						<Template label="32 X 1 posedge write (RAM32X1D)" treetype="template">
//   RAM32X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D: 32 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to two LUT6s)
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D #(
      .INIT(32'h00000000),     // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM32X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_inst instantiation
						</Template>
						<Template label="64 X 1 posedge write (RAM64X1D)" treetype="template">
//   RAM64X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM64X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1D: 64 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to two LUT6s)
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1D #(
      .INIT(64'h0000000000000000), // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)      // Specifies active high/low WCLK
   ) RAM64X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .A5(A5),       // Rw/ address[5] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .DPRA5(DPRA5), // Read-only address[5] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM64X1D_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">
//  RAM128X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM128X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read
   //            dual-port distributed LUT RAM
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM128X1D #(
      .INIT(128'h00000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0) // Specifies active high/low WCLK
   ) RAM128X1D_inst (
      .DPO(DPO),   // Read port 1-bit output
      .SPO(SPO),   // Read/write port 1-bit output
      .A(A),       // Read/write port 7-bit address input
      .D(D),       // RAM data input
      .DPRA(DPRA), // Read port 7-bit address input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM128X1D_inst instantiation
						</Template>
						<Template label="256 X 1 posedge write (RAM256X1D)" treetype="template">
//  RAM256X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM256X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM256X1D: 256-deep by 1-wide positive edge write, asynchronous read
   //            dual-port distributed LUT RAM
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM256X1D #(
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM256X1D_inst (
      .DPO(DPO),   // Read port 1-bit output
      .SPO(SPO),   // Read/write port 1-bit output
      .A(A),       // Read/write port 8-bit address input
      .D(D),       // RAM data input
      .DPRA(DPRA), // Read port 8-bit address input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM256X1D_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">
//   RAM32M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32M: 32-deep by 8-wide Multi Port LUT RAM (Mapped to four LUT6s)
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4
      
   RAM32M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM32M_inst (
      .DOA(DOA),     // Read port A 2-bit output
      .DOB(DOB),     // Read port B 2-bit output
      .DOC(DOC),     // Read port C 2-bit output
      .DOD(DOD),     // Read/write port D 2-bit output
      .ADDRA(ADDRA), // Read port A 5-bit address input
      .ADDRB(ADDRB), // Read port B 5-bit address input
      .ADDRC(ADDRC), // Read port C 5-bit address input
      .ADDRD(ADDRD), // Read/write port D 5-bit address input
      .DIA(DIA),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );
   
   // End of RAM32M_inst instantiation
						</Template>
						<Template label="32 X 16 (RAM32M16)" treetype="template">
//   RAM32M16  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32M16_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32M16: 32-deep by 16-wide Multi Port LUT RAM (Mapped to eight LUT6s)
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4
      
   RAM32M16 #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .INIT_E(64'h0000000000000000), // Initial contents of E Port
      .INIT_F(64'h0000000000000000), // Initial contents of F Port
      .INIT_G(64'h0000000000000000), // Initial contents of G Port
      .INIT_H(64'h0000000000000000), // Initial contents of H Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM32M16_inst (
      .DOA(DOA),     // Read port A 2-bit output
      .DOB(DOB),     // Read port B 2-bit output
      .DOC(DOC),     // Read port C 2-bit output
      .DOD(DOD),     // Read port D 2-bit output
      .DOE(DOE),     // Read port E 2-bit output
      .DOF(DOF),     // Read port F 2-bit output
      .DOG(DOG),     // Read port G 2-bit output
      .DOH(DOH),     // Read/write port H 2-bit output
      .ADDRA(ADDRA), // Read port A 5-bit address input
      .ADDRB(ADDRB), // Read port B 5-bit address input
      .ADDRC(ADDRC), // Read port C 5-bit address input
      .ADDRD(ADDRD), // Read port D 5-bit address input
      .ADDRE(ADDRE), // Read port E 5-bit address input
      .ADDRF(ADDRF), // Read port F 5-bit address input
      .ADDRG(ADDRG), // Read port G 5-bit address input
      .ADDRH(ADDRH), // Read/write port H 5-bit address input
      .DIA(DIA),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .DIE(DIE),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRE
      .DIF(DIF),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRF
      .DIG(DIG),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRG
      .DIH(DIH),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRH
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );
   
   // End of RAM32M16_inst instantiation
						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">
//   RAM64M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64M: 64-deep by 4-wide Multi Port LUT RAM (Mapped to four LUT6s)
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM64M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM64M_inst (
      .DOA(DOA),     // Read port A 1-bit output
      .DOB(DOB),     // Read port B 1-bit output
      .DOC(DOC),     // Read port C 1-bit output
      .DOD(DOD),     // Read/write port D 1-bit output
      .DIA(DIA),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .ADDRA(ADDRA), // Read port A 6-bit address input
      .ADDRB(ADDRB), // Read port B 6-bit address input
      .ADDRC(ADDRC), // Read port C 6-bit address input
      .ADDRD(ADDRD), // Read/write port D 6-bit address input
      .WE(WE),       // Write enable input
      .WCLK(WCLK)    // Write clock input
   );

   // End of RAM64M_inst instantiation
						</Template>
						<Template label="64 X 8 (RAM64M8)" treetype="template">
//   RAM64M8   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64M8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64M8: 64-deep by 8-wide Multi Port LUT RAM (Mapped to eight LUT6s)
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM64M8 #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .INIT_E(64'h0000000000000000), // Initial contents of E Port
      .INIT_F(64'h0000000000000000), // Initial contents of F Port
      .INIT_G(64'h0000000000000000), // Initial contents of G Port
      .INIT_H(64'h0000000000000000), // Initial contents of H Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM64M8_inst (
      .DOA(DOA),     // Read port A 1-bit output
      .DOB(DOB),     // Read port B 1-bit output
      .DOC(DOC),     // Read port C 1-bit output
      .DOD(DOD),     // Read port D 1-bit output
      .DOE(DOE),     // Read port E 1-bit output
      .DOF(DOF),     // Read port F 1-bit output
      .DOG(DOG),     // Read port G 1-bit output
      .DOH(DOH),     // Read/write port H 1-bit output
      .DIA(DIA),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .DIE(DIE),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRE
      .DIF(DIF),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRF
      .DIG(DIG),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRG
      .DIH(DIH),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRH
      .ADDRA(ADDRA), // Read port A 6-bit address input
      .ADDRB(ADDRB), // Read port B 6-bit address input
      .ADDRC(ADDRC), // Read port C 6-bit address input
      .ADDRD(ADDRD), // Read port D 6-bit address input
      .ADDRE(ADDRE), // Read port E 6-bit address input
      .ADDRF(ADDRF), // Read port F 6-bit address input
      .ADDRG(ADDRG), // Read port G 6-bit address input
      .ADDRH(ADDRH), // Read/write port H 6-bit address input
      .WE(WE),       // Write enable input
      .WCLK(WCLK)    // Write clock input
   );

   // End of RAM64M8_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">
//  RAM32X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM (Mapped to a LUT6)
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1S #(
      .INIT(32'h00000000),    // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0) // Specifies active high/low WCLK
   ) RAM32X1S_inst (
      .O(O),       // RAM output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D(D),       // RAM data input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X1S_inst instantiation
						</Template>
						<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">
//  RAM64X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port
   //           distributed RAM (Mapped to a LUT6)
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1S #(
      .INIT(64'h0000000000000000), // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)      // Specifies active high/low WCLK
   ) RAM64X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM64X1S_inst instantiation
						</Template>
						<Template label="128 X 1 negedge write (RAM128X1S_1)" treetype="template">
// RAM128X1S_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S_1: 128 x 1 negative edge write, asynchronous read single-port
   //              distributed RAM (Mapped to two LUT6s)
   //              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1 #(
      .INIT(128'h00000000000000000000000000000000),  // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM128X1S_1_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_1_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1S)" treetype="template">
//  RAM128X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S: 128 x 1 positive edge write, asynchronous read single-port
   //            distributed RAM (Mapped to two LUT6s)
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S #(
      .INIT(128'h00000000000000000000000000000000), // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM128X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_inst instantiation
						</Template>
						<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">
//  RAM256X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM256X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read  (Mapped to four LUT6s)
   //            single-port distributed LUT RAM
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM256X1S #( 
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM256X1S_inst (
      .O(O),       // Read/write port 1-bit output
      .A(A),       // Read/write port 8-bit address input
      .WE(WE),     // Write enable input
      .WCLK(WCLK), // Write clock input
      .D(D)        // RAM data input
   );

   // End of RAM256X1S_inst instantiation
						</Template>
						<Template label="512 X 1 posedge write (RAM512X1S)" treetype="template">
//  RAM512X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM512X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM512X1S: 512-deep by 1-wide positive edge write, asynchronous read  (Mapped to eight LUT6s)
   //            single-port distributed LUT RAM
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM512X1S #( 
      .INIT(512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM512X1S_inst (
      .O(O),       // Read/write port 1-bit output
      .A(A),       // Read/write port 9-bit address input
      .WE(WE),     // Write enable input
      .WCLK(WCLK), // Write clock input
      .D(D)        // RAM data input
   );

   // End of RAM512X1S_inst instantiation
						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="MUXF" treetype="folder">
					<Template label="CLB MUX to connect two LUT6's Together (MUXF7)" treetype="template">
//    MUXF7    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7: CLB MUX to connect two LUT6's Together
   //        Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MUXF7 MUXF7_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to LUT6 output
      .I1(I1), // 1-bit input: Connect to LUT6 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF7_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF7's Together (MUXF8)" treetype="template">
//    MUXF8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8: CLB MUX to connect two MUXF7's Together
   //        Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MUXF8 MUXF8_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to MUXF7 output
      .I1(I1), // 1-bit input: Connect to MUXF7 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF8_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF8's Together (MUXF9)" treetype="template">
//    MUXF9    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF9_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF9: CLB MUX to connect two MUXF8's Together
   //        Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MUXF9 MUXF9_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to MUXF8 output
      .I1(I1), // 1-bit input: Connect to MUXF8 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF9_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="16-Bit Shift Register Look-Up Table (LUT) (SRL16E)" treetype="template">
//   SRL16E    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL16E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRL16E: 16-Bit Shift Register Look-Up Table (LUT)
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   SRL16E #(
      .INIT(16'h0000),        // Initial contents of shift register
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   SRL16E_inst (
      .Q(Q),     // 1-bit output: SRL Data
      .CE(CE),   // 1-bit input: Clock enable
      .CLK(CLK), // 1-bit input: Clock
      .D(D),     // 1-bit input: SRL Data
      // Depth Selection inputs: A0-A3 select SRL depth
      .A0(A0),
      .A1(A1),
      .A2(A2),
      .A3(A3) 
   );

   // End of SRL16E_inst instantiation
					</Template>
					<Template label="32-Bit Shift Register Look-Up Table (LUT) (SRLC32E)" treetype="template">
//   SRLC32E   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRLC32E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRLC32E: 32-Bit Shift Register Look-Up Table (LUT)
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   SRLC32E #(
      .INIT(32'h00000000),    // Initial contents of shift register
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   SRLC32E_inst (
      .Q(Q),     // 1-bit output: SRL Data
      .Q31(Q31), // 1-bit output: SRL Cascade Data
      .A(A),     // 5-bit input: Selects SRL depth
      .CE(CE),   // 1-bit input: Clock enable
      .CLK(CLK), // 1-bit input: Clock
      .D(D)      // 1-bit input: SRL Data
   );

   // End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLOCK" treetype="folder">
				<SubFolder label="BUFFER" treetype="folder">
					<Template label="Clock Buffer Driven by Gigabit Transceiver (BUFG_GT)" treetype="template">
//   BUFG_GT   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_GT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_GT: Clock Buffer Driven by Gigabit Transceiver
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFG_GT BUFG_GT_inst (
      .O(O),             // 1-bit output: Buffer
      .CE(CE),           // 1-bit input: Buffer enable
      .CEMASK(CEMASK),   // 1-bit input: CE Mask
      .CLR(CLR),         // 1-bit input: Asynchronous clear
      .CLRMASK(CLRMASK), // 1-bit input: CLR Mask
      .DIV(DIV),         // 3-bit input: Dynamic divide Value
      .I(I)              // 1-bit input: Buffer
   );

   // End of BUFG_GT_inst instantiation
					</Template>
					<Template label="General Clock Buffer (BUFG)" treetype="template">
//    BUFG     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG: General Clock Buffer
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFG BUFG_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFG_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
//   BUFGCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE: General Clock Buffer with Clock Enable
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE #(
      .CE_TYPE("SYNC"),      // ASYNC, SYNC
      .IS_CE_INVERTED(1'b0), // Programmable inversion on CE
      .IS_I_INVERTED(1'b0)   // Programmable inversion on I
   )
   BUFGCE_inst (
      .O(O),   // 1-bit output: Buffer
      .CE(CE), // 1-bit input: Buffer enable
      .I(I)    // 1-bit input: Buffer
   );

   // End of BUFGCE_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Divide (BUFGCE_DIV)" treetype="template">
// BUFGCE_DIV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_DIV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_DIV: General Clock Buffer with Divide Function
   //             Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_DIV #(
      .BUFGCE_DIVIDE(1),      // 1-8
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CE_INVERTED(1'b0),  // Optional inversion for CE
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_I_INVERTED(1'b0)    // Optional inversion for I
   )
   BUFGCE_DIV_inst (
      .O(O),     // 1-bit output: Buffer
      .CE(CE),   // 1-bit input: Buffer enable
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .I(I)      // 1-bit input: Buffer
   );

   // End of BUFGCE_DIV_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
//  BUFGCE_1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_1: General Clock Buffer with Clock Enable and Output State 1
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_1 BUFGCE_1_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock buffer active-High enable
      .I(I)    // 1-bit input: Clock input
   );

   // End of BUFGCE_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="CLOCK_SYNC" treetype="folder">
					<Template label="Synchronizer for BUFG_GT Control Signals (BUFG_GT_SYNC)" treetype="template">
// BUFG_GT_SYNC : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFG_GT_SYNC_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_GT_SYNC: Synchronizer for BUFG_GT Control Signals
   //               Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFG_GT_SYNC BUFG_GT_SYNC_inst (
      .CESYNC(CESYNC),   // 1-bit output: Synchronized CE
      .CLRSYNC(CLRSYNC), // 1-bit output: Synchronized CLR
      .CE(CE),           // 1-bit input: Asynchronous enable
      .CLK(CLK),         // 1-bit input: Clock
      .CLR(CLR)          // 1-bit input: Asynchronous clear
   );

   // End of BUFG_GT_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUX" treetype="folder">
					<Template label="2-to-1 General Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
// BUFGMUX_CTRL : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_CTRL: 2-to-1 General Clock MUX Buffer
   //               Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL BUFGMUX_CTRL_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="General Clock Control Buffer (BUFGCTRL)" treetype="template">
//  BUFGCTRL   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCTRL: General Clock Control Buffer
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGCTRL #(
      .INIT_OUT(0),               // Initial value of BUFGCTRL output, 0-1
      .PRESELECT_I0("FALSE"),     // BUFGCTRL output uses I0 input, FALSE, TRUE
      .PRESELECT_I1("FALSE"),     // BUFGCTRL output uses I1 input, FALSE, TRUE
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CE0_INVERTED(1'b0),     // Optional inversion for CE0
      .IS_CE1_INVERTED(1'b0),     // Optional inversion for CE1
      .IS_I0_INVERTED(1'b0),      // Optional inversion for I0
      .IS_I1_INVERTED(1'b0),      // Optional inversion for I1
      .IS_IGNORE0_INVERTED(1'b0), // Optional inversion for IGNORE0
      .IS_IGNORE1_INVERTED(1'b0), // Optional inversion for IGNORE1
      .IS_S0_INVERTED(1'b0),      // Optional inversion for S0
      .IS_S1_INVERTED(1'b0)       // Optional inversion for S1
   )
   BUFGCTRL_inst (
      .O(O),             // 1-bit output: Clock output
      .CE0(CE0),         // 1-bit input: Clock enable input for I0
      .CE1(CE1),         // 1-bit input: Clock enable input for I1
      .I0(I0),           // 1-bit input: Primary clock
      .I1(I1),           // 1-bit input: Secondary clock
      .IGNORE0(IGNORE0), // 1-bit input: Clock ignore input for I0
      .IGNORE1(IGNORE1), // 1-bit input: Clock ignore input for I1
      .S0(S0),           // 1-bit input: Clock select for I0
      .S1(S1)            // 1-bit input: Clock select for I1
   );

   // End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer (BUFGMUX)" treetype="template">
//   BUFGMUX   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX: General Clock Mux Buffer
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX #(
      .CLK_SEL_TYPE("SYNC")  // ASYNC, SYNC
   )
   BUFGMUX_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
//  BUFGMUX_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_1: General Clock Mux Buffer with Output State 1
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1 #(
      .CLK_SEL_TYPE("SYNC")  // ASYNC, SYNC
   )
   BUFGMUX_1_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME3_ADV)" treetype="template">
// MMCME3_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME3_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME3_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   //             Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MMCME3_ADV #(
      .BANDWIDTH("OPTIMIZED"),        // Jitter programming (HIGH, LOW, OPTIMIZED)
      .CLKFBOUT_MULT_F(5.0),          // Multiply value for all CLKOUT (2.000-64.000)
      .CLKFBOUT_PHASE(0.0),           // Phase offset in degrees of CLKFB (-360.000-360.000)
      // CLKIN_PERIOD: Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      .CLKOUT0_DIVIDE_F(1.0),         // Divide amount for CLKOUT0 (1.000-128.000)
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      // CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_CASCADE("FALSE"),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .COMPENSATION("AUTO"),          // AUTO, BUF_IN, EXTERNAL, INTERNAL, ZHOLD
      .DIVCLK_DIVIDE(1),              // Master division value (1-106)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0),     // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),      // Optional inversion for CLKIN1
      .IS_CLKIN2_INVERTED(1'b0),      // Optional inversion for CLKIN2
      .IS_CLKINSEL_INVERTED(1'b0),    // Optional inversion for CLKINSEL
      .IS_PSEN_INVERTED(1'b0),        // Optional inversion for PSEN
      .IS_PSINCDEC_INVERTED(1'b0),    // Optional inversion for PSINCDEC
      .IS_PWRDWN_INVERTED(1'b0),      // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE"),         // Delays DONE until MMCM is locked (FALSE, TRUE)
      // Spread Spectrum: Spread Spectrum Attributes
      .SS_EN("FALSE"),                // Enables spread spectrum (FALSE, TRUE)
      .SS_MODE("CENTER_HIGH"),        // CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      .SS_MOD_PERIOD(10000),          // Spread spectrum modulation period (ns) (4000-40000)
      // USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      .CLKFBOUT_USE_FINE_PS("FALSE"),
      .CLKOUT0_USE_FINE_PS("FALSE"),
      .CLKOUT1_USE_FINE_PS("FALSE"),
      .CLKOUT2_USE_FINE_PS("FALSE"),
      .CLKOUT3_USE_FINE_PS("FALSE"),
      .CLKOUT4_USE_FINE_PS("FALSE"),
      .CLKOUT5_USE_FINE_PS("FALSE"),
      .CLKOUT6_USE_FINE_PS("FALSE") 
   )
   MMCME3_ADV_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),           // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),         // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),           // 1-bit output: Primary clock
      .CLKOUT1B(CLKOUT1B),         // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),           // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),         // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),           // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),         // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),           // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),           // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),           // 1-bit output: CLKOUT6
      // DRP Ports outputs: Dynamic reconfiguration ports
      .DO(DO),                     // 16-bit output: DRP data
      .DRDY(DRDY),                 // 1-bit output: DRP ready
      // Dynamic Phase Shift Ports outputs: Ports used for dynamic phase shifting of the outputs
      .PSDONE(PSDONE),             // 1-bit output: Phase shift done
      // Feedback outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),         // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB),       // 1-bit output: Inverted CLKFBOUT
      // Status Ports outputs: MMCM status ports
      .CDDCDONE(CDDCDONE),         // 1-bit output: Clock dynamic divide done
      .CLKFBSTOPPED(CLKFBSTOPPED), // 1-bit output: Feedback clock stopped
      .CLKINSTOPPED(CLKINSTOPPED), // 1-bit output: Input clock stopped
      .LOCKED(LOCKED),             // 1-bit output: LOCK
      .CDDCREQ(CDDCREQ),           // 1-bit input: Request to dynamic divide clock
      // Clock Inputs inputs: Clock inputs
      .CLKIN1(CLKIN1),             // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),             // 1-bit input: Secondary clock
      // Control Ports inputs: MMCM control ports
      .CLKINSEL(CLKINSEL),         // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),             // 1-bit input: Power-down
      .RST(RST),                   // 1-bit input: Reset
      // DRP Ports inputs: Dynamic reconfiguration ports
      .DADDR(DADDR),               // 7-bit input: DRP address
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable
      .DI(DI),                     // 16-bit input: DRP data
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // Dynamic Phase Shift Ports inputs: Ports used for dynamic phase shifting of the outputs
      .PSCLK(PSCLK),               // 1-bit input: Phase shift clock
      .PSEN(PSEN),                 // 1-bit input: Phase shift enable
      .PSINCDEC(PSINCDEC),         // 1-bit input: Phase shift increment/decrement
      // Feedback inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)            // 1-bit input: Feedback clock
   );

   // End of MMCME3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE3_ADV)" treetype="template">
//  PLLE3_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE3_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE3_ADV: Advanced Phase-Locked Loop (PLL)
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   PLLE3_ADV #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT, (1-19)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB, (-360.000-360.000)
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0 (1-128)
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0 (0.001-0.999)
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0 (-360.000-360.000)
      // CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1 (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1 (0.001-0.999)
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1 (-360.000-360.000)
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      .COMPENSATION("AUTO"),      // AUTO, BUF_IN, INTERNAL
      .DIVCLK_DIVIDE(1),          // Master division value, (1-15)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked (FALSE, TRUE)
   )
   PLLE3_ADV_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      // DRP Ports outputs: Dynamic reconfiguration ports
      .DO(DO),                   // 16-bit output: DRP data
      .DRDY(DRDY),               // 1-bit output: DRP ready
      // Feedback Clocks outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      // Control Ports inputs: PLL control ports
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST),                 // 1-bit input: Reset
      // DRP Ports inputs: Dynamic reconfiguration ports
      .DADDR(DADDR),             // 7-bit input: DRP address
      .DCLK(DCLK),               // 1-bit input: DRP clock
      .DEN(DEN),                 // 1-bit input: DRP enable
      .DI(DI),                   // 16-bit input: DRP data
      .DWE(DWE),                 // 1-bit input: DRP write enable
      // Feedback Clocks inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)          // 1-bit input: Feedback clock
   );

   // End of PLLE3_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME3_BASE)" treetype="template">
// MMCME3_BASE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME3_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME3_BASE: Base Mixed Mode Clock Manager (MMCM)
   //              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MMCME3_BASE #(
      .BANDWIDTH("OPTIMIZED"),    // Jitter programming (HIGH, LOW, OPTIMIZED)
      .CLKFBOUT_MULT_F(5.0),      // Multiply value for all CLKOUT (2.000-64.000)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB (-360.000-360.000)
      .CLKIN1_PERIOD(0.0),        // Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE_F(1.0),     // Divide amount for CLKOUT0 (1.000-128.000)
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      // CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT4_CASCADE("FALSE"),  // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .DIVCLK_DIVIDE(1),          // Master division value (1-106)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),  // Optional inversion for CLKIN1
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER1(0.0),          // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   MMCME3_BASE_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),     // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),     // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6
      // Feedback outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),   // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT
      // Status Ports outputs: MMCM status ports
      .LOCKED(LOCKED),       // 1-bit output: LOCK
      // Clock Inputs inputs: Clock input
      .CLKIN1(CLKIN1),       // 1-bit input: Clock
      // Control Ports inputs: MMCM control ports
      .PWRDWN(PWRDWN),       // 1-bit input: Power-down
      .RST(RST),             // 1-bit input: Reset
      // Feedback inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)      // 1-bit input: Feedback clock
   );

   // End of MMCME3_BASE_inst instantiation
					</Template>
					<Template label="Base Phase-Locked Loop (PLL) (PLLE3_BASE)" treetype="template">
// PLLE3_BASE  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE3_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE3_BASE: Base Phase-Locked Loop (PLL)
   //             Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   PLLE3_BASE #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT, (1-19)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB, (-360.000-360.000)
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0 (1-128)
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0 (0.001-0.999)
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0 (-360.000-360.000)
      // CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1 (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1 (0.001-0.999)
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1 (-360.000-360.000)
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      .DIVCLK_DIVIDE(1),          // Master division value, (1-15)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked (FALSE, TRUE)
   )
   PLLE3_BASE_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      // Feedback Clocks outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      // Control Ports inputs: PLL control ports
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST),                 // 1-bit input: Reset
      // Feedback Clocks inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)          // 1-bit input: Feedback clock
   );

   // End of PLLE3_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CONFIGURATION" treetype="folder">
				<SubFolder label="BSCAN" treetype="folder">
					<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
//   BSCANE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BSCANE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BSCANE2: Boundary-Scan User Instruction
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BSCANE2 #(
      .JTAG_CHAIN(1)  // Value for USER command
   )
   BSCANE2_inst (
      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.
      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                         // SHIFT are asserted.

      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.
      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      .SEL(SEL),         // 1-bit output: USER instruction active output.
      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.
      .TCK(TCK),         // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.
      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.
      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller
      .TDO(TDO)          // 1-bit input: Test Data Output (TDO) input for USER function.
   );

   // End of BSCANE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DNA" treetype="folder">
					<Template label="Device DNA Access Port (DNA_PORTE2)" treetype="template">
// DNA_PORTE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DNA_PORTE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DNA_PORTE2: Device DNA Access Port
   //             Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   DNA_PORTE2 #(
      .SIM_DNA_VALUE(96'h000000000000000000000000)  // Specifies a sample 96-bit DNA value for simulation
   )
   DNA_PORTE2_inst (
      .DOUT(DOUT),   // 1-bit output: DNA output data
      .CLK(CLK),     // 1-bit input: Clock input
      .DIN(DIN),     // 1-bit input: User data input pin
      .READ(READ),   // 1-bit input: Active-High load DNA, active-Low read input
      .SHIFT(SHIFT)  // 1-bit input: Active-High shift enable input
   );

   // End of DNA_PORTE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="EFUSE" treetype="folder">
					<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
//  EFUSE_USR  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (EFUSE_USR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EFUSE_USR: 32-bit non-volatile design ID
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   EFUSE_USR #(
      .SIM_EFUSE_VALUE(32'h00000000)  // Value of the 32-bit non-volatile value used in simulation
   )
   EFUSE_USR_inst (
      .EFUSEUSR(EFUSEUSR)  // 32-bit output: User eFUSE register value output
   );

   // End of EFUSE_USR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="ICAP" treetype="folder">
					<Template label="Internal Configuration Access Port (ICAPE3)" treetype="template">
//   ICAPE3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ICAPE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ICAPE3: Internal Configuration Access Port
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   ICAPE3 #(
      .DEVICE_ID(32'h03628093),     // Specifies the pre-programmed Device ID value to be used for simulation
                                    // purposes.
      .ICAP_AUTO_SWITCH("DISABLE"), // Enable switch ICAP using sync word
      .SIM_CFG_FILE_NAME("NONE")    // Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                    // model
   )
   ICAPE3_inst (
      .AVAIL(AVAIL),     // 1-bit output: Availability status of ICAP
      .O(O),             // 32-bit output: Configuration data output bus
      .PRDONE(PRDONE),   // 1-bit output: Indicates completion of Partial Reconfiguration
      .PRERROR(PRERROR), // 1-bit output: Indicates Error during Partial Reconfiguration
      .CLK(CLK),         // 1-bit input: Clock input
      .CSIB(CSIB),       // 1-bit input: Active-Low ICAP enable
      .I(I),             // 32-bit input: Configuration data input bus
      .RDWRB(RDWRB)      // 1-bit input: Read/Write Select input
   );

   // End of ICAPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MASTER_JTAG" treetype="folder">
					<Template label="JTAG Port Access (MASTER_JTAG)" treetype="template">
// MASTER_JTAG : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MASTER_JTAG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MASTER_JTAG: JTAG Port Access
   //              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MASTER_JTAG MASTER_JTAG_inst (
      .TDO(TDO), // 1-bit output: JTAG TDO output pin
      .TCK(TCK), // 1-bit input: JTAG TCK input pin
      .TDI(TDI), // 1-bit input: JTAG TDI input pin
      .TMS(TMS)  // 1-bit input: JTAG TMS input pin
   );

   // End of MASTER_JTAG_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="STARTUP" treetype="folder">
					<Template label="STARTUP Block (STARTUPE3)" treetype="template">
//  STARTUPE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (STARTUPE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // STARTUPE3: STARTUP Block
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   STARTUPE3 #(
      .PROG_USR("FALSE"),  // Activate program event security feature. Requires encrypted bitstreams.
      .SIM_CCLK_FREQ(0.0)  // Set the Configuration Clock Frequency (ns) for simulation
   )
   STARTUPE3_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration main clock output
      .CFGMCLK(CFGMCLK),     // 1-bit output: Configuration internal oscillator clock output
      .DI(DI),               // 4-bit output: Allow receiving on the D input pin
      .EOS(EOS),             // 1-bit output: Active-High output signal indicating the End Of Startup
      .PREQ(PREQ),           // 1-bit output: PROGRAM request to fabric output
      .DO(DO),               // 4-bit input: Allows control of the D pin output
      .DTS(DTS),             // 4-bit input: Allows tristate of the D pin
      .FCSBO(FCSBO),         // 1-bit input: Controls the FCS_B pin for flash access
      .FCSBTS(FCSBTS),       // 1-bit input: Tristate the FCS_B pin
      .GSR(GSR),             // 1-bit input: Global Set/Reset input (GSR cannot be used for the port)
      .GTS(GTS),             // 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      .KEYCLEARB(KEYCLEARB), // 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      .PACK(PACK),           // 1-bit input: PROGRAM acknowledge input
      .USRCCLKO(USRCCLKO),   // 1-bit input: User CCLK input
      .USRCCLKTS(USRCCLKTS), // 1-bit input: User CCLK 3-state enable input
      .USRDONEO(USRDONEO),   // 1-bit input: User DONE pin output control
      .USRDONETS(USRDONETS)  // 1-bit input: User DONE 3-state enable output
   );

   // End of STARTUPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="USR_ACCESS" treetype="folder">
					<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
// USR_ACCESSE2 : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (USR_ACCESSE2_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // USR_ACCESSE2: Configuration Data Access
   //               Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2 USR_ACCESSE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration Clock
      .DATA(DATA),           // 32-bit output: Configuration Data reflecting the contents of the AXSS register
      .DATAVALID(DATAVALID)  // 1-bit output: Active High Data Valid
   );

   // End of USR_ACCESSE2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="BIDIR_BUFFER" treetype="folder">
					<Template label="Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable (IOBUF_INTERMDISABLE)" treetype="template">
// IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog       : the following instance declaration needs to be placed
//      instance       : in the body of the design code.  The instance name
//     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code         : parenthesis may be changed to properly reference and
//                     : connect this function to the design.  All inputs
//                     : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_INTERMDISABLE: Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable
   //                      Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUF_INTERMDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUF_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)                          // 1-bit input: 3-state enable input
   );

   // End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Bidirectional I/O Buffer with Offset Calibration and VREF Tuning (IOBUFE3)" treetype="template">
//   IOBUFE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFE3: Bidirectional I/O Buffer with Offset Calibration and VREF Tuning
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFE3 #(
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IOBUFE3_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Buffer inout (connect directly to top-level port)
      .OSC(OSC),                       // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),                 // 1-bit input: Offset cancellation enable
      .T(T),                           // 1-bit input: 3-state enable input
      .VREF(VREF)                      // 1-bit input: Vref input from HPIO_VREF
   );

   // End of IOBUFE3_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog             : the following instance declaration needs to be placed
//            instance            : in the body of the design code.  The instance name
//          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//              code              : parenthesis may be changed to properly reference and
//                                : connect this function to the design.  All inputs
//                                : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable
   //                                 Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer diff_p output
      .OB(OB),                       // 1-bit output: Buffer diff_n output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Must be tied to a logic '0'
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                     // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),                       // 1-bit input: 3-state master enable input
      .TS(TS)                        // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
// IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
//        Verilog         : the following instance declaration needs to be placed
//        instance        : in the body of the design code.  The instance name
//      declaration       : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations within the
//          code          : parenthesis may be changed to properly reference and
//                        : connect this function to the design.  All inputs
//                        : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_DCIEN: Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable
   //                         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_DCIEN #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DIFF_OUT_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer diff_p output
      .OB(OB),                         // 1-bit output: Buffer diff_n output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Must be tied to a logic '0'
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),                         // 1-bit input: 3-state master enable input
      .TS(TS)                          // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input (IOBUFDS_INTERMDISABLE)" treetype="template">
// IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//        Verilog        : the following instance declaration needs to be placed
//       instance        : in the body of the design code.  The instance name
//      declaration      : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//         code          : parenthesis may be changed to properly reference and
//                       : connect this function to the design.  All inputs
//                       : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_INTERMDISABLE: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input
   //                        Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                     // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)                          // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DCIEN)" treetype="template">
// IOBUFDS_DCIEN : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  All inputs
//               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DCIEN: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DCIEN #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional I/O Buffer with Offset Calibration (IOBUFDSE3)" treetype="template">
//  IOBUFDSE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFDSE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDSE3: Differential Bidirectional I/O Buffer with Offset Calibration
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDSE3 #(
      .DQS_BIAS("FALSE"),          // (FALSE, TRUE)
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IOBUFDSE3_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .OSC(OSC),                       // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),                 // 2-bit input: Offset cancellation enable
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUFDSE3_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer (IOBUFDS)" treetype="template">
//   IOBUFDS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS: Differential Input/Output Buffer
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IOBUFDS_inst (
      .O(O),     // 1-bit output: Buffer output
      .I(I),     // 1-bit input: Buffer input
      .IO(IO),   // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)      // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer (IOBUFDS_DIFF_OUT)" treetype="template">
// IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT: Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer
   //                   Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IOBUFDS_DIFF_OUT_inst (
      .O(O),     // 1-bit output: Buffer diff_p output
      .OB(OB),   // 1-bit output: Buffer diff_n output
      .I(I),     // 1-bit input: Buffer input
      .IO(IO),   // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),   // 1-bit input: 3-state master enable input
      .TS(TS)    // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Input/Output Buffer DCI Enable (IOBUF_DCIEN)" treetype="template">
// IOBUF_DCIEN : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUF_DCIEN_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_DCIEN: Input/Output Buffer DCI Enable
   //              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUF_DCIEN #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUF_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Input/Output Buffer (IOBUF)" treetype="template">
//    IOBUF    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF: Input/Output Buffer
   //        Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUF IOBUF_inst (
      .O(O),   // 1-bit output: Buffer output
      .I(I),   // 1-bit input: Buffer input
      .IO(IO), // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)    // 1-bit input: 3-state enable input
   );

   // End of IOBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="BITSLICE" treetype="folder">
					<Template label="BITSLICE_CONTROL (BITSLICE_CONTROL)" treetype="template">
// BITSLICE_CONTROL : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (BITSLICE_CONTROL_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BITSLICE_CONTROL: BITSLICE_CONTROL for control using Native Mode
   //                   Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BITSLICE_CONTROL #(
      .DIV_MODE("DIV2"),               // Controller DIV2/DIV4 mode (DIV2, DIV4)
      .EN_CLK_TO_EXT_NORTH("DISABLE"), // Enable clock forwarding to north
      .EN_CLK_TO_EXT_SOUTH("DISABLE"), // Enable clock forwarding to south
      .EN_DYN_ODLY_MODE("FALSE"),      // Enable dynamic output delay mode
      .EN_OTHER_NCLK("FALSE"),         // Select the NCLK from the other BITSLICE_CONTROL in the nibble (FALSE,
                                       // TRUE)
      .EN_OTHER_PCLK("FALSE"),         // Select the PCLK from the other BITSLICE_CONTROL in the nibble (FALSE,
                                       // TRUE)
      .IDLY_VT_TRACK("TRUE"),          // Enable VT tracking for input delays
      .INV_RXCLK("FALSE"),             // Invert clock path from IOB to upper RX bitslice
      .ODLY_VT_TRACK("TRUE"),          // Enable VT tracking for output delays
      .QDLY_VT_TRACK("TRUE"),          // Enable VT tracking for clock delays
      .READ_IDLE_COUNT(6'h00),         // Gap count between read bursts for ODT control counter (0-3f)
      .REFCLK_SRC("PLLCLK"),           // Select the input clock for the delay control (PLLCLK, REFCLK)
      .ROUNDING_FACTOR(16),            // Rounding factor in BISC spec (128-8)
      .RXGATE_EXTEND("FALSE"),         // Reserved for use by MIG Memory Controller. Do Not Change.
      .RX_CLK_PHASE_N("SHIFT_0"),      // Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                       // SHIFT_90)
      .RX_CLK_PHASE_P("SHIFT_0"),      // Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                       // SHIFT_90)
      .RX_GATING("DISABLE"),           // ENABLE/DISABLE read DQS gating
      .SELF_CALIBRATE("ENABLE"),       // Enable BISC of nibble controlled by BITSLICE_CONTROL
      .SERIAL_MODE("FALSE"),           // Put BITSLICE read paths into serial mode (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE"),       // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                       // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TX_GATING("DISABLE")            // ENABLE/DISABLE clock gating in WClkgen
   )
   BITSLICE_CONTROL_inst (
      .CLK_TO_EXT_NORTH(CLK_TO_EXT_NORTH),       // 1-bit output: Inter-byte clock going to north
                                                 // BITSLICE_CONTROL

      .CLK_TO_EXT_SOUTH(CLK_TO_EXT_SOUTH),       // 1-bit output: Inter-byte clock going to south
                                                 // BITSLICE_CONTROL

      .DLY_RDY(DLY_RDY),                         // 1-bit output: Fixed delay calibration complete
      .DYN_DCI(DYN_DCI),                         // 7-bit output: Direct control of IOB DCI when using a memory
                                                 // interface

      .NCLK_NIBBLE_OUT(NCLK_NIBBLE_OUT),         // 1-bit output: Intra-byte DQS strobes/clock to other control
                                                 // block

      .PCLK_NIBBLE_OUT(PCLK_NIBBLE_OUT),         // 1-bit output: Intra-byte DQS strobes/clock to other control
                                                 // block

      .RIU_RD_DATA(RIU_RD_DATA),                 // 16-bit output: RIU Output Read data to the controller
      .RIU_VALID(RIU_VALID),                     // 1-bit output: Last data written has been accepted when High
      .RX_BIT_CTRL_OUT0(RX_BIT_CTRL_OUT0),       // 40-bit output: Output bus to Bitslice 0
      .RX_BIT_CTRL_OUT1(RX_BIT_CTRL_OUT1),       // 40-bit output: Output bus to Bitslice 1
      .RX_BIT_CTRL_OUT2(RX_BIT_CTRL_OUT2),       // 40-bit output: Output bus to Bitslice 2
      .RX_BIT_CTRL_OUT3(RX_BIT_CTRL_OUT3),       // 40-bit output: Output bus to Bitslice 3
      .RX_BIT_CTRL_OUT4(RX_BIT_CTRL_OUT4),       // 40-bit output: Output bus to Bitslice 4
      .RX_BIT_CTRL_OUT5(RX_BIT_CTRL_OUT5),       // 40-bit output: Output bus to Bitslice 5
      .RX_BIT_CTRL_OUT6(RX_BIT_CTRL_OUT6),       // 40-bit output: Output bus to Bitslice 6
      .TX_BIT_CTRL_OUT0(TX_BIT_CTRL_OUT0),       // 40-bit output: Output bus to Bitslice 0
      .TX_BIT_CTRL_OUT1(TX_BIT_CTRL_OUT1),       // 40-bit output: Output bus to Bitslice 1
      .TX_BIT_CTRL_OUT2(TX_BIT_CTRL_OUT2),       // 40-bit output: Output bus to Bitslice 2
      .TX_BIT_CTRL_OUT3(TX_BIT_CTRL_OUT3),       // 40-bit output: Output bus to Bitslice 3
      .TX_BIT_CTRL_OUT4(TX_BIT_CTRL_OUT4),       // 40-bit output: Output bus to Bitslice 4
      .TX_BIT_CTRL_OUT5(TX_BIT_CTRL_OUT5),       // 40-bit output: Output bus to Bitslice 5
      .TX_BIT_CTRL_OUT6(TX_BIT_CTRL_OUT6),       // 40-bit output: Output bus to Bitslice 6
      .TX_BIT_CTRL_OUT_TRI(TX_BIT_CTRL_OUT_TRI), // 40-bit output: Output bus to 3-state TX_BITSLICE_TRI
      .VTC_RDY(VTC_RDY),                         // 1-bit output: PHY calibration is complete
      .CLK_FROM_EXT(CLK_FROM_EXT),               // 1-bit input: Inter-byte clock coming from north or south
                                                 // BITSLICE_CONTROL

      .EN_VTC(EN_VTC),                           // 1-bit input: Enables voltage and temperature compensation
                                                 // when High

      .NCLK_NIBBLE_IN(NCLK_NIBBLE_IN),           // 1-bit input: Intra-byte DQS strobes from other/clock
                                                 // control block

      .PCLK_NIBBLE_IN(PCLK_NIBBLE_IN),           // 1-bit input: Intra-byte DQS strobes/clock from other
                                                 // control block

      .PHY_RDCS0(PHY_RDCS0),                     // 4-bit input: Rank select
      .PHY_RDCS1(PHY_RDCS1),                     // 4-bit input: Rank select
      .PHY_RDEN(PHY_RDEN),                       // 4-bit input: Read burst enable when using a memory interface
      .PHY_WRCS0(PHY_WRCS0),                     // 4-bit input: Rank select
      .PHY_WRCS1(PHY_WRCS1),                     // 4-bit input: Rank select
      .PLL_CLK(PLL_CLK),                         // 1-bit input: PLL clock input
      .REFCLK(REFCLK),                           // 1-bit input: Frequency reference clock for delay control
      .RIU_ADDR(RIU_ADDR),                       // 6-bit input: Address input for RIU
      .RIU_CLK(RIU_CLK),                         // 1-bit input: System clock from fabric for RIU access
      .RIU_NIBBLE_SEL(RIU_NIBBLE_SEL),           // 1-bit input: Nibble select to enable RIU read/write
      .RIU_WR_DATA(RIU_WR_DATA),                 // 16-bit input: RIU Input Write data from the controller
      .RIU_WR_EN(RIU_WR_EN),                     // 1-bit input: Enables write to RIU when High
      .RST(RST),                                 // 1-bit input: Asynchronous global reset
      .RX_BIT_CTRL_IN0(RX_BIT_CTRL_IN0),         // 40-bit input: Input bus from Bitslice 0
      .RX_BIT_CTRL_IN1(RX_BIT_CTRL_IN1),         // 40-bit input: Input bus from Bitslice 1
      .RX_BIT_CTRL_IN2(RX_BIT_CTRL_IN2),         // 40-bit input: Input bus from Bitslice 2
      .RX_BIT_CTRL_IN3(RX_BIT_CTRL_IN3),         // 40-bit input: Input bus from Bitslice 3
      .RX_BIT_CTRL_IN4(RX_BIT_CTRL_IN4),         // 40-bit input: Input bus from Bitslice 4
      .RX_BIT_CTRL_IN5(RX_BIT_CTRL_IN5),         // 40-bit input: Input bus from Bitslice 5
      .RX_BIT_CTRL_IN6(RX_BIT_CTRL_IN6),         // 40-bit input: Input bus from Bitslice 6
      .TBYTE_IN(TBYTE_IN),                       // 4-bit input: Output enable for 3-state control
      .TX_BIT_CTRL_IN0(TX_BIT_CTRL_IN0),         // 40-bit input: Input bus from Bitslice 0
      .TX_BIT_CTRL_IN1(TX_BIT_CTRL_IN1),         // 40-bit input: Input bus from Bitslice 1
      .TX_BIT_CTRL_IN2(TX_BIT_CTRL_IN2),         // 40-bit input: Input bus from Bitslice 2
      .TX_BIT_CTRL_IN3(TX_BIT_CTRL_IN3),         // 40-bit input: Input bus from Bitslice 3
      .TX_BIT_CTRL_IN4(TX_BIT_CTRL_IN4),         // 40-bit input: Input bus from Bitslice 4
      .TX_BIT_CTRL_IN5(TX_BIT_CTRL_IN5),         // 40-bit input: Input bus from Bitslice 5
      .TX_BIT_CTRL_IN6(TX_BIT_CTRL_IN6),         // 40-bit input: Input bus from Bitslice 6
      .TX_BIT_CTRL_IN_TRI(TX_BIT_CTRL_IN_TRI)    // 40-bit input: Input bus from 3-state TX_BITSLICE_TRI
   );

   // End of BITSLICE_CONTROL_inst instantiation
					</Template>
					<Template label="Register Interface Unit Selection Block (RIU_OR)" treetype="template">
//   RIU_OR    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RIU_OR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RIU_OR: Register Interface Unit Selection Block
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RIU_OR #(
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   RIU_OR_inst (
      .RIU_RD_DATA(RIU_RD_DATA),           // 16-bit output: RIU data bus to the controller
      .RIU_RD_VALID(RIU_RD_VALID),         // 1-bit output: Combined RIU read valid signal to the controller
      .RIU_RD_DATA_LOW(RIU_RD_DATA_LOW),   // 16-bit input: RIU data bus from the controller to the lower
                                           // nibble BITSLICE_CONTROL

      .RIU_RD_DATA_UPP(RIU_RD_DATA_UPP),   // 16-bit input: RIU data bus from the controller to the upper
                                           // nibble BITSLICE_CONTROL

      .RIU_RD_VALID_LOW(RIU_RD_VALID_LOW), // 1-bit input: RIU_VALID of the lower nibble BITSLICE_CONTROL
      .RIU_RD_VALID_UPP(RIU_RD_VALID_UPP)  // 1-bit input: RIU_VALID of the upper nibble BITSLICE_CONTROL
   );

   // End of RIU_OR_inst instantiation
					</Template>
					<Template label="RX_BITSLICE (RX_BITSLICE)" treetype="template">
// RX_BITSLICE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RX_BITSLICE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RX_BITSLICE: RX_BITSLICE for input using Native Mode
   //              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RX_BITSLICE #(
      .CASCADE("FALSE"),              // Enables cascading of IDELAY and ODELAY lines
      .DATA_TYPE("DATA"),             // Defines what the input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                      // SERIAL)
      .DATA_WIDTH(8),                 // Defines the width of the serial-to-parallel converter (4-8)
      .DELAY_FORMAT("TIME"),          // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),           // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),                // Input delay value setting in ps
      .DELAY_VALUE_EXT(0),            // Value of the extended input delay value in ps
      .FIFO_SYNC_MODE("FALSE"),       // Internal write clock and FIFO_RD_CLK are coming from a common source
      .IS_CLK_EXT_INVERTED(1'b0),     // Optional inversion for CLK_EXT
      .IS_CLK_INVERTED(1'b0),         // Optional inversion for CLK
      .IS_RST_DLY_EXT_INVERTED(1'b0), // Optional inversion for RST_DLY_EXT
      .IS_RST_DLY_INVERTED(1'b0),     // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),       // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),      // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC"),          // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      // SYNC)
      .UPDATE_MODE_EXT("ASYNC")       // Determines when updates to the extended input delay will take effect
                                      // (ASYNC, MANUAL, SYNC)
   )
   RX_BITSLICE_inst (
      .CNTVALUEOUT(CNTVALUEOUT),         // 9-bit output: Counter value to device logic
      .CNTVALUEOUT_EXT(CNTVALUEOUT_EXT), // 9-bit output: Optional extended (cascaded delay) counter value
                                         // going to the device logic

      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .FIFO_WRCLK_OUT(FIFO_WRCLK_OUT),   // 1-bit output: FIFO source synchronous write clock out to the device
                                         // logic (currently unsupported, do not connect)

      .Q(Q),                             // 8-bit output: Registered output data from FIFO
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .CE(CE),                           // 1-bit input: Clock enable for IDELAY
      .CE_EXT(CE_EXT),                   // 1-bit input: Optional extended (cascaded delay) clock enable
      .CLK(CLK),                         // 1-bit input: Clock used to sample LOAD, CE, INC
      .CLK_EXT(CLK_EXT),                 // 1-bit input: Optional extended (cascaded delay) clock
      .CNTVALUEIN(CNTVALUEIN),           // 9-bit input: Counter value from device logic
      .CNTVALUEIN_EXT(CNTVALUEIN_EXT),   // 9-bit input: Optional extended (cascaded delay) counter value from
                                         // device logic

      .DATAIN(DATAIN),                   // 1-bit input: Input signal from IBUF
      .EN_VTC(EN_VTC),                   // 1-bit input: Enable IDELAYCTRL to keep stable delay over VT
      .EN_VTC_EXT(EN_VTC_EXT),           // 1-bit input: Optional extended (cascaded delay) to keep stable
                                         // delay over VT

      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: FIFO read enable
      .INC(INC),                         // 1-bit input: Increment the current delay tap setting
      .INC_EXT(INC_EXT),                 // 1-bit input: Optional extended (cascaded delay) increments the
                                         // current delay tap setting

      .LOAD(LOAD),                       // 1-bit input: Load the CNTVALUEIN tap setting
      .LOAD_EXT(LOAD_EXT),               // 1-bit input: Optional extended (cascaded delay) load the
                                         // CNTVALUEIN_EXT tap setting

      .RST(RST),                         // 1-bit input: Asynchronous assert, synchronous deassert for
                                         // RX_BITSLICE ISERDES

      .RST_DLY(RST_DLY),                 // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      .RST_DLY_EXT(RST_DLY_EXT),         // 1-bit input: Optional extended (cascaded delay) reset delay to
                                         // DELAY_VALUE_EXT

      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN)    // 40-bit input: Input bus from BITSLICE_CONTROL
   );

   // End of RX_BITSLICE_inst instantiation
					</Template>
					<Template label="RXTX_BITSLICE (RXTX_BITSLICE)" treetype="template">
// RXTX_BITSLICE : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (RXTX_BITSLICE_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  All inputs
//               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RXTX_BITSLICE: RXTX_BITSLICE for bidirectional I/O using Native Mode
   //                Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RXTX_BITSLICE #(
      .ENABLE_PRE_EMPHASIS("FALSE"), // Enable the pre-emphasis
      .FIFO_SYNC_MODE("FALSE"),      // Internal write clock and FIFO_RD_CLK are coming from a common source
      .INIT(1'b1),                   // Defines initial O value
      .IS_RX_CLK_INVERTED(1'b0),     // Optional inversion for RX_CLK
      .IS_RX_RST_DLY_INVERTED(1'b0), // Optional inversion for RX_RST_DLY
      .IS_RX_RST_INVERTED(1'b0),     // Optional inversion for RX_RST
      .IS_TX_CLK_INVERTED(1'b0),     // Optional inversion for TX_CLK
      .IS_TX_RST_DLY_INVERTED(1'b0), // Optional inversion for TX_RST_DLY
      .IS_TX_RST_INVERTED(1'b0),     // Optional inversion for TX_RST
      .RX_DATA_TYPE("DATA"),         // Defines what the RX input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                     // SERIAL)
      .RX_DATA_WIDTH(8),             // Defines the width of the serial-to-parallel converter (4-8)
      .RX_DELAY_FORMAT("TIME"),      // Units of the RX DELAY_VALUE (COUNT, TIME)
      .RX_DELAY_TYPE("FIXED"),       // Set the type of RX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .RX_DELAY_VALUE(0),            // RX Input delay value setting in ps
      .RX_REFCLK_FREQUENCY(300.0),   // Specification of the RX reference clock frequency in MHz (200.0-2667.0)
      .RX_UPDATE_MODE("ASYNC"),      // Determines when updates to the RX delay will take effect (ASYNC,
                                     // MANUAL, SYNC)
      .SIM_DEVICE("ULTRASCALE"),     // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                     // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TBYTE_CTL("TBYTE_IN"),        // Select between T and TBYTE_IN inputs
      .TX_DATA_WIDTH(8),             // Parallel data input width (4-8)
      .TX_DELAY_FORMAT("TIME"),      // Units of the TX DELAY_VALUE (COUNT, TIME)
      .TX_DELAY_TYPE("FIXED"),       // Set the type of TX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .TX_DELAY_VALUE(0),            // TX Input delay value setting in ps
      .TX_OUTPUT_PHASE_90("FALSE"),  // Delays the output phase by 90-degrees
      .TX_REFCLK_FREQUENCY(300.0),   // Specification of the TX reference clock frequency in MHz (200.0-2667.0)
      .TX_UPDATE_MODE("ASYNC")       // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                     // SYNC)
   )
   RXTX_BITSLICE_inst (
      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .FIFO_WRCLK_OUT(FIFO_WRCLK_OUT),   // 1-bit output: FIFO source synchronous write clock out to the device
                                         // logic (currently unsupported, do not connect)

      .O(O),                             // 1-bit output: Serialized output going to output buffer
      .Q(Q),                             // 8-bit output: Registered output data from FIFO
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: RX Output bus to BITSLICE_CONTROL
      .RX_CNTVALUEOUT(RX_CNTVALUEOUT),   // 9-bit output: RX Counter value from device logic
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL for TX
      .TX_CNTVALUEOUT(TX_CNTVALUEOUT),   // 9-bit output: TX Counter value to device logic
      .T_OUT(T_OUT),                     // 1-bit output: Byte group 3-state output
      .D(D),                             // 8-bit input: Data from device logic
      .DATAIN(DATAIN),                   // 1-bit input: Input signal from IOBUF
      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: FIFO read enable
      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: RX Input bus from BITSLICE_CONTROL
      .RX_CE(RX_CE),                     // 1-bit input: Clock enable for IDELAY
      .RX_CLK(RX_CLK),                   // 1-bit input: RX Clock used to sample LOAD, CE, INC
      .RX_CNTVALUEIN(RX_CNTVALUEIN),     // 9-bit input: RX Counter value from device logic
      .RX_EN_VTC(RX_EN_VTC),             // 1-bit input: RX Enable to keep stable delay over VT
      .RX_INC(RX_INC),                   // 1-bit input: RX Increment the current delay tap setting
      .RX_LOAD(RX_LOAD),                 // 1-bit input: RX Load the CNTVALUEIN tap setting
      .RX_RST(RX_RST),                   // 1-bit input: RX Asynchronous assert, synchronous deassert for
                                         // RXTX_BITSLICE ISERDES

      .RX_RST_DLY(RX_RST_DLY),           // 1-bit input: RX Reset the internal DELAY value to DELAY_VALUE
      .T(T),                             // 1-bit input: Legacy T byte input from device logic
      .TBYTE_IN(TBYTE_IN),               // 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN),   // 40-bit input: TX Input bus from BITSLICE_CONTROL
      .TX_CE(TX_CE),                     // 1-bit input: Clock enable for ODELAY
      .TX_CLK(TX_CLK),                   // 1-bit input: TX Clock used to sample LOAD, CE, INC
      .TX_CNTVALUEIN(TX_CNTVALUEIN),     // 9-bit input: TX Counter value from device logic
      .TX_EN_VTC(TX_EN_VTC),             // 1-bit input: TX Enable to keep stable delay over VT
      .TX_INC(TX_INC),                   // 1-bit input: TX Increment the current delay tap setting
      .TX_LOAD(TX_LOAD),                 // 1-bit input: TX Load the CNTVALUEIN tap setting
      .TX_RST(TX_RST),                   // 1-bit input: TX Asynchronous assert, synchronous deassert for
                                         // RXTX_BITSLICE OSERDES

      .TX_RST_DLY(TX_RST_DLY)            // 1-bit input: TX Reset the internal DELAY value to DELAY_VALUE
   );

   // End of RXTX_BITSLICE_inst instantiation
					</Template>
					<Template label="TX_BITSLICE_TRI (TX_BITSLICE_TRI)" treetype="template">
// TX_BITSLICE_TRI : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (TX_BITSLICE_TRI_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // TX_BITSLICE_TRI: TX_BITSLICE_TRI for tristate using Native Mode
   //                  Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_TRI #(
      .DATA_WIDTH(8),             // Parallel data input width (4-8)
      .DELAY_FORMAT("TIME"),      // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),       // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),            // Output delay value setting
      .INIT(1'b1),                // Defines initial O value
      .IS_CLK_INVERTED(1'b0),     // Optional inversion for CLK
      .IS_RST_DLY_INVERTED(1'b0), // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .OUTPUT_PHASE_90("FALSE"),  // Delays the output phase by 90-degrees
      .REFCLK_FREQUENCY(300.0),   // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")       // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  // SYNC)
   )
   TX_BITSLICE_TRI_inst (
      .BIT_CTRL_OUT(BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .CNTVALUEOUT(CNTVALUEOUT),   // 9-bit output: Counter value to device logic
      .TRI_OUT(TRI_OUT),           // 1-bit output: Output to the TBYTE_IN pins of the bitslices
      .BIT_CTRL_IN(BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .CE(CE),                     // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                   // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),     // 9-bit input: Counter value input
      .EN_VTC(EN_VTC),             // 1-bit input: Enable to keep stable delay over VT
      .INC(INC),                   // 1-bit input: Increment the current delay tap setting
      .LOAD(LOAD),                 // 1-bit input: Load the CNTVALUEIN tap setting
      .RST(RST),                   // 1-bit input: Asynchronous assert, synchronous deassert
      .RST_DLY(RST_DLY)            // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
   );

   // End of TX_BITSLICE_TRI_inst instantiation
					</Template>
					<Template label="TX_BITSLICE (TX_BITSLICE)" treetype="template">
// TX_BITSLICE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (TX_BITSLICE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // TX_BITSLICE: TX_BITSLICE for output using Native Mode
   //              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE #(
      .DATA_WIDTH(8),                // Parallel data input width (4-8)
      .DELAY_FORMAT("TIME"),         // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),          // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),               // Output delay value setting
      .ENABLE_PRE_EMPHASIS("FALSE"), // Enable the pre-emphasis
      .INIT(1'b1),                   // Defines initial O value
      .IS_CLK_INVERTED(1'b0),        // Optional inversion for CLK
      .IS_RST_DLY_INVERTED(1'b0),    // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),        // Optional inversion for RST
      .OUTPUT_PHASE_90("FALSE"),     // Delays the output phase by 90-degrees
      .REFCLK_FREQUENCY(300.0),      // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),     // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                     // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TBYTE_CTL("TBYTE_IN"),        // Select between T and TBYTE_IN inputs
      .UPDATE_MODE("ASYNC")          // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                     // SYNC)
   )
   TX_BITSLICE_inst (
      .CNTVALUEOUT(CNTVALUEOUT),         // 9-bit output: Counter value to device logic
      .O(O),                             // 1-bit output: Serialized output going to output buffer
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .T_OUT(T_OUT),                     // 1-bit output: Byte group 3-state output
      .CE(CE),                           // 1-bit input: Clock enable for ODELAY
      .CLK(CLK),                         // 1-bit input: Clock used to sample LOAD, CE, INC
      .CNTVALUEIN(CNTVALUEIN),           // 9-bit input: Counter value from device logic
      .D(D),                             // 8-bit input: Data from device logic
      .EN_VTC(EN_VTC),                   // 1-bit input: Enable to keep stable delay over VT
      .INC(INC),                         // 1-bit input: Increment the current delay tap setting
      .LOAD(LOAD),                       // 1-bit input: Load the CNTVALUEIN tap setting
      .RST(RST),                         // 1-bit input: Asynchronous assert, synchronous deassert for
                                         // TX_BITSLICE OSERDES

      .RST_DLY(RST_DLY),                 // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .T(T),                             // 1-bit input: Legacy T byte input from device logic
      .TBYTE_IN(TBYTE_IN),               // 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN)    // 40-bit input: Input bus from BITSLICE_CONTROL
   );

   // End of TX_BITSLICE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DCI_RESET" treetype="folder">
					<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
//  DCIRESET   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DCIRESET_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DCIRESET: Digitally Controlled Impedance Reset Component
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   DCIRESET DCIRESET_inst (
      .LOCKED(LOCKED), // 1-bit output: LOCK status output
      .RST(RST)        // 1-bit input: Active-High asynchronous reset input
   );

   // End of DCIRESET_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DELAY" treetype="folder">
					<Template label="IDELAYE3/ODELAYE3 Tap Delay Value Control (IDELAYCTRL)" treetype="template">
// IDELAYCTRL  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYCTRL: IDELAYE3/ODELAYE3 Tap Delay Value Control
   //             Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL #(
      .SIM_DEVICE("7SERIES")  // Set the device version (7SERIES, ULTRASCALE)
   )
   IDELAYCTRL_inst (
      .RDY(RDY),       // 1-bit output: Ready output
      .REFCLK(REFCLK), // 1-bit input: Reference clock input
      .RST(RST)        // 1-bit input: Active high reset input. Asynchronous assert, synchronous deassert to
                       // REFCLK.

   );

   // End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE3)" treetype="template">
//  IDELAYE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYE3: Input Fixed or Variable Delay Element
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IDELAYE3 #(
      .CASCADE("NONE"),          // Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      .DELAY_FORMAT("TIME"),     // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_SRC("IDATAIN"),     // Delay input (DATAIN, IDATAIN)
      .DELAY_TYPE("FIXED"),      // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),           // Input delay value setting
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),  // IDELAYCTRL clock input frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"), // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")      // Determines when updates to the delay will take effect (ASYNC, MANUAL, SYNC)
   )
   IDELAYE3_inst (
      .CASC_OUT(CASC_OUT),       // 1-bit output: Cascade delay output to ODELAY input cascade
      .CNTVALUEOUT(CNTVALUEOUT), // 9-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data output
      .CASC_IN(CASC_IN),         // 1-bit input: Cascade delay input from slave ODELAY CASCADE_OUT
      .CASC_RETURN(CASC_RETURN), // 1-bit input: Cascade delay returning from slave ODELAY DATAOUT
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                 // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),   // 9-bit input: Counter value input
      .DATAIN(DATAIN),           // 1-bit input: Data input from the logic
      .EN_VTC(EN_VTC),           // 1-bit input: Keep delay constant over VT
      .IDATAIN(IDATAIN),         // 1-bit input: Data input from the IOBUF
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LOAD(LOAD),               // 1-bit input: Load DELAY_VALUE input
      .RST(RST)                  // 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   // End of IDELAYE3_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE3)" treetype="template">
//  ODELAYE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODELAYE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODELAYE3: Output Fixed or Variable Delay Element
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   ODELAYE3 #(
      .CASCADE("NONE"),          // Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      .DELAY_FORMAT("TIME"),     // (COUNT, TIME)
      .DELAY_TYPE("FIXED"),      // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),           // Output delay tap setting
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),  // IDELAYCTRL clock input frequency in MHz (200.0-2667.0).
      .SIM_DEVICE("ULTRASCALE"), // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")      // Determines when updates to the delay will take effect (ASYNC, MANUAL, SYNC)
   )
   ODELAYE3_inst (
      .CASC_OUT(CASC_OUT),       // 1-bit output: Cascade delay output to IDELAY input cascade
      .CNTVALUEOUT(CNTVALUEOUT), // 9-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data from ODATAIN input port
      .CASC_IN(CASC_IN),         // 1-bit input: Cascade delay input from slave IDELAY CASCADE_OUT
      .CASC_RETURN(CASC_RETURN), // 1-bit input: Cascade delay returning from slave IDELAY DATAOUT
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                 // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),   // 9-bit input: Counter value input
      .EN_VTC(EN_VTC),           // 1-bit input: Keep delay constant over VT
      .INC(INC),                 // 1-bit input: Increment/Decrement tap delay input
      .LOAD(LOAD),               // 1-bit input: Load DELAY_VALUE input
      .ODATAIN(ODATAIN),         // 1-bit input: Data input
      .RST(RST)                  // 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   // End of ODELAYE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="INPUT_BUFFER" treetype="folder">
					<Template label="Analog Auxiliary SYSMON Input Buffer (IBUF_ANALOG)" treetype="template">
// IBUF_ANALOG : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUF_ANALOG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_ANALOG: Analog Auxiliary SYSMON Input Buffer
   //              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUF_ANALOG IBUF_ANALOG_inst (
      .O(O), // 1-bit output: Connect to a VAUXP/VAUXN port of the SYSMONE1
      .I(I)  // 1-bit input: Connect to a top-level design port
   );

   // End of IBUF_ANALOG_inst instantiation
					</Template>
					<Template label="Differential Input Buffer (IBUFDS)" treetype="template">
//   IBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS: Differential Input Buffer
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IBUFDS_inst (
      .O(O),   // 1-bit output: Buffer output
      .I(I),   // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs and Input Buffer Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
//           Verilog           : the following instance declaration needs to be placed
//          instance           : in the body of the design code.  The instance name
//         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations within the
//            code             : parenthesis may be changed to properly reference and
//                             : connect this function to the design.  All inputs
//                             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer With Complementary Outputs and Input Buffer Disable
   //                              Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_DIFF_OUT_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer diff_p output
      .OB(OB),                   // 1-bit output: Buffer diff_n output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Must be tied to a logic '0'
   );

   // End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs (IBUFDS_DIFF_OUT)" treetype="template">
// IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT: Differential Input Buffer With Complementary Outputs
   //                  Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IBUFDS_DIFF_OUT_inst (
      .O(O),   // 1-bit output: Buffer diff_p output
      .OB(OB), // 1-bit output: Buffer diff_n output
      .I(I),   // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog            : the following instance declaration needs to be placed
//           instance            : in the body of the design code.  The instance name
//          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code              : parenthesis may be changed to properly reference and
//                               : connect this function to the design.  All inputs
//                               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable
   //                                Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer diff_p output
      .OB(OB),                       // 1-bit output: Buffer diff_n output
      .I(I),                         // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                       // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Must be tied to a logic '0'
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Buffer termination disable, high=disable
   );

   // End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
// IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog        : the following instance declaration needs to be placed
//       instance       : in the body of the design code.  The instance name
//     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//         code         : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_INTERMDISABLE: Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                       // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer input disable, high=disable
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Buffer termination disable, high=disable
   );

   // End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable (IBUFDS_IBUFDISABLE)" treetype="template">
// IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//      instance      : in the body of the design code.  The instance name
//    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations within the
//        code        : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_IBUFDISABLE: Differential Input Buffer With Input Buffer Disable
   //                     Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Must be tied to a logic '0'
   );

   // End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Offset Calibration (IBUFDSE3)" treetype="template">
//  IBUFDSE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDSE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDSE3: Differential Input Buffer with Offset Calibration
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDSE3 #(
      .DQS_BIAS("FALSE"),          // (FALSE, TRUE)
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IBUFDSE3_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE), // 1-bit input: Buffer disable input, high=disable
      .OSC(OSC),                 // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN)            // 2-bit input: Offset cancellation enable
   );

   // End of IBUFDSE3_inst instantiation
					</Template>
					<Template label="Input Buffer (IBUF)" treetype="template">
//    IBUF     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF: Input Buffer
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUF IBUF_inst (
      .O(O), // 1-bit output: Buffer output
      .I(I)  // 1-bit input: Buffer input
   );

   // End of IBUF_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
// IBUF_INTERMDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//      instance      : in the body of the design code.  The instance name
//    declaration     : (IBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code        : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_INTERMDISABLE: Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                     Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUF_INTERMDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUF_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Input Termination Disable
   );

   // End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable (IBUF_IBUFDISABLE)" treetype="template">
// IBUF_IBUFDISABLE : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_IBUFDISABLE: Input Buffer With Input Buffer Disable
   //                   Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUF_IBUFDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUF_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Buffer disable input, high=disable
   );

   // End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer with Offset Calibration and VREF Tuning (IBUFE3)" treetype="template">
//   IBUFE3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFE3: Input Buffer with Offset Calibration and VREF Tuning
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFE3 #(
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IBUFE3_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE), // 1-bit input: Buffer disable input, high=disable
      .OSC(OSC),                 // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),           // 1-bit input: Offset cancellation enable
      .VREF(VREF)                // 1-bit input: Vref input from HPIO_VREF
   );

   // End of IBUFE3_inst instantiation
					</Template>
					<Template label="VREF Scan (HPIO_VREF)" treetype="template">
//  HPIO_VREF  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (HPIO_VREF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // HPIO_VREF: VREF Scan
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   HPIO_VREF #(
      .VREF_CNTR("OFF")  // FABRIC_RANGE1, FABRIC_RANGE2, OFF
   )
   HPIO_VREF_inst (
      .VREF(VREF),                         // 1-bit output: Tuned output (connect to associated IBUFE3
                                           // component)

      .FABRIC_VREF_TUNE(FABRIC_VREF_TUNE)  // 7-bit input: VREF tuning value
   );

   // End of HPIO_VREF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="OUTPUT_BUFFER" treetype="folder">
					<Template label="3-State Output Buffer (OBUFT)" treetype="template">
//    OBUFT    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFT: 3-State Output Buffer
   //        Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFT OBUFT_inst (
      .O(O), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(I), // 1-bit input: Buffer input
      .T(T)  // 1-bit input: 3-state enable input
   );

   // End of OBUFT_inst instantiation
					</Template>
					<Template label="Differential Output Buffer (OBUFDS)" treetype="template">
//   OBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS: Differential Output Buffer
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS OBUFDS_inst (
      .O(O),   // 1-bit output: Diff_p output (connect directly to top-level port)
      .OB(OB), // 1-bit output: Diff_n output (connect directly to top-level port)
      .I(I)    // 1-bit input: Buffer input
   );

   // End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential 3-state Output Buffer (OBUFTDS)" treetype="template">
//   OBUFTDS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFTDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFTDS: Differential 3-state Output Buffer
   //          Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFTDS OBUFTDS_inst (
      .O(O),   // 1-bit output: Diff_p output (connect directly to top-level port)
      .OB(OB), // 1-bit output: Diff_n output (connect directly to top-level port)
      .I(I),   // 1-bit input: Buffer input
      .T(T)    // 1-bit input: 3-state enable input
   );

   // End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Output Buffer (OBUF)" treetype="template">
//    OBUF     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUF: Output Buffer
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUF OBUF_inst (
      .O(O), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(I)  // 1-bit input: Buffer input
   );

   // End of OBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer (ISERDESE3)" treetype="template">
//  ISERDESE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ISERDESE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ISERDESE3: Input SERial/DESerializer
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   ISERDESE3 #(
      .DATA_WIDTH(8),            // Parallel data width (4,8)
      .FIFO_ENABLE("FALSE"),     // Enables the use of the FIFO
      .FIFO_SYNC_MODE("FALSE"),  // Enables the use of internal 2-stage synchronizers on the FIFO
      .IS_CLK_B_INVERTED(1'b0),  // Optional inversion for CLK_B
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   ISERDESE3_inst (
      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .INTERNAL_DIVCLK(INTERNAL_DIVCLK), // 1-bit output: Internally divided down clock used when FIFO is
                                         // disabled (do not connect)

      .Q(Q),                             // 8-bit registered output
      .CLK(CLK),                         // 1-bit input: High-speed clock
      .CLKDIV(CLKDIV),                   // 1-bit input: Divided Clock
      .CLK_B(CLK_B),                     // 1-bit input: Inversion of High-speed clock CLK
      .D(D),                             // 1-bit input: Serial Data Input
      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: Enables reading the FIFO when asserted
      .RST(RST)                          // 1-bit input: Asynchronous Reset
   );

   // End of ISERDESE3_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer (OSERDESE3)" treetype="template">
//  OSERDESE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OSERDESE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OSERDESE3: Output SERial/DESerializer
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OSERDESE3 #(
      .DATA_WIDTH(8),            // Parallel Data Width (4-8)
      .INIT(1'b0),               // Initialization value of the OSERDES flip-flops
      .IS_CLKDIV_INVERTED(1'b0), // Optional inversion for CLKDIV
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   OSERDESE3_inst (
      .OQ(OQ),         // 1-bit output: Serial Output Data
      .T_OUT(T_OUT),   // 1-bit output: 3-state control output to IOB
      .CLK(CLK),       // 1-bit input: High-speed clock
      .CLKDIV(CLKDIV), // 1-bit input: Divided Clock
      .D(D),           // 8-bit input: Parallel Data Input
      .RST(RST),       // 1-bit input: Asynchronous Reset
      .T(T)            // 1-bit input: Tristate input from fabric
   );

   // End of OSERDESE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="WEAK_DRIVER" treetype="folder">
					<Template label="I/O Pulldown (PULLDOWN)" treetype="template">
//  PULLDOWN   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PULLDOWN_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PULLDOWN: I/O Pulldown
   //           Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   PULLDOWN PULLDOWN_inst (
      .O(O)  // 1-bit output: Pulldown output (connect directly to top-level port)
   );

   // End of PULLDOWN_inst instantiation
					</Template>
					<Template label="I/O Pullup (PULLUP)" treetype="template">
//   PULLUP    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PULLUP_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PULLUP: I/O Pullup
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   PULLUP PULLUP_inst (
      .O(O)  // 1-bit output: Pullup output (connect directly to top-level port)
   );

   // End of PULLUP_inst instantiation
					</Template>
					<Template label="I/O Weak Keeper (KEEPER)" treetype="template">
//   KEEPER    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (KEEPER_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // KEEPER: I/O Weak Keeper
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   KEEPER KEEPER_inst (
      .O(O)  // 1-bit inout: Keeper output (connect directly to top-level port)
   );

   // End of KEEPER_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="REGISTER" treetype="folder">
				<SubFolder label="DDR" treetype="folder">
					<Template label="Input DDR (IDDRE1)" treetype="template">
//   IDDRE1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDDRE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDDRE1: Dedicated Dual Data Rate (DDR) Input Register
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IDDRE1 #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // IDDRE1 mode (OPPOSITE_EDGE, SAME_EDGE, SAME_EDGE_PIPELINED)
      .IS_CB_INVERTED(1'b0),          // Optional inversion for CB
      .IS_C_INVERTED(1'b0)            // Optional inversion for C
   )
   IDDRE1_inst (
      .Q1(Q1), // 1-bit output: Registered parallel output 1
      .Q2(Q2), // 1-bit output: Registered parallel output 2
      .C(C),   // 1-bit input: High-speed clock
      .CB(CB), // 1-bit input: Inversion of High-speed clock C
      .D(D),   // 1-bit input: Serial Data Input
      .R(R)    // 1-bit input: Active High Async Reset
   );

   // End of IDDRE1_inst instantiation
					</Template>
					<Template label="Output DDR (ODDRE1)" treetype="template">
//   ODDRE1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODDRE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODDRE1: Dedicated Dual Data Rate (DDR) Output Register
   //         Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   ODDRE1 #(
      .IS_C_INVERTED(1'b0),  // Optional inversion for C
      .IS_D1_INVERTED(1'b0), // Optional inversion for D1
      .IS_D2_INVERTED(1'b0), // Optional inversion for D2
      .SRVAL(1'b0)           // Initializes the ODDRE1 Flip-Flops to the specified value (1'b0, 1'b1)
   )
   ODDRE1_inst (
      .Q(Q),   // 1-bit output: Data output to IOB
      .C(C),   // 1-bit input: High-speed clock input
      .D1(D1), // 1-bit input: Parallel data input 1
      .D2(D2), // 1-bit input: Parallel data input 2
      .SR(SR)  // 1-bit input: Active High Async Reset
   );

   // End of ODDRE1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Transparent Latch with Clock Enable and Asynchronous Clear (LDCE)" treetype="template">
//    LDCE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LDCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LDCE: Transparent Latch with Clock Enable and Asynchronous Clear
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LDCE #(
      .INIT(1'b0),            // Initial value of latch, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_G_INVERTED(1'b0)    // Optional inversion for G
   )
   LDCE_inst (
      .Q(Q),     // 1-bit output: Data
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .D(D),     // 1-bit input: Data
      .G(G),     // 1-bit input: Gate
      .GE(GE)    // 1-bit input: Gate enable
   );

   // End of LDCE_inst instantiation
					</Template>
					<Template label="Transparent Latch with Clock Enable and Asynchronous Preset (LDPE)" treetype="template">
//    LDPE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LDPE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LDPE: Transparent Latch with Clock Enable and Asynchronous Preset
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LDPE #(
      .INIT(1'b1),            // Initial value of latch, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_G_INVERTED(1'b0),   // Optional inversion for G
      .IS_PRE_INVERTED(1'b0)  // Optional inversion for PRE
   )
   LDPE_inst (
      .Q(Q),     // 1-bit output: Data
      .D(D),     // 1-bit input: Data
      .G(G),     // 1-bit input: Gate
      .GE(GE),   // 1-bit input: Gate enable
      .PRE(PRE)  // 1-bit input: Asynchronous preset
   );

   // End of LDPE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="METASTABILITY" treetype="folder">
					<Template label="Metastability Hardened Registers (HARD_SYNC)" treetype="template">
//  HARD_SYNC  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (HARD_SYNC_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // HARD_SYNC: Metastability Hardened Registers
   //            Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   HARD_SYNC #(
      .INIT(1'b0),            // Initial values, 1'b0, 1'b1
      .IS_CLK_INVERTED(1'b0), // Programmable inversion on CLK input
      .LATENCY(2)             // 2-3
   )
   HARD_SYNC_inst (
      .DOUT(DOUT), // 1-bit output: Data
      .CLK(CLK),   // 1-bit input: Clock
      .DIN(DIN)    // 1-bit input: Data
   );

   // End of HARD_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SDR" treetype="folder">
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Clear (FDCE)" treetype="template">
//    FDCE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDCE: D Flip-Flop with Clock Enable and Asynchronous Clear
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FDCE #(
      .INIT(1'b0),            // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_C_INVERTED(1'b0),   // Optional inversion for C
      .IS_D_INVERTED(1'b0)    // Optional inversion for D
   )
   FDCE_inst (
      .Q(Q),     // 1-bit output: Data
      .C(C),     // 1-bit input: Clock
      .CE(CE),   // 1-bit input: Clock enable
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .D(D)      // 1-bit input: Data
   );

   // End of FDCE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Preset (FDPE)" treetype="template">
//    FDPE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDPE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDPE: D Flip-Flop with Clock Enable and Asynchronous Preset
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FDPE #(
      .INIT(1'b1),            // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0),   // Optional inversion for C
      .IS_D_INVERTED(1'b0),   // Optional inversion for D
      .IS_PRE_INVERTED(1'b0)  // Optional inversion for PRE
   )
   FDPE_inst (
      .Q(Q),     // 1-bit output: Data
      .C(C),     // 1-bit input: Clock
      .CE(CE),   // 1-bit input: Clock enable
      .D(D),     // 1-bit input: Data
      .PRE(PRE)  // 1-bit input: Asynchronous preset
   );

   // End of FDPE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Reset (FDRE)" treetype="template">
//    FDRE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDRE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDRE: D Flip-Flop with Clock Enable and Synchronous Reset
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FDRE #(
      .INIT(1'b0),          // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0), // Optional inversion for C
      .IS_D_INVERTED(1'b0), // Optional inversion for D
      .IS_R_INVERTED(1'b0)  // Optional inversion for R
   )
   FDRE_inst (
      .Q(Q),   // 1-bit output: Data
      .C(C),   // 1-bit input: Clock
      .CE(CE), // 1-bit input: Clock enable
      .D(D),   // 1-bit input: Data
      .R(R)    // 1-bit input: Synchronous reset
   );

   // End of FDRE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Set (FDSE)" treetype="template">
//    FDSE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDSE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDSE: D Flip-Flop with Clock Enable and Synchronous Set
   //       Kintex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FDSE #(
      .INIT(1'b1),          // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0), // Optional inversion for C
      .IS_D_INVERTED(1'b0), // Optional inversion for D
      .IS_S_INVERTED(1'b0)  // Optional inversion for S
   )
   FDSE_inst (
      .Q(Q),   // 1-bit output: Data
      .C(C),   // 1-bit input: Clock
      .CE(CE), // 1-bit input: Clock enable
      .D(D),   // 1-bit input: Data
      .S(S)    // 1-bit input: Synchronous set
   );

   // End of FDSE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Kintex UltraScale+" treetype="folder">
			<SubFolder label="ADVANCED" treetype="folder">
				<SubFolder label="GT" treetype="folder">
					<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE4)" treetype="template">
// IBUFDS_GTE4 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_GTE4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_GTE4: Gigabit Transceiver Buffer
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE4 #(
      .REFCLK_EN_TX_PATH(1'b0),   // Refer to Transceiver User Guide
      .REFCLK_HROW_CK_SEL(2'b00), // Refer to Transceiver User Guide
      .REFCLK_ICNTL_RX(2'b00)     // Refer to Transceiver User Guide
   )
   IBUFDS_GTE4_inst (
      .O(O),         // 1-bit output: Refer to Transceiver User Guide
      .ODIV2(ODIV2), // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),     // 1-bit input: Refer to Transceiver User Guide
      .I(I),         // 1-bit input: Refer to Transceiver User Guide
      .IB(IB)        // 1-bit input: Refer to Transceiver User Guide
   );

   // End of IBUFDS_GTE4_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE4_ADV)" treetype="template">
// OBUFDS_GTE4_ADV : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFDS_GTE4_ADV_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_GTE4_ADV: Gigabit Transceiver Buffer
   //                  Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE4_ADV #(
      .REFCLK_EN_TX_PATH(1'b1),   // Refer to Transceiver User Guide
      .REFCLK_ICNTL_TX(5'b00000)  // Refer to Transceiver User Guide
   )
   OBUFDS_GTE4_ADV_inst (
      .O(O),                       // 1-bit output: Refer to Transceiver User Guide
      .OB(OB),                     // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),                   // 1-bit input: Refer to Transceiver User Guide
      .I(I),                       // 4-bit input: Refer to Transceiver User Guide
      .RXRECCLK_SEL(RXRECCLK_SEL)  // 2-bit input: Refer to Transceiver User Guide
   );

   // End of OBUFDS_GTE4_ADV_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE4)" treetype="template">
// OBUFDS_GTE4 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_GTE4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_GTE4: Gigabit Transceiver Buffer
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE4 #(
      .REFCLK_EN_TX_PATH(1'b1),   // Refer to Transceiver User Guide
      .REFCLK_ICNTL_TX(5'b00000)  // Refer to Transceiver User Guide
   )
   OBUFDS_GTE4_inst (
      .O(O),     // 1-bit output: Refer to Transceiver User Guide
      .OB(OB),   // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB), // 1-bit input: Refer to Transceiver User Guide
      .I(I)      // 1-bit input: Refer to Transceiver User Guide
   );

   // End of OBUFDS_GTE4_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SYSMON" treetype="folder">
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE1)" treetype="template">
//  SYSMONE1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SYSMONE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SYSMONE1: Xilinx Analog-to-Digital Converter and System Monitor
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   SYSMONE1 #(
      // INIT_40 - INIT_44: SYSMON configuration registers
      .INIT_40(16'h0000),
      .INIT_41(16'h0000),
      .INIT_42(16'h0000),
      .INIT_43(16'h0000),
      .INIT_44(16'h0000),
      .INIT_45(16'h0000),              // Analog Bus Register
      // INIT_46 - INIT_4F: Sequence Registers
      .INIT_46(16'h0000),
      .INIT_47(16'h0000),
      .INIT_48(16'h0000),
      .INIT_49(16'h0000),
      .INIT_4A(16'h0000),
      .INIT_4B(16'h0000),
      .INIT_4C(16'h0000),
      .INIT_4D(16'h0000),
      .INIT_4E(16'h0000),
      .INIT_4F(16'h0000),
      // INIT_50 - INIT_5F: Alarm Limit Registers
      .INIT_50(16'h0000),
      .INIT_51(16'h0000),
      .INIT_52(16'h0000),
      .INIT_53(16'h0000),
      .INIT_54(16'h0000),
      .INIT_55(16'h0000),
      .INIT_56(16'h0000),
      .INIT_57(16'h0000),
      .INIT_58(16'h0000),
      .INIT_59(16'h0000),
      .INIT_5A(16'h0000),
      .INIT_5B(16'h0000),
      .INIT_5C(16'h0000),
      .INIT_5D(16'h0000),
      .INIT_5E(16'h0000),
      .INIT_5F(16'h0000),
      // INIT_60 - INIT_6F: User Supply Alarms
      .INIT_60(16'h0000),
      .INIT_61(16'h0000),
      .INIT_62(16'h0000),
      .INIT_63(16'h0000),
      .INIT_64(16'h0000),
      .INIT_65(16'h0000),
      .INIT_66(16'h0000),
      .INIT_67(16'h0000),
      .INIT_68(16'h0000),
      .INIT_69(16'h0000),
      .INIT_6A(16'h0000),
      .INIT_6B(16'h0000),
      .INIT_6C(16'h0000),
      .INIT_6D(16'h0000),
      .INIT_6E(16'h0000),
      .INIT_6F(16'h0000),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      // specific pins
      .IS_CONVSTCLK_INVERTED(1'b0),    // Optional inversion for CONVSTCLK, 0-1
      .IS_DCLK_INVERTED(1'b0),         // Optional inversion for DCLK, 0-1
      // Simulation attributes: Set for proper simulation behavior
      .SIM_MONITOR_FILE("design.txt"), // Analog simulation data file name
      // User Voltage Monitor: SYSMON User voltage monitor
      .SYSMON_VUSER0_BANK(0),          // Specify IO Bank for User0
      .SYSMON_VUSER0_MONITOR("NONE"),  // Specify Voltage for User0
      .SYSMON_VUSER1_BANK(0),          // Specify IO Bank for User1
      .SYSMON_VUSER1_MONITOR("NONE"),  // Specify Voltage for User1
      .SYSMON_VUSER2_BANK(0),          // Specify IO Bank for User2
      .SYSMON_VUSER2_MONITOR("NONE"),  // Specify Voltage for User2
      .SYSMON_VUSER3_MONITOR("NONE")   // Specify Voltage for User3
   )
   SYSMONE1_inst (
      // ALARMS outputs: ALM, OT
      .ALM(ALM),                   // 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      .OT(OT),                     // 1-bit output: Over-Temperature alarm
      // Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      .DO(DO),                     // 16-bit output: DRP output data bus
      .DRDY(DRDY),                 // 1-bit output: DRP data ready
      // I2C Interface outputs: Ports used with the I2C DRP interface
      .I2C_SCLK_TS(I2C_SCLK_TS),   // 1-bit output: I2C_SCLK output port
      .I2C_SDA_TS(I2C_SDA_TS),     // 1-bit output: I2C_SDA_TS output port
      // STATUS outputs: SYSMON status ports
      .BUSY(BUSY),                 // 1-bit output: System Monitor busy output
      .CHANNEL(CHANNEL),           // 6-bit output: Channel selection outputs
      .EOC(EOC),                   // 1-bit output: End of Conversion
      .EOS(EOS),                   // 1-bit output: End of Sequence
      .JTAGBUSY(JTAGBUSY),         // 1-bit output: JTAG DRP transaction in progress output
      .JTAGLOCKED(JTAGLOCKED),     // 1-bit output: JTAG requested DRP port lock
      .JTAGMODIFIED(JTAGMODIFIED), // 1-bit output: JTAG Write to the DRP has occurred
      .MUXADDR(MUXADDR),           // 5-bit output: External MUX channel decode
      // Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      .VAUXN(VAUXN),               // 16-bit input: N-side auxiliary analog input
      .VAUXP(VAUXP),               // 16-bit input: P-side auxiliary analog input
      // CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      .CONVST(CONVST),             // 1-bit input: Convert start input
      .CONVSTCLK(CONVSTCLK),       // 1-bit input: Convert start input
      .RESET(RESET),               // 1-bit input: Active-High reset
      // Dedicated Analog Input Pair inputs: VP/VN
      .VN(VN),                     // 1-bit input: N-side analog input
      .VP(VP),                     // 1-bit input: P-side analog input
      // Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      .DADDR(DADDR),               // 8-bit input: DRP address bus
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable signal
      .DI(DI),                     // 16-bit input: DRP input data bus
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // I2C Interface inputs: Ports used with the I2C DRP interface
      .I2C_SCLK(I2C_SCLK),         // 1-bit input: I2C_SCLK input port
      .I2C_SDA(I2C_SDA)            // 1-bit input: I2C_SDA input port
   );

   // End of SYSMONE1_inst instantiation
					</Template>
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE4)" treetype="template">
//  SYSMONE4   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SYSMONE4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SYSMONE4: Xilinx Analog-to-Digital Converter and System Monitor
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   SYSMONE4 #(
      // INIT_40 - INIT_44: SYSMON configuration registers
      .INIT_40(16'h0000),
      .INIT_41(16'h0000),
      .INIT_42(16'h0000),
      .INIT_43(16'h0000),
      .INIT_44(16'h0000),
      .INIT_45(16'h0000),              // Analog Bus Register
      // INIT_46 - INIT_4F: Sequence Registers
      .INIT_46(16'h0000),
      .INIT_47(16'h0000),
      .INIT_48(16'h0000),
      .INIT_49(16'h0000),
      .INIT_4A(16'h0000),
      .INIT_4B(16'h0000),
      .INIT_4C(16'h0000),
      .INIT_4D(16'h0000),
      .INIT_4E(16'h0000),
      .INIT_4F(16'h0000),
      // INIT_50 - INIT_5F: Alarm Limit Registers
      .INIT_50(16'h0000),
      .INIT_51(16'h0000),
      .INIT_52(16'h0000),
      .INIT_53(16'h0000),
      .INIT_54(16'h0000),
      .INIT_55(16'h0000),
      .INIT_56(16'h0000),
      .INIT_57(16'h0000),
      .INIT_58(16'h0000),
      .INIT_59(16'h0000),
      .INIT_5A(16'h0000),
      .INIT_5B(16'h0000),
      .INIT_5C(16'h0000),
      .INIT_5D(16'h0000),
      .INIT_5E(16'h0000),
      .INIT_5F(16'h0000),
      // INIT_60 - INIT_6F: User Supply Alarms
      .INIT_60(16'h0000),
      .INIT_61(16'h0000),
      .INIT_62(16'h0000),
      .INIT_63(16'h0000),
      .INIT_64(16'h0000),
      .INIT_65(16'h0000),
      .INIT_66(16'h0000),
      .INIT_67(16'h0000),
      .INIT_68(16'h0000),
      .INIT_69(16'h0000),
      .INIT_6A(16'h0000),
      .INIT_6B(16'h0000),
      .INIT_6C(16'h0000),
      .INIT_6D(16'h0000),
      .INIT_6E(16'h0000),
      .INIT_6F(16'h0000),
      // Primitive attributes: Primitive Attributes
      .COMMON_N_SOURCE(16'hffff),      // Sets the auxiliary analog input that is used for the Common-N input.
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      // specific pins
      .IS_CONVSTCLK_INVERTED(1'b0),    // Optional inversion for CONVSTCLK, 0-1
      .IS_DCLK_INVERTED(1'b0),         // Optional inversion for DCLK, 0-1
      // Simulation attributes: Set for proper simulation behavior
      .SIM_DEVICE("ULTRASCALE_PLUS"),  // Sets the correct target device for simulation functionality.
      .SIM_MONITOR_FILE("design.txt"), // Analog simulation data file name
      // User Voltage Monitor: SYSMON User voltage monitor
      .SYSMON_VUSER0_BANK(0),          // Specify IO Bank for User0
      .SYSMON_VUSER0_MONITOR("NONE"),  // Specify Voltage for User0
      .SYSMON_VUSER1_BANK(0),          // Specify IO Bank for User1
      .SYSMON_VUSER1_MONITOR("NONE"),  // Specify Voltage for User1
      .SYSMON_VUSER2_BANK(0),          // Specify IO Bank for User2
      .SYSMON_VUSER2_MONITOR("NONE"),  // Specify Voltage for User2
      .SYSMON_VUSER3_MONITOR("NONE")   // Specify Voltage for User3
   )
   SYSMONE4_inst (
      // ALARMS outputs: ALM, OT
      .ALM(ALM),                   // 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      .OT(OT),                     // 1-bit output: Over-Temperature alarm
      // Direct Data Out outputs: ADC_DATA
      .ADC_DATA(ADC_DATA),         // 16-bit output: Direct Data Out
      // Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      .DO(DO),                     // 16-bit output: DRP output data bus
      .DRDY(DRDY),                 // 1-bit output: DRP data ready
      // I2C Interface outputs: Ports used with the I2C DRP interface
      .I2C_SCLK_TS(I2C_SCLK_TS),   // 1-bit output: I2C_SCLK output port
      .I2C_SDA_TS(I2C_SDA_TS),     // 1-bit output: I2C_SDA_TS output port
      .SMBALERT_TS(SMBALERT_TS),   // 1-bit output: Output control signal for SMBALERT.
      // STATUS outputs: SYSMON status ports
      .BUSY(BUSY),                 // 1-bit output: System Monitor busy output
      .CHANNEL(CHANNEL),           // 6-bit output: Channel selection outputs
      .EOC(EOC),                   // 1-bit output: End of Conversion
      .EOS(EOS),                   // 1-bit output: End of Sequence
      .JTAGBUSY(JTAGBUSY),         // 1-bit output: JTAG DRP transaction in progress output
      .JTAGLOCKED(JTAGLOCKED),     // 1-bit output: JTAG requested DRP port lock
      .JTAGMODIFIED(JTAGMODIFIED), // 1-bit output: JTAG Write to the DRP has occurred
      .MUXADDR(MUXADDR),           // 5-bit output: External MUX channel decode
      // Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      .VAUXN(VAUXN),               // 16-bit input: N-side auxiliary analog input
      .VAUXP(VAUXP),               // 16-bit input: P-side auxiliary analog input
      // CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      .CONVST(CONVST),             // 1-bit input: Convert start input
      .CONVSTCLK(CONVSTCLK),       // 1-bit input: Convert start input
      .RESET(RESET),               // 1-bit input: Active-High reset
      // Dedicated Analog Input Pair inputs: VP/VN
      .VN(VN),                     // 1-bit input: N-side analog input
      .VP(VP),                     // 1-bit input: P-side analog input
      // Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      .DADDR(DADDR),               // 8-bit input: DRP address bus
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable signal
      .DI(DI),                     // 16-bit input: DRP input data bus
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // I2C Interface inputs: Ports used with the I2C DRP interface
      .I2C_SCLK(I2C_SCLK),         // 1-bit input: I2C_SCLK input port
      .I2C_SDA(I2C_SDA)            // 1-bit input: I2C_SDA input port
   );

   // End of SYSMONE4_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="ARITHMETIC" treetype="folder">
				<SubFolder label="DSP" treetype="folder">
					<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E2)" treetype="template">
//   DSP48E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DSP48E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DSP48E2: 48-bit Multi-Functional Arithmetic Block
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   DSP48E2 #(
      // Feature Control Attributes: Data Path Selection
      .AMULTSEL("A"),                    // Selects A input to multiplier (A, AD)
      .A_INPUT("DIRECT"),                // Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      .BMULTSEL("B"),                    // Selects B input to multiplier (AD, B)
      .B_INPUT("DIRECT"),                // Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      .PREADDINSEL("A"),                 // Selects input to pre-adder (A, B)
      .RND(48'h000000000000),            // Rounding Constant
      .USE_MULT("MULTIPLY"),             // Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
      .USE_SIMD("ONE48"),                // SIMD selection (FOUR12, ONE48, TWO24)
      .USE_WIDEXOR("FALSE"),             // Use the Wide XOR function (FALSE, TRUE)
      .XORSIMD("XOR24_48_96"),           // Mode of operation for the Wide XOR (XOR12, XOR24_48_96)
      // Pattern Detector Attributes: Pattern Detection Configuration
      .AUTORESET_PATDET("NO_RESET"),     // NO_RESET, RESET_MATCH, RESET_NOT_MATCH
      .AUTORESET_PRIORITY("RESET"),      // Priority of AUTORESET vs. CEP (CEP, RESET).
      .MASK(48'h3fffffffffff),           // 48-bit mask value for pattern detect (1=ignore)
      .PATTERN(48'h000000000000),        // 48-bit pattern match for pattern detect
      .SEL_MASK("MASK"),                 // C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
      .SEL_PATTERN("PATTERN"),           // Select pattern value (C, PATTERN)
      .USE_PATTERN_DETECT("NO_PATDET"),  // Enable pattern detect (NO_PATDET, PATDET)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_ALUMODE_INVERTED(4'b0000),     // Optional inversion for ALUMODE
      .IS_CARRYIN_INVERTED(1'b0),        // Optional inversion for CARRYIN
      .IS_CLK_INVERTED(1'b0),            // Optional inversion for CLK
      .IS_INMODE_INVERTED(5'b00000),     // Optional inversion for INMODE
      .IS_OPMODE_INVERTED(9'b000000000), // Optional inversion for OPMODE
      .IS_RSTALLCARRYIN_INVERTED(1'b0),  // Optional inversion for RSTALLCARRYIN
      .IS_RSTALUMODE_INVERTED(1'b0),     // Optional inversion for RSTALUMODE
      .IS_RSTA_INVERTED(1'b0),           // Optional inversion for RSTA
      .IS_RSTB_INVERTED(1'b0),           // Optional inversion for RSTB
      .IS_RSTCTRL_INVERTED(1'b0),        // Optional inversion for RSTCTRL
      .IS_RSTC_INVERTED(1'b0),           // Optional inversion for RSTC
      .IS_RSTD_INVERTED(1'b0),           // Optional inversion for RSTD
      .IS_RSTINMODE_INVERTED(1'b0),      // Optional inversion for RSTINMODE
      .IS_RSTM_INVERTED(1'b0),           // Optional inversion for RSTM
      .IS_RSTP_INVERTED(1'b0),           // Optional inversion for RSTP
      // Register Control Attributes: Pipeline Register Configuration
      .ACASCREG(1),                      // Number of pipeline stages between A/ACIN and ACOUT (0-2)
      .ADREG(1),                         // Pipeline stages for pre-adder (0-1)
      .ALUMODEREG(1),                    // Pipeline stages for ALUMODE (0-1)
      .AREG(1),                          // Pipeline stages for A (0-2)
      .BCASCREG(1),                      // Number of pipeline stages between B/BCIN and BCOUT (0-2)
      .BREG(1),                          // Pipeline stages for B (0-2)
      .CARRYINREG(1),                    // Pipeline stages for CARRYIN (0-1)
      .CARRYINSELREG(1),                 // Pipeline stages for CARRYINSEL (0-1)
      .CREG(1),                          // Pipeline stages for C (0-1)
      .DREG(1),                          // Pipeline stages for D (0-1)
      .INMODEREG(1),                     // Pipeline stages for INMODE (0-1)
      .MREG(1),                          // Multiplier pipeline stages (0-1)
      .OPMODEREG(1),                     // Pipeline stages for OPMODE (0-1)
      .PREG(1)                           // Number of pipeline stages for P (0-1)
   )
   DSP48E2_inst (
      // Cascade outputs: Cascade Ports
      .ACOUT(ACOUT),                   // 30-bit output: A port cascade
      .BCOUT(BCOUT),                   // 18-bit output: B cascade
      .CARRYCASCOUT(CARRYCASCOUT),     // 1-bit output: Cascade carry
      .MULTSIGNOUT(MULTSIGNOUT),       // 1-bit output: Multiplier sign cascade
      .PCOUT(PCOUT),                   // 48-bit output: Cascade output
      // Control outputs: Control Inputs/Status Bits
      .OVERFLOW(OVERFLOW),             // 1-bit output: Overflow in add/acc
      .PATTERNBDETECT(PATTERNBDETECT), // 1-bit output: Pattern bar detect
      .PATTERNDETECT(PATTERNDETECT),   // 1-bit output: Pattern detect
      .UNDERFLOW(UNDERFLOW),           // 1-bit output: Underflow in add/acc
      // Data outputs: Data Ports
      .CARRYOUT(CARRYOUT),             // 4-bit output: Carry
      .P(P),                           // 48-bit output: Primary data
      .XOROUT(XOROUT),                 // 8-bit output: XOR data
      // Cascade inputs: Cascade Ports
      .ACIN(ACIN),                     // 30-bit input: A cascade data
      .BCIN(BCIN),                     // 18-bit input: B cascade
      .CARRYCASCIN(CARRYCASCIN),       // 1-bit input: Cascade carry
      .MULTSIGNIN(MULTSIGNIN),         // 1-bit input: Multiplier sign cascade
      .PCIN(PCIN),                     // 48-bit input: P cascade
      // Control inputs: Control Inputs/Status Bits
      .ALUMODE(ALUMODE),               // 4-bit input: ALU control
      .CARRYINSEL(CARRYINSEL),         // 3-bit input: Carry select
      .CLK(CLK),                       // 1-bit input: Clock
      .INMODE(INMODE),                 // 5-bit input: INMODE control
      .OPMODE(OPMODE),                 // 9-bit input: Operation mode
      // Data inputs: Data Ports
      .A(A),                           // 30-bit input: A data
      .B(B),                           // 18-bit input: B data
      .C(C),                           // 48-bit input: C data
      .CARRYIN(CARRYIN),               // 1-bit input: Carry-in
      .D(D),                           // 27-bit input: D data
      // Reset/Clock Enable inputs: Reset/Clock Enable Inputs
      .CEA1(CEA1),                     // 1-bit input: Clock enable for 1st stage AREG
      .CEA2(CEA2),                     // 1-bit input: Clock enable for 2nd stage AREG
      .CEAD(CEAD),                     // 1-bit input: Clock enable for ADREG
      .CEALUMODE(CEALUMODE),           // 1-bit input: Clock enable for ALUMODE
      .CEB1(CEB1),                     // 1-bit input: Clock enable for 1st stage BREG
      .CEB2(CEB2),                     // 1-bit input: Clock enable for 2nd stage BREG
      .CEC(CEC),                       // 1-bit input: Clock enable for CREG
      .CECARRYIN(CECARRYIN),           // 1-bit input: Clock enable for CARRYINREG
      .CECTRL(CECTRL),                 // 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
      .CED(CED),                       // 1-bit input: Clock enable for DREG
      .CEINMODE(CEINMODE),             // 1-bit input: Clock enable for INMODEREG
      .CEM(CEM),                       // 1-bit input: Clock enable for MREG
      .CEP(CEP),                       // 1-bit input: Clock enable for PREG
      .RSTA(RSTA),                     // 1-bit input: Reset for AREG
      .RSTALLCARRYIN(RSTALLCARRYIN),   // 1-bit input: Reset for CARRYINREG
      .RSTALUMODE(RSTALUMODE),         // 1-bit input: Reset for ALUMODEREG
      .RSTB(RSTB),                     // 1-bit input: Reset for BREG
      .RSTC(RSTC),                     // 1-bit input: Reset for CREG
      .RSTCTRL(RSTCTRL),               // 1-bit input: Reset for OPMODEREG and CARRYINSELREG
      .RSTD(RSTD),                     // 1-bit input: Reset for DREG and ADREG
      .RSTINMODE(RSTINMODE),           // 1-bit input: Reset for INMODEREG
      .RSTM(RSTM),                     // 1-bit input: Reset for MREG
      .RSTP(RSTP)                      // 1-bit input: Reset for PREG
   );

   // End of DSP48E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="BLOCKRAM" treetype="folder">
				<SubFolder label="BRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E2)" treetype="template">
//  RAMB18E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB18E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB18E2: 18K-bit Configurable Synchronous Block RAM
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAMB18E2 #(
      // CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      .CASCADE_ORDER_A("NONE"),
      .CASCADE_ORDER_B("NONE"),
      // CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      .CLOCK_DOMAINS("INDEPENDENT"),
      // Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0, 1)
      .DOA_REG(1),
      .DOB_REG(1),
      // ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      .ENADDRENA("FALSE"),
      .ENADDRENB("FALSE"),
      // INITP_00 to INITP_07: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_3F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(18'h00000),
      .INIT_B(18'h00000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLKARDCLK_INVERTED(1'b0),
      .IS_CLKBWRCLK_INVERTED(1'b0),
      .IS_ENARDEN_INVERTED(1'b0),
      .IS_ENBWREN_INVERTED(1'b0),
      .IS_RSTRAMARSTRAM_INVERTED(1'b0),
      .IS_RSTRAMB_INVERTED(1'b0),
      .IS_RSTREGARSTREG_INVERTED(1'b0),
      .IS_RSTREGB_INVERTED(1'b0),
      // RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      .RDADDRCHANGEA("FALSE"),
      .RDADDRCHANGEB("FALSE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-9
      .READ_WIDTH_B(0),                                                                 // 0-9
      .WRITE_WIDTH_A(0),                                                                // 0-9
      .WRITE_WIDTH_B(0),                                                                // 0-9
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(18'h00000),
      .SRVAL_B(18'h00000),
      // Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      .SLEEP_ASYNC("FALSE"),
      // WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      .WRITE_MODE_A("NO_CHANGE"),
      .WRITE_MODE_B("NO_CHANGE") 
   )
   RAMB18E2_inst (
      // Cascade Signals outputs: Multi-BRAM cascade signals
      .CASDOUTA(CASDOUTA),               // 16-bit output: Port A cascade output data
      .CASDOUTB(CASDOUTB),               // 16-bit output: Port B cascade output data
      .CASDOUTPA(CASDOUTPA),             // 2-bit output: Port A cascade output parity data
      .CASDOUTPB(CASDOUTPB),             // 2-bit output: Port B cascade output parity data
      // Port A Data outputs: Port A data
      .DOUTADOUT(DOUTADOUT),             // 16-bit output: Port A data/LSB data
      .DOUTPADOUTP(DOUTPADOUTP),         // 2-bit output: Port A parity/LSB parity
      // Port B Data outputs: Port B data
      .DOUTBDOUT(DOUTBDOUT),             // 16-bit output: Port B data/MSB data
      .DOUTPBDOUTP(DOUTPBDOUTP),         // 2-bit output: Port B parity/MSB parity
      // Cascade Signals inputs: Multi-BRAM cascade signals
      .CASDIMUXA(CASDIMUXA),             // 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      .CASDIMUXB(CASDIMUXB),             // 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      .CASDINA(CASDINA),                 // 16-bit input: Port A cascade input data
      .CASDINB(CASDINB),                 // 16-bit input: Port B cascade input data
      .CASDINPA(CASDINPA),               // 2-bit input: Port A cascade input parity data
      .CASDINPB(CASDINPB),               // 2-bit input: Port B cascade input parity data
      .CASDOMUXA(CASDOMUXA),             // 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      .CASDOMUXB(CASDOMUXB),             // 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      .CASDOMUXEN_A(CASDOMUXEN_A),       // 1-bit input: Port A unregistered output data enable
      .CASDOMUXEN_B(CASDOMUXEN_B),       // 1-bit input: Port B unregistered output data enable
      .CASOREGIMUXA(CASOREGIMUXA),       // 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      .CASOREGIMUXB(CASOREGIMUXB),       // 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      .CASOREGIMUXEN_A(CASOREGIMUXEN_A), // 1-bit input: Port A registered output data enable
      .CASOREGIMUXEN_B(CASOREGIMUXEN_B), // 1-bit input: Port B registered output data enable
      // Port A Address/Control Signals inputs: Port A address and control signals
      .ADDRARDADDR(ADDRARDADDR),         // 14-bit input: A/Read port address
      .ADDRENA(ADDRENA),                 // 1-bit input: Active-High A/Read port address enable
      .CLKARDCLK(CLKARDCLK),             // 1-bit input: A/Read port clock
      .ENARDEN(ENARDEN),                 // 1-bit input: Port A enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),         // 1-bit input: Port A register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM),     // 1-bit input: Port A set/reset
      .RSTREGARSTREG(RSTREGARSTREG),     // 1-bit input: Port A register set/reset
      .WEA(WEA),                         // 2-bit input: Port A write enable
      // Port A Data inputs: Port A data
      .DINADIN(DINADIN),                 // 16-bit input: Port A data/LSB data
      .DINPADINP(DINPADINP),             // 2-bit input: Port A parity/LSB parity
      // Port B Address/Control Signals inputs: Port B address and control signals
      .ADDRBWRADDR(ADDRBWRADDR),         // 14-bit input: B/Write port address
      .ADDRENB(ADDRENB),                 // 1-bit input: Active-High B/Write port address enable
      .CLKBWRCLK(CLKBWRCLK),             // 1-bit input: B/Write port clock
      .ENBWREN(ENBWREN),                 // 1-bit input: Port B enable/Write enable
      .REGCEB(REGCEB),                   // 1-bit input: Port B register enable
      .RSTRAMB(RSTRAMB),                 // 1-bit input: Port B set/reset
      .RSTREGB(RSTREGB),                 // 1-bit input: Port B register set/reset
      .SLEEP(SLEEP),                     // 1-bit input: Sleep Mode
      .WEBWE(WEBWE),                     // 4-bit input: Port B write enable/Write enable
      // Port B Data inputs: Port B data
      .DINBDIN(DINBDIN),                 // 16-bit input: Port B data/MSB data
      .DINPBDINP(DINPBDINP)              // 2-bit input: Port B parity/MSB parity
   );

   // End of RAMB18E2_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E2)" treetype="template">
//  RAMB36E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB36E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB36E2: 36K-bit Configurable Synchronous Block RAM
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAMB36E2 #(
      // CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      .CASCADE_ORDER_A("NONE"),
      .CASCADE_ORDER_B("NONE"),
      // CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      .CLOCK_DOMAINS("INDEPENDENT"),
      .DOB_REG(1),
      // Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0, 1)
      .DOA_REG(1),
      // ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      .ENADDRENA("FALSE"),
      .ENADDRENB("FALSE"),
      // EN_ECC_PIPE: ECC pipeline register, "TRUE"/"FALSE" 
      .EN_ECC_PIPE("FALSE"),
      // EN_ECC_READ: Enable ECC decoder, "TRUE"/"FALSE" 
      .EN_ECC_READ("FALSE"),
      // EN_ECC_WRITE: Enable ECC encoder, "TRUE"/"FALSE" 
      .EN_ECC_WRITE("FALSE"),
      // INITP_00 to INITP_0F: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_7F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(36'h000000000),
      .INIT_B(36'h000000000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLKARDCLK_INVERTED(1'b0),
      .IS_CLKBWRCLK_INVERTED(1'b0),
      .IS_ENARDEN_INVERTED(1'b0),
      .IS_ENBWREN_INVERTED(1'b0),
      .IS_RSTRAMARSTRAM_INVERTED(1'b0),
      .IS_RSTRAMB_INVERTED(1'b0),
      .IS_RSTREGARSTREG_INVERTED(1'b0),
      .IS_RSTREGB_INVERTED(1'b0),
      // RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      .RDADDRCHANGEA("FALSE"),
      .RDADDRCHANGEB("FALSE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-9
      .READ_WIDTH_B(0),                                                                 // 0-9
      .WRITE_WIDTH_A(0),                                                                // 0-9
      .WRITE_WIDTH_B(0),                                                                // 0-9
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(36'h000000000),
      .SRVAL_B(36'h000000000),
      // Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      .SLEEP_ASYNC("FALSE"),
      // WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      .WRITE_MODE_A("NO_CHANGE"),
      .WRITE_MODE_B("NO_CHANGE") 
   )
   RAMB36E2_inst (
      // Cascade Signals outputs: Multi-BRAM cascade signals
      .CASDOUTA(CASDOUTA),               // 32-bit output: Port A cascade output data
      .CASDOUTB(CASDOUTB),               // 32-bit output: Port B cascade output data
      .CASDOUTPA(CASDOUTPA),             // 4-bit output: Port A cascade output parity data
      .CASDOUTPB(CASDOUTPB),             // 4-bit output: Port B cascade output parity data
      .CASOUTDBITERR(CASOUTDBITERR),     // 1-bit output: DBITERR cascade output
      .CASOUTSBITERR(CASOUTSBITERR),     // 1-bit output: SBITERR cascade output
      // ECC Signals outputs: Error Correction Circuitry ports
      .DBITERR(DBITERR),                 // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),             // 8-bit output: Generated error correction parity
      .RDADDRECC(RDADDRECC),             // 9-bit output: ECC Read Address
      .SBITERR(SBITERR),                 // 1-bit output: Single bit error status
      // Port A Data outputs: Port A data
      .DOUTADOUT(DOUTADOUT),             // 32-bit output: Port A ata/LSB data
      .DOUTPADOUTP(DOUTPADOUTP),         // 4-bit output: Port A parity/LSB parity
      // Port B Data outputs: Port B data
      .DOUTBDOUT(DOUTBDOUT),             // 32-bit output: Port B data/MSB data
      .DOUTPBDOUTP(DOUTPBDOUTP),         // 4-bit output: Port B parity/MSB parity
      // Cascade Signals inputs: Multi-BRAM cascade signals
      .CASDIMUXA(CASDIMUXA),             // 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      .CASDIMUXB(CASDIMUXB),             // 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      .CASDINA(CASDINA),                 // 32-bit input: Port A cascade input data
      .CASDINB(CASDINB),                 // 32-bit input: Port B cascade input data
      .CASDINPA(CASDINPA),               // 4-bit input: Port A cascade input parity data
      .CASDINPB(CASDINPB),               // 4-bit input: Port B cascade input parity data
      .CASDOMUXA(CASDOMUXA),             // 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      .CASDOMUXB(CASDOMUXB),             // 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      .CASDOMUXEN_A(CASDOMUXEN_A),       // 1-bit input: Port A unregistered output data enable
      .CASDOMUXEN_B(CASDOMUXEN_B),       // 1-bit input: Port B unregistered output data enable
      .CASINDBITERR(CASINDBITERR),       // 1-bit input: DBITERR cascade input
      .CASINSBITERR(CASINSBITERR),       // 1-bit input: SBITERR cascade input
      .CASOREGIMUXA(CASOREGIMUXA),       // 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      .CASOREGIMUXB(CASOREGIMUXB),       // 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      .CASOREGIMUXEN_A(CASOREGIMUXEN_A), // 1-bit input: Port A registered output data enable
      .CASOREGIMUXEN_B(CASOREGIMUXEN_B), // 1-bit input: Port B registered output data enable
      // ECC Signals inputs: Error Correction Circuitry ports
      .ECCPIPECE(ECCPIPECE),             // 1-bit input: ECC Pipeline Register Enable
      .INJECTDBITERR(INJECTDBITERR),     // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR),
      // Port A Address/Control Signals inputs: Port A address and control signals
      .ADDRARDADDR(ADDRARDADDR),         // 15-bit input: A/Read port address
      .ADDRENA(ADDRENA),                 // 1-bit input: Active-High A/Read port address enable
      .CLKARDCLK(CLKARDCLK),             // 1-bit input: A/Read port clock
      .ENARDEN(ENARDEN),                 // 1-bit input: Port A enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),         // 1-bit input: Port A register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM),     // 1-bit input: Port A set/reset
      .RSTREGARSTREG(RSTREGARSTREG),     // 1-bit input: Port A register set/reset
      .SLEEP(SLEEP),                     // 1-bit input: Sleep Mode
      .WEA(WEA),                         // 4-bit input: Port A write enable
      // Port A Data inputs: Port A data
      .DINADIN(DINADIN),                 // 32-bit input: Port A data/LSB data
      .DINPADINP(DINPADINP),             // 4-bit input: Port A parity/LSB parity
      // Port B Address/Control Signals inputs: Port B address and control signals
      .ADDRBWRADDR(ADDRBWRADDR),         // 15-bit input: B/Write port address
      .ADDRENB(ADDRENB),                 // 1-bit input: Active-High B/Write port address enable
      .CLKBWRCLK(CLKBWRCLK),             // 1-bit input: B/Write port clock
      .ENBWREN(ENBWREN),                 // 1-bit input: Port B enable/Write enable
      .REGCEB(REGCEB),                   // 1-bit input: Port B register enable
      .RSTRAMB(RSTRAMB),                 // 1-bit input: Port B set/reset
      .RSTREGB(RSTREGB),                 // 1-bit input: Port B register set/reset
      .WEBWE(WEBWE),                     // 8-bit input: Port B write enable/Write enable
      // Port B Data inputs: Port B data
      .DINBDIN(DINBDIN),                 // 32-bit input: Port B data/MSB data
      .DINPBDINP(DINPBDINP)              // 4-bit input: Port B parity/MSB parity
   );

   // End of RAMB36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E2)" treetype="template">
//  FIFO18E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO18E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO18E2: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FIFO18E2 #(
      .CASCADE_ORDER("NONE"),            // FIRST, LAST, MIDDLE, NONE, PARALLEL
      .CLOCK_DOMAINS("INDEPENDENT"),     // COMMON, INDEPENDENT
      .FIRST_WORD_FALL_THROUGH("FALSE"), // FALSE, TRUE
      .INIT(36'h000000000),              // Initial values on output port
      .PROG_EMPTY_THRESH(256),           // Programmable Empty Threshold
      .PROG_FULL_THRESH(256),            // Programmable Full Threshold
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_RDCLK_INVERTED(1'b0),          // Optional inversion for RDCLK
      .IS_RDEN_INVERTED(1'b0),           // Optional inversion for RDEN
      .IS_RSTREG_INVERTED(1'b0),         // Optional inversion for RSTREG
      .IS_RST_INVERTED(1'b0),            // Optional inversion for RST
      .IS_WRCLK_INVERTED(1'b0),          // Optional inversion for WRCLK
      .IS_WREN_INVERTED(1'b0),           // Optional inversion for WREN
      .RDCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .READ_WIDTH(4),                    // 18-9
      .REGISTER_MODE("UNREGISTERED"),    // DO_PIPELINED, REGISTERED, UNREGISTERED
      .RSTREG_PRIORITY("RSTREG"),        // REGCE, RSTREG
      .SLEEP_ASYNC("FALSE"),             // FALSE, TRUE
      .SRVAL(36'h000000000),             // SET/reset value of the FIFO outputs
      .WRCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .WRITE_WIDTH(4)                    // 18-9
   )
   FIFO18E2_inst (
      // Cascade Signals outputs: Multi-FIFO cascade signals
      .CASDOUT(CASDOUT),             // 32-bit output: Data cascade output bus
      .CASDOUTP(CASDOUTP),           // 4-bit output: Parity data cascade output bus
      .CASNXTEMPTY(CASNXTEMPTY),     // 1-bit output: Cascade next empty
      .CASPRVRDEN(CASPRVRDEN),       // 1-bit output: Cascade previous read enable
      // Read Data outputs: Read output data
      .DOUT(DOUT),                   // 32-bit output: FIFO data output bus
      .DOUTP(DOUTP),                 // 4-bit output: FIFO parity output bus.
      // Status outputs: Flags and other FIFO status outputs
      .EMPTY(EMPTY),                 // 1-bit output: Empty
      .FULL(FULL),                   // 1-bit output: Full
      .PROGEMPTY(PROGEMPTY),         // 1-bit output: Programmable empty
      .PROGFULL(PROGFULL),           // 1-bit output: Programmable full
      .RDCOUNT(RDCOUNT),             // 13-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .RDRSTBUSY(RDRSTBUSY),         // 1-bit output: Reset busy (sync to RDCLK)
      .WRCOUNT(WRCOUNT),             // 13-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write Error
      .WRRSTBUSY(WRRSTBUSY),         // 1-bit output: Reset busy (sync to WRCLK)
      // Cascade Signals inputs: Multi-FIFO cascade signals
      .CASDIN(CASDIN),               // 32-bit input: Data cascade input bus
      .CASDINP(CASDINP),             // 4-bit input: Parity data cascade input bus
      .CASDOMUX(CASDOMUX),           // 1-bit input: Cascade MUX select
      .CASDOMUXEN(CASDOMUXEN),       // 1-bit input: Enable for cascade MUX select
      .CASNXTRDEN(CASNXTRDEN),       // 1-bit input: Cascade next read enable
      .CASOREGIMUX(CASOREGIMUX),     // 1-bit input: Cascade output MUX select
      .CASOREGIMUXEN(CASOREGIMUXEN), // 1-bit input: Cascade output MUX select enable
      .CASPRVEMPTY(CASPRVEMPTY),     // 1-bit input: Cascade previous empty
      // Read Control Signals inputs: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Output register clock enable
      .RSTREG(RSTREG),               // 1-bit input: Output register reset
      .SLEEP(SLEEP),                 // 1-bit input: Sleep Mode
      // Write Control Signals inputs: Write clock and enable input signals
      .RST(RST),                     // 1-bit input: Reset
      .WRCLK(WRCLK),                 // 1-bit input: Write clock
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data inputs: Write input data
      .DIN(DIN),                     // 32-bit input: FIFO data input bus
      .DINP(DINP)                    // 4-bit input: FIFO parity input bus
   );

   // End of FIFO18E2_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E2)" treetype="template">
//  FIFO36E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO36E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO36E2: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FIFO36E2 #(
      .CASCADE_ORDER("NONE"),            // FIRST, LAST, MIDDLE, NONE, PARALLEL
      .CLOCK_DOMAINS("INDEPENDENT"),     // COMMON, INDEPENDENT
      .EN_ECC_PIPE("FALSE"),             // ECC pipeline register, (FALSE, TRUE)
      .EN_ECC_READ("FALSE"),             // Enable ECC decoder, (FALSE, TRUE)
      .EN_ECC_WRITE("FALSE"),            // Enable ECC encoder, (FALSE, TRUE)
      .FIRST_WORD_FALL_THROUGH("FALSE"), // FALSE, TRUE
      .INIT(72'h000000000000000000),     // Initial values on output port
      .PROG_EMPTY_THRESH(256),           // Programmable Empty Threshold
      .PROG_FULL_THRESH(256),            // Programmable Full Threshold
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_RDCLK_INVERTED(1'b0),          // Optional inversion for RDCLK
      .IS_RDEN_INVERTED(1'b0),           // Optional inversion for RDEN
      .IS_RSTREG_INVERTED(1'b0),         // Optional inversion for RSTREG
      .IS_RST_INVERTED(1'b0),            // Optional inversion for RST
      .IS_WRCLK_INVERTED(1'b0),          // Optional inversion for WRCLK
      .IS_WREN_INVERTED(1'b0),           // Optional inversion for WREN
      .RDCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .READ_WIDTH(4),                    // 18-9
      .REGISTER_MODE("UNREGISTERED"),    // DO_PIPELINED, REGISTERED, UNREGISTERED
      .RSTREG_PRIORITY("RSTREG"),        // REGCE, RSTREG
      .SLEEP_ASYNC("FALSE"),             // FALSE, TRUE
      .SRVAL(72'h000000000000000000),    // SET/reset value of the FIFO outputs
      .WRCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .WRITE_WIDTH(4)                    // 18-9
   )
   FIFO36E2_inst (
      // Cascade Signals outputs: Multi-FIFO cascade signals
      .CASDOUT(CASDOUT),             // 64-bit output: Data cascade output bus
      .CASDOUTP(CASDOUTP),           // 8-bit output: Parity data cascade output bus
      .CASNXTEMPTY(CASNXTEMPTY),     // 1-bit output: Cascade next empty
      .CASPRVRDEN(CASPRVRDEN),       // 1-bit output: Cascade previous read enable
      // ECC Signals outputs: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Read Data outputs: Read output data
      .DOUT(DOUT),                   // 64-bit output: FIFO data output bus
      .DOUTP(DOUTP),                 // 8-bit output: FIFO parity output bus.
      // Status outputs: Flags and other FIFO status outputs
      .EMPTY(EMPTY),                 // 1-bit output: Empty
      .FULL(FULL),                   // 1-bit output: Full
      .PROGEMPTY(PROGEMPTY),         // 1-bit output: Programmable empty
      .PROGFULL(PROGFULL),           // 1-bit output: Programmable full
      .RDCOUNT(RDCOUNT),             // 14-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .RDRSTBUSY(RDRSTBUSY),         // 1-bit output: Reset busy (sync to RDCLK)
      .WRCOUNT(WRCOUNT),             // 14-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write Error
      .WRRSTBUSY(WRRSTBUSY),         // 1-bit output: Reset busy (sync to WRCLK)
      // Cascade Signals inputs: Multi-FIFO cascade signals
      .CASDIN(CASDIN),               // 64-bit input: Data cascade input bus
      .CASDINP(CASDINP),             // 8-bit input: Parity data cascade input bus
      .CASDOMUX(CASDOMUX),           // 1-bit input: Cascade MUX select input
      .CASDOMUXEN(CASDOMUXEN),       // 1-bit input: Enable for cascade MUX select
      .CASNXTRDEN(CASNXTRDEN),       // 1-bit input: Cascade next read enable
      .CASOREGIMUX(CASOREGIMUX),     // 1-bit input: Cascade output MUX select
      .CASOREGIMUXEN(CASOREGIMUXEN), // 1-bit input: Cascade output MUX select enable
      .CASPRVEMPTY(CASPRVEMPTY),     // 1-bit input: Cascade previous empty
      // ECC Signals inputs: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR), // 1-bit input: Inject a single bit error
      // Read Control Signals inputs: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Output register clock enable
      .RSTREG(RSTREG),               // 1-bit input: Output register reset
      .SLEEP(SLEEP),                 // 1-bit input: Sleep Mode
      // Write Control Signals inputs: Write clock and enable input signals
      .RST(RST),                     // 1-bit input: Reset
      .WRCLK(WRCLK),                 // 1-bit input: Write clock
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data inputs: Write input data
      .DIN(DIN),                     // 64-bit input: FIFO data input bus
      .DINP(DINP)                    // 8-bit input: FIFO parity input bus
   );

   // End of FIFO36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="URAM" treetype="folder">
					<Template label="288K-bit High-Density Base Memory Building Block (URAM288_BASE)" treetype="template">
// URAM288_BASE : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (URAM288_BASE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // URAM288_BASE: 288K-bit High-Density Base Memory Building Block
   //               Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   URAM288_BASE #(
      .AUTO_SLEEP_LATENCY(8),            // Latency requirement to enter sleep mode
      .AVG_CONS_INACTIVE_CYCLES(10),     // Average concecutive inactive cycles when is SLEEP mode for power
                                         // estimation
      .BWE_MODE_A("PARITY_INTERLEAVED"), // Port A Byte write control
      .BWE_MODE_B("PARITY_INTERLEAVED"), // Port B Byte write control
      .EN_AUTO_SLEEP_MODE("FALSE"),      // Enable to automatically enter sleep mode
      .EN_ECC_RD_A("FALSE"),             // Port A ECC encoder
      .EN_ECC_RD_B("FALSE"),             // Port B ECC encoder
      .EN_ECC_WR_A("FALSE"),             // Port A ECC decoder
      .EN_ECC_WR_B("FALSE"),             // Port B ECC decoder
      .IREG_PRE_A("FALSE"),              // Optional Port A input pipeline registers
      .IREG_PRE_B("FALSE"),              // Optional Port B input pipeline registers
      .IS_CLK_INVERTED(1'b0),            // Optional inverter for CLK
      .IS_EN_A_INVERTED(1'b0),           // Optional inverter for Port A enable
      .IS_EN_B_INVERTED(1'b0),           // Optional inverter for Port B enable
      .IS_RDB_WR_A_INVERTED(1'b0),       // Optional inverter for Port A read/write select
      .IS_RDB_WR_B_INVERTED(1'b0),       // Optional inverter for Port B read/write select
      .IS_RST_A_INVERTED(1'b0),          // Optional inverter for Port A reset
      .IS_RST_B_INVERTED(1'b0),          // Optional inverter for Port B reset
      .MATRIX_ID("NONE"),
      .NUM_UNIQUE_SELF_ADDR_A(1),
      .NUM_UNIQUE_SELF_ADDR_B(1),
      .NUM_URAM_IN_MATRIX(1),
      .OREG_A("FALSE"),                  // Optional Port A output pipeline registers
      .OREG_B("FALSE"),                  // Optional Port B output pipeline registers
      .OREG_ECC_A("FALSE"),              // Port A ECC decoder output
      .OREG_ECC_B("FALSE"),              // Port B output ECC decoder
      .RST_MODE_A("SYNC"),               // Port A reset mode
      .RST_MODE_B("SYNC"),               // Port B reset mode
      .USE_EXT_CE_A("FALSE"),            // Enable Port A external CE inputs for output registers
      .USE_EXT_CE_B("FALSE")             // Enable Port B external CE inputs for output registers
   )
   URAM288_BASE_inst (
      .DBITERR_A(DBITERR_A),               // 1-bit output: Port A double-bit error flag status
      .DBITERR_B(DBITERR_B),               // 1-bit output: Port B double-bit error flag status
      .DOUT_A(DOUT_A),                     // 72-bit output: Port A read data output
      .DOUT_B(DOUT_B),                     // 72-bit output: Port B read data output
      .SBITERR_A(SBITERR_A),               // 1-bit output: Port A single-bit error flag status
      .SBITERR_B(SBITERR_B),               // 1-bit output: Port B single-bit error flag status
      .ADDR_A(ADDR_A),                     // 23-bit input: Port A address
      .ADDR_B(ADDR_B),                     // 23-bit input: Port B address
      .BWE_A(BWE_A),                       // 9-bit input: Port A Byte-write enable
      .BWE_B(BWE_B),                       // 9-bit input: Port B Byte-write enable
      .CLK(CLK),                           // 1-bit input: Clock source
      .DIN_A(DIN_A),                       // 72-bit input: Port A write data input
      .DIN_B(DIN_B),                       // 72-bit input: Port B write data input
      .EN_A(EN_A),                         // 1-bit input: Port A enable
      .EN_B(EN_B),                         // 1-bit input: Port B enable
      .INJECT_DBITERR_A(INJECT_DBITERR_A), // 1-bit input: Port A double-bit error injection
      .INJECT_DBITERR_B(INJECT_DBITERR_B), // 1-bit input: Port B double-bit error injection
      .INJECT_SBITERR_A(INJECT_SBITERR_A), // 1-bit input: Port A single-bit error injection
      .INJECT_SBITERR_B(INJECT_SBITERR_B), // 1-bit input: Port B single-bit error injection
      .OREG_CE_A(OREG_CE_A),               // 1-bit input: Port A output register clock enable
      .OREG_CE_B(OREG_CE_B),               // 1-bit input: Port B output register clock enable
      .OREG_ECC_CE_A(OREG_ECC_CE_A),       // 1-bit input: Port A ECC decoder output register clock enable
      .OREG_ECC_CE_B(OREG_ECC_CE_B),       // 1-bit input: Port B ECC decoder output register clock enable
      .RDB_WR_A(RDB_WR_A),                 // 1-bit input: Port A read/write select
      .RDB_WR_B(RDB_WR_B),                 // 1-bit input: Port B read/write select
      .RST_A(RST_A),                       // 1-bit input: Port A asynchronous or synchronous reset for output
                                           // registers

      .RST_B(RST_B),                       // 1-bit input: Port B asynchronous or synchronous reset for output
                                           // registers

      .SLEEP(SLEEP)                        // 1-bit input: Dynamic power gating control
   );

   // End of URAM288_BASE_inst instantiation
					</Template>
					<Template label="288K-bit High-Density Memory Building Block (URAM288)" treetype="template">
//   URAM288   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (URAM288_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // URAM288: 288K-bit High-Density Memory Building Block
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   URAM288 #(
      .AUTO_SLEEP_LATENCY(8),            // Latency requirement to enter sleep mode
      .AVG_CONS_INACTIVE_CYCLES(10),     // Average concecutive inactive cycles when is SLEEP mode for power
                                         // estimation
      .BWE_MODE_A("PARITY_INTERLEAVED"), // Port A Byte write control
      .BWE_MODE_B("PARITY_INTERLEAVED"), // Port B Byte write control
      .CASCADE_ORDER_A("NONE"),          // Port A position in cascade chain
      .CASCADE_ORDER_B("NONE"),          // Port B position in cascade chain
      .EN_AUTO_SLEEP_MODE("FALSE"),      // Enable to automatically enter sleep mode
      .EN_ECC_RD_A("FALSE"),             // Port A ECC encoder
      .EN_ECC_RD_B("FALSE"),             // Port B ECC encoder
      .EN_ECC_WR_A("FALSE"),             // Port A ECC decoder
      .EN_ECC_WR_B("FALSE"),             // Port B ECC decoder
      .IREG_PRE_A("FALSE"),              // Optional Port A input pipeline registers
      .IREG_PRE_B("FALSE"),              // Optional Port B input pipeline registers
      .IS_CLK_INVERTED(1'b0),            // Optional inverter for CLK
      .IS_EN_A_INVERTED(1'b0),           // Optional inverter for Port A enable
      .IS_EN_B_INVERTED(1'b0),           // Optional inverter for Port B enable
      .IS_RDB_WR_A_INVERTED(1'b0),       // Optional inverter for Port A read/write select
      .IS_RDB_WR_B_INVERTED(1'b0),       // Optional inverter for Port B read/write select
      .IS_RST_A_INVERTED(1'b0),          // Optional inverter for Port A reset
      .IS_RST_B_INVERTED(1'b0),          // Optional inverter for Port B reset
      .MATRIX_ID("NONE"),                // Custom label to set a matrix ID name used by the power reporting
                                         // tools to tag all of the UltraRAM blocks that belong to a cascade
                                         // chain or matrix.
      .NUM_UNIQUE_SELF_ADDR_A(1),        // The number of unique SELF_ADDR_A UltraRAM blocks in a cascade chain
                                         // or matrix.
      .NUM_UNIQUE_SELF_ADDR_B(1),        // The number of unique SELF_ADDR_B UltraRAM blocks in a cascade chain
                                         // or matrix.
      .NUM_URAM_IN_MATRIX(1),            // Defines the cascade/matrix size (the number of UltraRAMs in a
                                         // matrix).
      .OREG_A("FALSE"),                  // Optional Port A output pipeline registers
      .OREG_B("FALSE"),                  // Optional Port B output pipeline registers
      .OREG_ECC_A("FALSE"),              // Port A ECC decoder output
      .OREG_ECC_B("FALSE"),              // Port B output ECC decoder
      .REG_CAS_A("FALSE"),               // Optional Port A cascade register
      .REG_CAS_B("FALSE"),               // Optional Port B cascade register
      .RST_MODE_A("SYNC"),               // Port A reset mode
      .RST_MODE_B("SYNC"),               // Port B reset mode
      .SELF_ADDR_A(11'h000),             // Port A self-address value
      .SELF_ADDR_B(11'h000),             // Port B self-address value
      .SELF_MASK_A(11'h7ff),             // Port A self-address mask
      .SELF_MASK_B(11'h7ff),             // Port B self-address mask
      .USE_EXT_CE_A("FALSE"),            // Enable Port A external CE inputs for output registers
      .USE_EXT_CE_B("FALSE")             // Enable Port B external CE inputs for output registers
   )
   URAM288_inst (
      .CAS_OUT_ADDR_A(CAS_OUT_ADDR_A),         // 23-bit output: Port A cascade output address
      .CAS_OUT_ADDR_B(CAS_OUT_ADDR_B),         // 23-bit output: Port B cascade output address
      .CAS_OUT_BWE_A(CAS_OUT_BWE_A),           // 9-bit output: Port A cascade Byte-write enable output
      .CAS_OUT_BWE_B(CAS_OUT_BWE_B),           // 9-bit output: Port B cascade Byte-write enable output
      .CAS_OUT_DBITERR_A(CAS_OUT_DBITERR_A),   // 1-bit output: Port A cascade double-bit error flag output
      .CAS_OUT_DBITERR_B(CAS_OUT_DBITERR_B),   // 1-bit output: Port B cascade double-bit error flag output
      .CAS_OUT_DIN_A(CAS_OUT_DIN_A),           // 72-bit output: Port A cascade output write mode data
      .CAS_OUT_DIN_B(CAS_OUT_DIN_B),           // 72-bit output: Port B cascade output write mode data
      .CAS_OUT_DOUT_A(CAS_OUT_DOUT_A),         // 72-bit output: Port A cascade output read mode data
      .CAS_OUT_DOUT_B(CAS_OUT_DOUT_B),         // 72-bit output: Port B cascade output read mode data
      .CAS_OUT_EN_A(CAS_OUT_EN_A),             // 1-bit output: Port A cascade output enable
      .CAS_OUT_EN_B(CAS_OUT_EN_B),             // 1-bit output: Port B cascade output enable
      .CAS_OUT_RDACCESS_A(CAS_OUT_RDACCESS_A), // 1-bit output: Port A cascade read status output
      .CAS_OUT_RDACCESS_B(CAS_OUT_RDACCESS_B), // 1-bit output: Port B cascade read status output
      .CAS_OUT_RDB_WR_A(CAS_OUT_RDB_WR_A),     // 1-bit output: Port A cascade read/write select output
      .CAS_OUT_RDB_WR_B(CAS_OUT_RDB_WR_B),     // 1-bit output: Port B cascade read/write select output
      .CAS_OUT_SBITERR_A(CAS_OUT_SBITERR_A),   // 1-bit output: Port A cascade single-bit error flag output
      .CAS_OUT_SBITERR_B(CAS_OUT_SBITERR_B),   // 1-bit output: Port B cascade single-bit error flag output
      .DBITERR_A(DBITERR_A),                   // 1-bit output: Port A double-bit error flag status
      .DBITERR_B(DBITERR_B),                   // 1-bit output: Port B double-bit error flag status
      .DOUT_A(DOUT_A),                         // 72-bit output: Port A read data output
      .DOUT_B(DOUT_B),                         // 72-bit output: Port B read data output
      .RDACCESS_A(RDACCESS_A),                 // 1-bit output: Port A read status
      .RDACCESS_B(RDACCESS_B),                 // 1-bit output: Port B read status
      .SBITERR_A(SBITERR_A),                   // 1-bit output: Port A single-bit error flag status
      .SBITERR_B(SBITERR_B),                   // 1-bit output: Port B single-bit error flag status
      .ADDR_A(ADDR_A),                         // 23-bit input: Port A address
      .ADDR_B(ADDR_B),                         // 23-bit input: Port B address
      .BWE_A(BWE_A),                           // 9-bit input: Port A Byte-write enable
      .BWE_B(BWE_B),                           // 9-bit input: Port B Byte-write enable
      .CAS_IN_ADDR_A(CAS_IN_ADDR_A),           // 23-bit input: Port A cascade input address
      .CAS_IN_ADDR_B(CAS_IN_ADDR_B),           // 23-bit input: Port B cascade input address
      .CAS_IN_BWE_A(CAS_IN_BWE_A),             // 9-bit input: Port A cascade Byte-write enable input
      .CAS_IN_BWE_B(CAS_IN_BWE_B),             // 9-bit input: Port B cascade Byte-write enable input
      .CAS_IN_DBITERR_A(CAS_IN_DBITERR_A),     // 1-bit input: Port A cascade double-bit error flag input
      .CAS_IN_DBITERR_B(CAS_IN_DBITERR_B),     // 1-bit input: Port B cascade double-bit error flag input
      .CAS_IN_DIN_A(CAS_IN_DIN_A),             // 72-bit input: Port A cascade input write mode data
      .CAS_IN_DIN_B(CAS_IN_DIN_B),             // 72-bit input: Port B cascade input write mode data
      .CAS_IN_DOUT_A(CAS_IN_DOUT_A),           // 72-bit input: Port A cascade input read mode data
      .CAS_IN_DOUT_B(CAS_IN_DOUT_B),           // 72-bit input: Port B cascade input read mode data
      .CAS_IN_EN_A(CAS_IN_EN_A),               // 1-bit input: Port A cascade enable input
      .CAS_IN_EN_B(CAS_IN_EN_B),               // 1-bit input: Port B cascade enable input
      .CAS_IN_RDACCESS_A(CAS_IN_RDACCESS_A),   // 1-bit input: Port A cascade read status input
      .CAS_IN_RDACCESS_B(CAS_IN_RDACCESS_B),   // 1-bit input: Port B cascade read status input
      .CAS_IN_RDB_WR_A(CAS_IN_RDB_WR_A),       // 1-bit input: Port A cascade read/write select input
      .CAS_IN_RDB_WR_B(CAS_IN_RDB_WR_B),       // 1-bit input: Port A cascade read/write select input
      .CAS_IN_SBITERR_A(CAS_IN_SBITERR_A),     // 1-bit input: Port A cascade single-bit error flag input
      .CAS_IN_SBITERR_B(CAS_IN_SBITERR_B),     // 1-bit input: Port B cascade single-bit error flag input
      .CLK(CLK),                               // 1-bit input: Clock source
      .DIN_A(DIN_A),                           // 72-bit input: Port A write data input
      .DIN_B(DIN_B),                           // 72-bit input: Port B write data input
      .EN_A(EN_A),                             // 1-bit input: Port A enable
      .EN_B(EN_B),                             // 1-bit input: Port B enable
      .INJECT_DBITERR_A(INJECT_DBITERR_A),     // 1-bit input: Port A double-bit error injection
      .INJECT_DBITERR_B(INJECT_DBITERR_B),     // 1-bit input: Port B double-bit error injection
      .INJECT_SBITERR_A(INJECT_SBITERR_A),     // 1-bit input: Port A single-bit error injection
      .INJECT_SBITERR_B(INJECT_SBITERR_B),     // 1-bit input: Port B single-bit error injection
      .OREG_CE_A(OREG_CE_A),                   // 1-bit input: Port A output register clock enable
      .OREG_CE_B(OREG_CE_B),                   // 1-bit input: Port B output register clock enable
      .OREG_ECC_CE_A(OREG_ECC_CE_A),           // 1-bit input: Port A ECC decoder output register clock enable
      .OREG_ECC_CE_B(OREG_ECC_CE_B),           // 1-bit input: Port B ECC decoder output register clock enable
      .RDB_WR_A(RDB_WR_A),                     // 1-bit input: Port A read/write select
      .RDB_WR_B(RDB_WR_B),                     // 1-bit input: Port B read/write select
      .RST_A(RST_A),                           // 1-bit input: Port A asynchronous or synchronous reset for
                                               // output registers

      .RST_B(RST_B),                           // 1-bit input: Port B asynchronous or synchronous reset for
                                               // output registers

      .SLEEP(SLEEP)                            // 1-bit input: Dynamic power gating control
   );

   // End of URAM288_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLB" treetype="folder">
				<SubFolder label="CARRY" treetype="folder">
					<Template label="Fast Carry Logic with Look Ahead (CARRY8)" treetype="template">
//   CARRY8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CARRY8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CARRY8: Fast Carry Logic with Look Ahead
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   CARRY8 #(
      .CARRY_TYPE("SINGLE_CY8")  // 8-bit or dual 4-bit carry (DUAL_CY4, SINGLE_CY8)
   )
   CARRY8_inst (
      .CO(CO),         // 8-bit output: Carry-out
      .O(O),           // 8-bit output: Carry chain XOR data out
      .CI(CI),         // 1-bit input: Lower Carry-In
      .CI_TOP(CI_TOP), // 1-bit input: Upper Carry-In
      .DI(DI),         // 8-bit input: Carry-MUX data in
      .S(S)            // 8-bit input: Carry-mux select
   );

   // End of CARRY8_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Two input AND gate implemented in place of a CLB Latch (AND2B1L)" treetype="template">
//   AND2B1L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (AND2B1L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // AND2B1L: Two input AND gate implemented in place of a CLB Latch
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   AND2B1L #(
      .IS_SRI_INVERTED(1'b0)  // Optional inversion for SRI
   )
   AND2B1L_inst (
      .O(O),     // 1-bit output: AND gate output
      .DI(DI),   // 1-bit input: Data input connected to LUT logic
      .SRI(SRI)  // 1-bit input: External CLB data
   );

   // End of AND2B1L_inst instantiation
					</Template>
					<Template label="Two input OR gate implemented in place of a CLB Latch (OR2L)" treetype="template">
//    OR2L     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OR2L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OR2L: Two input OR gate implemented in place of a CLB Latch
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OR2L #(
      .IS_SRI_INVERTED(1'b0)  // Optional inversion for SRI
   )
   OR2L_inst (
      .O(O),     // 1-bit output: OR gate output
      .DI(DI),   // 1-bit input: Data input connected to LUT logic
      .SRI(SRI)  // 1-bit input: External CLB data
   );

   // End of OR2L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUT" treetype="folder">
					<Template label="1-Bit Look-Up Table (LUT1)" treetype="template">
//    LUT1     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1: 1-Bit Look-Up Table
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT1 #(
      .INIT(2'h0)  // Logic function
   )
   LUT1_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0)  // 1-bit input: LUT
   );

   // End of LUT1_inst instantiation
					</Template>
					<Template label="2-Bit Look-Up Table (LUT2)" treetype="template">
//    LUT2     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2: 2-Bit Look-Up Table
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT2 #(
      .INIT(4'h0)  // Logic function
   )
   LUT2_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1)  // 1-bit input: LUT
   );

   // End of LUT2_inst instantiation
					</Template>
					<Template label="3-Bit Look-Up Table (LUT3)" treetype="template">
//    LUT3     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3: 3-Bit Look-Up Table
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT3 #(
      .INIT(8'h00)  // Logic function
   )
   LUT3_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2)  // 1-bit input: LUT
   );

   // End of LUT3_inst instantiation
					</Template>
					<Template label="4-Bit Look-Up Table (LUT4)" treetype="template">
//    LUT4     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4: 4-Bit Look-Up Table
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT(16'h0000)  // Logic function
   )
   LUT4_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3)  // 1-bit input: LUT
   );

   // End of LUT4_inst instantiation
					</Template>
					<Template label="5-Bit Look-Up Table (LUT5)" treetype="template">
//    LUT5     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5: 5-Bit Look-Up Table
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT5 #(
      .INIT(32'h00000000)  // Logic function
   )
   LUT5_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3), // 1-bit input: LUT
      .I4(I4)  // 1-bit input: LUT
   );

   // End of LUT5_inst instantiation
					</Template>
					<Template label="5-input Dynamically Reconfigurable Look-Up Table (LUT) (CFGLUT5)" treetype="template">
//   CFGLUT5   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CFGLUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CFGLUT5: 5-input Dynamically Reconfigurable Look-Up Table (LUT)
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   CFGLUT5 #(
      .INIT(32'h00000000),    // Initial logic function
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   CFGLUT5_inst (
      .CDO(CDO), // 1-bit output: Reconfiguration cascade
      .O5(O5),   // 1-bit output: 4-LUT
      .O6(O6),   // 1-bit output: 5-LUT
      .CDI(CDI), // 1-bit input: Reconfiguration data
      .CE(CE),   // 1-bit input: Reconfiguration enable
      .CLK(CLK), // 1-bit input: Clock
      // LUT Inputs inputs: Logic inputs
      .I0(I0),
      .I1(I1),
      .I2(I2),
      .I3(I3),
      .I4(I4) 
   );

   // End of CFGLUT5_inst instantiation
					</Template>
					<Template label="6-Bit Look-Up Table (LUT6)" treetype="template">
//    LUT6     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6: 6-Bit Look-Up Table
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT6 #(
      .INIT(64'h0000000000000000)  // Logic function
   )
   LUT6_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3), // 1-bit input: LUT
      .I4(I4), // 1-bit input: LUT
      .I5(I5)  // 1-bit input: LUT
   );

   // End of LUT6_inst instantiation
					</Template>
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
// The INIT parameter for the FPGA LUT primitive is what gives the LUT its
// logical value. By default this value is zero thus driving the output to a
// zero regardless of the input values (acting as a ground) however in most
// cases an new INIT value must be determined in order to specify the logic
// function for the LUT primitive.  There are a few methods in which the LUT
// value can be determined and two of those methods will be discussed here.
//
// The Truth Table Method
// ----------------------
//
//  A common method to determine the desired INIT value for a LUT is using a
// truth table.  To do so, simply create a binary truth table of all possible
// inputs, specify the desired logic value of the output and then create the
// INIT string from those output values.  An example is shown below:
//
// Example of determining an XOR INIT equation for a LUT4:
//
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | 0 |\
//     |  0  0  0  1 | 1 | \ = 4'b0110 = 4'h6 ---------------+
//     |  0  0  1  0 | 1 | /                                 |
//     |  0  0  1  1 | 0 |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | 1 |\                                  |
//     |  0  1  0  1 | 0 | \ = 4'b1001 = 4'h9                |
//     |  0  1  1  0 | 0 | /                                 |
//     |  0  1  1  1 | 1 |/                                  |
//     |-------------|---|                     INIT = 16'h6996
//     |  1  0  0  0 | 1 |\                               |
//     |  1  0  0  1 | 0 | \ = 4'b0110 = 4'h9             |
//     |  1  0  1  0 | 0 | /                              |
//     |  1  0  1  1 | 1 |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | 0 |\                               |
//     |  1  1  0  1 | 1 | \ = 4'b1001 = 4'h6 ------------+
//     |  1  1  1  0 | 1 | /
//     |  1  1  1  1 | 0 |/
//     -------------------
//
// Example of determining a 3-input AND gate:
//
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | 0 |\
//     |  0  0  1 | 0 | \ = 4'b0000 = 4'h0 --------------+
//     |  0  1  0 | 0 | /                                |
//     |  0  1  1 | 0 |/                                 |
//     |----------|---|                       INIT = 8'h80
//     |  1  0  0 | 0 |\                                |
//     |  1  0  1 | 0 | \ = 4'b1000 = 4'h8 -------------+
//     |  1  1  0 | 0 | /
//     |  1  1  1 | 1 |/
//     ----------------
//
// The Equation Method
// -------------------
//
// Another method to determine the LUT value is to define parameters for each
// input to the LUT that correspond to their listed truth value and use those to
// build the logic equation you are after.  This method is easier to understand
// once you have grasped the concept and more self-documenting that the above
// method however does require the code to first specify the appropriate
// parameters.  See the example below.
//
// Example of specifying the equation (A and B) or (C and D) for a LUT4:
//
   // The following parameters are defined to allow for
   //   equation-based INIT specification.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;

   // LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT((I0&amp;I1)|(I2&amp;I3))  // Specify LUT Contents
   ) LUT4_inst (
      .O(O_LUT), // LUT general output
      .I0(A),    // LUT input
      .I1(B),    // LUT input
      .I2(C),    // LUT input
      .I3(D)     // LUT input
   );

   // End of LUT4_inst instantiation

// With the parameters specifying all possible cases for the truth table, a
// Verilog equation can be written to determine the end INIT value.
						</Template>
						<SubFolder label="INIT Parameters" treetype="folder">
							<Template label="LUT1" treetype="template">
   // The following parameter is defined to allow for
   //   equation-based INIT specification for a LUT1.
   parameter I0 = 2'b10;
							</Template>
							<Template label="LUT2" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT2.
   parameter I0 = 4'ha;
   parameter I1 = 4'hc;
							</Template>
							<Template label="LUT3" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT3.
   parameter I0 = 8'haa;
   parameter I1 = 8'hcc;
   parameter I2 = 8'hf0;
							</Template>
							<Template label="LUT4" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT4.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;
							</Template>
							<Template label="LUT5" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT5.
   parameter I0 = 32'haaaaaaaa;
   parameter I1 = 32'hcccccccc;
   parameter I2 = 32'hf0f0f0f0;
   parameter I3 = 32'hff00ff00;
   parameter I4 = 32'hffff0000;
							</Template>
							<Template label="LUT6" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT6.
   parameter I0 = 64'haaaaaaaaaaaaaaaa;
   parameter I1 = 64'hcccccccccccccccc;
   parameter I2 = 64'hf0f0f0f0f0f0f0f0;
   parameter I3 = 64'hff00ff00ff00ff00;
   parameter I4 = 64'hffff0000ffff0000;
   parameter I5 = 64'hffffffff00000000;
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
//  Truth Table to determine INIT value for a LUT1
//      ________
//     | I0 | O |
//     |--------|
//     |  0 | ? |\
//     |  1 | ? |/ = 2'b??
//     ----------
							</Template>
							<Template label="LUT2" treetype="template">
//  Truth Table to determine INIT value for a LUT2
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
//     |  0  1  0 | ? | /
//     |  0  1  1 | ? |/
//      ---------- ---
							</Template>
							<Template label="LUT3" treetype="template">
//  Truth Table to determine INIT value for a LUT3
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
//     |  0  1  0 | ? | /                                |
//     |  0  1  1 | ? |/                                 |
//     |----------|---|                       INIT = 8'h??
//     |  1  0  0 | ? |\                                |
//     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
//     |  1  1  0 | ? | /
//     |  1  1  1 | ? |/
//     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
//  Truth Table to determine INIT value for a LUT4
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | ? |\
//     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
//     |  0  0  1  0 | ? | /                                 |
//     |  0  0  1  1 | ? |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | ? |\                                  |
//     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
//     |  0  1  1  0 | ? | /                                 |
//     |  0  1  1  1 | ? |/                                  |
//     |-------------|---|                     INIT = 16'h????
//     |  1  0  0  0 | ? |\                               |
//     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  0 | ? | /                              |
//     |  1  0  1  1 | ? |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | ? |\                               |
//     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  0 | ? | /
//     |  1  1  1  1 | ? |/
//     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
//  Truth Table to determine INIT value for a LUT5
//      ____________________
//     | I4 I3 I2 I1 I0 | O |
//     |--------------------|
//     |  0  0  0  0  0 | ? |\
//     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  0  1  0  0 | ? |\                                      |
//     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  1  0  0  0 | ? |\                                      |
//     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  0 | ? | /                                     |
//     |  0  1  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  1  1  0  0 | ? |\                                      |
//     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1 | ? |/                                      |
//     ----------------------                     INIT = 32'h????????
//     |  1  0  0  0  0 | ? |\                               |
//     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  0  1  0 | ? | /                              |
//     |  1  0  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  0  1  0  0 | ? |\                               |
//     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  1  0 | ? | /                              |
//     |  1  0  1  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  0  0  0 | ? |\                               |
//     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  1  0  1  0 | ? | /                              |
//     |  1  1  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  1  0  0 | ? |\                               |
//     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1 | ? |/
//     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
//  Truth Table to determine INIT value for a LUT6
//      _______________________
//     | I5 I4 I3 I2 I1 I0 | O |
//     |-----------------------|
//     |  0  0  0  0  0  0 | ? |\
//     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  0  1  0  0 | ? |\                                      |
//     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  0  1  1  0 | ? | /                                     |
//     |  0  0  0  1  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  1  0  0  0 | ? |\                                      |
//     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  0  1  0 | ? | /                                     |
//     |  0  0  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  1  1  0  0 | ? |\                                      |
//     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1  1 | ? |/                                      |
//     -------------------------                                       |
//     |  0  1  0  0  0  0 | ? |\                                      |
//     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  0  1  0 | ? | /                                     |
//     |  0  1  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  0  1  0  0 | ? |\                                      |
//     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  1  0 | ? | /                                     |
//     |  0  1  0  1  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  0  0  0 | ? |\                                      |
//     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  0  1  0 | ? | /                                     |
//     |  0  1  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  1  0  0 | ? |\                                      |
//     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1  1 | ? |/                                      |
//     ------------------------              INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
							<Template label="LUT6_2" treetype="template">
//  Truth Table to determine INIT value for a LUT6_2
//      _____________________________
//     | I5 I4 I3 I2 I1 I0 | O6 | O5 |
//     |-----------------------------|
//     |  0  0  0  0  0  0 |    ?    |\
//     |  0  0  0  0  0  1 |    ?    | \ = 4'b???? = 4'h? -------------+
//     |  0  0  0  0  1  0 |    ?    | /                               |
//     |  0  0  0  0  1  1 |	?    |/				       |
//     |-------------------|---------|                                 |
//     |  0  0  0  1  0  0 |	?    |\                                |
//     |  0  0  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  0  1  1  0 |	?    | /                               |
//     |  0  0  0  1  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  0  1  0  0  0 |	?    |\                                |
//     |  0  0  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  0  1  0 |	?    | /                               |
//     |  0  0  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  0  1  1  0  0 |	?    |\                                |
//     |  0  0  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  1  1  0 |	?    | /                               |
//     |  0  0  1  1  1  1 |	?    |/                                |
//     -------------------------------                                 |
//     |  0  1  0  0  0  0 |	?    |\                                |
//     |  0  1  0  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  0  1  0 |	?    | /                               |
//     |  0  1  0  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  0  1  0  0 |	?    |\                                |
//     |  0  1  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  1  1  0 |	?    | /                               |
//     |  0  1  0  1  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  0  0  0 |	?    |\                                |
//     |  0  1  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  0  1  0 |	?    | /                               |
//     |  0  1  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  1  0  0 |	?    |\                                |
//     |  0  1  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  1  1  0 |	?    | /                               |
//     |  0  1  1  1  1  1 |	?    |/                                |
//     ------------------------------        INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT6_2" treetype="template">
//   LUT6_2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_2: 6-input, 2 output Look-Up Table
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT6_2 #(
      .INIT(64'h0000000000000000) // Specify LUT Contents
   ) LUT6_2_inst (
      .O6(O6), // 1-bit LUT6 output
      .O5(O5), // 1-bit lower LUT5 output
      .I0(I0), // 1-bit LUT input
      .I1(I1), // 1-bit LUT input
      .I2(I2), // 1-bit LUT input
      .I3(I3), // 1-bit LUT input
      .I4(I4), // 1-bit LUT input
      .I5(I5)  // 1-bit LUT input (fast MUX select only available to O6 output)
   );

   // End of LUT6_2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUTRAM" treetype="folder">
					<Template label="64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM) (RAM64X8SW)" treetype="template">
//  RAM64X8SW  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X8SW_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X8SW: 64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM)
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM64X8SW #(
      .INIT_A(64'h0000000000000000), // Initial contents of the RAM for Bit 7
      .INIT_B(64'h0000000000000000), // Initial contents of the RAM for Bit 6
      .INIT_C(64'h0000000000000000), // Initial contents of the RAM for Bit 5
      .INIT_D(64'h0000000000000000), // Initial contents of the RAM for Bit 4
      .INIT_E(64'h0000000000000000), // Initial contents of the RAM for Bit 3
      .INIT_F(64'h0000000000000000), // Initial contents of the RAM for Bit 2
      .INIT_G(64'h0000000000000000), // Initial contents of the RAM for Bit 1
      .INIT_H(64'h0000000000000000), // Initial contents of the RAM for Bit 0
      .IS_WCLK_INVERTED(1'b0)        // Optional inversion for WCLK
   )
   RAM64X8SW_inst (
      .O(O),       // 8-bit data output
      .A(A),       // 6-bit address input
      .D(D),       // 1-bit input: Write data input
      .WCLK(WCLK), // 1-bit input: Write clock input
      .WE(WE),     // 1-bit input: Write enable input
      .WSEL(WSEL)  // 3-bit write select
   );

   // End of RAM64X8SW_inst instantiation
					</Template>
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 X 1 negedge write (RAM32X1D_1)" treetype="template">
//  RAM32X1D_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_1_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D_1: 32 x 1 negative edge write, asynchronous read dual-port
   //             distributed RAM (Mapped to two LUT6s)
   //             Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1 #(
      .INIT(32'h00000000),    // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0) // Specifies active high/low WCLK
   ) RAM32X1D_1_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_1_inst instantiation
						</Template>
						<Template label="32 X 1 posedge write (RAM32X1D)" treetype="template">
//   RAM32X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D: 32 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to two LUT6s)
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D #(
      .INIT(32'h00000000),     // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM32X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_inst instantiation
						</Template>
						<Template label="64 X 1 posedge write (RAM64X1D)" treetype="template">
//   RAM64X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM64X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1D: 64 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to two LUT6s)
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1D #(
      .INIT(64'h0000000000000000), // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)      // Specifies active high/low WCLK
   ) RAM64X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .A5(A5),       // Rw/ address[5] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .DPRA5(DPRA5), // Read-only address[5] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM64X1D_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">
//  RAM128X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM128X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read
   //            dual-port distributed LUT RAM
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1D #(
      .INIT(128'h00000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0) // Specifies active high/low WCLK
   ) RAM128X1D_inst (
      .DPO(DPO),   // Read port 1-bit output
      .SPO(SPO),   // Read/write port 1-bit output
      .A(A),       // Read/write port 7-bit address input
      .D(D),       // RAM data input
      .DPRA(DPRA), // Read port 7-bit address input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM128X1D_inst instantiation
						</Template>
						<Template label="256 X 1 posedge write (RAM256X1D)" treetype="template">
//  RAM256X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM256X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM256X1D: 256-deep by 1-wide positive edge write, asynchronous read
   //            dual-port distributed LUT RAM
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM256X1D #(
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM256X1D_inst (
      .DPO(DPO),   // Read port 1-bit output
      .SPO(SPO),   // Read/write port 1-bit output
      .A(A),       // Read/write port 8-bit address input
      .D(D),       // RAM data input
      .DPRA(DPRA), // Read port 8-bit address input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM256X1D_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">
//   RAM32M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32M: 32-deep by 8-wide Multi Port LUT RAM (Mapped to four LUT6s)
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM32M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM32M_inst (
      .DOA(DOA),     // Read port A 2-bit output
      .DOB(DOB),     // Read port B 2-bit output
      .DOC(DOC),     // Read port C 2-bit output
      .DOD(DOD),     // Read/write port D 2-bit output
      .ADDRA(ADDRA), // Read port A 5-bit address input
      .ADDRB(ADDRB), // Read port B 5-bit address input
      .ADDRC(ADDRC), // Read port C 5-bit address input
      .ADDRD(ADDRD), // Read/write port D 5-bit address input
      .DIA(DIA),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRD
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32M_inst instantiation
						</Template>
						<Template label="32 X 16 (RAM32M16)" treetype="template">
//   RAM32M16  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32M16_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32M16: 32-deep by 16-wide Multi Port LUT RAM (Mapped to eight LUT6s)
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM32M16 #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .INIT_E(64'h0000000000000000), // Initial contents of E Port
      .INIT_F(64'h0000000000000000), // Initial contents of F Port
      .INIT_G(64'h0000000000000000), // Initial contents of G Port
      .INIT_H(64'h0000000000000000), // Initial contents of H Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM32M16_inst (
      .DOA(DOA),     // Read port A 2-bit output
      .DOB(DOB),     // Read port B 2-bit output
      .DOC(DOC),     // Read port C 2-bit output
      .DOD(DOD),     // Read port D 2-bit output
      .DOE(DOE),     // Read port E 2-bit output
      .DOF(DOF),     // Read port F 2-bit output
      .DOG(DOG),     // Read port G 2-bit output
      .DOH(DOH),     // Read/write port H 2-bit output
      .ADDRA(ADDRA), // Read port A 5-bit address input
      .ADDRB(ADDRB), // Read port B 5-bit address input
      .ADDRC(ADDRC), // Read port C 5-bit address input
      .ADDRD(ADDRD), // Read port D 5-bit address input
      .ADDRE(ADDRE), // Read port E 5-bit address input
      .ADDRF(ADDRF), // Read port F 5-bit address input
      .ADDRG(ADDRG), // Read port G 5-bit address input
      .ADDRH(ADDRH), // Read/write port H 5-bit address input
      .DIA(DIA),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRD
      .DIE(DIE),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRE
      .DIF(DIF),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRF
      .DIG(DIG),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRG
      .DIH(DIH),     // RAM 2-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRH
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32M16_inst instantiation
						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">
//   RAM64M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64M: 64-deep by 4-wide Multi Port LUT RAM (Mapped to four LUT6s)
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM64M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM64M_inst (
      .DOA(DOA),     // Read port A 1-bit output
      .DOB(DOB),     // Read port B 1-bit output
      .DOC(DOC),     // Read port C 1-bit output
      .DOD(DOD),     // Read/write port D 1-bit output
      .DIA(DIA),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRD
      .ADDRA(ADDRA), // Read port A 6-bit address input
      .ADDRB(ADDRB), // Read port B 6-bit address input
      .ADDRC(ADDRC), // Read port C 6-bit address input
      .ADDRD(ADDRD), // Read/write port D 6-bit address input
      .WE(WE),       // Write enable input
      .WCLK(WCLK)    // Write clock input
   );

   // End of RAM64M_inst instantiation
						</Template>
						<Template label="64 X 8 (RAM64M8)" treetype="template">
//   RAM64M8   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64M8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64M8: 64-deep by 8-wide Multi Port LUT RAM (Mapped to eight LUT6s)
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM64M8 #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .INIT_E(64'h0000000000000000), // Initial contents of E Port
      .INIT_F(64'h0000000000000000), // Initial contents of F Port
      .INIT_G(64'h0000000000000000), // Initial contents of G Port
      .INIT_H(64'h0000000000000000), // Initial contents of H Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM64M8_inst (
      .DOA(DOA),     // Read port A 1-bit output
      .DOB(DOB),     // Read port B 1-bit output
      .DOC(DOC),     // Read port C 1-bit output
      .DOD(DOD),     // Read port D 1-bit output
      .DOE(DOE),     // Read port E 1-bit output
      .DOF(DOF),     // Read port F 1-bit output
      .DOG(DOG),     // Read port G 1-bit output
      .DOH(DOH),     // Read/write port H 1-bit output
      .DIA(DIA),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRD
      .DIE(DIE),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRE
      .DIF(DIF),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRF
      .DIG(DIG),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRG
      .DIH(DIH),     // RAM 1-bit data write input addressed by ADDRD,
                     //   read addressed by ADDRH
      .ADDRA(ADDRA), // Read port A 6-bit address input
      .ADDRB(ADDRB), // Read port B 6-bit address input
      .ADDRC(ADDRC), // Read port C 6-bit address input
      .ADDRD(ADDRD), // Read port D 6-bit address input
      .ADDRE(ADDRE), // Read port E 6-bit address input
      .ADDRF(ADDRF), // Read port F 6-bit address input
      .ADDRG(ADDRG), // Read port G 6-bit address input
      .ADDRH(ADDRH), // Read/write port H 6-bit address input
      .WE(WE),       // Write enable input
      .WCLK(WCLK)    // Write clock input
   );

   // End of RAM64M8_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">
//  RAM32X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM (Mapped to a LUT6)
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1S #(
      .INIT(32'h00000000),    // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0) // Specifies active high/low WCLK
   ) RAM32X1S_inst (
      .O(O),       // RAM output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D(D),       // RAM data input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X1S_inst instantiation
						</Template>
						<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">
//  RAM64X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port
   //           distributed RAM (Mapped to a LUT6)
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1S #(
      .INIT(64'h0000000000000000), // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)      // Specifies active high/low WCLK
   ) RAM64X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM64X1S_inst instantiation
						</Template>
						<Template label="128 X 1 negedge write (RAM128X1S_1)" treetype="template">
// RAM128X1S_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S_1: 128 x 1 negative edge write, asynchronous read single-port
   //              distributed RAM (Mapped to two LUT6s)
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1 #(
      .INIT(128'h00000000000000000000000000000000),  // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM128X1S_1_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_1_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1S)" treetype="template">
//  RAM128X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S: 128 x 1 positive edge write, asynchronous read single-port
   //            distributed RAM (Mapped to two LUT6s)
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S #(
      .INIT(128'h00000000000000000000000000000000), // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM128X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_inst instantiation
						</Template>
						<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">
//  RAM256X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM256X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read  (Mapped to four LUT6s)
   //            single-port distributed LUT RAM
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM256X1S #(
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM256X1S_inst (
      .O(O),       // Read/write port 1-bit output
      .A(A),       // Read/write port 8-bit address input
      .WE(WE),     // Write enable input
      .WCLK(WCLK), // Write clock input
      .D(D)        // RAM data input
   );

   // End of RAM256X1S_inst instantiation
						</Template>
						<Template label="512 X 1 posedge write (RAM512X1S)" treetype="template">
//  RAM512X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM512X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM512X1S: 512-deep by 1-wide positive edge write, asynchronous read  (Mapped to eight LUT6s)
   //            single-port distributed LUT RAM
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM512X1S #(
      .INIT(512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM512X1S_inst (
      .O(O),       // Read/write port 1-bit output
      .A(A),       // Read/write port 9-bit address input
      .WE(WE),     // Write enable input
      .WCLK(WCLK), // Write clock input
      .D(D)        // RAM data input
   );

   // End of RAM512X1S_inst instantiation
						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="MUXF" treetype="folder">
					<Template label="CLB MUX to connect two LUT6's Together (MUXF7)" treetype="template">
//    MUXF7    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7: CLB MUX to connect two LUT6's Together
   //        Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MUXF7 MUXF7_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to LUT6 output
      .I1(I1), // 1-bit input: Connect to LUT6 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF7_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF7's Together (MUXF8)" treetype="template">
//    MUXF8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8: CLB MUX to connect two MUXF7's Together
   //        Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MUXF8 MUXF8_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to MUXF7 output
      .I1(I1), // 1-bit input: Connect to MUXF7 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF8_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF8's Together (MUXF9)" treetype="template">
//    MUXF9    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF9_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF9: CLB MUX to connect two MUXF8's Together
   //        Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MUXF9 MUXF9_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to MUXF8 output
      .I1(I1), // 1-bit input: Connect to MUXF8 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF9_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="16-Bit Shift Register Look-Up Table (LUT) (SRL16E)" treetype="template">
//   SRL16E    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL16E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRL16E: 16-Bit Shift Register Look-Up Table (LUT)
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   SRL16E #(
      .INIT(16'h0000),        // Initial contents of shift register
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   SRL16E_inst (
      .Q(Q),     // 1-bit output: SRL Data
      .CE(CE),   // 1-bit input: Clock enable
      .CLK(CLK), // 1-bit input: Clock
      .D(D),     // 1-bit input: SRL Data
      // Depth Selection inputs: A0-A3 select SRL depth
      .A0(A0),
      .A1(A1),
      .A2(A2),
      .A3(A3) 
   );

   // End of SRL16E_inst instantiation
					</Template>
					<Template label="32-Bit Shift Register Look-Up Table (LUT) (SRLC32E)" treetype="template">
//   SRLC32E   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRLC32E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRLC32E: 32-Bit Shift Register Look-Up Table (LUT)
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   SRLC32E #(
      .INIT(32'h00000000),    // Initial contents of shift register
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   SRLC32E_inst (
      .Q(Q),     // 1-bit output: SRL Data
      .Q31(Q31), // 1-bit output: SRL Cascade Data
      .A(A),     // 5-bit input: Selects SRL depth
      .CE(CE),   // 1-bit input: Clock enable
      .CLK(CLK), // 1-bit input: Clock
      .D(D)      // 1-bit input: SRL Data
   );

   // End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLOCK" treetype="folder">
				<SubFolder label="BUFFER" treetype="folder">
					<Template label="A high-fanout buffer for low-skew distribution of the PS Clock signals (BUFG_PS)" treetype="template">
//   BUFG_PS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_PS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_PS: A high-fanout buffer for low-skew distribution of the PS Clock signals
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFG_PS BUFG_PS_inst (
      .O(O), // 1-bit output: Clock buffer output
      .I(I)  // 1-bit input: Clock buffer input
   );

   // End of BUFG_PS_inst instantiation
					</Template>
					<Template label="Clock Buffer Driven by Gigabit Transceiver (BUFG_GT)" treetype="template">
//   BUFG_GT   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_GT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_GT: Clock Buffer Driven by Gigabit Transceiver
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFG_GT BUFG_GT_inst (
      .O(O),             // 1-bit output: Buffer
      .CE(CE),           // 1-bit input: Buffer enable
      .CEMASK(CEMASK),   // 1-bit input: CE Mask
      .CLR(CLR),         // 1-bit input: Asynchronous clear
      .CLRMASK(CLRMASK), // 1-bit input: CLR Mask
      .DIV(DIV),         // 3-bit input: Dynamic divide Value
      .I(I)              // 1-bit input: Buffer
   );

   // End of BUFG_GT_inst instantiation
					</Template>
					<Template label="General Clock Buffer (BUFG)" treetype="template">
//    BUFG     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG: General Clock Buffer
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFG BUFG_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFG_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
//   BUFGCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE: General Clock Buffer with Clock Enable
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE #(
      .CE_TYPE("SYNC"),      // ASYNC, SYNC
      .IS_CE_INVERTED(1'b0), // Programmable inversion on CE
      .IS_I_INVERTED(1'b0)   // Programmable inversion on I
   )
   BUFGCE_inst (
      .O(O),   // 1-bit output: Buffer
      .CE(CE), // 1-bit input: Buffer enable
      .I(I)    // 1-bit input: Buffer
   );

   // End of BUFGCE_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Divide (BUFGCE_DIV)" treetype="template">
// BUFGCE_DIV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_DIV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_DIV: General Clock Buffer with Divide Function
   //             Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_DIV #(
      .BUFGCE_DIVIDE(1),      // 1-8
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CE_INVERTED(1'b0),  // Optional inversion for CE
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_I_INVERTED(1'b0)    // Optional inversion for I
   )
   BUFGCE_DIV_inst (
      .O(O),     // 1-bit output: Buffer
      .CE(CE),   // 1-bit input: Buffer enable
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .I(I)      // 1-bit input: Buffer
   );

   // End of BUFGCE_DIV_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
//  BUFGCE_1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_1: General Clock Buffer with Clock Enable and Output State 1
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_1 BUFGCE_1_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock buffer active-High enable
      .I(I)    // 1-bit input: Clock input
   );

   // End of BUFGCE_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="CLOCK_SYNC" treetype="folder">
					<Template label="Synchronizer for BUFG_GT Control Signals (BUFG_GT_SYNC)" treetype="template">
// BUFG_GT_SYNC : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFG_GT_SYNC_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_GT_SYNC: Synchronizer for BUFG_GT Control Signals
   //               Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFG_GT_SYNC BUFG_GT_SYNC_inst (
      .CESYNC(CESYNC),   // 1-bit output: Synchronized CE
      .CLRSYNC(CLRSYNC), // 1-bit output: Synchronized CLR
      .CE(CE),           // 1-bit input: Asynchronous enable
      .CLK(CLK),         // 1-bit input: Clock
      .CLR(CLR)          // 1-bit input: Asynchronous clear
   );

   // End of BUFG_GT_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUX" treetype="folder">
					<Template label="2-to-1 General Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
// BUFGMUX_CTRL : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_CTRL: 2-to-1 General Clock MUX Buffer
   //               Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL BUFGMUX_CTRL_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="General Clock Control Buffer (BUFGCTRL)" treetype="template">
//  BUFGCTRL   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCTRL: General Clock Control Buffer
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGCTRL #(
      .INIT_OUT(0),               // Initial value of BUFGCTRL output, 0-1
      .PRESELECT_I0("FALSE"),     // BUFGCTRL output uses I0 input, FALSE, TRUE
      .PRESELECT_I1("FALSE"),     // BUFGCTRL output uses I1 input, FALSE, TRUE
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CE0_INVERTED(1'b0),     // Optional inversion for CE0
      .IS_CE1_INVERTED(1'b0),     // Optional inversion for CE1
      .IS_I0_INVERTED(1'b0),      // Optional inversion for I0
      .IS_I1_INVERTED(1'b0),      // Optional inversion for I1
      .IS_IGNORE0_INVERTED(1'b0), // Optional inversion for IGNORE0
      .IS_IGNORE1_INVERTED(1'b0), // Optional inversion for IGNORE1
      .IS_S0_INVERTED(1'b0),      // Optional inversion for S0
      .IS_S1_INVERTED(1'b0)       // Optional inversion for S1
   )
   BUFGCTRL_inst (
      .O(O),             // 1-bit output: Clock output
      .CE0(CE0),         // 1-bit input: Clock enable input for I0
      .CE1(CE1),         // 1-bit input: Clock enable input for I1
      .I0(I0),           // 1-bit input: Primary clock
      .I1(I1),           // 1-bit input: Secondary clock
      .IGNORE0(IGNORE0), // 1-bit input: Clock ignore input for I0
      .IGNORE1(IGNORE1), // 1-bit input: Clock ignore input for I1
      .S0(S0),           // 1-bit input: Clock select for I0
      .S1(S1)            // 1-bit input: Clock select for I1
   );

   // End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer (BUFGMUX)" treetype="template">
//   BUFGMUX   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX: General Clock Mux Buffer
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX #(
      .CLK_SEL_TYPE("SYNC")  // ASYNC, SYNC
   )
   BUFGMUX_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
//  BUFGMUX_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_1: General Clock Mux Buffer with Output State 1
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1 #(
      .CLK_SEL_TYPE("SYNC")  // ASYNC, SYNC
   )
   BUFGMUX_1_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME3_ADV)" treetype="template">
// MMCME3_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME3_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME3_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   //             Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MMCME3_ADV #(
      .BANDWIDTH("OPTIMIZED"),        // Jitter programming (HIGH, LOW, OPTIMIZED)
      .CLKFBOUT_MULT_F(5.0),          // Multiply value for all CLKOUT (2.000-64.000)
      .CLKFBOUT_PHASE(0.0),           // Phase offset in degrees of CLKFB (-360.000-360.000)
      // CLKIN_PERIOD: Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      .CLKOUT0_DIVIDE_F(1.0),         // Divide amount for CLKOUT0 (1.000-128.000)
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      // CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_CASCADE("FALSE"),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .COMPENSATION("AUTO"),          // AUTO, BUF_IN, EXTERNAL, INTERNAL, ZHOLD
      .DIVCLK_DIVIDE(1),              // Master division value (1-106)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0),     // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),      // Optional inversion for CLKIN1
      .IS_CLKIN2_INVERTED(1'b0),      // Optional inversion for CLKIN2
      .IS_CLKINSEL_INVERTED(1'b0),    // Optional inversion for CLKINSEL
      .IS_PSEN_INVERTED(1'b0),        // Optional inversion for PSEN
      .IS_PSINCDEC_INVERTED(1'b0),    // Optional inversion for PSINCDEC
      .IS_PWRDWN_INVERTED(1'b0),      // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE"),         // Delays DONE until MMCM is locked (FALSE, TRUE)
      // Spread Spectrum: Spread Spectrum Attributes
      .SS_EN("FALSE"),                // Enables spread spectrum (FALSE, TRUE)
      .SS_MODE("CENTER_HIGH"),        // CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      .SS_MOD_PERIOD(10000),          // Spread spectrum modulation period (ns) (4000-40000)
      // USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      .CLKFBOUT_USE_FINE_PS("FALSE"),
      .CLKOUT0_USE_FINE_PS("FALSE"),
      .CLKOUT1_USE_FINE_PS("FALSE"),
      .CLKOUT2_USE_FINE_PS("FALSE"),
      .CLKOUT3_USE_FINE_PS("FALSE"),
      .CLKOUT4_USE_FINE_PS("FALSE"),
      .CLKOUT5_USE_FINE_PS("FALSE"),
      .CLKOUT6_USE_FINE_PS("FALSE") 
   )
   MMCME3_ADV_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),           // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),         // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),           // 1-bit output: Primary clock
      .CLKOUT1B(CLKOUT1B),         // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),           // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),         // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),           // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),         // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),           // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),           // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),           // 1-bit output: CLKOUT6
      // DRP Ports outputs: Dynamic reconfiguration ports
      .DO(DO),                     // 16-bit output: DRP data
      .DRDY(DRDY),                 // 1-bit output: DRP ready
      // Dynamic Phase Shift Ports outputs: Ports used for dynamic phase shifting of the outputs
      .PSDONE(PSDONE),             // 1-bit output: Phase shift done
      // Feedback outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),         // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB),       // 1-bit output: Inverted CLKFBOUT
      // Status Ports outputs: MMCM status ports
      .CDDCDONE(CDDCDONE),         // 1-bit output: Clock dynamic divide done
      .CLKFBSTOPPED(CLKFBSTOPPED), // 1-bit output: Feedback clock stopped
      .CLKINSTOPPED(CLKINSTOPPED), // 1-bit output: Input clock stopped
      .LOCKED(LOCKED),             // 1-bit output: LOCK
      .CDDCREQ(CDDCREQ),           // 1-bit input: Request to dynamic divide clock
      // Clock Inputs inputs: Clock inputs
      .CLKIN1(CLKIN1),             // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),             // 1-bit input: Secondary clock
      // Control Ports inputs: MMCM control ports
      .CLKINSEL(CLKINSEL),         // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),             // 1-bit input: Power-down
      .RST(RST),                   // 1-bit input: Reset
      // DRP Ports inputs: Dynamic reconfiguration ports
      .DADDR(DADDR),               // 7-bit input: DRP address
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable
      .DI(DI),                     // 16-bit input: DRP data
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // Dynamic Phase Shift Ports inputs: Ports used for dynamic phase shifting of the outputs
      .PSCLK(PSCLK),               // 1-bit input: Phase shift clock
      .PSEN(PSEN),                 // 1-bit input: Phase shift enable
      .PSINCDEC(PSINCDEC),         // 1-bit input: Phase shift increment/decrement
      // Feedback inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)            // 1-bit input: Feedback clock
   );

   // End of MMCME3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME4_ADV)" treetype="template">
// MMCME4_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME4_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME4_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   //             Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MMCME4_ADV #(
      .BANDWIDTH("OPTIMIZED"),        // Jitter programming
      .CLKFBOUT_MULT_F(5.0),          // Multiply value for all CLKOUT
      .CLKFBOUT_PHASE(0.0),           // Phase offset in degrees of CLKFB
      .CLKFBOUT_USE_FINE_PS("FALSE"), // Fine phase shift enable (TRUE/FALSE)
      .CLKIN1_PERIOD(0.0),            // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN2_PERIOD(0.0),            // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE_F(1.0),         // Divide amount for CLKOUT0
      .CLKOUT0_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT0
      .CLKOUT0_PHASE(0.0),            // Phase offset for CLKOUT0
      .CLKOUT0_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT1_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT1_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT1_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT2_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT2_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT2_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT2_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT3_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT3_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT3_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT3_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT4_CASCADE("FALSE"),      // Divide amount for CLKOUT (1-128)
      .CLKOUT4_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT4_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT4_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT4_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT5_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT5_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT5_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT5_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT6_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT6_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT6_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT6_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .COMPENSATION("AUTO"),          // Clock input compensation
      .DIVCLK_DIVIDE(1),              // Master division value
      .IS_CLKFBIN_INVERTED(1'b0),     // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),      // Optional inversion for CLKIN1
      .IS_CLKIN2_INVERTED(1'b0),      // Optional inversion for CLKIN2
      .IS_CLKINSEL_INVERTED(1'b0),    // Optional inversion for CLKINSEL
      .IS_PSEN_INVERTED(1'b0),        // Optional inversion for PSEN
      .IS_PSINCDEC_INVERTED(1'b0),    // Optional inversion for PSINCDEC
      .IS_PWRDWN_INVERTED(1'b0),      // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      .REF_JITTER1(0.0),              // Reference input jitter in UI (0.000-0.999).
      .REF_JITTER2(0.0),              // Reference input jitter in UI (0.000-0.999).
      .SS_EN("FALSE"),                // Enables spread spectrum
      .SS_MODE("CENTER_HIGH"),        // Spread spectrum frequency deviation and the spread type
      .SS_MOD_PERIOD(10000),          // Spread spectrum modulation period (ns)
      .STARTUP_WAIT("FALSE")          // Delays DONE until MMCM is locked
   )
   MMCME4_ADV_inst (
      .CDDCDONE(CDDCDONE),         // 1-bit output: Clock dynamic divide done
      .CLKFBOUT(CLKFBOUT),         // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB),       // 1-bit output: Inverted CLKFBOUT
      .CLKFBSTOPPED(CLKFBSTOPPED), // 1-bit output: Feedback clock stopped
      .CLKINSTOPPED(CLKINSTOPPED), // 1-bit output: Input clock stopped
      .CLKOUT0(CLKOUT0),           // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),         // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),           // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),         // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),           // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),         // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),           // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),         // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),           // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),           // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),           // 1-bit output: CLKOUT6
      .DO(DO),                     // 16-bit output: DRP data output
      .DRDY(DRDY),                 // 1-bit output: DRP ready
      .LOCKED(LOCKED),             // 1-bit output: LOCK
      .PSDONE(PSDONE),             // 1-bit output: Phase shift done
      .CDDCREQ(CDDCREQ),           // 1-bit input: Request to dynamic divide clock
      .CLKFBIN(CLKFBIN),           // 1-bit input: Feedback clock
      .CLKIN1(CLKIN1),             // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),             // 1-bit input: Secondary clock
      .CLKINSEL(CLKINSEL),         // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .DADDR(DADDR),               // 7-bit input: DRP address
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable
      .DI(DI),                     // 16-bit input: DRP data input
      .DWE(DWE),                   // 1-bit input: DRP write enable
      .PSCLK(PSCLK),               // 1-bit input: Phase shift clock
      .PSEN(PSEN),                 // 1-bit input: Phase shift enable
      .PSINCDEC(PSINCDEC),         // 1-bit input: Phase shift increment/decrement
      .PWRDWN(PWRDWN),             // 1-bit input: Power-down
      .RST(RST)                    // 1-bit input: Reset
   );

   // End of MMCME4_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE3_ADV)" treetype="template">
//  PLLE3_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE3_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE3_ADV: Advanced Phase-Locked Loop (PLL)
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PLLE3_ADV #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT, (1-19)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB, (-360.000-360.000)
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0 (1-128)
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0 (0.001-0.999)
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0 (-360.000-360.000)
      // CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1 (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1 (0.001-0.999)
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1 (-360.000-360.000)
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      .COMPENSATION("AUTO"),      // AUTO, BUF_IN, INTERNAL
      .DIVCLK_DIVIDE(1),          // Master division value, (1-15)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked (FALSE, TRUE)
   )
   PLLE3_ADV_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      // DRP Ports outputs: Dynamic reconfiguration ports
      .DO(DO),                   // 16-bit output: DRP data
      .DRDY(DRDY),               // 1-bit output: DRP ready
      // Feedback Clocks outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      // Control Ports inputs: PLL control ports
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST),                 // 1-bit input: Reset
      // DRP Ports inputs: Dynamic reconfiguration ports
      .DADDR(DADDR),             // 7-bit input: DRP address
      .DCLK(DCLK),               // 1-bit input: DRP clock
      .DEN(DEN),                 // 1-bit input: DRP enable
      .DI(DI),                   // 16-bit input: DRP data
      .DWE(DWE),                 // 1-bit input: DRP write enable
      // Feedback Clocks inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)          // 1-bit input: Feedback clock
   );

   // End of PLLE3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE4_ADV)" treetype="template">
//  PLLE4_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE4_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE4_ADV: Advanced Phase-Locked Loop (PLL)
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PLLE4_ADV #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY
      .COMPENSATION("AUTO"),      // Clock input compensation
      .DIVCLK_DIVIDE(1),          // Master division value
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked
   )
   PLLE4_ADV_inst (
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      .DO(DO),                   // 16-bit output: DRP data output
      .DRDY(DRDY),               // 1-bit output: DRP ready
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKFBIN(CLKFBIN),         // 1-bit input: Feedback clock
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .DADDR(DADDR),             // 7-bit input: DRP address
      .DCLK(DCLK),               // 1-bit input: DRP clock
      .DEN(DEN),                 // 1-bit input: DRP enable
      .DI(DI),                   // 16-bit input: DRP data input
      .DWE(DWE),                 // 1-bit input: DRP write enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST)                  // 1-bit input: Reset
   );

   // End of PLLE4_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE4_BASE)" treetype="template">
// PLLE4_BASE  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE4_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE4_BASE: Advanced Phase-Locked Loop (PLL)
   //             Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PLLE4_BASE #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY
      .DIVCLK_DIVIDE(1),          // Master division value
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked
   )
   PLLE4_BASE_inst (
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKFBIN(CLKFBIN),         // 1-bit input: Feedback clock
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST)                  // 1-bit input: Reset
   );

   // End of PLLE4_BASE_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME3_BASE)" treetype="template">
// MMCME3_BASE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME3_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME3_BASE: Base Mixed Mode Clock Manager (MMCM)
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MMCME3_BASE #(
      .BANDWIDTH("OPTIMIZED"),    // Jitter programming (HIGH, LOW, OPTIMIZED)
      .CLKFBOUT_MULT_F(5.0),      // Multiply value for all CLKOUT (2.000-64.000)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB (-360.000-360.000)
      .CLKIN1_PERIOD(0.0),        // Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE_F(1.0),     // Divide amount for CLKOUT0 (1.000-128.000)
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      // CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT4_CASCADE("FALSE"),  // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .DIVCLK_DIVIDE(1),          // Master division value (1-106)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),  // Optional inversion for CLKIN1
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER1(0.0),          // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   MMCME3_BASE_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),     // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),     // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6
      // Feedback outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),   // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT
      // Status Ports outputs: MMCM status ports
      .LOCKED(LOCKED),       // 1-bit output: LOCK
      // Clock Inputs inputs: Clock input
      .CLKIN1(CLKIN1),       // 1-bit input: Clock
      // Control Ports inputs: MMCM control ports
      .PWRDWN(PWRDWN),       // 1-bit input: Power-down
      .RST(RST),             // 1-bit input: Reset
      // Feedback inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)      // 1-bit input: Feedback clock
   );

   // End of MMCME3_BASE_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME4_BASE)" treetype="template">
// MMCME4_BASE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME4_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME4_BASE: Base Mixed Mode Clock Manager (MMCM)
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MMCME4_BASE #(
      .BANDWIDTH("OPTIMIZED"),    // Jitter programming
      .CLKFBOUT_MULT_F(5.0),      // Multiply value for all CLKOUT
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB
      .CLKIN1_PERIOD(0.0),        // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE_F(1.0),     // Divide amount for CLKOUT0
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT2_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT2_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT2_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT3_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT3_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT3_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT4_CASCADE("FALSE"),  // Divide amount for CLKOUT (1-128)
      .CLKOUT4_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT4_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT4_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT5_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT5_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT5_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT6_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT6_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT6_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .DIVCLK_DIVIDE(1),          // Master division value
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),  // Optional inversion for CLKIN1
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER1(0.0),          // Reference input jitter in UI (0.000-0.999).
      .STARTUP_WAIT("FALSE")      // Delays DONE until MMCM is locked
   )
   MMCME4_BASE_inst (
      .CLKFBOUT(CLKFBOUT),   // 1-bit output: Feedback clock pin to the MMCM
      .CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT
      .CLKOUT0(CLKOUT0),     // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),     // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6
      .LOCKED(LOCKED),       // 1-bit output: LOCK
      .CLKFBIN(CLKFBIN),     // 1-bit input: Feedback clock pin to the MMCM
      .CLKIN1(CLKIN1),       // 1-bit input: Primary clock
      .PWRDWN(PWRDWN),       // 1-bit input: Power-down
      .RST(RST)              // 1-bit input: Reset
   );

   // End of MMCME4_BASE_inst instantiation
					</Template>
					<Template label="Base Phase-Locked Loop (PLL) (PLLE3_BASE)" treetype="template">
// PLLE3_BASE  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE3_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE3_BASE: Base Phase-Locked Loop (PLL)
   //             Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PLLE3_BASE #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT, (1-19)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB, (-360.000-360.000)
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0 (1-128)
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0 (0.001-0.999)
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0 (-360.000-360.000)
      // CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1 (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1 (0.001-0.999)
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1 (-360.000-360.000)
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      .DIVCLK_DIVIDE(1),          // Master division value, (1-15)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked (FALSE, TRUE)
   )
   PLLE3_BASE_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      // Feedback Clocks outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      // Control Ports inputs: PLL control ports
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST),                 // 1-bit input: Reset
      // Feedback Clocks inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)          // 1-bit input: Feedback clock
   );

   // End of PLLE3_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CONFIGURATION" treetype="folder">
				<SubFolder label="BSCAN" treetype="folder">
					<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
//   BSCANE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BSCANE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BSCANE2: Boundary-Scan User Instruction
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BSCANE2 #(
      .JTAG_CHAIN(1)  // Value for USER command
   )
   BSCANE2_inst (
      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.
      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                         // SHIFT are asserted.

      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.
      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      .SEL(SEL),         // 1-bit output: USER instruction active output.
      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.
      .TCK(TCK),         // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.
      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.
      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller
      .TDO(TDO)          // 1-bit input: Test Data Output (TDO) input for USER function.
   );

   // End of BSCANE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DNA" treetype="folder">
					<Template label="Device DNA Access Port (DNA_PORTE2)" treetype="template">
// DNA_PORTE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DNA_PORTE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DNA_PORTE2: Device DNA Access Port
   //             Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   DNA_PORTE2 #(
      .SIM_DNA_VALUE(96'h000000000000000000000000)  // Specifies a sample 96-bit DNA value for simulation
   )
   DNA_PORTE2_inst (
      .DOUT(DOUT),   // 1-bit output: DNA output data
      .CLK(CLK),     // 1-bit input: Clock input
      .DIN(DIN),     // 1-bit input: User data input pin
      .READ(READ),   // 1-bit input: Active-High load DNA, active-Low read input
      .SHIFT(SHIFT)  // 1-bit input: Active-High shift enable input
   );

   // End of DNA_PORTE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="EFUSE" treetype="folder">
					<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
//  EFUSE_USR  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (EFUSE_USR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EFUSE_USR: 32-bit non-volatile design ID
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   EFUSE_USR #(
      .SIM_EFUSE_VALUE(32'h00000000)  // Value of the 32-bit non-volatile value used in simulation
   )
   EFUSE_USR_inst (
      .EFUSEUSR(EFUSEUSR)  // 32-bit output: User eFUSE register value output
   );

   // End of EFUSE_USR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="ICAP" treetype="folder">
					<Template label="Internal Configuration Access Port (ICAPE3)" treetype="template">
//   ICAPE3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ICAPE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ICAPE3: Internal Configuration Access Port
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   ICAPE3 #(
      .DEVICE_ID(32'h03628093),     // Specifies the pre-programmed Device ID value to be used for simulation
                                    // purposes.
      .ICAP_AUTO_SWITCH("DISABLE"), // Enable switch ICAP using sync word
      .SIM_CFG_FILE_NAME("NONE")    // Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                    // model
   )
   ICAPE3_inst (
      .AVAIL(AVAIL),     // 1-bit output: Availability status of ICAP
      .O(O),             // 32-bit output: Configuration data output bus
      .PRDONE(PRDONE),   // 1-bit output: Indicates completion of Partial Reconfiguration
      .PRERROR(PRERROR), // 1-bit output: Indicates Error during Partial Reconfiguration
      .CLK(CLK),         // 1-bit input: Clock input
      .CSIB(CSIB),       // 1-bit input: Active-Low ICAP enable
      .I(I),             // 32-bit input: Configuration data input bus
      .RDWRB(RDWRB)      // 1-bit input: Read/Write Select input
   );

   // End of ICAPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MASTER_JTAG" treetype="folder">
					<Template label="JTAG Port Access (MASTER_JTAG)" treetype="template">
// MASTER_JTAG : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MASTER_JTAG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MASTER_JTAG: JTAG Port Access
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MASTER_JTAG MASTER_JTAG_inst (
      .TDO(TDO), // 1-bit output: JTAG TDO output pin
      .TCK(TCK), // 1-bit input: JTAG TCK input pin
      .TDI(TDI), // 1-bit input: JTAG TDI input pin
      .TMS(TMS)  // 1-bit input: JTAG TMS input pin
   );

   // End of MASTER_JTAG_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="STARTUP" treetype="folder">
					<Template label="STARTUP Block (STARTUPE3)" treetype="template">
//  STARTUPE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (STARTUPE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // STARTUPE3: STARTUP Block
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   STARTUPE3 #(
      .PROG_USR("FALSE"),  // Activate program event security feature. Requires encrypted bitstreams.
      .SIM_CCLK_FREQ(0.0)  // Set the Configuration Clock Frequency (ns) for simulation
   )
   STARTUPE3_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration main clock output
      .CFGMCLK(CFGMCLK),     // 1-bit output: Configuration internal oscillator clock output
      .DI(DI),               // 4-bit output: Allow receiving on the D input pin
      .EOS(EOS),             // 1-bit output: Active-High output signal indicating the End Of Startup
      .PREQ(PREQ),           // 1-bit output: PROGRAM request to fabric output
      .DO(DO),               // 4-bit input: Allows control of the D pin output
      .DTS(DTS),             // 4-bit input: Allows tristate of the D pin
      .FCSBO(FCSBO),         // 1-bit input: Controls the FCS_B pin for flash access
      .FCSBTS(FCSBTS),       // 1-bit input: Tristate the FCS_B pin
      .GSR(GSR),             // 1-bit input: Global Set/Reset input (GSR cannot be used for the port)
      .GTS(GTS),             // 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      .KEYCLEARB(KEYCLEARB), // 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      .PACK(PACK),           // 1-bit input: PROGRAM acknowledge input
      .USRCCLKO(USRCCLKO),   // 1-bit input: User CCLK input
      .USRCCLKTS(USRCCLKTS), // 1-bit input: User CCLK 3-state enable input
      .USRDONEO(USRDONEO),   // 1-bit input: User DONE pin output control
      .USRDONETS(USRDONETS)  // 1-bit input: User DONE 3-state enable output
   );

   // End of STARTUPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="USR_ACCESS" treetype="folder">
					<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
// USR_ACCESSE2 : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (USR_ACCESSE2_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // USR_ACCESSE2: Configuration Data Access
   //               Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2 USR_ACCESSE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration Clock
      .DATA(DATA),           // 32-bit output: Configuration Data reflecting the contents of the AXSS register
      .DATAVALID(DATAVALID)  // 1-bit output: Active High Data Valid
   );

   // End of USR_ACCESSE2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="BIDIR_BUFFER" treetype="folder">
					<Template label="Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable (IOBUF_INTERMDISABLE)" treetype="template">
// IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog       : the following instance declaration needs to be placed
//      instance       : in the body of the design code.  The instance name
//     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code         : parenthesis may be changed to properly reference and
//                     : connect this function to the design.  All inputs
//                     : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_INTERMDISABLE: Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable
   //                      Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUF_INTERMDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUF_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)                          // 1-bit input: 3-state enable input
   );

   // End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Bidirectional I/O Buffer with Offset Calibration and VREF Tuning (IOBUFE3)" treetype="template">
//   IOBUFE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFE3: Bidirectional I/O Buffer with Offset Calibration and VREF Tuning
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFE3 #(
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IOBUFE3_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Buffer inout (connect directly to top-level port)
      .OSC(OSC),                       // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),                 // 1-bit input: Offset cancellation enable
      .T(T),                           // 1-bit input: 3-state enable input
      .VREF(VREF)                      // 1-bit input: Vref input from HPIO_VREF
   );

   // End of IOBUFE3_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog             : the following instance declaration needs to be placed
//            instance            : in the body of the design code.  The instance name
//          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//              code              : parenthesis may be changed to properly reference and
//                                : connect this function to the design.  All inputs
//                                : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable
   //                                 Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer diff_p output
      .OB(OB),                       // 1-bit output: Buffer diff_n output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Must be tied to a logic '0'
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                     // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),                       // 1-bit input: 3-state master enable input
      .TS(TS)                        // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
// IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
//        Verilog         : the following instance declaration needs to be placed
//        instance        : in the body of the design code.  The instance name
//      declaration       : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations within the
//          code          : parenthesis may be changed to properly reference and
//                        : connect this function to the design.  All inputs
//                        : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_DCIEN: Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable
   //                         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_DCIEN #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DIFF_OUT_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer diff_p output
      .OB(OB),                         // 1-bit output: Buffer diff_n output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Must be tied to a logic '0'
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),                         // 1-bit input: 3-state master enable input
      .TS(TS)                          // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input (IOBUFDS_INTERMDISABLE)" treetype="template">
// IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//        Verilog        : the following instance declaration needs to be placed
//       instance        : in the body of the design code.  The instance name
//      declaration      : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//         code          : parenthesis may be changed to properly reference and
//                       : connect this function to the design.  All inputs
//                       : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_INTERMDISABLE: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input
   //                        Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                     // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)                          // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DCIEN)" treetype="template">
// IOBUFDS_DCIEN : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  All inputs
//               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DCIEN: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DCIEN #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional I/O Buffer with Offset Calibration (IOBUFDSE3)" treetype="template">
//  IOBUFDSE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFDSE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDSE3: Differential Bidirectional I/O Buffer with Offset Calibration
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDSE3 #(
      .DQS_BIAS("FALSE"),          // (FALSE, TRUE)
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IOBUFDSE3_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .OSC(OSC),                       // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),                 // 2-bit input: Offset cancellation enable
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUFDSE3_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer (IOBUFDS)" treetype="template">
//   IOBUFDS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS: Differential Input/Output Buffer
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IOBUFDS_inst (
      .O(O),     // 1-bit output: Buffer output
      .I(I),     // 1-bit input: Buffer input
      .IO(IO),   // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)      // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer (IOBUFDS_DIFF_OUT)" treetype="template">
// IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT: Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer
   //                   Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IOBUFDS_DIFF_OUT_inst (
      .O(O),     // 1-bit output: Buffer diff_p output
      .OB(OB),   // 1-bit output: Buffer diff_n output
      .I(I),     // 1-bit input: Buffer input
      .IO(IO),   // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),   // 1-bit input: 3-state master enable input
      .TS(TS)    // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Input/Output Buffer DCI Enable (IOBUF_DCIEN)" treetype="template">
// IOBUF_DCIEN : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUF_DCIEN_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_DCIEN: Input/Output Buffer DCI Enable
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUF_DCIEN #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUF_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Input/Output Buffer (IOBUF)" treetype="template">
//    IOBUF    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF: Input/Output Buffer
   //        Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUF IOBUF_inst (
      .O(O),   // 1-bit output: Buffer output
      .I(I),   // 1-bit input: Buffer input
      .IO(IO), // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)    // 1-bit input: 3-state enable input
   );

   // End of IOBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="BITSLICE" treetype="folder">
					<Template label="BITSLICE_CONTROL (BITSLICE_CONTROL)" treetype="template">
// BITSLICE_CONTROL : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (BITSLICE_CONTROL_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BITSLICE_CONTROL: BITSLICE_CONTROL for control using Native Mode
   //                   Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BITSLICE_CONTROL #(
      .DIV_MODE("DIV2"),               // Controller DIV2/DIV4 mode (DIV2, DIV4)
      .EN_CLK_TO_EXT_NORTH("DISABLE"), // Enable clock forwarding to north
      .EN_CLK_TO_EXT_SOUTH("DISABLE"), // Enable clock forwarding to south
      .EN_DYN_ODLY_MODE("FALSE"),      // Enable dynamic output delay mode
      .EN_OTHER_NCLK("FALSE"),         // Select the NCLK from the other BITSLICE_CONTROL in the nibble (FALSE,
                                       // TRUE)
      .EN_OTHER_PCLK("FALSE"),         // Select the PCLK from the other BITSLICE_CONTROL in the nibble (FALSE,
                                       // TRUE)
      .IDLY_VT_TRACK("TRUE"),          // Enable VT tracking for input delays
      .INV_RXCLK("FALSE"),             // Invert clock path from IOB to upper RX bitslice
      .ODLY_VT_TRACK("TRUE"),          // Enable VT tracking for output delays
      .QDLY_VT_TRACK("TRUE"),          // Enable VT tracking for clock delays
      .READ_IDLE_COUNT(6'h00),         // Gap count between read bursts for ODT control counter (0-3f)
      .REFCLK_SRC("PLLCLK"),           // Select the input clock for the delay control (PLLCLK, REFCLK)
      .ROUNDING_FACTOR(16),            // Rounding factor in BISC spec (128-8)
      .RXGATE_EXTEND("FALSE"),         // Reserved for use by MIG Memory Controller. Do Not Change.
      .RX_CLK_PHASE_N("SHIFT_0"),      // Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                       // SHIFT_90)
      .RX_CLK_PHASE_P("SHIFT_0"),      // Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                       // SHIFT_90)
      .RX_GATING("DISABLE"),           // ENABLE/DISABLE read DQS gating
      .SELF_CALIBRATE("ENABLE"),       // Enable BISC of nibble controlled by BITSLICE_CONTROL
      .SERIAL_MODE("FALSE"),           // Put BITSLICE read paths into serial mode (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE"),       // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                       // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TX_GATING("DISABLE")            // ENABLE/DISABLE clock gating in WClkgen
   )
   BITSLICE_CONTROL_inst (
      .CLK_TO_EXT_NORTH(CLK_TO_EXT_NORTH),       // 1-bit output: Inter-byte clock going to north
                                                 // BITSLICE_CONTROL

      .CLK_TO_EXT_SOUTH(CLK_TO_EXT_SOUTH),       // 1-bit output: Inter-byte clock going to south
                                                 // BITSLICE_CONTROL

      .DLY_RDY(DLY_RDY),                         // 1-bit output: Fixed delay calibration complete
      .DYN_DCI(DYN_DCI),                         // 7-bit output: Direct control of IOB DCI when using a memory
                                                 // interface

      .NCLK_NIBBLE_OUT(NCLK_NIBBLE_OUT),         // 1-bit output: Intra-byte DQS strobes/clock to other control
                                                 // block

      .PCLK_NIBBLE_OUT(PCLK_NIBBLE_OUT),         // 1-bit output: Intra-byte DQS strobes/clock to other control
                                                 // block

      .RIU_RD_DATA(RIU_RD_DATA),                 // 16-bit output: RIU Output Read data to the controller
      .RIU_VALID(RIU_VALID),                     // 1-bit output: Last data written has been accepted when High
      .RX_BIT_CTRL_OUT0(RX_BIT_CTRL_OUT0),       // 40-bit output: Output bus to Bitslice 0
      .RX_BIT_CTRL_OUT1(RX_BIT_CTRL_OUT1),       // 40-bit output: Output bus to Bitslice 1
      .RX_BIT_CTRL_OUT2(RX_BIT_CTRL_OUT2),       // 40-bit output: Output bus to Bitslice 2
      .RX_BIT_CTRL_OUT3(RX_BIT_CTRL_OUT3),       // 40-bit output: Output bus to Bitslice 3
      .RX_BIT_CTRL_OUT4(RX_BIT_CTRL_OUT4),       // 40-bit output: Output bus to Bitslice 4
      .RX_BIT_CTRL_OUT5(RX_BIT_CTRL_OUT5),       // 40-bit output: Output bus to Bitslice 5
      .RX_BIT_CTRL_OUT6(RX_BIT_CTRL_OUT6),       // 40-bit output: Output bus to Bitslice 6
      .TX_BIT_CTRL_OUT0(TX_BIT_CTRL_OUT0),       // 40-bit output: Output bus to Bitslice 0
      .TX_BIT_CTRL_OUT1(TX_BIT_CTRL_OUT1),       // 40-bit output: Output bus to Bitslice 1
      .TX_BIT_CTRL_OUT2(TX_BIT_CTRL_OUT2),       // 40-bit output: Output bus to Bitslice 2
      .TX_BIT_CTRL_OUT3(TX_BIT_CTRL_OUT3),       // 40-bit output: Output bus to Bitslice 3
      .TX_BIT_CTRL_OUT4(TX_BIT_CTRL_OUT4),       // 40-bit output: Output bus to Bitslice 4
      .TX_BIT_CTRL_OUT5(TX_BIT_CTRL_OUT5),       // 40-bit output: Output bus to Bitslice 5
      .TX_BIT_CTRL_OUT6(TX_BIT_CTRL_OUT6),       // 40-bit output: Output bus to Bitslice 6
      .TX_BIT_CTRL_OUT_TRI(TX_BIT_CTRL_OUT_TRI), // 40-bit output: Output bus to 3-state TX_BITSLICE_TRI
      .VTC_RDY(VTC_RDY),                         // 1-bit output: PHY calibration is complete
      .CLK_FROM_EXT(CLK_FROM_EXT),               // 1-bit input: Inter-byte clock coming from north or south
                                                 // BITSLICE_CONTROL

      .EN_VTC(EN_VTC),                           // 1-bit input: Enables voltage and temperature compensation
                                                 // when High

      .NCLK_NIBBLE_IN(NCLK_NIBBLE_IN),           // 1-bit input: Intra-byte DQS strobes from other/clock
                                                 // control block

      .PCLK_NIBBLE_IN(PCLK_NIBBLE_IN),           // 1-bit input: Intra-byte DQS strobes/clock from other
                                                 // control block

      .PHY_RDCS0(PHY_RDCS0),                     // 4-bit input: Rank select
      .PHY_RDCS1(PHY_RDCS1),                     // 4-bit input: Rank select
      .PHY_RDEN(PHY_RDEN),                       // 4-bit input: Read burst enable when using a memory interface
      .PHY_WRCS0(PHY_WRCS0),                     // 4-bit input: Rank select
      .PHY_WRCS1(PHY_WRCS1),                     // 4-bit input: Rank select
      .PLL_CLK(PLL_CLK),                         // 1-bit input: PLL clock input
      .REFCLK(REFCLK),                           // 1-bit input: Frequency reference clock for delay control
      .RIU_ADDR(RIU_ADDR),                       // 6-bit input: Address input for RIU
      .RIU_CLK(RIU_CLK),                         // 1-bit input: System clock from fabric for RIU access
      .RIU_NIBBLE_SEL(RIU_NIBBLE_SEL),           // 1-bit input: Nibble select to enable RIU read/write
      .RIU_WR_DATA(RIU_WR_DATA),                 // 16-bit input: RIU Input Write data from the controller
      .RIU_WR_EN(RIU_WR_EN),                     // 1-bit input: Enables write to RIU when High
      .RST(RST),                                 // 1-bit input: Asynchronous global reset
      .RX_BIT_CTRL_IN0(RX_BIT_CTRL_IN0),         // 40-bit input: Input bus from Bitslice 0
      .RX_BIT_CTRL_IN1(RX_BIT_CTRL_IN1),         // 40-bit input: Input bus from Bitslice 1
      .RX_BIT_CTRL_IN2(RX_BIT_CTRL_IN2),         // 40-bit input: Input bus from Bitslice 2
      .RX_BIT_CTRL_IN3(RX_BIT_CTRL_IN3),         // 40-bit input: Input bus from Bitslice 3
      .RX_BIT_CTRL_IN4(RX_BIT_CTRL_IN4),         // 40-bit input: Input bus from Bitslice 4
      .RX_BIT_CTRL_IN5(RX_BIT_CTRL_IN5),         // 40-bit input: Input bus from Bitslice 5
      .RX_BIT_CTRL_IN6(RX_BIT_CTRL_IN6),         // 40-bit input: Input bus from Bitslice 6
      .TBYTE_IN(TBYTE_IN),                       // 4-bit input: Output enable for 3-state control
      .TX_BIT_CTRL_IN0(TX_BIT_CTRL_IN0),         // 40-bit input: Input bus from Bitslice 0
      .TX_BIT_CTRL_IN1(TX_BIT_CTRL_IN1),         // 40-bit input: Input bus from Bitslice 1
      .TX_BIT_CTRL_IN2(TX_BIT_CTRL_IN2),         // 40-bit input: Input bus from Bitslice 2
      .TX_BIT_CTRL_IN3(TX_BIT_CTRL_IN3),         // 40-bit input: Input bus from Bitslice 3
      .TX_BIT_CTRL_IN4(TX_BIT_CTRL_IN4),         // 40-bit input: Input bus from Bitslice 4
      .TX_BIT_CTRL_IN5(TX_BIT_CTRL_IN5),         // 40-bit input: Input bus from Bitslice 5
      .TX_BIT_CTRL_IN6(TX_BIT_CTRL_IN6),         // 40-bit input: Input bus from Bitslice 6
      .TX_BIT_CTRL_IN_TRI(TX_BIT_CTRL_IN_TRI)    // 40-bit input: Input bus from 3-state TX_BITSLICE_TRI
   );

   // End of BITSLICE_CONTROL_inst instantiation
					</Template>
					<Template label="Register Interface Unit Selection Block (RIU_OR)" treetype="template">
//   RIU_OR    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RIU_OR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RIU_OR: Register Interface Unit Selection Block
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RIU_OR #(
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   RIU_OR_inst (
      .RIU_RD_DATA(RIU_RD_DATA),           // 16-bit output: RIU data bus to the controller
      .RIU_RD_VALID(RIU_RD_VALID),         // 1-bit output: Combined RIU read valid signal to the controller
      .RIU_RD_DATA_LOW(RIU_RD_DATA_LOW),   // 16-bit input: RIU data bus from the controller to the lower
                                           // nibble BITSLICE_CONTROL

      .RIU_RD_DATA_UPP(RIU_RD_DATA_UPP),   // 16-bit input: RIU data bus from the controller to the upper
                                           // nibble BITSLICE_CONTROL

      .RIU_RD_VALID_LOW(RIU_RD_VALID_LOW), // 1-bit input: RIU_VALID of the lower nibble BITSLICE_CONTROL
      .RIU_RD_VALID_UPP(RIU_RD_VALID_UPP)  // 1-bit input: RIU_VALID of the upper nibble BITSLICE_CONTROL
   );

   // End of RIU_OR_inst instantiation
					</Template>
					<Template label="RX_BITSLICE (RX_BITSLICE)" treetype="template">
// RX_BITSLICE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RX_BITSLICE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RX_BITSLICE: RX_BITSLICE for input using Native Mode
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RX_BITSLICE #(
      .CASCADE("FALSE"),              // Enables cascading of IDELAY and ODELAY lines
      .DATA_TYPE("DATA"),             // Defines what the input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                      // SERIAL)
      .DATA_WIDTH(8),                 // Defines the width of the serial-to-parallel converter (4-8)
      .DELAY_FORMAT("TIME"),          // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),           // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),                // Input delay value setting in ps
      .DELAY_VALUE_EXT(0),            // Value of the extended input delay value in ps
      .FIFO_SYNC_MODE("FALSE"),       // Internal write clock and FIFO_RD_CLK are coming from a common source
      .IS_CLK_EXT_INVERTED(1'b0),     // Optional inversion for CLK_EXT
      .IS_CLK_INVERTED(1'b0),         // Optional inversion for CLK
      .IS_RST_DLY_EXT_INVERTED(1'b0), // Optional inversion for RST_DLY_EXT
      .IS_RST_DLY_INVERTED(1'b0),     // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),       // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),      // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC"),          // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      // SYNC)
      .UPDATE_MODE_EXT("ASYNC")       // Determines when updates to the extended input delay will take effect
                                      // (ASYNC, MANUAL, SYNC)
   )
   RX_BITSLICE_inst (
      .CNTVALUEOUT(CNTVALUEOUT),         // 9-bit output: Counter value to device logic
      .CNTVALUEOUT_EXT(CNTVALUEOUT_EXT), // 9-bit output: Optional extended (cascaded delay) counter value
                                         // going to the device logic

      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .FIFO_WRCLK_OUT(FIFO_WRCLK_OUT),   // 1-bit output: FIFO source synchronous write clock out to the device
                                         // logic (currently unsupported, do not connect)

      .Q(Q),                             // 8-bit output: Registered output data from FIFO
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .CE(CE),                           // 1-bit input: Clock enable for IDELAY
      .CE_EXT(CE_EXT),                   // 1-bit input: Optional extended (cascaded delay) clock enable
      .CLK(CLK),                         // 1-bit input: Clock used to sample LOAD, CE, INC
      .CLK_EXT(CLK_EXT),                 // 1-bit input: Optional extended (cascaded delay) clock
      .CNTVALUEIN(CNTVALUEIN),           // 9-bit input: Counter value from device logic
      .CNTVALUEIN_EXT(CNTVALUEIN_EXT),   // 9-bit input: Optional extended (cascaded delay) counter value from
                                         // device logic

      .DATAIN(DATAIN),                   // 1-bit input: Input signal from IBUF
      .EN_VTC(EN_VTC),                   // 1-bit input: Enable IDELAYCTRL to keep stable delay over VT
      .EN_VTC_EXT(EN_VTC_EXT),           // 1-bit input: Optional extended (cascaded delay) to keep stable
                                         // delay over VT

      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: FIFO read enable
      .INC(INC),                         // 1-bit input: Increment the current delay tap setting
      .INC_EXT(INC_EXT),                 // 1-bit input: Optional extended (cascaded delay) increments the
                                         // current delay tap setting

      .LOAD(LOAD),                       // 1-bit input: Load the CNTVALUEIN tap setting
      .LOAD_EXT(LOAD_EXT),               // 1-bit input: Optional extended (cascaded delay) load the
                                         // CNTVALUEIN_EXT tap setting

      .RST(RST),                         // 1-bit input: Asynchronous assert, synchronous deassert for
                                         // RX_BITSLICE ISERDES

      .RST_DLY(RST_DLY),                 // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      .RST_DLY_EXT(RST_DLY_EXT),         // 1-bit input: Optional extended (cascaded delay) reset delay to
                                         // DELAY_VALUE_EXT

      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN)    // 40-bit input: Input bus from BITSLICE_CONTROL
   );

   // End of RX_BITSLICE_inst instantiation
					</Template>
					<Template label="RXTX_BITSLICE (RXTX_BITSLICE)" treetype="template">
// RXTX_BITSLICE : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (RXTX_BITSLICE_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  All inputs
//               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RXTX_BITSLICE: RXTX_BITSLICE for bidirectional I/O using Native Mode
   //                Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RXTX_BITSLICE #(
      .ENABLE_PRE_EMPHASIS("FALSE"), // Enable the pre-emphasis
      .FIFO_SYNC_MODE("FALSE"),      // Internal write clock and FIFO_RD_CLK are coming from a common source
      .INIT(1'b1),                   // Defines initial O value
      .IS_RX_CLK_INVERTED(1'b0),     // Optional inversion for RX_CLK
      .IS_RX_RST_DLY_INVERTED(1'b0), // Optional inversion for RX_RST_DLY
      .IS_RX_RST_INVERTED(1'b0),     // Optional inversion for RX_RST
      .IS_TX_CLK_INVERTED(1'b0),     // Optional inversion for TX_CLK
      .IS_TX_RST_DLY_INVERTED(1'b0), // Optional inversion for TX_RST_DLY
      .IS_TX_RST_INVERTED(1'b0),     // Optional inversion for TX_RST
      .RX_DATA_TYPE("DATA"),         // Defines what the RX input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                     // SERIAL)
      .RX_DATA_WIDTH(8),             // Defines the width of the serial-to-parallel converter (4-8)
      .RX_DELAY_FORMAT("TIME"),      // Units of the RX DELAY_VALUE (COUNT, TIME)
      .RX_DELAY_TYPE("FIXED"),       // Set the type of RX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .RX_DELAY_VALUE(0),            // RX Input delay value setting in ps
      .RX_REFCLK_FREQUENCY(300.0),   // Specification of the RX reference clock frequency in MHz (200.0-2667.0)
      .RX_UPDATE_MODE("ASYNC"),      // Determines when updates to the RX delay will take effect (ASYNC,
                                     // MANUAL, SYNC)
      .SIM_DEVICE("ULTRASCALE"),     // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                     // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TBYTE_CTL("TBYTE_IN"),        // Select between T and TBYTE_IN inputs
      .TX_DATA_WIDTH(8),             // Parallel data input width (4-8)
      .TX_DELAY_FORMAT("TIME"),      // Units of the TX DELAY_VALUE (COUNT, TIME)
      .TX_DELAY_TYPE("FIXED"),       // Set the type of TX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .TX_DELAY_VALUE(0),            // TX Input delay value setting in ps
      .TX_OUTPUT_PHASE_90("FALSE"),  // Delays the output phase by 90-degrees
      .TX_REFCLK_FREQUENCY(300.0),   // Specification of the TX reference clock frequency in MHz (200.0-2667.0)
      .TX_UPDATE_MODE("ASYNC")       // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                     // SYNC)
   )
   RXTX_BITSLICE_inst (
      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .FIFO_WRCLK_OUT(FIFO_WRCLK_OUT),   // 1-bit output: FIFO source synchronous write clock out to the device
                                         // logic (currently unsupported, do not connect)

      .O(O),                             // 1-bit output: Serialized output going to output buffer
      .Q(Q),                             // 8-bit output: Registered output data from FIFO
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: RX Output bus to BITSLICE_CONTROL
      .RX_CNTVALUEOUT(RX_CNTVALUEOUT),   // 9-bit output: RX Counter value from device logic
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL for TX
      .TX_CNTVALUEOUT(TX_CNTVALUEOUT),   // 9-bit output: TX Counter value to device logic
      .T_OUT(T_OUT),                     // 1-bit output: Byte group 3-state output
      .D(D),                             // 8-bit input: Data from device logic
      .DATAIN(DATAIN),                   // 1-bit input: Input signal from IOBUF
      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: FIFO read enable
      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: RX Input bus from BITSLICE_CONTROL
      .RX_CE(RX_CE),                     // 1-bit input: Clock enable for IDELAY
      .RX_CLK(RX_CLK),                   // 1-bit input: RX Clock used to sample LOAD, CE, INC
      .RX_CNTVALUEIN(RX_CNTVALUEIN),     // 9-bit input: RX Counter value from device logic
      .RX_EN_VTC(RX_EN_VTC),             // 1-bit input: RX Enable to keep stable delay over VT
      .RX_INC(RX_INC),                   // 1-bit input: RX Increment the current delay tap setting
      .RX_LOAD(RX_LOAD),                 // 1-bit input: RX Load the CNTVALUEIN tap setting
      .RX_RST(RX_RST),                   // 1-bit input: RX Asynchronous assert, synchronous deassert for
                                         // RXTX_BITSLICE ISERDES

      .RX_RST_DLY(RX_RST_DLY),           // 1-bit input: RX Reset the internal DELAY value to DELAY_VALUE
      .T(T),                             // 1-bit input: Legacy T byte input from device logic
      .TBYTE_IN(TBYTE_IN),               // 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN),   // 40-bit input: TX Input bus from BITSLICE_CONTROL
      .TX_CE(TX_CE),                     // 1-bit input: Clock enable for ODELAY
      .TX_CLK(TX_CLK),                   // 1-bit input: TX Clock used to sample LOAD, CE, INC
      .TX_CNTVALUEIN(TX_CNTVALUEIN),     // 9-bit input: TX Counter value from device logic
      .TX_EN_VTC(TX_EN_VTC),             // 1-bit input: TX Enable to keep stable delay over VT
      .TX_INC(TX_INC),                   // 1-bit input: TX Increment the current delay tap setting
      .TX_LOAD(TX_LOAD),                 // 1-bit input: TX Load the CNTVALUEIN tap setting
      .TX_RST(TX_RST),                   // 1-bit input: TX Asynchronous assert, synchronous deassert for
                                         // RXTX_BITSLICE OSERDES

      .TX_RST_DLY(TX_RST_DLY)            // 1-bit input: TX Reset the internal DELAY value to DELAY_VALUE
   );

   // End of RXTX_BITSLICE_inst instantiation
					</Template>
					<Template label="TX_BITSLICE_TRI (TX_BITSLICE_TRI)" treetype="template">
// TX_BITSLICE_TRI : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (TX_BITSLICE_TRI_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // TX_BITSLICE_TRI: TX_BITSLICE_TRI for tristate using Native Mode
   //                  Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_TRI #(
      .DATA_WIDTH(8),             // Parallel data input width (4-8)
      .DELAY_FORMAT("TIME"),      // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),       // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),            // Output delay value setting
      .INIT(1'b1),                // Defines initial O value
      .IS_CLK_INVERTED(1'b0),     // Optional inversion for CLK
      .IS_RST_DLY_INVERTED(1'b0), // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .OUTPUT_PHASE_90("FALSE"),  // Delays the output phase by 90-degrees
      .REFCLK_FREQUENCY(300.0),   // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")       // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  // SYNC)
   )
   TX_BITSLICE_TRI_inst (
      .BIT_CTRL_OUT(BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .CNTVALUEOUT(CNTVALUEOUT),   // 9-bit output: Counter value to device logic
      .TRI_OUT(TRI_OUT),           // 1-bit output: Output to the TBYTE_IN pins of the bitslices
      .BIT_CTRL_IN(BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .CE(CE),                     // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                   // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),     // 9-bit input: Counter value input
      .EN_VTC(EN_VTC),             // 1-bit input: Enable to keep stable delay over VT
      .INC(INC),                   // 1-bit input: Increment the current delay tap setting
      .LOAD(LOAD),                 // 1-bit input: Load the CNTVALUEIN tap setting
      .RST(RST),                   // 1-bit input: Asynchronous assert, synchronous deassert
      .RST_DLY(RST_DLY)            // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
   );

   // End of TX_BITSLICE_TRI_inst instantiation
					</Template>
					<Template label="TX_BITSLICE (TX_BITSLICE)" treetype="template">
// TX_BITSLICE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (TX_BITSLICE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // TX_BITSLICE: TX_BITSLICE for output using Native Mode
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE #(
      .DATA_WIDTH(8),                // Parallel data input width (4-8)
      .DELAY_FORMAT("TIME"),         // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),          // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),               // Output delay value setting
      .ENABLE_PRE_EMPHASIS("FALSE"), // Enable the pre-emphasis
      .INIT(1'b1),                   // Defines initial O value
      .IS_CLK_INVERTED(1'b0),        // Optional inversion for CLK
      .IS_RST_DLY_INVERTED(1'b0),    // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),        // Optional inversion for RST
      .OUTPUT_PHASE_90("FALSE"),     // Delays the output phase by 90-degrees
      .REFCLK_FREQUENCY(300.0),      // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),     // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                     // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TBYTE_CTL("TBYTE_IN"),        // Select between T and TBYTE_IN inputs
      .UPDATE_MODE("ASYNC")          // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                     // SYNC)
   )
   TX_BITSLICE_inst (
      .CNTVALUEOUT(CNTVALUEOUT),         // 9-bit output: Counter value to device logic
      .O(O),                             // 1-bit output: Serialized output going to output buffer
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .T_OUT(T_OUT),                     // 1-bit output: Byte group 3-state output
      .CE(CE),                           // 1-bit input: Clock enable for ODELAY
      .CLK(CLK),                         // 1-bit input: Clock used to sample LOAD, CE, INC
      .CNTVALUEIN(CNTVALUEIN),           // 9-bit input: Counter value from device logic
      .D(D),                             // 8-bit input: Data from device logic
      .EN_VTC(EN_VTC),                   // 1-bit input: Enable to keep stable delay over VT
      .INC(INC),                         // 1-bit input: Increment the current delay tap setting
      .LOAD(LOAD),                       // 1-bit input: Load the CNTVALUEIN tap setting
      .RST(RST),                         // 1-bit input: Asynchronous assert, synchronous deassert for
                                         // TX_BITSLICE OSERDES

      .RST_DLY(RST_DLY),                 // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .T(T),                             // 1-bit input: Legacy T byte input from device logic
      .TBYTE_IN(TBYTE_IN),               // 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN)    // 40-bit input: Input bus from BITSLICE_CONTROL
   );

   // End of TX_BITSLICE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DCI_RESET" treetype="folder">
					<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
//  DCIRESET   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DCIRESET_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DCIRESET: Digitally Controlled Impedance Reset Component
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   DCIRESET DCIRESET_inst (
      .LOCKED(LOCKED), // 1-bit output: LOCK status output
      .RST(RST)        // 1-bit input: Active-High asynchronous reset input
   );

   // End of DCIRESET_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DELAY" treetype="folder">
					<Template label="IDELAYE3/ODELAYE3 Tap Delay Value Control (IDELAYCTRL)" treetype="template">
// IDELAYCTRL  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYCTRL: IDELAYE3/ODELAYE3 Tap Delay Value Control
   //             Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL #(
      .SIM_DEVICE("7SERIES")  // Set the device version (7SERIES, ULTRASCALE)
   )
   IDELAYCTRL_inst (
      .RDY(RDY),       // 1-bit output: Ready output
      .REFCLK(REFCLK), // 1-bit input: Reference clock input
      .RST(RST)        // 1-bit input: Active high reset input. Asynchronous assert, synchronous deassert to
                       // REFCLK.

   );

   // End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE3)" treetype="template">
//  IDELAYE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYE3: Input Fixed or Variable Delay Element
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IDELAYE3 #(
      .CASCADE("NONE"),          // Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      .DELAY_FORMAT("TIME"),     // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_SRC("IDATAIN"),     // Delay input (DATAIN, IDATAIN)
      .DELAY_TYPE("FIXED"),      // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),           // Input delay value setting
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),  // IDELAYCTRL clock input frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"), // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")      // Determines when updates to the delay will take effect (ASYNC, MANUAL, SYNC)
   )
   IDELAYE3_inst (
      .CASC_OUT(CASC_OUT),       // 1-bit output: Cascade delay output to ODELAY input cascade
      .CNTVALUEOUT(CNTVALUEOUT), // 9-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data output
      .CASC_IN(CASC_IN),         // 1-bit input: Cascade delay input from slave ODELAY CASCADE_OUT
      .CASC_RETURN(CASC_RETURN), // 1-bit input: Cascade delay returning from slave ODELAY DATAOUT
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                 // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),   // 9-bit input: Counter value input
      .DATAIN(DATAIN),           // 1-bit input: Data input from the logic
      .EN_VTC(EN_VTC),           // 1-bit input: Keep delay constant over VT
      .IDATAIN(IDATAIN),         // 1-bit input: Data input from the IOBUF
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LOAD(LOAD),               // 1-bit input: Load DELAY_VALUE input
      .RST(RST)                  // 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   // End of IDELAYE3_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE3)" treetype="template">
//  ODELAYE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODELAYE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODELAYE3: Output Fixed or Variable Delay Element
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   ODELAYE3 #(
      .CASCADE("NONE"),          // Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      .DELAY_FORMAT("TIME"),     // (COUNT, TIME)
      .DELAY_TYPE("FIXED"),      // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),           // Output delay tap setting
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),  // IDELAYCTRL clock input frequency in MHz (200.0-2667.0).
      .SIM_DEVICE("ULTRASCALE"), // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")      // Determines when updates to the delay will take effect (ASYNC, MANUAL, SYNC)
   )
   ODELAYE3_inst (
      .CASC_OUT(CASC_OUT),       // 1-bit output: Cascade delay output to IDELAY input cascade
      .CNTVALUEOUT(CNTVALUEOUT), // 9-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data from ODATAIN input port
      .CASC_IN(CASC_IN),         // 1-bit input: Cascade delay input from slave IDELAY CASCADE_OUT
      .CASC_RETURN(CASC_RETURN), // 1-bit input: Cascade delay returning from slave IDELAY DATAOUT
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                 // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),   // 9-bit input: Counter value input
      .EN_VTC(EN_VTC),           // 1-bit input: Keep delay constant over VT
      .INC(INC),                 // 1-bit input: Increment/Decrement tap delay input
      .LOAD(LOAD),               // 1-bit input: Load DELAY_VALUE input
      .ODATAIN(ODATAIN),         // 1-bit input: Data input
      .RST(RST)                  // 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   // End of ODELAYE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="INPUT_BUFFER" treetype="folder">
					<Template label="Analog Auxiliary SYSMON Input Buffer (IBUF_ANALOG)" treetype="template">
// IBUF_ANALOG : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUF_ANALOG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_ANALOG: Analog Auxiliary SYSMON Input Buffer
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUF_ANALOG IBUF_ANALOG_inst (
      .O(O), // 1-bit output: Connect to a VAUXP/VAUXN port of the SYSMONE1
      .I(I)  // 1-bit input: Connect to a top-level design port
   );

   // End of IBUF_ANALOG_inst instantiation
					</Template>
					<Template label="Differential Input Buffer (IBUFDS)" treetype="template">
//   IBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS: Differential Input Buffer
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IBUFDS_inst (
      .O(O),   // 1-bit output: Buffer output
      .I(I),   // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs and Input Buffer Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
//           Verilog           : the following instance declaration needs to be placed
//          instance           : in the body of the design code.  The instance name
//         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations within the
//            code             : parenthesis may be changed to properly reference and
//                             : connect this function to the design.  All inputs
//                             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer With Complementary Outputs and Input Buffer Disable
   //                              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_DIFF_OUT_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer diff_p output
      .OB(OB),                   // 1-bit output: Buffer diff_n output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Must be tied to a logic '0'
   );

   // End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs (IBUFDS_DIFF_OUT)" treetype="template">
// IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT: Differential Input Buffer With Complementary Outputs
   //                  Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IBUFDS_DIFF_OUT_inst (
      .O(O),   // 1-bit output: Buffer diff_p output
      .OB(OB), // 1-bit output: Buffer diff_n output
      .I(I),   // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog            : the following instance declaration needs to be placed
//           instance            : in the body of the design code.  The instance name
//          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code              : parenthesis may be changed to properly reference and
//                               : connect this function to the design.  All inputs
//                               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable
   //                                Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer diff_p output
      .OB(OB),                       // 1-bit output: Buffer diff_n output
      .I(I),                         // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                       // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Must be tied to a logic '0'
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Buffer termination disable, high=disable
   );

   // End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
// IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog        : the following instance declaration needs to be placed
//       instance       : in the body of the design code.  The instance name
//     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//         code         : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_INTERMDISABLE: Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                       // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer input disable, high=disable
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Buffer termination disable, high=disable
   );

   // End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable (IBUFDS_IBUFDISABLE)" treetype="template">
// IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//      instance      : in the body of the design code.  The instance name
//    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations within the
//        code        : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_IBUFDISABLE: Differential Input Buffer With Input Buffer Disable
   //                     Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Must be tied to a logic '0'
   );

   // End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with MIPI support (IBUFDS_DPHY)" treetype="template">
// IBUFDS_DPHY : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_DPHY_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DPHY: Differential Input Buffer with MIPI support
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DPHY #(
      .DIFF_TERM("TRUE"),     // Differential termination
      .IOSTANDARD("DEFAULT")  // I/O standard
   )
   IBUFDS_DPHY_inst (
      .HSRX_O(HSRX_O),             // 1-bit output: HS RX output
      .LPRX_O_N(LPRX_O_N),         // 1-bit output: LP RX output (Slave)
      .LPRX_O_P(LPRX_O_P),         // 1-bit output: LP RX output (Master)
      .HSRX_DISABLE(HSRX_DISABLE), // 1-bit input: Disable control for HS mode
      .I(I),                       // 1-bit input: Data input0 PAD
      .IB(IB),                     // 1-bit input: Data input1 PAD
      .LPRX_DISABLE(LPRX_DISABLE)  // 1-bit input: Disable control for LP mode
   );

   // End of IBUFDS_DPHY_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Offset Calibration (IBUFDSE3)" treetype="template">
//  IBUFDSE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDSE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDSE3: Differential Input Buffer with Offset Calibration
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDSE3 #(
      .DQS_BIAS("FALSE"),          // (FALSE, TRUE)
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IBUFDSE3_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE), // 1-bit input: Buffer disable input, high=disable
      .OSC(OSC),                 // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN)            // 2-bit input: Offset cancellation enable
   );

   // End of IBUFDSE3_inst instantiation
					</Template>
					<Template label="Input Buffer (IBUF)" treetype="template">
//    IBUF     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF: Input Buffer
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUF IBUF_inst (
      .O(O), // 1-bit output: Buffer output
      .I(I)  // 1-bit input: Buffer input
   );

   // End of IBUF_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
// IBUF_INTERMDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//      instance      : in the body of the design code.  The instance name
//    declaration     : (IBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code        : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_INTERMDISABLE: Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                     Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUF_INTERMDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUF_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Input Termination Disable
   );

   // End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable (IBUF_IBUFDISABLE)" treetype="template">
// IBUF_IBUFDISABLE : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_IBUFDISABLE: Input Buffer With Input Buffer Disable
   //                   Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUF_IBUFDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUF_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Buffer disable input, high=disable
   );

   // End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer with Offset Calibration and VREF Tuning (IBUFE3)" treetype="template">
//   IBUFE3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFE3: Input Buffer with Offset Calibration and VREF Tuning
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFE3 #(
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IBUFE3_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE), // 1-bit input: Buffer disable input, high=disable
      .OSC(OSC),                 // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),           // 1-bit input: Offset cancellation enable
      .VREF(VREF)                // 1-bit input: Vref input from HPIO_VREF
   );

   // End of IBUFE3_inst instantiation
					</Template>
					<Template label="VREF Scan (HPIO_VREF)" treetype="template">
//  HPIO_VREF  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (HPIO_VREF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // HPIO_VREF: VREF Scan
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   HPIO_VREF #(
      .VREF_CNTR("OFF")  // FABRIC_RANGE1, FABRIC_RANGE2, OFF
   )
   HPIO_VREF_inst (
      .VREF(VREF),                         // 1-bit output: Tuned output (connect to associated IBUFE3
                                           // component)

      .FABRIC_VREF_TUNE(FABRIC_VREF_TUNE)  // 7-bit input: VREF tuning value
   );

   // End of HPIO_VREF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="OUTPUT_BUFFER" treetype="folder">
					<Template label="3-State Output Buffer (OBUFT)" treetype="template">
//    OBUFT    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFT: 3-State Output Buffer
   //        Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFT OBUFT_inst (
      .O(O), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(I), // 1-bit input: Buffer input
      .T(T)  // 1-bit input: 3-state enable input
   );

   // End of OBUFT_inst instantiation
					</Template>
					<Template label="Differential Output Buffer (OBUFDS)" treetype="template">
//   OBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS: Differential Output Buffer
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS OBUFDS_inst (
      .O(O),   // 1-bit output: Diff_p output (connect directly to top-level port)
      .OB(OB), // 1-bit output: Diff_n output (connect directly to top-level port)
      .I(I)    // 1-bit input: Buffer input
   );

   // End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential Output Buffer with MIPI support (OBUFDS_DPHY)" treetype="template">
// OBUFDS_DPHY : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_DPHY_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_DPHY: Differential Output Buffer with MIPI support
   //              Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_DPHY #(
      .IOSTANDARD("DEFAULT")  // I/O standard
   )
   OBUFDS_DPHY_inst (
      .O(O),               // 1-bit output: Diff_P Data output
      .OB(OB),             // 1-bit output: Diff_N Data output
      .HSTX_I(HSTX_I),     // 1-bit input: Data input (HS TX)
      .HSTX_T(HSTX_T),     // 1-bit input: Tristate Control input (HS TX)
      .LPTX_I_N(LPTX_I_N), // 1-bit input: Data input (LP TX) (Master-N)
      .LPTX_I_P(LPTX_I_P), // 1-bit input: Data input (LP TX) (Master-P)
      .LPTX_T(LPTX_T)      // 1-bit input: Tristate Control input (LP TX)
   );

   // End of OBUFDS_DPHY_inst instantiation
					</Template>
					<Template label="Differential 3-state Output Buffer (OBUFTDS)" treetype="template">
//   OBUFTDS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFTDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFTDS: Differential 3-state Output Buffer
   //          Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFTDS OBUFTDS_inst (
      .O(O),   // 1-bit output: Diff_p output (connect directly to top-level port)
      .OB(OB), // 1-bit output: Diff_n output (connect directly to top-level port)
      .I(I),   // 1-bit input: Buffer input
      .T(T)    // 1-bit input: 3-state enable input
   );

   // End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Output Buffer (OBUF)" treetype="template">
//    OBUF     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUF: Output Buffer
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUF OBUF_inst (
      .O(O), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(I)  // 1-bit input: Buffer input
   );

   // End of OBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer (ISERDESE3)" treetype="template">
//  ISERDESE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ISERDESE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ISERDESE3: Input SERial/DESerializer
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   ISERDESE3 #(
      .DATA_WIDTH(8),            // Parallel data width (4,8)
      .FIFO_ENABLE("FALSE"),     // Enables the use of the FIFO
      .FIFO_SYNC_MODE("FALSE"),  // Enables the use of internal 2-stage synchronizers on the FIFO
      .IS_CLK_B_INVERTED(1'b0),  // Optional inversion for CLK_B
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   ISERDESE3_inst (
      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .INTERNAL_DIVCLK(INTERNAL_DIVCLK), // 1-bit output: Internally divided down clock used when FIFO is
                                         // disabled (do not connect)

      .Q(Q),                             // 8-bit registered output
      .CLK(CLK),                         // 1-bit input: High-speed clock
      .CLKDIV(CLKDIV),                   // 1-bit input: Divided Clock
      .CLK_B(CLK_B),                     // 1-bit input: Inversion of High-speed clock CLK
      .D(D),                             // 1-bit input: Serial Data Input
      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: Enables reading the FIFO when asserted
      .RST(RST)                          // 1-bit input: Asynchronous Reset
   );

   // End of ISERDESE3_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer (OSERDESE3)" treetype="template">
//  OSERDESE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OSERDESE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OSERDESE3: Output SERial/DESerializer
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OSERDESE3 #(
      .DATA_WIDTH(8),            // Parallel Data Width (4-8)
      .INIT(1'b0),               // Initialization value of the OSERDES flip-flops
      .IS_CLKDIV_INVERTED(1'b0), // Optional inversion for CLKDIV
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   OSERDESE3_inst (
      .OQ(OQ),         // 1-bit output: Serial Output Data
      .T_OUT(T_OUT),   // 1-bit output: 3-state control output to IOB
      .CLK(CLK),       // 1-bit input: High-speed clock
      .CLKDIV(CLKDIV), // 1-bit input: Divided Clock
      .D(D),           // 8-bit input: Parallel Data Input
      .RST(RST),       // 1-bit input: Asynchronous Reset
      .T(T)            // 1-bit input: Tristate input from fabric
   );

   // End of OSERDESE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="WEAK_DRIVER" treetype="folder">
					<Template label="I/O Pulldown (PULLDOWN)" treetype="template">
//  PULLDOWN   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PULLDOWN_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PULLDOWN: I/O Pulldown
   //           Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PULLDOWN PULLDOWN_inst (
      .O(O)  // 1-bit output: Pulldown output (connect directly to top-level port)
   );

   // End of PULLDOWN_inst instantiation
					</Template>
					<Template label="I/O Pullup (PULLUP)" treetype="template">
//   PULLUP    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PULLUP_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PULLUP: I/O Pullup
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PULLUP PULLUP_inst (
      .O(O)  // 1-bit output: Pullup output (connect directly to top-level port)
   );

   // End of PULLUP_inst instantiation
					</Template>
					<Template label="I/O Weak Keeper (KEEPER)" treetype="template">
//   KEEPER    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (KEEPER_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // KEEPER: I/O Weak Keeper
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   KEEPER KEEPER_inst (
      .O(O)  // 1-bit inout: Keeper output (connect directly to top-level port)
   );

   // End of KEEPER_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="REGISTER" treetype="folder">
				<SubFolder label="DDR" treetype="folder">
					<Template label="Input DDR (IDDRE1)" treetype="template">
//   IDDRE1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDDRE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDDRE1: Dedicated Dual Data Rate (DDR) Input Register
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IDDRE1 #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // IDDRE1 mode (OPPOSITE_EDGE, SAME_EDGE, SAME_EDGE_PIPELINED)
      .IS_CB_INVERTED(1'b0),          // Optional inversion for CB
      .IS_C_INVERTED(1'b0)            // Optional inversion for C
   )
   IDDRE1_inst (
      .Q1(Q1), // 1-bit output: Registered parallel output 1
      .Q2(Q2), // 1-bit output: Registered parallel output 2
      .C(C),   // 1-bit input: High-speed clock
      .CB(CB), // 1-bit input: Inversion of High-speed clock C
      .D(D),   // 1-bit input: Serial Data Input
      .R(R)    // 1-bit input: Active High Async Reset
   );

   // End of IDDRE1_inst instantiation
					</Template>
					<Template label="Output DDR (ODDRE1)" treetype="template">
//   ODDRE1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODDRE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODDRE1: Dedicated Dual Data Rate (DDR) Output Register
   //         Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   ODDRE1 #(
      .IS_C_INVERTED(1'b0),  // Optional inversion for C
      .IS_D1_INVERTED(1'b0), // Optional inversion for D1
      .IS_D2_INVERTED(1'b0), // Optional inversion for D2
      .SRVAL(1'b0)           // Initializes the ODDRE1 Flip-Flops to the specified value (1'b0, 1'b1)
   )
   ODDRE1_inst (
      .Q(Q),   // 1-bit output: Data output to IOB
      .C(C),   // 1-bit input: High-speed clock input
      .D1(D1), // 1-bit input: Parallel data input 1
      .D2(D2), // 1-bit input: Parallel data input 2
      .SR(SR)  // 1-bit input: Active High Async Reset
   );

   // End of ODDRE1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Transparent Latch with Clock Enable and Asynchronous Clear (LDCE)" treetype="template">
//    LDCE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LDCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LDCE: Transparent Latch with Clock Enable and Asynchronous Clear
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LDCE #(
      .INIT(1'b0),            // Initial value of latch, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_G_INVERTED(1'b0)    // Optional inversion for G
   )
   LDCE_inst (
      .Q(Q),     // 1-bit output: Data
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .D(D),     // 1-bit input: Data
      .G(G),     // 1-bit input: Gate
      .GE(GE)    // 1-bit input: Gate enable
   );

   // End of LDCE_inst instantiation
					</Template>
					<Template label="Transparent Latch with Clock Enable and Asynchronous Preset (LDPE)" treetype="template">
//    LDPE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LDPE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LDPE: Transparent Latch with Clock Enable and Asynchronous Preset
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LDPE #(
      .INIT(1'b1),            // Initial value of latch, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_G_INVERTED(1'b0),   // Optional inversion for G
      .IS_PRE_INVERTED(1'b0)  // Optional inversion for PRE
   )
   LDPE_inst (
      .Q(Q),     // 1-bit output: Data
      .D(D),     // 1-bit input: Data
      .G(G),     // 1-bit input: Gate
      .GE(GE),   // 1-bit input: Gate enable
      .PRE(PRE)  // 1-bit input: Asynchronous preset
   );

   // End of LDPE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="METASTABILITY" treetype="folder">
					<Template label="Metastability Hardened Registers (HARD_SYNC)" treetype="template">
//  HARD_SYNC  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (HARD_SYNC_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // HARD_SYNC: Metastability Hardened Registers
   //            Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   HARD_SYNC #(
      .INIT(1'b0),            // Initial values, 1'b0, 1'b1
      .IS_CLK_INVERTED(1'b0), // Programmable inversion on CLK input
      .LATENCY(2)             // 2-3
   )
   HARD_SYNC_inst (
      .DOUT(DOUT), // 1-bit output: Data
      .CLK(CLK),   // 1-bit input: Clock
      .DIN(DIN)    // 1-bit input: Data
   );

   // End of HARD_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SDR" treetype="folder">
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Clear (FDCE)" treetype="template">
//    FDCE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDCE: D Flip-Flop with Clock Enable and Asynchronous Clear
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FDCE #(
      .INIT(1'b0),            // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_C_INVERTED(1'b0),   // Optional inversion for C
      .IS_D_INVERTED(1'b0)    // Optional inversion for D
   )
   FDCE_inst (
      .Q(Q),     // 1-bit output: Data
      .C(C),     // 1-bit input: Clock
      .CE(CE),   // 1-bit input: Clock enable
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .D(D)      // 1-bit input: Data
   );

   // End of FDCE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Preset (FDPE)" treetype="template">
//    FDPE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDPE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDPE: D Flip-Flop with Clock Enable and Asynchronous Preset
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FDPE #(
      .INIT(1'b1),            // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0),   // Optional inversion for C
      .IS_D_INVERTED(1'b0),   // Optional inversion for D
      .IS_PRE_INVERTED(1'b0)  // Optional inversion for PRE
   )
   FDPE_inst (
      .Q(Q),     // 1-bit output: Data
      .C(C),     // 1-bit input: Clock
      .CE(CE),   // 1-bit input: Clock enable
      .D(D),     // 1-bit input: Data
      .PRE(PRE)  // 1-bit input: Asynchronous preset
   );

   // End of FDPE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Reset (FDRE)" treetype="template">
//    FDRE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDRE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDRE: D Flip-Flop with Clock Enable and Synchronous Reset
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FDRE #(
      .INIT(1'b0),          // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0), // Optional inversion for C
      .IS_D_INVERTED(1'b0), // Optional inversion for D
      .IS_R_INVERTED(1'b0)  // Optional inversion for R
   )
   FDRE_inst (
      .Q(Q),   // 1-bit output: Data
      .C(C),   // 1-bit input: Clock
      .CE(CE), // 1-bit input: Clock enable
      .D(D),   // 1-bit input: Data
      .R(R)    // 1-bit input: Synchronous reset
   );

   // End of FDRE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Set (FDSE)" treetype="template">
//    FDSE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDSE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDSE: D Flip-Flop with Clock Enable and Synchronous Set
   //       Kintex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FDSE #(
      .INIT(1'b1),          // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0), // Optional inversion for C
      .IS_D_INVERTED(1'b0), // Optional inversion for D
      .IS_S_INVERTED(1'b0)  // Optional inversion for S
   )
   FDSE_inst (
      .Q(Q),   // 1-bit output: Data
      .C(C),   // 1-bit input: Clock
      .CE(CE), // 1-bit input: Clock enable
      .D(D),   // 1-bit input: Data
      .S(S)    // 1-bit input: Synchronous set
   );

   // End of FDSE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Kintex-7" treetype="folder">
			<SubFolder label="Advanced" treetype="folder">
				<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE2)" treetype="template">
// IBUFDS_GTE2 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_GTE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_GTE2: Gigabit Transceiver Buffer
   //              Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE2 #(
      .CLKCM_CFG("TRUE"),   // Refer to Transceiver User Guide
      .CLKRCV_TRST("TRUE"), // Refer to Transceiver User Guide
      .CLKSWING_CFG(2'b11)  // Refer to Transceiver User Guide
   )
   IBUFDS_GTE2_inst (
      .O(O),         // 1-bit output: Refer to Transceiver User Guide
      .ODIV2(ODIV2), // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),     // 1-bit input: Refer to Transceiver User Guide
      .I(I),         // 1-bit input: Refer to Transceiver User Guide
      .IB(IB)        // 1-bit input: Refer to Transceiver User Guide
   );

   // End of IBUFDS_GTE2_inst instantiation
				</Template>
				<Template label="XADC Simulation File" treetype="template">
// Must use valid headers on all columns
// Comments can be added to the stimulus file using '//'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

// Time stamp data is in nano seconds (ns)
// Temperature is recorded in C (degrees centigrade)
// All other channels are recorded as V (Volts)
// Valid column headers are:
// TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
// VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
// External analog inputs are differential so VP = 0.5 and VN = 0.1 the
// input on channel VP/VN in 0.5 - 0.1 = 0.4V
				</Template>
				<Template label="Xilinx Analog-to-Digital Converter (XADC)" treetype="template">
//    XADC     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (XADC_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // XADC: Dual 12-Bit 1MSPS Analog-to-Digital Converter
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   XADC #(
      // INIT_40 - INIT_42: XADC configuration registers
      .INIT_40(16'h0000),
      .INIT_41(16'h0000),
      .INIT_42(16'h0800),
      // INIT_48 - INIT_4F: Sequence Registers
      .INIT_48(16'h0000),
      .INIT_49(16'h0000),
      .INIT_4A(16'h0000),
      .INIT_4B(16'h0000),
      .INIT_4C(16'h0000),
      .INIT_4D(16'h0000),
      .INIT_4F(16'h0000),
      .INIT_4E(16'h0000),                // Sequence register 6
      // INIT_50 - INIT_58, INIT5C: Alarm Limit Registers
      .INIT_50(16'h0000),
      .INIT_51(16'h0000),
      .INIT_52(16'h0000),
      .INIT_53(16'h0000),
      .INIT_54(16'h0000),
      .INIT_55(16'h0000),
      .INIT_56(16'h0000),
      .INIT_57(16'h0000),
      .INIT_58(16'h0000),
      .INIT_5C(16'h0000),
      // Simulation attributes: Set for proper simulation behavior
      .SIM_DEVICE("7SERIES"),            // Select target device (values)
      .SIM_MONITOR_FILE("design.txt")  // Analog simulation data file name
   )
   XADC_inst (
      // ALARMS: 8-bit (each) output: ALM, OT
      .ALM(ALM),                   // 8-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      .OT(OT),                     // 1-bit output: Over-Temperature alarm
      // Dynamic Reconfiguration Port (DRP): 16-bit (each) output: Dynamic Reconfiguration Ports
      .DO(DO),                     // 16-bit output: DRP output data bus
      .DRDY(DRDY),                 // 1-bit output: DRP data ready
      // STATUS: 1-bit (each) output: XADC status ports
      .BUSY(BUSY),                 // 1-bit output: ADC busy output
      .CHANNEL(CHANNEL),           // 5-bit output: Channel selection outputs
      .EOC(EOC),                   // 1-bit output: End of Conversion
      .EOS(EOS),                   // 1-bit output: End of Sequence
      .JTAGBUSY(JTAGBUSY),         // 1-bit output: JTAG DRP transaction in progress output
      .JTAGLOCKED(JTAGLOCKED),     // 1-bit output: JTAG requested DRP port lock
      .JTAGMODIFIED(JTAGMODIFIED), // 1-bit output: JTAG Write to the DRP has occurred
      .MUXADDR(MUXADDR),           // 5-bit output: External MUX channel decode
      // Auxiliary Analog-Input Pairs: 16-bit (each) input: VAUXP[15:0], VAUXN[15:0]
      .VAUXN(VAUXN),               // 16-bit input: N-side auxiliary analog input
      .VAUXP(VAUXP),               // 16-bit input: P-side auxiliary analog input
      // CONTROL and CLOCK: 1-bit (each) input: Reset, conversion start and clock inputs
      .CONVST(CONVST),             // 1-bit input: Convert start input
      .CONVSTCLK(CONVSTCLK),       // 1-bit input: Convert start input
      .RESET(RESET),               // 1-bit input: Active-high reset
      // Dedicated Analog Input Pair: 1-bit (each) input: VP/VN
      .VN(VN),                     // 1-bit input: N-side analog input
      .VP(VP),                     // 1-bit input: P-side analog input
      // Dynamic Reconfiguration Port (DRP): 7-bit (each) input: Dynamic Reconfiguration Ports
      .DADDR(DADDR),               // 7-bit input: DRP address bus
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable signal
      .DI(DI),                     // 16-bit input: DRP input data bus
      .DWE(DWE)                    // 1-bit input: DRP write enable
   );

   // End of XADC_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Arithmetic Functions" treetype="folder">
				<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E1)" treetype="template">
//   DSP48E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DSP48E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DSP48E1: 48-bit Multi-Functional Arithmetic Block
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   DSP48E1 #(
      // Feature Control Attributes: Data Path Selection
      .A_INPUT("DIRECT"),               // Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      .B_INPUT("DIRECT"),               // Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      .USE_DPORT("FALSE"),              // Select D port usage (TRUE or FALSE)
      .USE_MULT("MULTIPLY"),            // Select multiplier usage ("MULTIPLY", "DYNAMIC", or "NONE")
      .USE_SIMD("ONE48"),               // SIMD selection ("ONE48", "TWO24", "FOUR12")
      // Pattern Detector Attributes: Pattern Detection Configuration
      .AUTORESET_PATDET("NO_RESET"),    // "NO_RESET", "RESET_MATCH", "RESET_NOT_MATCH" 
      .MASK(48'h3fffffffffff),          // 48-bit mask value for pattern detect (1=ignore)
      .PATTERN(48'h000000000000),       // 48-bit pattern match for pattern detect
      .SEL_MASK("MASK"),                // "C", "MASK", "ROUNDING_MODE1", "ROUNDING_MODE2" 
      .SEL_PATTERN("PATTERN"),          // Select pattern value ("PATTERN" or "C")
      .USE_PATTERN_DETECT("NO_PATDET"), // Enable pattern detect ("PATDET" or "NO_PATDET")
      // Register Control Attributes: Pipeline Register Configuration
      .ACASCREG(1),                     // Number of pipeline stages between A/ACIN and ACOUT (0, 1 or 2)
      .ADREG(1),                        // Number of pipeline stages for pre-adder (0 or 1)
      .ALUMODEREG(1),                   // Number of pipeline stages for ALUMODE (0 or 1)
      .AREG(1),                         // Number of pipeline stages for A (0, 1 or 2)
      .BCASCREG(1),                     // Number of pipeline stages between B/BCIN and BCOUT (0, 1 or 2)
      .BREG(1),                         // Number of pipeline stages for B (0, 1 or 2)
      .CARRYINREG(1),                   // Number of pipeline stages for CARRYIN (0 or 1)
      .CARRYINSELREG(1),                // Number of pipeline stages for CARRYINSEL (0 or 1)
      .CREG(1),                         // Number of pipeline stages for C (0 or 1)
      .DREG(1),                         // Number of pipeline stages for D (0 or 1)
      .INMODEREG(1),                    // Number of pipeline stages for INMODE (0 or 1)
      .MREG(1),                         // Number of multiplier pipeline stages (0 or 1)
      .OPMODEREG(1),                    // Number of pipeline stages for OPMODE (0 or 1)
      .PREG(1)                          // Number of pipeline stages for P (0 or 1)
   )
   DSP48E1_inst (
      // Cascade: 30-bit (each) output: Cascade Ports
      .ACOUT(ACOUT),                   // 30-bit output: A port cascade output
      .BCOUT(BCOUT),                   // 18-bit output: B port cascade output
      .CARRYCASCOUT(CARRYCASCOUT),     // 1-bit output: Cascade carry output
      .MULTSIGNOUT(MULTSIGNOUT),       // 1-bit output: Multiplier sign cascade output
      .PCOUT(PCOUT),                   // 48-bit output: Cascade output
      // Control: 1-bit (each) output: Control Inputs/Status Bits
      .OVERFLOW(OVERFLOW),             // 1-bit output: Overflow in add/acc output
      .PATTERNBDETECT(PATTERNBDETECT), // 1-bit output: Pattern bar detect output
      .PATTERNDETECT(PATTERNDETECT),   // 1-bit output: Pattern detect output
      .UNDERFLOW(UNDERFLOW),           // 1-bit output: Underflow in add/acc output
      // Data: 4-bit (each) output: Data Ports
      .CARRYOUT(CARRYOUT),             // 4-bit output: Carry output
      .P(P),                           // 48-bit output: Primary data output
      // Cascade: 30-bit (each) input: Cascade Ports
      .ACIN(ACIN),                     // 30-bit input: A cascade data input
      .BCIN(BCIN),                     // 18-bit input: B cascade input
      .CARRYCASCIN(CARRYCASCIN),       // 1-bit input: Cascade carry input
      .MULTSIGNIN(MULTSIGNIN),         // 1-bit input: Multiplier sign input
      .PCIN(PCIN),                     // 48-bit input: P cascade input
      // Control: 4-bit (each) input: Control Inputs/Status Bits
      .ALUMODE(ALUMODE),               // 4-bit input: ALU control input
      .CARRYINSEL(CARRYINSEL),         // 3-bit input: Carry select input
      .CLK(CLK),                       // 1-bit input: Clock input
      .INMODE(INMODE),                 // 5-bit input: INMODE control input
      .OPMODE(OPMODE),                 // 7-bit input: Operation mode input
      // Data: 30-bit (each) input: Data Ports
      .A(A),                           // 30-bit input: A data input
      .B(B),                           // 18-bit input: B data input
      .C(C),                           // 48-bit input: C data input
      .CARRYIN(CARRYIN),               // 1-bit input: Carry input signal
      .D(D),                           // 25-bit input: D data input
      // Reset/Clock Enable: 1-bit (each) input: Reset/Clock Enable Inputs
      .CEA1(CEA1),                     // 1-bit input: Clock enable input for 1st stage AREG
      .CEA2(CEA2),                     // 1-bit input: Clock enable input for 2nd stage AREG
      .CEAD(CEAD),                     // 1-bit input: Clock enable input for ADREG
      .CEALUMODE(CEALUMODE),           // 1-bit input: Clock enable input for ALUMODE
      .CEB1(CEB1),                     // 1-bit input: Clock enable input for 1st stage BREG
      .CEB2(CEB2),                     // 1-bit input: Clock enable input for 2nd stage BREG
      .CEC(CEC),                       // 1-bit input: Clock enable input for CREG
      .CECARRYIN(CECARRYIN),           // 1-bit input: Clock enable input for CARRYINREG
      .CECTRL(CECTRL),                 // 1-bit input: Clock enable input for OPMODEREG and CARRYINSELREG
      .CED(CED),                       // 1-bit input: Clock enable input for DREG
      .CEINMODE(CEINMODE),             // 1-bit input: Clock enable input for INMODEREG
      .CEM(CEM),                       // 1-bit input: Clock enable input for MREG
      .CEP(CEP),                       // 1-bit input: Clock enable input for PREG
      .RSTA(RSTA),                     // 1-bit input: Reset input for AREG
      .RSTALLCARRYIN(RSTALLCARRYIN),   // 1-bit input: Reset input for CARRYINREG
      .RSTALUMODE(RSTALUMODE),         // 1-bit input: Reset input for ALUMODEREG
      .RSTB(RSTB),                     // 1-bit input: Reset input for BREG
      .RSTC(RSTC),                     // 1-bit input: Reset input for CREG
      .RSTCTRL(RSTCTRL),               // 1-bit input: Reset input for OPMODEREG and CARRYINSELREG
      .RSTD(RSTD),                     // 1-bit input: Reset input for DREG and ADREG
      .RSTINMODE(RSTINMODE),           // 1-bit input: Reset input for INMODEREG
      .RSTM(RSTM),                     // 1-bit input: Reset input for MREG
      .RSTP(RSTP)                      // 1-bit input: Reset input for PREG
   );

   // End of DSP48E1_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Clock Components" treetype="folder">
				<SubFolder label="Clock Buffers" treetype="folder">
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
//  BUFGCE_1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_1: Global Clock Buffer with Clock Enable and Output State 1
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_1 BUFGCE_1_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock enable input for I0
      .I(I)    // 1-bit input: Primary clock
   );

   // End of BUFGCE_1_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
//   BUFGCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE: Global Clock Buffer with Clock Enable
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE BUFGCE_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock enable input for I0
      .I(I)    // 1-bit input: Primary clock
   );

   // End of BUFGCE_inst instantiation
					</Template>
					<Template label="Global Clock Simple Buffer (BUFG)" treetype="template">
//    BUFG     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG: Global Clock Simple Buffer
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFG BUFG_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFG_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer (BUFH)" treetype="template">
//    BUFH     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFH_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFH: HROW Clock Buffer for a Single Clocking Region
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFH BUFH_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFH_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer with Clock Enable (BUFHCE)" treetype="template">
//   BUFHCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFHCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFHCE: HROW Clock Buffer for a Single Clocking Region with Clock Enable
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFHCE #(
      .CE_TYPE("SYNC"), // "SYNC" (glitchless switching) or "ASYNC" (immediate switch)
      .INIT_OUT(0)      // Initial output value (0-1)
   )
   BUFHCE_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Active high enable
      .I(I)    // 1-bit input: Clock input
   );

   // End of BUFHCE_inst instantiation
					</Template>
					<Template label="I/O Clock Buffer (BUFIO)" treetype="template">
//    BUFIO    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFIO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFIO: Local Clock Buffer for I/O
   //        Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFIO BUFIO_inst (
      .O(O), // 1-bit output: Clock output (connect to I/O clock loads).
      .I(I)  // 1-bit input: Clock input (connect to an IBUF or BUFMR).
   );

   // End of BUFIO_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer (BUFMR)" treetype="template">
//    BUFMR    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFMR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFMR: Multi-Region Clock Buffer
   //        Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFMR BUFMR_inst (
      .O(O), // 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      .I(I)  // 1-bit input: Clock input (Connect to IBUF)
   );

   // End of BUFMR_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer with Clock Enable (BUFMRCE)" treetype="template">
//   BUFMRCE   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFMRCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFMRCE: Multi-Region Clock Buffer with Clock Enable
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFMRCE #(
      .CE_TYPE("SYNC"), // SYNC, ASYNC
      .INIT_OUT(0)      // Initial output and stopped polarity, (0-1)
   )
   BUFMRCE_inst (
      .O(O),   // 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      .CE(CE), // 1-bit input: Active high buffer enable
      .I(I)    // 1-bit input: Clock input (Connect to IBUF)
   );

   // End of BUFMRCE_inst instantiation
					</Template>
					<Template label="Regional Clock Buffer (BUFR)" treetype="template">
//    BUFR     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFR: Regional Clock Buffer for I/O and Logic Resources within a Clock Region
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFR #(
      .BUFR_DIVIDE("BYPASS"),   // Values: "BYPASS, 1, 2, 3, 4, 5, 6, 7, 8" 
      .SIM_DEVICE("7SERIES")  // Must be set to "7SERIES" 
   )
   BUFR_inst (
      .O(O),     // 1-bit output: Clock output port
      .CE(CE),   // 1-bit input: Active high, clock enable (Divided modes only)
      .CLR(CLR), // 1-bit input: Active high, asynchronous clear (Divided modes only)
      .I(I)      // 1-bit input: Clock buffer input driven by an IBUF, MMCM or local interconnect
   );

   // End of BUFR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Clock MUXes" treetype="folder">
					<Template label="2-to-1 Global Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
// BUFGMUX_CTRL : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_CTRL: 2-to-1 Global Clock MUX Buffer
   //               Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL BUFGMUX_CTRL_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="Global Clock Control Buffer (BUFGCTRL)" treetype="template">
//  BUFGCTRL   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCTRL: Global Clock Control Buffer
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGCTRL #(
      .INIT_OUT(0),           // Initial value of BUFGCTRL output ($VALUES;)
      .PRESELECT_I0("FALSE"), // BUFGCTRL output uses I0 input ($VALUES;)
      .PRESELECT_I1("FALSE")  // BUFGCTRL output uses I1 input ($VALUES;)
   )
   BUFGCTRL_inst (
      .O(O),             // 1-bit output: Clock output
      .CE0(CE0),         // 1-bit input: Clock enable input for I0
      .CE1(CE1),         // 1-bit input: Clock enable input for I1
      .I0(I0),           // 1-bit input: Primary clock
      .I1(I1),           // 1-bit input: Secondary clock
      .IGNORE0(IGNORE0), // 1-bit input: Clock ignore input for I0
      .IGNORE1(IGNORE1), // 1-bit input: Clock ignore input for I1
      .S0(S0),           // 1-bit input: Clock select for I0
      .S1(S1)            // 1-bit input: Clock select for I1
   );

   // End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer (BUFGMUX)" treetype="template">
//   BUFGMUX   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX: Global Clock Mux Buffer
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX #(
   )
   BUFGMUX_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
//  BUFGMUX_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_1: Global Clock Mux Buffer with Output State 1
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1 #(
   )
   BUFGMUX_1_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MMCM / PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCME2_ADV)" treetype="template">
// MMCME2_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME2_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME2_ADV: Advanced Mixed Mode Clock Manager
   //             Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   MMCME2_ADV #(
      .BANDWIDTH("OPTIMIZED"),        // Jitter programming (OPTIMIZED, HIGH, LOW)
      .CLKFBOUT_MULT_F(5.0),          // Multiply value for all CLKOUT (2.000-64.000).
      .CLKFBOUT_PHASE(0.0),           // Phase offset in degrees of CLKFB (-360.000-360.000).
      // CLKIN_PERIOD: Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      // CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT0_DIVIDE_F(1.0),         // Divide amount for CLKOUT0 (1.000-128.000).
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.01-0.99).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      .CLKOUT4_CASCADE("FALSE"),      // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .COMPENSATION("ZHOLD"),         // ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      .DIVCLK_DIVIDE(1),              // Master division value (1-106)
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE"),         // Delays DONE until MMCM is locked (FALSE, TRUE)
      // Spread Spectrum: Spread Spectrum Attributes
      .SS_EN("FALSE"),                // Enables spread spectrum (FALSE, TRUE)
      .SS_MODE("CENTER_HIGH"),        // CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      .SS_MOD_PERIOD(10000),          // Spread spectrum modulation period (ns) (VALUES)
      // USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      .CLKFBOUT_USE_FINE_PS("FALSE"),
      .CLKOUT0_USE_FINE_PS("FALSE"),
      .CLKOUT1_USE_FINE_PS("FALSE"),
      .CLKOUT2_USE_FINE_PS("FALSE"),
      .CLKOUT3_USE_FINE_PS("FALSE"),
      .CLKOUT4_USE_FINE_PS("FALSE"),
      .CLKOUT5_USE_FINE_PS("FALSE"),
      .CLKOUT6_USE_FINE_PS("FALSE") 
   )
   MMCME2_ADV_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),           // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),         // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),           // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),         // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),           // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),         // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),           // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),         // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),           // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),           // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),           // 1-bit output: CLKOUT6
      // DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      .DO(DO),                     // 16-bit output: DRP data
      .DRDY(DRDY),                 // 1-bit output: DRP ready
      // Dynamic Phase Shift Ports: 1-bit (each) output: Ports used for dynamic phase shifting of the outputs
      .PSDONE(PSDONE),             // 1-bit output: Phase shift done
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),         // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB),       // 1-bit output: Inverted CLKFBOUT
      // Status Ports: 1-bit (each) output: MMCM status ports
      .CLKFBSTOPPED(CLKFBSTOPPED), // 1-bit output: Feedback clock stopped
      .CLKINSTOPPED(CLKINSTOPPED), // 1-bit output: Input clock stopped
      .LOCKED(LOCKED),             // 1-bit output: LOCK
      // Clock Inputs: 1-bit (each) input: Clock inputs
      .CLKIN1(CLKIN1),             // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),             // 1-bit input: Secondary clock
      // Control Ports: 1-bit (each) input: MMCM control ports
      .CLKINSEL(CLKINSEL),         // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),             // 1-bit input: Power-down
      .RST(RST),                   // 1-bit input: Reset
      // DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      .DADDR(DADDR),               // 7-bit input: DRP address
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable
      .DI(DI),                     // 16-bit input: DRP data
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // Dynamic Phase Shift Ports: 1-bit (each) input: Ports used for dynamic phase shifting of the outputs
      .PSCLK(PSCLK),               // 1-bit input: Phase shift clock
      .PSEN(PSEN),                 // 1-bit input: Phase shift enable
      .PSINCDEC(PSINCDEC),         // 1-bit input: Phase shift increment/decrement
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)            // 1-bit input: Feedback clock
   );

   // End of MMCME2_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase Locked Loop (PLLE2_ADV)" treetype="template">
//  PLLE2_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE2_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE2_ADV: Advanced Phase Locked Loop (PLL)
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   PLLE2_ADV #(
      .BANDWIDTH("OPTIMIZED"),  // OPTIMIZED, HIGH, LOW
      .CLKFBOUT_MULT(5),        // Multiply value for all CLKOUT, (2-64)
      .CLKFBOUT_PHASE(0.0),     // Phase offset in degrees of CLKFB, (-360.000-360.000).
      // CLKIN_PERIOD: Input clock period in nS to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      // CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT0_DIVIDE(1),
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      // CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .COMPENSATION("ZHOLD"),   // ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      .DIVCLK_DIVIDE(1),        // Master division value (1-56)
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE")    // Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   PLLE2_ADV_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),   // 1-bit output: CLKOUT0
      .CLKOUT1(CLKOUT1),   // 1-bit output: CLKOUT1
      .CLKOUT2(CLKOUT2),   // 1-bit output: CLKOUT2
      .CLKOUT3(CLKOUT3),   // 1-bit output: CLKOUT3
      .CLKOUT4(CLKOUT4),   // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),   // 1-bit output: CLKOUT5
      // DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      .DO(DO),             // 16-bit output: DRP data
      .DRDY(DRDY),         // 1-bit output: DRP ready
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT), // 1-bit output: Feedback clock
      .LOCKED(LOCKED),     // 1-bit output: LOCK
      // Clock Inputs: 1-bit (each) input: Clock inputs
      .CLKIN1(CLKIN1),     // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),     // 1-bit input: Secondary clock
      // Control Ports: 1-bit (each) input: PLL control ports
      .CLKINSEL(CLKINSEL), // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),     // 1-bit input: Power-down
      .RST(RST),           // 1-bit input: Reset
      // DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      .DADDR(DADDR),       // 7-bit input: DRP address
      .DCLK(DCLK),         // 1-bit input: DRP clock
      .DEN(DEN),           // 1-bit input: DRP enable
      .DI(DI),             // 16-bit input: DRP data
      .DWE(DWE),           // 1-bit input: DRP write enable
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)    // 1-bit input: Feedback clock
   );

   // End of PLLE2_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCME2_BASE)" treetype="template">
// MMCME2_BASE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME2_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME2_BASE: Base Mixed Mode Clock Manager
   //              Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   MMCME2_BASE #(
      .BANDWIDTH("OPTIMIZED"),   // Jitter programming (OPTIMIZED, HIGH, LOW)
      .CLKFBOUT_MULT_F(5.0),     // Multiply value for all CLKOUT (2.000-64.000).
      .CLKFBOUT_PHASE(0.0),      // Phase offset in degrees of CLKFB (-360.000-360.000).
      .CLKIN1_PERIOD(0.0),       // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT0_DIVIDE_F(1.0),    // Divide amount for CLKOUT0 (1.000-128.000).
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.01-0.99).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      .CLKOUT4_CASCADE("FALSE"), // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .DIVCLK_DIVIDE(1),         // Master division value (1-106)
      .REF_JITTER1(0.0),         // Reference input jitter in UI (0.000-0.999).
      .STARTUP_WAIT("FALSE")     // Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   MMCME2_BASE_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),     // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),     // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),   // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT
      // Status Ports: 1-bit (each) output: MMCM status ports
      .LOCKED(LOCKED),       // 1-bit output: LOCK
      // Clock Inputs: 1-bit (each) input: Clock input
      .CLKIN1(CLKIN1),       // 1-bit input: Clock
      // Control Ports: 1-bit (each) input: MMCM control ports
      .PWRDWN(PWRDWN),       // 1-bit input: Power-down
      .RST(RST),             // 1-bit input: Reset
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)      // 1-bit input: Feedback clock
   );

   // End of MMCME2_BASE_inst instantiation
					</Template>
					<Template label="Base Phase Locked Loop (PLLE2_BASE)" treetype="template">
// PLLE2_BASE  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE2_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE2_BASE: Base Phase Locked Loop (PLL)
   //             Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   PLLE2_BASE #(
      .BANDWIDTH("OPTIMIZED"),  // OPTIMIZED, HIGH, LOW
      .CLKFBOUT_MULT(5),        // Multiply value for all CLKOUT, (2-64)
      .CLKFBOUT_PHASE(0.0),     // Phase offset in degrees of CLKFB, (-360.000-360.000).
      .CLKIN1_PERIOD(0.0),      // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT0_DIVIDE(1),
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      // CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .DIVCLK_DIVIDE(1),        // Master division value, (1-56)
      .REF_JITTER1(0.0),        // Reference input jitter in UI, (0.000-0.999).
      .STARTUP_WAIT("FALSE")    // Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   PLLE2_BASE_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),   // 1-bit output: CLKOUT0
      .CLKOUT1(CLKOUT1),   // 1-bit output: CLKOUT1
      .CLKOUT2(CLKOUT2),   // 1-bit output: CLKOUT2
      .CLKOUT3(CLKOUT3),   // 1-bit output: CLKOUT3
      .CLKOUT4(CLKOUT4),   // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),   // 1-bit output: CLKOUT5
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT), // 1-bit output: Feedback clock
      .LOCKED(LOCKED),     // 1-bit output: LOCK
      .CLKIN1(CLKIN1),     // 1-bit input: Input clock
      // Control Ports: 1-bit (each) input: PLL control ports
      .PWRDWN(PWRDWN),     // 1-bit input: Power-down
      .RST(RST),           // 1-bit input: Reset
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)    // 1-bit input: Feedback clock
   );

   // End of PLLE2_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Config/BSCAN Components" treetype="folder">
				<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
//  EFUSE_USR  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (EFUSE_USR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EFUSE_USR: 32-bit non-volatile design ID
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   EFUSE_USR #(
      .SIM_EFUSE_VALUE(32'h00000000)  // Value of the 32-bit non-volatile value used in simulation
   )
   EFUSE_USR_inst (
      .EFUSEUSR(EFUSEUSR)  // 32-bit output: User eFUSE register value output
   );

   // End of EFUSE_USR_inst instantiation
				</Template>
				<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
//   BSCANE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BSCANE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BSCANE2: Boundary-Scan User Instruction
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   BSCANE2 #(
      .JTAG_CHAIN(1)  // Value for USER command.
   )
   BSCANE2_inst (
      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.
      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                         // SHIFT are asserted.

      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.
      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      .SEL(SEL),         // 1-bit output: USER instruction active output.
      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.
      .TCK(TCK),         // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.
      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.
      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller
      .TDO(TDO)          // 1-bit input: Test Data Output (TDO) input for USER function.
   );

   // End of BSCANE2_inst instantiation
				</Template>
				<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
// USR_ACCESSE2 : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (USR_ACCESSE2_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // USR_ACCESSE2: Configuration Data Access
   //               Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2 USR_ACCESSE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration Clock output
      .DATA(DATA),           // 32-bit output: Configuration Data output
      .DATAVALID(DATAVALID)  // 1-bit output: Active high data valid output
   );

   // End of USR_ACCESSE2_inst instantiation
				</Template>
				<Template label="Configuration Frame Error Correction (FRAME_ECCE2)" treetype="template">
// FRAME_ECCE2 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FRAME_ECCE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FRAME_ECCE2: Configuration Frame Error Correction
   //              Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   FRAME_ECCE2 #(
      .FARSRC("EFAR"),                // Determines if the output of FAR[25:0] configuration register points to
                                      // the FAR or EFAR. Sets configuration option register bit CTL0[7].
      .FRAME_RBT_IN_FILENAME("None")  // This file is output by the ICAP_E2 model and it contains Frame Data
                                      // information for the Raw Bitstream (RBT) file. The FRAME_ECCE2 model
                                      // will parse this file, calculate ECC and output any error conditions.
   )
   FRAME_ECCE2_inst (
      .CRCERROR(CRCERROR),             // 1-bit output: Output indicating a CRC error.
      .ECCERROR(ECCERROR),             // 1-bit output: Output indicating an ECC error.
      .ECCERRORSINGLE(ECCERRORSINGLE), // 1-bit output: Output Indicating single-bit Frame ECC error detected.
      .FAR(FAR),                       // 26-bit output: Frame Address Register Value output.
      .SYNBIT(SYNBIT),                 // 5-bit output: Output bit address of error.
      .SYNDROME(SYNDROME),             // 13-bit output: Output location of erroneous bit.
      .SYNDROMEVALID(SYNDROMEVALID),   // 1-bit output: Frame ECC output indicating the SYNDROME output is
                                       // valid.

      .SYNWORD(SYNWORD)                // 7-bit output: Word output in the frame where an ECC error has been
                                       // detected.

   );

   // End of FRAME_ECCE2_inst instantiation
				</Template>
				<Template label="Device DNA Access Port (DNA_PORT)" treetype="template">
//  DNA_PORT   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DNA_PORT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DNA_PORT: Device DNA Access Port
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   DNA_PORT #(
      .SIM_DNA_VALUE(57'h000000000000000)  // Specifies a sample 57-bit DNA value for simulation
   )
   DNA_PORT_inst (
      .DOUT(DOUT),   // 1-bit output: DNA output data.
      .CLK(CLK),     // 1-bit input: Clock input.
      .DIN(DIN),     // 1-bit input: User data input pin.
      .READ(READ),   // 1-bit input: Active high load DNA, active low read input.
      .SHIFT(SHIFT)  // 1-bit input: Active high shift enable input.
   );

   // End of DNA_PORT_inst instantiation
				</Template>
				<Template label="Internal Configuration Access Port (ICAPE2)" treetype="template">
//   ICAPE2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ICAPE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ICAPE2: Internal Configuration Access Port
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   ICAPE2 #(
      .DEVICE_ID(0'h3651093),     // Specifies the pre-programmed Device ID value to be used for simulation
                                  // purposes.
      .ICAP_WIDTH("X32"),         // Specifies the input and output data width.
      .SIM_CFG_FILE_NAME("None")  // Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                  // model.
   )
   ICAPE2_inst (
      .O(O),         // 32-bit output: Configuration data output bus
      .CLK(CLK),     // 1-bit input: Clock Input
      .CSIB(CSIB),   // 1-bit input: Active-Low ICAP Enable
      .I(I),         // 32-bit input: Configuration data input bus
      .RDWRB(RDWRB)  // 1-bit input: Read/Write Select input
   );

   // End of ICAPE2_inst instantiation
				</Template>
				<Template label="Register Capture (CAPTUREE2)" treetype="template">
//  CAPTUREE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CAPTUREE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CAPTUREE2: Register Capture
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   CAPTUREE2 #(
      .ONESHOT("TRUE")  // Specifies the procedure for performing single readback per CAP trigger.
   )
   CAPTUREE2_inst (
      .CAP(CAP), // 1-bit input: Capture Input
      .CLK(CLK)  // 1-bit input: Clock Input
   );

   // End of CAPTUREE2_inst instantiation
				</Template>
				<Template label="STARTUP Block (STARTUPE2)" treetype="template">
//  STARTUPE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (STARTUPE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // STARTUPE2: STARTUP Block
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   STARTUPE2 #(
      .PROG_USR("FALSE"),  // Activate program event security feature. Requires encrypted bitstreams.
      .SIM_CCLK_FREQ(0.0)  // Set the Configuration Clock Frequency(ns) for simulation.
   )
   STARTUPE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration main clock output
      .CFGMCLK(CFGMCLK),     // 1-bit output: Configuration internal oscillator clock output
      .EOS(EOS),             // 1-bit output: Active high output signal indicating the End Of Startup.
      .PREQ(PREQ),           // 1-bit output: PROGRAM request to fabric output
      .CLK(CLK),             // 1-bit input: User start-up clock input
      .GSR(GSR),             // 1-bit input: Global Set/Reset input (GSR cannot be used for the port name)
      .GTS(GTS),             // 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      .KEYCLEARB(KEYCLEARB), // 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      .PACK(PACK),           // 1-bit input: PROGRAM acknowledge input
      .USRCCLKO(USRCCLKO),   // 1-bit input: User CCLK input
      .USRCCLKTS(USRCCLKTS), // 1-bit input: User CCLK 3-state enable input
      .USRDONEO(USRDONEO),   // 1-bit input: User DONE pin output control
      .USRDONETS(USRDONETS)  // 1-bit input: User DONE 3-state enable output
   );

   // End of STARTUPE2_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="I/O Components" treetype="folder">
				<SubFolder label="Bi-directional Buffers" treetype="folder">
					<Template label="Differential Buffer (IOBUFDS)" treetype="template">
//     IOBUFDS   : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IOBUFDS_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS: Differential Bi-directional Buffer
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .SLEW("SLOW")            // Specify the output slew rate
   ) IOBUFDS_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ Differential Output, input and DCI disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
// IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
//         Verilog        : the following instance declaration needs to be placed
//        instance        : in the body of the design code.  The instance name
//       declaration      : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations within the
//          code          : parenthesis may be changed to properly reference and
//                        : connect this function to the design.  Delete or comment
//                        : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_DCIEN: Differential Bi-directional Buffer with Differential Output,
   //                         Digital Controlled Impedance (DCI)and Input path enable/disable
   //                         May only be placed in High Performance (HP) Banks
   //                         Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_DCIEN #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUFDS_DIFF_OUT_DCIEN_inst (
      .O(O),     // Buffer p-side output
      .OB(OB),   // Buffer n-side output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .DCITERMDISABLE(DCITERMDISABLE), //  DCI Termination enable input
      .I(I),                           // Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // Input disable input, high=disable
      .TM(TM),   // 3-state enable input, high=input, low=output
      .TS(TS)    // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ input and DCI disable (IOBUFDS_DCIEN)" treetype="template">
// IOBUFDS_DCIEN : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DCIEN: Differential Bi-directional Buffer with Digital Controlled Impedance (DCI)
   //                and Input path enable/disable
   //                May only be placed in High Performance (HP) Banks
   //                Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DCIEN #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .SLEW("SLOW"),           // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUFDS_DCIEN_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .DCITERMDISABLE(DCITERMDISABLE), // DCI Termination enable input
      .I(I),                           // Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // Input disable input, high=disable
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ input and input termination disable (IOBUFDS_INTERMDISABLE)" treetype="template">
// IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_INTERMDISABLE: Differential Bi-directional Buffer with Input Termination
   //                        and Input path enable/disable
   //                        May only be placed in High Range (HR) Banks
   //                        Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_INTERMDISABLE #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .SLEW("SLOW"),           // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUFDS_INTERMDISABLE_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // Input disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // Input termination disable input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output (IOBUFDS_DIFF_OUT)" treetype="template">
// IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//      Verilog     : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//    declaration   : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  Delete or comment
//                  : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT: Differential Bi-directional Buffer with Differential Output
   //                   Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT #(
      .DIFF_TERM("FALSE"),    // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25") // Specify the I/O standard
   ) IOBUFDS_DIFF_OUT_inst (
      .O(O),     // Buffer p-side output
      .OB(OB),   // Buffer n-side output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .TM(TM),   // 3-state enable input, high=input, low=output
      .TS(TS)    // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Global Clock Buffer w/ Differential Output, INTERM and IBUF disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog             : the following instance declaration needs to be placed
//           instance             : in the body of the design code.  The instance name
//          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code               : parenthesis may be changed to properly reference and
//                                : connect this function to the design.  All inputs
//                                : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Global Clock Buffer with Differential Output
   //                                 Input Termination and Input Path Disable
   //                                 May only be placed in High Range (HR) Banks
   //                                 Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DIFF_TERM("FALSE"),     // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"),   // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IOBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),     // Buffer p-side output
      .OB(OB),   // Buffer n-side output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .INTERMDISABLE(INTERMDISABLE), //  Input termination disable input
      .IBUFDISABLE(IBUFDISABLE),     // Input disable input, high=disable
      .TM(TM),   // 3-state enable input, high=input, low=output
      .TS(TS)    // 3-state enable input, high=input, low=output
   );

   // End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Single-ended Buffer (IOBUF)" treetype="template">
//      IOBUF      : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IOBUF_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF: Single-ended Bi-directional Buffer
   //        All devices
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUF #(
      .DRIVE(12), // Specify the output drive strength
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("DEFAULT"), // Specify the I/O standard
      .SLEW("SLOW") // Specify the output slew rate
   ) IOBUF_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Buffer inout port (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUF_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ input and DCI disable (IOBUF_DCIEN)" treetype="template">
//   IOBUF_DCIEN   : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IOBUF_DCIEN_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_DCIEN: Single-ended Bi-directional Buffer with Digital Controlled Impedance (DCI)
   //              and Input path enable/disable
   //              May only be placed in High Performance (HP) Banks
   //              Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUF_DCIEN #(
      .DRIVE(12), // Specify the output drive strength
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("DEFAULT"), // Specify the I/O standard
      .SLEW("SLOW"),          // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUF_DCIEN_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Buffer inout port (connect directly to top-level port)
      .DCITERMDISABLE(DCITERMDISABLE), // DCI Termination enable input
      .I(I),     // Buffer input
      .IBUFDISABLE(IBUFDISABLE), // Input disable input, high=disable
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ input and INTERM disable (IOBUF_INTERMDISABLE)" treetype="template">
// IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog       : the following instance declaration needs to be placed
//      instance       : in the body of the design code.  The instance name
//     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code         : parenthesis may be changed to properly reference and
//                     : connect this function to the design.  Delete or comment
//                     : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_INTERMDISABLE: Single-ended Bi-directional Buffer with Input Termination
   //                      and Input path enable/disable
   //                      May only be placed in High Range (HR) Banks
   //                      Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUF_INTERMDISABLE #(
      .DRIVE(12), // Specify the output drive strength
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("DEFAULT"), // Specify the I/O standard
      .SLEW("SLOW"),          // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUF_INTERMDISABLE_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Buffer inout port (connect directly to top-level port)
      .I(I),     // Buffer input
      .IBUFDISABLE(IBUFDISABLE), // Input disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // Input termination disable input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DDR Registers" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
//    IDDR_2CLK  : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   //            Set, Reset and Clock Enable.
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_2CLK_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit primary clock input
      .CB(CB), // 1-bit secondary clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_2CLK_inst instantiation
					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
//      IDDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR: Input Double Data Rate Input Register with Set, Reset
   //       and Clock Enable.
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_inst instantiation
					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
//      ODDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (ODDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // ODDR: Output Double Data Rate Output Register with Set, Reset
   //       and Clock Enable.
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   ODDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE" or "SAME_EDGE" 
      .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) ODDR_inst (
      .Q(Q),   // 1-bit DDR output
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D1(D1), // 1-bit data input (positive edge)
      .D2(D2), // 1-bit data input (negative edge)
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of ODDR_inst instantiation
					</Template>
				</SubFolder>
				<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
//  DCIRESET   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DCIRESET_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DCIRESET: Digitally Controlled Impedance Reset Component
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   DCIRESET DCIRESET_inst (
      .LOCKED(LOCKED), // 1-bit output: LOCK status output
      .RST(RST)        // 1-bit input: Active-high asynchronous reset input
   );

   // End of DCIRESET_inst instantiation
				</Template>
				<SubFolder label="FIFOs" treetype="folder">
					<Template label="Input FIFO (IN_FIFO)" treetype="template">
//   IN_FIFO   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IN_FIFO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IN_FIFO: Input First-In, First-Out (FIFO)
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IN_FIFO #(
      .ALMOST_EMPTY_VALUE(1),          // Almost empty offset (1-2)
      .ALMOST_FULL_VALUE(1),           // Almost full offset (1-2)
      .ARRAY_MODE("ARRAY_MODE_4_X_8"), // ARRAY_MODE_4_X_8, ARRAY_MODE_4_X_4
      .SYNCHRONOUS_MODE("FALSE")       // Clock synchronous (FALSE)
   )
   IN_FIFO_inst (
      // FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output: Almost empty
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output: Almost full
      .EMPTY(EMPTY),             // 1-bit output: Empty
      .FULL(FULL),               // 1-bit output: Full
      // Q0-Q9: 8-bit (each) output: FIFO Outputs
      .Q0(Q0),                   // 8-bit output: Channel 0
      .Q1(Q1),                   // 8-bit output: Channel 1
      .Q2(Q2),                   // 8-bit output: Channel 2
      .Q3(Q3),                   // 8-bit output: Channel 3
      .Q4(Q4),                   // 8-bit output: Channel 4
      .Q5(Q5),                   // 8-bit output: Channel 5
      .Q6(Q6),                   // 8-bit output: Channel 6
      .Q7(Q7),                   // 8-bit output: Channel 7
      .Q8(Q8),                   // 8-bit output: Channel 8
      .Q9(Q9),                   // 8-bit output: Channel 9
      // D0-D9: 4-bit (each) input: FIFO inputs
      .D0(D0),                   // 4-bit input: Channel 0
      .D1(D1),                   // 4-bit input: Channel 1
      .D2(D2),                   // 4-bit input: Channel 2
      .D3(D3),                   // 4-bit input: Channel 3
      .D4(D4),                   // 4-bit input: Channel 4
      .D5(D5),                   // 8-bit input: Channel 5
      .D6(D6),                   // 8-bit input: Channel 6
      .D7(D7),                   // 4-bit input: Channel 7
      .D8(D8),                   // 4-bit input: Channel 8
      .D9(D9),                   // 4-bit input: Channel 9
      // FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      .RDCLK(RDCLK),             // 1-bit input: Read clock
      .RDEN(RDEN),               // 1-bit input: Read enable
      .RESET(RESET),             // 1-bit input: Reset
      .WRCLK(WRCLK),             // 1-bit input: Write clock
      .WREN(WREN)                // 1-bit input: Write enable
   );

   // End of IN_FIFO_inst instantiation
					</Template>
					<Template label="Output FIFO (OUT_FIFO)" treetype="template">
//  OUT_FIFO   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OUT_FIFO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OUT_FIFO: Output First-In, First-Out (FIFO) Buffer
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   OUT_FIFO #(
      .ALMOST_EMPTY_VALUE(1),          // Almost empty offset (1-2)
      .ALMOST_FULL_VALUE(1),           // Almost full offset (1-2)
      .ARRAY_MODE("ARRAY_MODE_8_X_4"), // ARRAY_MODE_8_X_4, ARRAY_MODE_4_X_4
      .OUTPUT_DISABLE("FALSE"),        // Disable output (FALSE, TRUE)
      .SYNCHRONOUS_MODE("FALSE")       // Must always be set to false.
   )
   OUT_FIFO_inst (
      // FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output: Almost empty flag
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output: Almost full flag
      .EMPTY(EMPTY),             // 1-bit output: Empty flag
      .FULL(FULL),               // 1-bit output: Full flag
      // Q0-Q9: 4-bit (each) output: FIFO Outputs
      .Q0(Q0),                   // 4-bit output: Channel 0 output bus
      .Q1(Q1),                   // 4-bit output: Channel 1 output bus
      .Q2(Q2),                   // 4-bit output: Channel 2 output bus
      .Q3(Q3),                   // 4-bit output: Channel 3 output bus
      .Q4(Q4),                   // 4-bit output: Channel 4 output bus
      .Q5(Q5),                   // 8-bit output: Channel 5 output bus
      .Q6(Q6),                   // 8-bit output: Channel 6 output bus
      .Q7(Q7),                   // 4-bit output: Channel 7 output bus
      .Q8(Q8),                   // 4-bit output: Channel 8 output bus
      .Q9(Q9),                   // 4-bit output: Channel 9 output bus
      // D0-D9: 8-bit (each) input: FIFO inputs
      .D0(D0),                   // 8-bit input: Channel 0 input bus
      .D1(D1),                   // 8-bit input: Channel 1 input bus
      .D2(D2),                   // 8-bit input: Channel 2 input bus
      .D3(D3),                   // 8-bit input: Channel 3 input bus
      .D4(D4),                   // 8-bit input: Channel 4 input bus
      .D5(D5),                   // 8-bit input: Channel 5 input bus
      .D6(D6),                   // 8-bit input: Channel 6 input bus
      .D7(D7),                   // 8-bit input: Channel 7 input bus
      .D8(D8),                   // 8-bit input: Channel 8 input bus
      .D9(D9),                   // 8-bit input: Channel 9 input bus
      // FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      .RDCLK(RDCLK),             // 1-bit input: Read clock
      .RDEN(RDEN),               // 1-bit input: Read enable
      .RESET(RESET),             // 1-bit input: Active high reset
      .WRCLK(WRCLK),             // 1-bit input: Write clock
      .WREN(WREN)                // 1-bit input: Write enable
   );

   // End of OUT_FIFO_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Input Buffers" treetype="folder">
					<Template label="Differential Buffer (IBUFDS)" treetype="template">
//   IBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS: Differential Input Buffer
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS #(
      .DIFF_TERM("FALSE"),       // Differential Termination
      .IBUF_LOW_PWR("TRUE"),     // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT")     // Specify the input I/O standard
   ) IBUFDS_inst (
      .O(O),  // Buffer output
      .I(I),  // Diff_p buffer input (connect directly to top-level port)
      .IB(IB) // Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ Disable (IBUFDS_IBUFDISABLE)" treetype="template">
// IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//     instance       : in the body of the design code.  The instance name
//    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations within the
//       code         : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_IBUFDISABLE: Differential Input Buffer with Input Disable
   //                     Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE #(
      .DIFF_TERM("FALSE"),      // Differential Termination
      .IBUF_LOW_PWR("TRUE"),    // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),   // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE")  // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_IBUFDISABLE_inst (
      .O(O),   // Buffer output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE) // Buffer disable input, high=disable
   );

   // End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output (IBUFDS_DIFF_OUT)" treetype="template">
// IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT: Differential Input Buffer with Differential Output
   //                  Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT #(
      .DIFF_TERM("FALSE"),   // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"), // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT") // Specify the input I/O standard
   ) IBUFDS_DIFF_OUT_inst (
      .O(O),   // Buffer diff_p output
      .OB(OB), // Buffer diff_n output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output w/ Input Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
//           Verilog           : the following instance declaration needs to be placed
//          instance           : in the body of the design code.  The instance name
//         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations within the
//            code             : parenthesis may be changed to properly reference and
//                             : connect this function to the design.  All inputs
//                             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer with Differential Output with Input Disable
   //                              Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE #(
      .DIFF_TERM("FALSE"),     // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"),   // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_DIFF_OUT_IBUFDISABLE_inst (
      .O(O),   // Buffer diff_p output
      .OB(OB), // Buffer diff_n output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // Buffer disable input, high=disable
   );

   // End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output w/ Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog            : the following instance declaration needs to be placed
//           instance            : in the body of the design code.  The instance name
//          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code              : parenthesis may be changed to properly reference and
//                               : connect this function to the design.  All inputs
//                               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Differential Output with Input Termination Disable
   //                                May only be placed in High Range (HR) Banks
   //                                Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE  #(
      .DIFF_TERM("FALSE"),     // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"),   // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),   // Buffer diff_p output
      .OB(OB), // Buffer diff_n output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),    // Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE) // Input Termination Disable
   );

   // End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
// IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog        : the following instance declaration needs to be placed
//      instance        : in the body of the design code.  The instance name
//     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//        code          : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_INTERMDISABLE: Differential Input Buffer with Input Termination Disable
   //                       May only be placed in High Range (HR) Banks
   //                       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE #(
      .DIFF_TERM("FALSE"),      // Differential Termination
      .IBUF_LOW_PWR("TRUE"),    // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),   // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE")  // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_INTERMDISABLE_inst (
      .O(O),   // Buffer output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),    // Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE) // Input Termination Disable
   );

   // End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Single-ended Buffer (IBUF)" treetype="template">
//      IBUF       : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUF_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IBUF: Single-ended Input Buffer
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IBUF #(
      .IBUF_LOW_PWR("TRUE"),  // Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards 
      .IOSTANDARD("DEFAULT")  // Specify the input I/O standard
   ) IBUF_inst (
      .O(O),     // Buffer output
      .I(I)      // Buffer input (connect directly to top-level port)
   );
  
   // End of IBUF_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ Disable (IBUF_IBUFDISABLE)" treetype="template">
//  IBUF_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog      : the following instance declaration needs to be placed
//     instance      : in the body of the design code.  The instance name
//    declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations within the
//       code        : parenthesis may be changed to properly reference and
//                   : connect this function to the design.  Delete or comment
//                   : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_IBUFDISABLE: Single-ended Input Buffer with Disable
   //                   Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IBUF_IBUFDISABLE #(
      .IBUF_LOW_PWR("TRUE"),   // Low power ("TRUE") vs. performance ("FALSE") for referenced I/O standards 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUF_IBUFDISABLE_inst (
      .O(O),                    // Buffer output
      .I(I),                    // Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE) // Buffer disable input, high=disable
   );
  
   // End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
//  IBUF_INTERMDISABLE : In order to incorporate this function into the design,
//      Verilog      : the following instance declaration needs to be placed
//     instance      : in the body of the design code.  The instance name
//    declaration    : (IBUF_INTERMDISABLE_inst) and/or the port declarations within the
//       code        : parenthesis may be changed to properly reference and
//                   : connect this function to the design.  Delete or comment
//                   : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_INTERMDISABLE: Single-ended Input Buffer with Termination Input Disable
   //                     May only be placed in High Range (HR) Banks
   //                     Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IBUF_INTERMDISABLE #(
      .IBUF_LOW_PWR("TRUE"),   // Low power ("TRUE") vs. performance ("FALSE") for referenced I/O standards 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUF_INTERMDISABLE_inst (
      .O(O),                    // Buffer output
      .I(I),                    // Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),    // Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE) // Input Termination Disable
   );
  
   // End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="I/O Delay Components" treetype="folder">
					<Template label="Delay Calibration (IDELAYCTRL)" treetype="template">
// IDELAYCTRL  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYCTRL: IDELAYE2/ODELAYE2 Tap Delay Value Control
   //             Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   (* IODELAY_GROUP = &lt;iodelay_group_name&gt; *) // Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

   IDELAYCTRL IDELAYCTRL_inst (
      .RDY(RDY),       // 1-bit output: Ready output
      .REFCLK(REFCLK), // 1-bit input: Reference clock input
      .RST(RST)        // 1-bit input: Active high reset input
   );

   // End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE2)" treetype="template">
//  IDELAYE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYE2: Input Fixed or Variable Delay Element
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   (* IODELAY_GROUP = &lt;iodelay_group_name&gt; *) // Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

   IDELAYE2 #(
      .CINVCTRL_SEL("FALSE"),          // Enable dynamic clock inversion (FALSE, TRUE)
      .DELAY_SRC("IDATAIN"),           // Delay input (IDATAIN, DATAIN)
      .HIGH_PERFORMANCE_MODE("FALSE"), // Reduced jitter ("TRUE"), Reduced power ("FALSE")
      .IDELAY_TYPE("FIXED"),           // FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      .IDELAY_VALUE(0),                // Input delay tap setting (0-31)
      .PIPE_SEL("FALSE"),              // Select pipelined mode, FALSE, TRUE
      .REFCLK_FREQUENCY(200.0),        // IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      .SIGNAL_PATTERN("DATA")          // DATA, CLOCK input signal
   )
   IDELAYE2_inst (
      .CNTVALUEOUT(CNTVALUEOUT), // 5-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data output
      .C(C),                     // 1-bit input: Clock input
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CINVCTRL(CINVCTRL),       // 1-bit input: Dynamic clock inversion input
      .CNTVALUEIN(CNTVALUEIN),   // 5-bit input: Counter value input
      .DATAIN(DATAIN),           // 1-bit input: Internal delay data input
      .IDATAIN(IDATAIN),         // 1-bit input: Data input from the I/O
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LD(LD),                   // 1-bit input: Load IDELAY_VALUE input
      .LDPIPEEN(LDPIPEEN),       // 1-bit input: Enable PIPELINE register to load data input
      .REGRST(REGRST)            // 1-bit input: Active-high reset tap-delay input
   );

   // End of IDELAYE2_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE2)" treetype="template">
//  ODELAYE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODELAYE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODELAYE2: Output Fixed or Variable Delay Element
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   (* IODELAY_GROUP = &lt;iodelay_group_name&gt; *) // Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

   ODELAYE2 #(
      .CINVCTRL_SEL("FALSE"),          // Enable dynamic clock inversion (FALSE, TRUE)
      .DELAY_SRC("ODATAIN"),           // Delay input (ODATAIN, CLKIN)
      .HIGH_PERFORMANCE_MODE("FALSE"), // Reduced jitter ("TRUE"), Reduced power ("FALSE")
      .ODELAY_TYPE("FIXED"),           // FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      .ODELAY_VALUE(0),                // Output delay tap setting (0-31)
      .PIPE_SEL("FALSE"),              // Select pipelined mode, FALSE, TRUE
      .REFCLK_FREQUENCY(200.0),        // IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      .SIGNAL_PATTERN("DATA")          // DATA, CLOCK input signal
   )
   ODELAYE2_inst (
      .CNTVALUEOUT(CNTVALUEOUT), // 5-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data/clock output
      .C(C),                     // 1-bit input: Clock input
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CINVCTRL(CINVCTRL),       // 1-bit input: Dynamic clock inversion input
      .CLKIN(CLKIN),             // 1-bit input: Clock delay input
      .CNTVALUEIN(CNTVALUEIN),   // 5-bit input: Counter value input
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LD(LD),                   // 1-bit input: Loads ODELAY_VALUE tap delay in VARIABLE mode, in VAR_LOAD or
                                 // VAR_LOAD_PIPE mode, loads the value of CNTVALUEIN

      .LDPIPEEN(LDPIPEEN),       // 1-bit input: Enables the pipeline register to load data
      .ODATAIN(ODATAIN),         // 1-bit input: Output delay data input
      .REGRST(REGRST)            // 1-bit input: Active-high reset tap-delay input
   );

   // End of ODELAYE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="I/O SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer with Bitslip (ISERDESE2)" treetype="template">
//  ISERDESE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ISERDESE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ISERDESE2: Input SERial/DESerializer with Bitslip
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   ISERDESE2 #(
      .DATA_RATE("DDR"),           // DDR, SDR
      .DATA_WIDTH(4),              // Parallel data width (2-8,10,14)
      .DYN_CLKDIV_INV_EN("FALSE"), // Enable DYNCLKDIVINVSEL inversion (FALSE, TRUE)
      .DYN_CLK_INV_EN("FALSE"),    // Enable DYNCLKINVSEL inversion (FALSE, TRUE)
      // INIT_Q1 - INIT_Q4: Initial value on the Q outputs (0/1)
      .INIT_Q1(1'b0),
      .INIT_Q2(1'b0),
      .INIT_Q3(1'b0),
      .INIT_Q4(1'b0),
      .INTERFACE_TYPE("MEMORY"),   // MEMORY, MEMORY_DDR3, MEMORY_QDR, NETWORKING, OVERSAMPLE
      .IOBDELAY("NONE"),           // NONE, BOTH, IBUF, IFD
      .NUM_CE(2),                  // Number of clock enables (1,2)
      .OFB_USED("FALSE"),          // Select OFB path (FALSE, TRUE)
      .SERDES_MODE("MASTER"),      // MASTER, SLAVE
      // SRVAL_Q1 - SRVAL_Q4: Q output values when SR is used (0/1)
      .SRVAL_Q1(1'b0),
      .SRVAL_Q2(1'b0),
      .SRVAL_Q3(1'b0),
      .SRVAL_Q4(1'b0) 
   )
   ISERDESE2_inst (
      .O(O),                       // 1-bit output: Combinatorial output
      // Q1 - Q8: 1-bit (each) output: Registered data outputs
      .Q1(Q1),
      .Q2(Q2),
      .Q3(Q3),
      .Q4(Q4),
      .Q5(Q5),
      .Q6(Q6),
      .Q7(Q7),
      .Q8(Q8),
      // SHIFTOUT1, SHIFTOUT2: 1-bit (each) output: Data width expansion output ports
      .SHIFTOUT1(SHIFTOUT1),
      .SHIFTOUT2(SHIFTOUT2),
      .BITSLIP(BITSLIP),           // 1-bit input: The BITSLIP pin performs a Bitslip operation synchronous to
                                   // CLKDIV when asserted (active High). Subsequently, the data seen on the Q1
                                   // to Q8 output ports will shift, as in a barrel-shifter operation, one
                                   // position every time Bitslip is invoked (DDR operation is different from
                                   // SDR).

      // CE1, CE2: 1-bit (each) input: Data register clock enable inputs
      .CE1(CE1),
      .CE2(CE2),
      .CLKDIVP(CLKDIVP),           // 1-bit input: TBD
      // Clocks: 1-bit (each) input: ISERDESE2 clock input ports
      .CLK(CLK),                   // 1-bit input: High-speed clock
      .CLKB(CLKB),                 // 1-bit input: High-speed secondary clock
      .CLKDIV(CLKDIV),             // 1-bit input: Divided clock
      .OCLK(OCLK),                 // 1-bit input: High speed output clock used when INTERFACE_TYPE="MEMORY" 
      // Dynamic Clock Inversions: 1-bit (each) input: Dynamic clock inversion pins to switch clock polarity
      .DYNCLKDIVSEL(DYNCLKDIVSEL), // 1-bit input: Dynamic CLKDIV inversion
      .DYNCLKSEL(DYNCLKSEL),       // 1-bit input: Dynamic CLK/CLKB inversion
      // Input Data: 1-bit (each) input: ISERDESE2 data input ports
      .D(D),                       // 1-bit input: Data input
      .DDLY(DDLY),                 // 1-bit input: Serial data from IDELAYE2
      .OFB(OFB),                   // 1-bit input: Data feedback from OSERDESE2
      .OCLKB(OCLKB),               // 1-bit input: High speed negative edge output clock
      .RST(RST),                   // 1-bit input: Active high asynchronous reset
      // SHIFTIN1, SHIFTIN2: 1-bit (each) input: Data width expansion input ports
      .SHIFTIN1(SHIFTIN1),
      .SHIFTIN2(SHIFTIN2) 
   );

   // End of ISERDESE2_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer with bitslip (OSERDESE2)" treetype="template">
//  OSERDESE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OSERDESE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OSERDESE2: Output SERial/DESerializer with bitslip
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   OSERDESE2 #(
      .DATA_RATE_OQ("DDR"),   // DDR, SDR
      .DATA_RATE_TQ("DDR"),   // DDR, BUF, SDR
      .DATA_WIDTH(4),         // Parallel data width (2-8,10,14)
      .INIT_OQ(1'b0),         // Initial value of OQ output (1'b0,1'b1)
      .INIT_TQ(1'b0),         // Initial value of TQ output (1'b0,1'b1)
      .SERDES_MODE("MASTER"), // MASTER, SLAVE
      .SRVAL_OQ(1'b0),        // OQ output value when SR is used (1'b0,1'b1)
      .SRVAL_TQ(1'b0),        // TQ output value when SR is used (1'b0,1'b1)
      .TBYTE_CTL("FALSE"),    // Enable tristate byte operation (FALSE, TRUE)
      .TBYTE_SRC("FALSE"),    // Tristate byte source (FALSE, TRUE)
      .TRISTATE_WIDTH(4)      // 3-state converter width (1,4)
   )
   OSERDESE2_inst (
      .OFB(OFB),             // 1-bit output: Feedback path for data
      .OQ(OQ),               // 1-bit output: Data path output
      // SHIFTOUT1 / SHIFTOUT2: 1-bit (each) output: Data output expansion (1-bit each)
      .SHIFTOUT1(SHIFTOUT1),
      .SHIFTOUT2(SHIFTOUT2),
      .TBYTEOUT(TBYTEOUT),   // 1-bit output: Byte group tristate
      .TFB(TFB),             // 1-bit output: 3-state control
      .TQ(TQ),               // 1-bit output: 3-state control
      .CLK(CLK),             // 1-bit input: High speed clock
      .CLKDIV(CLKDIV),       // 1-bit input: Divided clock
      // D1 - D8: 1-bit (each) input: Parallel data inputs (1-bit each)
      .D1(D1),
      .D2(D2),
      .D3(D3),
      .D4(D4),
      .D5(D5),
      .D6(D6),
      .D7(D7),
      .D8(D8),
      .OCE(OCE),             // 1-bit input: Output data clock enable
      .RST(RST),             // 1-bit input: Reset
      // SHIFTIN1 / SHIFTIN2: 1-bit (each) input: Data input expansion (1-bit each)
      .SHIFTIN1(SHIFTIN1),
      .SHIFTIN2(SHIFTIN2),
      // T1 - T4: 1-bit (each) input: Parallel 3-state inputs
      .T1(T1),
      .T2(T2),
      .T3(T3),
      .T4(T4),
      .TBYTEIN(TBYTEIN),     // 1-bit input: Byte group tristate
      .TCE(TCE)              // 1-bit input: 3-state clock enable
   );

   // End of OSERDESE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Output Buffers" treetype="folder">
					<Template label="Differential Buffer (OBUFDS)" treetype="template">

//     OBUFDS      : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFDS_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS: Differential Output Buffer
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   OBUFDS #(
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW")           // Specify the output slew rate
   ) OBUFDS_inst (
      .O(O),     // Diff_p output (connect directly to top-level port)
      .OB(OB),   // Diff_n output (connect directly to top-level port)
      .I(I)      // Buffer input 
   );
  
   // End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential 3-state Buffer (OBUFTDS)" treetype="template">
//     OBUFTDS   : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (OBUFTDS_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUFTDS: Differential 3-state Output Buffer
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   OBUFTDS #(
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW")           // Specify the output slew rate
   ) OBUFTDS_inst (
      .O(O),     // Diff_p output (connect directly to top-level port)
      .OB(OB),   // Diff_n output (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input
   );
  
   // End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Single-ended Buffer (OBUF)" treetype="template">
//      OBUF       : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUF_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUF: Single-ended Output Buffer
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   OBUF #(
      .DRIVE(12),   // Specify the output drive strength
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW") // Specify the output slew rate
   ) OBUF_inst (
      .O(O),     // Buffer output (connect directly to top-level port)
      .I(I)      // Buffer input 
   );
  
   // End of OBUF_inst instantiation
					</Template>
					<Template label="Single-ended 3-state Buffer (OBUFT)" treetype="template">
//      OBUFT      : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUFT: Single-ended 3-state Output Buffer
   //        All devices
   // Xilinx HDL Language Template, version 2016.4
   
   OBUFT #(
      .DRIVE(12),   // Specify the output drive strength
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW") // Specify the output slew rate
   ) OBUFT_inst (
      .O(O),     // Buffer output (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input 
   );
  
  // End of OBUFT_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Weak drivers" treetype="folder">
					<Template label="KEEPER" treetype="template">
//     KEEPER    : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (KEEPER_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.

//  &lt;-----Cut code below this line----&gt;

   // KEEPER: I/O Buffer Weak Keeper
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   KEEPER KEEPER_inst (
      .O(O)     // Keeper output (connect directly to top-level port)
   );
  
   // End of KEEPER_inst instantiation
					</Template>
					<Template label="PULLDOWN" treetype="template">
//    PULLDOWN   : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (PULLDOWN_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.

//  &lt;-----Cut code below this line----&gt;

   // PULLDOWN: I/O Buffer Weak Pull-down
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   PULLDOWN PULLDOWN_inst (
      .O(O)     // Pulldown output (connect directly to top-level port)
   );
  
   // End of PULLDOWN_inst instantiation
					</Template>
					<Template label="PULLUP" treetype="template">
//     PULLUP    : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (PULLUP_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.


//  &lt;-----Cut code below this line----&gt;

   // PULLUP: I/O Buffer Weak Pull-up
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   PULLUP PULLUP_inst (
      .O(O)     // Pullup output (connect directly to top-level port)
   );
  
   // End of PULLUP_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="RAM/ROM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E1)" treetype="template">
//  RAMB18E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB18E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB18E1: 18K-bit Configurable Synchronous Block RAM
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAMB18E1 #(
      // Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      .RDADDR_COLLISION_HWCONFIG("DELAYED_WRITE"),
      // Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0 or 1)
      .DOA_REG(0),
      .DOB_REG(0),
      // INITP_00 to INITP_07: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_3F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(18'h00000),
      .INIT_B(18'h00000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // RAM Mode: "SDP" or "TDP" 
      .RAM_MODE("TDP"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-72
      .READ_WIDTH_B(0),                                                                 // 0-18
      .WRITE_WIDTH_A(0),                                                                // 0-18
      .WRITE_WIDTH_B(0),                                                                // 0-72
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(18'h00000),
      .SRVAL_B(18'h00000),
      // Simulation Device: Must be set to "7SERIES" for simulation behavior
      .SIM_DEVICE("7SERIES"),
      // WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      .WRITE_MODE_A("WRITE_FIRST"),
      .WRITE_MODE_B("WRITE_FIRST") 
   )
   RAMB18E1_inst (
      // Port A Data: 16-bit (each) output: Port A data
      .DOADO(DOADO),                 // 16-bit output: A port data/LSB data
      .DOPADOP(DOPADOP),             // 2-bit output: A port parity/LSB parity
      // Port B Data: 16-bit (each) output: Port B data
      .DOBDO(DOBDO),                 // 16-bit output: B port data/MSB data
      .DOPBDOP(DOPBDOP),             // 2-bit output: B port parity/MSB parity
      // Port A Address/Control Signals: 14-bit (each) input: Port A address and control signals (read port
      // when RAM_MODE="SDP")
      .ADDRARDADDR(ADDRARDADDR),     // 14-bit input: A port address/Read address
      .CLKARDCLK(CLKARDCLK),         // 1-bit input: A port clock/Read clock
      .ENARDEN(ENARDEN),             // 1-bit input: A port enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),     // 1-bit input: A port register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM), // 1-bit input: A port set/reset
      .RSTREGARSTREG(RSTREGARSTREG), // 1-bit input: A port register set/reset
      .WEA(WEA),                     // 2-bit input: A port write enable
      // Port A Data: 16-bit (each) input: Port A data
      .DIADI(DIADI),                 // 16-bit input: A port data/LSB data
      .DIPADIP(DIPADIP),             // 2-bit input: A port parity/LSB parity
      // Port B Address/Control Signals: 14-bit (each) input: Port B address and control signals (write port
      // when RAM_MODE="SDP")
      .ADDRBWRADDR(ADDRBWRADDR),     // 14-bit input: B port address/Write address
      .CLKBWRCLK(CLKBWRCLK),         // 1-bit input: B port clock/Write clock
      .ENBWREN(ENBWREN),             // 1-bit input: B port enable/Write enable
      .REGCEB(REGCEB),               // 1-bit input: B port register enable
      .RSTRAMB(RSTRAMB),             // 1-bit input: B port set/reset
      .RSTREGB(RSTREGB),             // 1-bit input: B port register set/reset
      .WEBWE(WEBWE),                 // 4-bit input: B port write enable/Write enable
      // Port B Data: 16-bit (each) input: Port B data
      .DIBDI(DIBDI),                 // 16-bit input: B port data/MSB data
      .DIPBDIP(DIPBDIP)              // 2-bit input: B port parity/MSB parity
   );

   // End of RAMB18E1_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E1)" treetype="template">
//  RAMB36E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB36E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB36E1: 36K-bit Configurable Synchronous Block RAM
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAMB36E1 #(
      // Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      .RDADDR_COLLISION_HWCONFIG("DELAYED_WRITE"),
      // Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0 or 1)
      .DOA_REG(0),
      .DOB_REG(0),
      .EN_ECC_READ("FALSE"),                                                            // Enable ECC decoder,
                                                                                        // FALSE, TRUE
      .EN_ECC_WRITE("FALSE"),                                                           // Enable ECC encoder,
                                                                                        // FALSE, TRUE
      // INITP_00 to INITP_0F: Initial contents of the parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_7F: Initial contents of the data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(36'h000000000),
      .INIT_B(36'h000000000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // RAM Mode: "SDP" or "TDP" 
      .RAM_MODE("TDP"),
      // RAM_EXTENSION_A, RAM_EXTENSION_B: Selects cascade mode ("UPPER", "LOWER", or "NONE")
      .RAM_EXTENSION_A("NONE"),
      .RAM_EXTENSION_B("NONE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-72
      .READ_WIDTH_B(0),                                                                 // 0-36
      .WRITE_WIDTH_A(0),                                                                // 0-36
      .WRITE_WIDTH_B(0),                                                                // 0-72
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(36'h000000000),
      .SRVAL_B(36'h000000000),
      // Simulation Device: Must be set to "7SERIES" for simulation behavior
      .SIM_DEVICE("7SERIES"),
      // WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      .WRITE_MODE_A("WRITE_FIRST"),
      .WRITE_MODE_B("WRITE_FIRST") 
   )
   RAMB36E1_inst (
      // Cascade Signals: 1-bit (each) output: BRAM cascade ports (to create 64kx1)
      .CASCADEOUTA(CASCADEOUTA),     // 1-bit output: A port cascade
      .CASCADEOUTB(CASCADEOUTB),     // 1-bit output: B port cascade
      // ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .RDADDRECC(RDADDRECC),         // 9-bit output: ECC read address
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Port A Data: 32-bit (each) output: Port A data
      .DOADO(DOADO),                 // 32-bit output: A port data/LSB data
      .DOPADOP(DOPADOP),             // 4-bit output: A port parity/LSB parity
      // Port B Data: 32-bit (each) output: Port B data
      .DOBDO(DOBDO),                 // 32-bit output: B port data/MSB data
      .DOPBDOP(DOPBDOP),             // 4-bit output: B port parity/MSB parity
      // Cascade Signals: 1-bit (each) input: BRAM cascade ports (to create 64kx1)
      .CASCADEINA(CASCADEINA),       // 1-bit input: A port cascade
      .CASCADEINB(CASCADEINB),       // 1-bit input: B port cascade
      // ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR), // 1-bit input: Inject a single bit error
      // Port A Address/Control Signals: 16-bit (each) input: Port A address and control signals (read port
      // when RAM_MODE="SDP")
      .ADDRARDADDR(ADDRARDADDR),     // 16-bit input: A port address/Read address
      .CLKARDCLK(CLKARDCLK),         // 1-bit input: A port clock/Read clock
      .ENARDEN(ENARDEN),             // 1-bit input: A port enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),     // 1-bit input: A port register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM), // 1-bit input: A port set/reset
      .RSTREGARSTREG(RSTREGARSTREG), // 1-bit input: A port register set/reset
      .WEA(WEA),                     // 4-bit input: A port write enable
      // Port A Data: 32-bit (each) input: Port A data
      .DIADI(DIADI),                 // 32-bit input: A port data/LSB data
      .DIPADIP(DIPADIP),             // 4-bit input: A port parity/LSB parity
      // Port B Address/Control Signals: 16-bit (each) input: Port B address and control signals (write port
      // when RAM_MODE="SDP")
      .ADDRBWRADDR(ADDRBWRADDR),     // 16-bit input: B port address/Write address
      .CLKBWRCLK(CLKBWRCLK),         // 1-bit input: B port clock/Write clock
      .ENBWREN(ENBWREN),             // 1-bit input: B port enable/Write enable
      .REGCEB(REGCEB),               // 1-bit input: B port register enable
      .RSTRAMB(RSTRAMB),             // 1-bit input: B port set/reset
      .RSTREGB(RSTREGB),             // 1-bit input: B port register set/reset
      .WEBWE(WEBWE),                 // 8-bit input: B port write enable/Write enable
      // Port B Data: 32-bit (each) input: Port B data
      .DIBDI(DIBDI),                 // 32-bit input: B port data/MSB data
      .DIPBDIP(DIPBDIP)              // 4-bit input: B port parity/MSB parity
   );

   // End of RAMB36E1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Distributed RAM" treetype="folder">
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 X 1 negedge write (RAM32X1D_1)" treetype="template">
//  RAM32X1D_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_1_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D_1: 32 x 1 negative edge write, asynchronous read dual-port
   //             distributed RAM (Mapped to a SliceM LUT6)
   //             Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1 #(
      .INIT(32'h00000000) // Initial contents of RAM
   ) RAM32X1D_1_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_1_inst instantiation
						</Template>
						<Template label="32 X 1 posedge write (RAM32X1D)" treetype="template">
//   RAM32X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D: 32 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to a SliceM LUT6)
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D #(
      .INIT(32'h00000000) // Initial contents of RAM
   ) RAM32X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_inst instantiation
						</Template>
						<Template label="64 X 1 posedge write (RAM64X1D)" treetype="template">
//   RAM64X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM64X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1D: 64 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to a SliceM LUT6)
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1D #(
      .INIT(64'h0000000000000000) // Initial contents of RAM
   ) RAM64X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .A5(A5),       // Rw/ address[5] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .DPRA5(DPRA5), // Read-only address[5] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM64X1D_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">
//  RAM128X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM128X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read  (Mapped to two SliceM LUT6s)
   //            dual-port distributed LUT RAM
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   RAM128X1D #(
      .INIT(128'h00000000000000000000000000000000)
   ) RAM128X1D_inst (
      .DPO(DPO),   // Read port 1-bit output
      .SPO(SPO),   // Read/write port 1-bit output
      .A(A),       // Read/write port 7-bit address input
      .D(D),       // RAM data input
      .DPRA(DPRA), // Read port 7-bit address input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM128X1D_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">
//   RAM32M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32M: 32-deep by 8-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4
      
   RAM32M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000)  // Initial contents of D Port
   ) RAM32M_inst (
      .DOA(DOA),     // Read port A 2-bit output
      .DOB(DOB),     // Read port B 2-bit output
      .DOC(DOC),     // Read port C 2-bit output
      .DOD(DOD),     // Read/write port D 2-bit output
      .ADDRA(ADDRA), // Read port A 5-bit address input
      .ADDRB(ADDRB), // Read port B 5-bit address input
      .ADDRC(ADDRC), // Read port C 5-bit address input
      .ADDRD(ADDRD), // Read/write port D 5-bit address input
      .DIA(DIA),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );
   
   // End of RAM32M_inst instantiation
						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">
//   RAM64M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64M: 64-deep by 4-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   RAM64M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000)  // Initial contents of D Port
   ) RAM64M_inst (
      .DOA(DOA),     // Read port A 1-bit output
      .DOB(DOB),     // Read port B 1-bit output
      .DOC(DOC),     // Read port C 1-bit output
      .DOD(DOD),     // Read/write port D 1-bit output
      .DIA(DIA),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .ADDRA(ADDRA), // Read port A 6-bit address input
      .ADDRB(ADDRB), // Read port B 6-bit address input
      .ADDRC(ADDRC), // Read port C 6-bit address input
      .ADDRD(ADDRD), // Read/write port D 6-bit address input
      .WE(WE),       // Write enable input
      .WCLK(WCLK)    // Write clock input
   );

   // End of RAM64M_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<SubFolder label="32 Deep (5-bit address)" treetype="folder">
							<Template label="32 x 1 negedge write (RAM32X1S_1)" treetype="template">
// RAM32X1S_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1S_1: 32 x 1 negedge write distributed (LUT) RAM (Mapped to a SliceM LUT6)
   //             Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1S_1 #(
      .INIT(32'h00000000)  // Initial contents of RAM
   )RAM32X1S_1_inst (
      .O(O),       // RAM output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D(D),       // RAM data input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X1S_1_inst instantiation
							</Template>
							<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">
//  RAM32X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM (Mapped to a SliceM LUT6)
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1S #(
      .INIT(32'h00000000)  // Initial contents of RAM
   ) RAM32X1S_inst (
      .O(O),       // RAM output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D(D),       // RAM data input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X1S_inst instantiation
							</Template>
							<Template label="32 x 2 posedge write (RAM32X2S)" treetype="template">
//  RAM32X2S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM16X2S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X2S: 32 x 2 posedge write distributed (LUT) RAM (Mapped to a SliceM LUT6)
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X2S #(
      .INIT_00(32'h00000000), // INIT for bit 0 of RAM
      .INIT_01(32'h00000000)  // INIT for bit 1 of RAM
   ) RAM32X2S_inst (
      .O0(O0),     // RAM data[0] output
      .O1(O1),     // RAM data[1] output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D0(D0),     // RAM data[0] input
      .D1(D1),     // RAM data[1] input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X2S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="64 Deep (6-bit address)" treetype="folder">
							<Template label="64 X 1 negedge write (RAM64X1S_1)" treetype="template">
//  RAM64X1S_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1S_1: 64 x 1 negative edge write, asynchronous read single-port
   //             distributed RAM (Mapped to a SliceM LUT6)
   //             Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1S_1 #(
      .INIT(64'h0000000000000000) // Initial contents of RAM
   ) RAM64X1S_1_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM64X1S_1_inst instantiation
							</Template>
							<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">
//  RAM64X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port
   //           distributed RAM (Mapped to a SliceM LUT6)
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1S #(
      .INIT(64'h0000000000000000) // Initial contents of RAM
   ) RAM64X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM64X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="128 Deep (7-bit address)" treetype="folder">
							<Template label="128 X 1 negedge write (RAM128X1S_1)" treetype="template">
// RAM128X1S_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S_1: 128 x 1 negative edge write, asynchronous read single-port
   //              distributed RAM (Mapped to two SliceM LUT6s)
   //              Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1 #(
      .INIT(128'h00000000000000000000000000000000)  // Initial contents of RAM
   ) RAM128X1S_1_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_1_inst instantiation
							</Template>
							<Template label="128 X 1 posedge write (RAM128X1S)" treetype="template">
//  RAM128X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S: 128 x 1 positive edge write, asynchronous read single-port
   //            distributed RAM (Mapped to two SliceM LUT6s)
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S #(
      .INIT(128'h00000000000000000000000000000000) // Initial contents of RAM
   ) RAM128X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="256 Deep (8-bit address)" treetype="folder">
							<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">
//  RAM256X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM256X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read  (Mapped to four SliceM LUT6s)
   //            single-port distributed LUT RAM
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   RAM256X1S #( 
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) RAM256X1S_inst (
      .O(O),       // Read/write port 1-bit output
      .A(A),       // Read/write port 8-bit address input
      .WE(WE),     // Write enable input
      .WCLK(WCLK), // Write clock input
      .D(D)        // RAM data input
   );

   // End of RAM256X1S_inst instantiation
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Distributed ROM" treetype="folder">
					<Template label="32 X 1 (ROM32X1)" treetype="template">
//   ROM32X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM32X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM32X1: 32 x 1 Asynchronous Distributed (LUT) ROM (Mapped to a SliceM LUT6)
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   ROM32X1 #(
      .INIT(32'h00000000) // Contents of ROM
   ) ROM32X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4)  // ROM address[4]
   );

   // End of ROM32X1_inst instantiation
					</Template>
					<Template label="64 X 1 (ROM64X1)" treetype="template">
//   ROM64X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM64X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM64X1: 64 x 1 Asynchronous Distributed (LUT) ROM (Mapped to a SliceM LUT6)
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   ROM64X1 #(
      .INIT(64'h0000000000000000) // Contents of ROM
   ) ROM64X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4), // ROM address[4]
      .A5(A5)  // ROM address[5]
   );

   // End of ROM64X1_inst instantiation
					</Template>
					<Template label="128 X 1 (ROM128X1)" treetype="template">
//   ROM128X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM128X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM128X1: 128 x 1 Asynchronous Distributed (LUT) ROM (Mapped to two SliceM LUT6s)
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   ROM128X1 #(
      .INIT(128'h00000000000000000000000000000000) // Contents of ROM
   ) ROM128X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4), // ROM address[4]
      .A5(A5), // ROM address[5]
      .A6(A6)  // ROM address[6]
   );

   // End of ROM128X1_inst instantiation
					</Template>
					<Template label="256 X 1 (ROM256X1)" treetype="template">
//   ROM256X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM256X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM256X1: 256 x 1 Asynchronous Distributed (LUT) ROM (Mapped to four SliceM LUT6s)
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   ROM256X1 #(
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000) // Contents of ROM
   ) ROM256X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4), // ROM address[4]
      .A5(A5), // ROM address[5]
      .A6(A6), // ROM address[6]
      .A7(A7)  // ROM address[7]
   );

   // End of ROM256X1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E1)" treetype="template">
//  FIFO18E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO18E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO18E1: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   FIFO18E1 #(
      .ALMOST_EMPTY_OFFSET(13'h0080),    // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(13'h0080),     // Sets almost full threshold
      .DATA_WIDTH(4),                    // Sets data width to 4-36
      .DO_REG(1),                        // Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      .EN_SYN("FALSE"),                  // Specifies FIFO as dual-clock (FALSE) or Synchronous (TRUE)
      .FIFO_MODE("FIFO18"),              // Sets mode to FIFO18 or FIFO18_36
      .FIRST_WORD_FALL_THROUGH("FALSE"), // Sets the FIFO FWFT to FALSE, TRUE
      .INIT(36'h000000000),              // Initial values on output port
      .SIM_DEVICE("7SERIES"),            // Must be set to "7SERIES" for simulation behavior
      .SRVAL(36'h000000000)              // Set/Reset value for output port
   )
   FIFO18E1_inst (
      // Read Data: 32-bit (each) output: Read output data
      .DO(DO),                   // 32-bit output: Data output
      .DOP(DOP),                 // 4-bit output: Parity data output
      // Status: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output: Almost empty flag
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output: Almost full flag
      .EMPTY(EMPTY),             // 1-bit output: Empty flag
      .FULL(FULL),               // 1-bit output: Full flag
      .RDCOUNT(RDCOUNT),         // 12-bit output: Read count
      .RDERR(RDERR),             // 1-bit output: Read error
      .WRCOUNT(WRCOUNT),         // 12-bit output: Write count
      .WRERR(WRERR),             // 1-bit output: Write error
      // Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      .RDCLK(RDCLK),             // 1-bit input: Read clock
      .RDEN(RDEN),               // 1-bit input: Read enable
      .REGCE(REGCE),             // 1-bit input: Clock enable
      .RST(RST),                 // 1-bit input: Asynchronous Reset
      .RSTREG(RSTREG),           // 1-bit input: Output register set/reset
      // Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      .WRCLK(WRCLK),             // 1-bit input: Write clock
      .WREN(WREN),               // 1-bit input: Write enable
      // Write Data: 32-bit (each) input: Write input data
      .DI(DI),                   // 32-bit input: Data input
      .DIP(DIP)                  // 4-bit input: Parity input
   );

   // End of FIFO18E1_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E1)" treetype="template">
//  FIFO36E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO36E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO36E1: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   FIFO36E1 #(
      .ALMOST_EMPTY_OFFSET(13'h0080),    // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(13'h0080),     // Sets almost full threshold
      .DATA_WIDTH(4),                    // Sets data width to 4-72
      .DO_REG(1),                        // Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      .EN_ECC_READ("FALSE"),             // Enable ECC decoder, FALSE, TRUE
      .EN_ECC_WRITE("FALSE"),            // Enable ECC encoder, FALSE, TRUE
      .EN_SYN("FALSE"),                  // Specifies FIFO as Asynchronous (FALSE) or Synchronous (TRUE)
      .FIFO_MODE("FIFO36"),              // Sets mode to "FIFO36" or "FIFO36_72" 
      .FIRST_WORD_FALL_THROUGH("FALSE"), // Sets the FIFO FWFT to FALSE, TRUE
      .INIT(72'h000000000000000000),     // Initial values on output port
      .SIM_DEVICE("7SERIES"),            // Must be set to "7SERIES" for simulation behavior
      .SRVAL(72'h000000000000000000)     // Set/Reset value for output port
   )
   FIFO36E1_inst (
      // ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Read Data: 64-bit (each) output: Read output data
      .DO(DO),                       // 64-bit output: Data output
      .DOP(DOP),                     // 8-bit output: Parity data output
      // Status: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY),     // 1-bit output: Almost empty flag
      .ALMOSTFULL(ALMOSTFULL),       // 1-bit output: Almost full flag
      .EMPTY(EMPTY),                 // 1-bit output: Empty flag
      .FULL(FULL),                   // 1-bit output: Full flag
      .RDCOUNT(RDCOUNT),             // 13-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .WRCOUNT(WRCOUNT),             // 13-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write error
      // ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error input
      .INJECTSBITERR(INJECTSBITERR),
      // Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Clock enable
      .RST(RST),                     // 1-bit input: Reset
      .RSTREG(RSTREG),               // 1-bit input: Output register set/reset
      // Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      .WRCLK(WRCLK),                 // 1-bit input: Rising edge write clock.
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data: 64-bit (each) input: Write input data
      .DI(DI),                       // 64-bit input: Data input
      .DIP(DIP)                      // 8-bit input: Parity input
   );

   // End of FIFO36E1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Registers &amp; Latches" treetype="folder">
				<SubFolder label="Double Data Rate" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
//    IDDR_2CLK  : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   //            Set, Reset and Clock Enable.
   //            Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_2CLK_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit primary clock input
      .CB(CB), // 1-bit secondary clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_2CLK_inst instantiation
					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
//      IDDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR: Input Double Data Rate Input Register with Set, Reset
   //       and Clock Enable.
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_inst instantiation
					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
//      ODDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (ODDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // ODDR: Output Double Data Rate Output Register with Set, Reset
   //       and Clock Enable.
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   ODDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE" or "SAME_EDGE" 
      .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) ODDR_inst (
      .Q(Q),   // 1-bit DDR output
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D1(D1), // 1-bit data input (positive edge)
      .D2(D2), // 1-bit data input (negative edge)
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of ODDR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Single Data Rate" treetype="folder">
					<Template label="Posedge D-FF w/ Async Clear and CE (FDCE)" treetype="template">
//     FDCE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDCE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and
   //       Clock Enable (posedge clk).
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDCE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDCE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .CLR(CLR),  // 1-bit Asynchronous clear input
      .D(D)       // 1-bit Data input
   );

   // End of FDCE_inst instantiation
					</Template>
					<Template label="Posedge D-FF w/ Async Preset and CE (FDPE)" treetype="template">
//     FDPE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDPE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDPE: Single Data Rate D Flip-Flop with Asynchronous Preset and
   //       Clock Enable (posedge clk).
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDPE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDPE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .PRE(PRE),  // 1-bit Asynchronous preset input
      .D(D)       // 1-bit Data input
   );

   // End of FDPE_inst instantiation
					</Template>
					<Template label="Posedge D-FF w/ Sync Reset and CE (FDRE)" treetype="template">
//     FDRE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDRE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
   //       Clock Enable (posedge clk).
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDRE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDRE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .R(R),      // 1-bit Synchronous reset input
      .D(D)       // 1-bit Data input
   );

   // End of FDRE_inst instantiation
					</Template>
					<Template label="Posedge D-FF w/ Sync Set and CE (FDSE)" treetype="template">
//     FDSE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDSE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDSE: Single Data Rate D Flip-Flop with Synchronous Set and
   //       Clock Enable (posedge clk).
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDSE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDSE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .S(S),      // 1-bit Synchronous set input
      .D(D)       // 1-bit Data input
   );

   // End of FDSE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Transparent Latch" treetype="folder">
					<Template label="Latch with Async Reset and Gate Enable (LDCE)" treetype="template">
//     LDCE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (LDCE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // LDCE:  Transparent latch with Asynchronous Reset and Gate Enable.
   //        Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   LDCE #(
      .INIT(1'b0) // Initial value of latch (1'b0 or 1'b1)
   ) LDCE_inst (
      .Q(Q),      // Data output
      .CLR(CLR),  // Asynchronous clear/reset input
      .D(D),      // Data input
      .G(G),      // Gate input
      .GE(GE)     // Gate enable input
   );
  
   // End of LDCE_inst instantiation
					</Template>
					<Template label="Latch with Async Set and Gate Enable (LDPE)" treetype="template">
//     LDPE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (LDPE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // LDPE:  Transparent latch with Asynchronous Preset and Gate Enable.
   //        Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   LDPE #(
      .INIT(1'b1) // Initial value of latch (1'b0 or 1'b1)
   ) LDPE_inst (
      .Q(Q),      // Data output
      .PRE(PRE),  // Asynchronous preset/set input
      .D(D),      // Data input
      .G(G),      // Gate input
      .GE(GE)     // Gate enable input
   );
  
   // End of LDPE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Slice/CLB Primitives" treetype="folder">
				<Template label="Carry (CARRY4)" treetype="template">
//   CARRY4    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CARRY4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design. All inputs and
//             : and outputs of this primitive should be connected.

//  &lt;-----Cut code below this line----&gt;

   // CARRY4: Fast Carry Logic Component
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   CARRY4 CARRY4_inst (
      .CO(CO),         // 4-bit carry out
      .O(O),           // 4-bit carry chain XOR data out
      .CI(CI),         // 1-bit carry cascade input
      .CYINIT(CYINIT), // 1-bit carry initialization
      .DI(DI),         // 4-bit carry-MUX data in
      .S(S)            // 4-bit carry-MUX select input
   );

   // End of CARRY4_inst instantiation
				</Template>
				<SubFolder label="LUTs" treetype="folder">
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
// The INIT parameter for the FPGA LUT primitive is what gives the LUT its 
// logical value. By default this value is zero thus driving the output to a  
// zero regardless of the input values (acting as a ground) however in most 
// cases an new INIT value must be determined in order to specify the logic 
// function for the LUT primitive.  There are a few methods in which the LUT 
// value can be determined and two of those methods will be discussed here.
//
// The Truth Table Method
// ----------------------
//
//  A common method to determine the desired INIT value for a LUT is using a 
// truth table.  To do so, simply create a binary truth table of all possible 
// inputs, specify the desired logic value of the output and then create the 
// INIT string from those output values.  An example is shown below:
//
// Example of determining an XOR INIT equation for a LUT4:
//
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | 0 |\
//     |  0  0  0  1 | 1 | \ = 4'b0110 = 4'h6 ---------------+
//     |  0  0  1  0 | 1 | /                                 |
//     |  0  0  1  1 | 0 |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | 1 |\                                  |
//     |  0  1  0  1 | 0 | \ = 4'b1001 = 4'h9                |
//     |  0  1  1  0 | 0 | /                                 |
//     |  0  1  1  1 | 1 |/                                  |                     
//     |-------------|---|                     INIT = 16'h6996
//     |  1  0  0  0 | 1 |\                               |
//     |  1  0  0  1 | 0 | \ = 4'b0110 = 4'h9             |
//     |  1  0  1  0 | 0 | /                              |
//     |  1  0  1  1 | 1 |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | 0 |\                               |
//     |  1  1  0  1 | 1 | \ = 4'b1001 = 4'h6 ------------+
//     |  1  1  1  0 | 1 | /
//     |  1  1  1  1 | 0 |/
//     -------------------
//
// Example of determining a 3-input AND gate:
//
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | 0 |\
//     |  0  0  1 | 0 | \ = 4'b0000 = 4'h0 --------------+
//     |  0  1  0 | 0 | /                                |
//     |  0  1  1 | 0 |/                                 |
//     |----------|---|                       INIT = 8'h80 
//     |  1  0  0 | 0 |\                                |
//     |  1  0  1 | 0 | \ = 4'b1000 = 4'h8 -------------+
//     |  1  1  0 | 0 | / 
//     |  1  1  1 | 1 |/                      
//     ----------------
//
// The Equation Method
// -------------------
//
// Another method to determine the LUT value is to define parameters for each 
// input to the LUT that correspond to their listed truth value and use those to
// build the logic equation you are after.  This method is easier to understand 
// once you have grasped the concept and more self-documenting that the above 
// method however does require the code to first specify the appropriate 
// parameters.  See the example below.
//
// Example of specifying the equation (A and B) or (C and D) for a LUT4:
//
   // The following parameters are defined to allow for
   //   equation-based INIT specification.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;

   // LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT((I0&amp;I1)|(I2&amp;I3))  // Specify LUT Contents
   ) LUT4_inst (
      .O(O_LUT), // LUT general output
      .I0(A),    // LUT input
      .I1(B),    // LUT input
      .I2(C),    // LUT input
      .I3(D)     // LUT input
   );

   // End of LUT4_inst instantiation

// With the parameters specifying all possible cases for the truth table, a 
// Verilog equation can be written to determine the end INIT value.
						</Template>
						<SubFolder label="INIT Parameters" treetype="folder">
							<Template label="LUT1" treetype="template">
   // The following parameter is defined to allow for
   //   equation-based INIT specification for a LUT1.
   parameter I0 = 2'b10;
							</Template>
							<Template label="LUT2" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT2.
   parameter I0 = 4'ha;
   parameter I1 = 4'hc;
							</Template>
							<Template label="LUT3" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT3.
   parameter I0 = 8'haa;
   parameter I1 = 8'hcc;
   parameter I2 = 8'hf0;
							</Template>
							<Template label="LUT4" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT4.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;
							</Template>
							<Template label="LUT5" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT5.
   parameter I0 = 32'haaaaaaaa;
   parameter I1 = 32'hcccccccc;
   parameter I2 = 32'hf0f0f0f0;
   parameter I3 = 32'hff00ff00;
   parameter I4 = 32'hffff0000;
							</Template>
							<Template label="LUT6" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT6.
   parameter I0 = 64'haaaaaaaaaaaaaaaa;
   parameter I1 = 64'hcccccccccccccccc;
   parameter I2 = 64'hf0f0f0f0f0f0f0f0;
   parameter I3 = 64'hff00ff00ff00ff00;
   parameter I4 = 64'hffff0000ffff0000;
   parameter I5 = 64'hffffffff00000000;
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
//  Truth Table to determine INIT value for a LUT1
//      ________
//     | I0 | O |
//     |--------|
//     |  0 | ? |\
//     |  1 | ? |/ = 2'b??
//     ----------
							</Template>
							<Template label="LUT2" treetype="template">
//  Truth Table to determine INIT value for a LUT2
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
//     |  0  1  0 | ? | /
//     |  0  1  1 | ? |/ 
//      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
//  Truth Table to determine INIT value for a LUT3
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
//     |  0  1  0 | ? | /                                |
//     |  0  1  1 | ? |/                                 |
//     |----------|---|                       INIT = 8'h?? 
//     |  1  0  0 | ? |\                                |
//     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
//     |  1  1  0 | ? | / 
//     |  1  1  1 | ? |/                      
//     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
//  Truth Table to determine INIT value for a LUT4
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | ? |\
//     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
//     |  0  0  1  0 | ? | /                                 |
//     |  0  0  1  1 | ? |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | ? |\                                  |
//     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
//     |  0  1  1  0 | ? | /                                 |
//     |  0  1  1  1 | ? |/                                  |                     
//     |-------------|---|                     INIT = 16'h????
//     |  1  0  0  0 | ? |\                               |
//     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  0 | ? | /                              |
//     |  1  0  1  1 | ? |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | ? |\                               |
//     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  0 | ? | /
//     |  1  1  1  1 | ? |/
//     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
//  Truth Table to determine INIT value for a LUT5
//      ____________________
//     | I4 I3 I2 I1 I0 | O |
//     |--------------------|
//     |  0  0  0  0  0 | ? |\
//     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  0  1  0  0 | ? |\                                      |
//     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1 | ? |/                                      |                     
//     |----------------|---|                                       |
//     |  0  1  0  0  0 | ? |\                                      |
//     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  0 | ? | /                                     |
//     |  0  1  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  1  1  0  0 | ? |\                                      |
//     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1 | ? |/                                      |
//     ----------------------                     INIT = 32'h????????
//     |  1  0  0  0  0 | ? |\                               |
//     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  0  1  0 | ? | /                              |
//     |  1  0  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  0  1  0  0 | ? |\                               |
//     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  1  0 | ? | /                              |
//     |  1  0  1  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  0  0  0 | ? |\                               |
//     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  1  0  1  0 | ? | /                              |
//     |  1  1  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  1  0  0 | ? |\                               |
//     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1 | ? |/
//     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
//  Truth Table to determine INIT value for a LUT6
//      _______________________
//     | I5 I4 I3 I2 I1 I0 | O |
//     |-----------------------|
//     |  0  0  0  0  0  0 | ? |\
//     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  0  1  0  0 | ? |\                                      |
//     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  0  1  1  0 | ? | /                                     |
//     |  0  0  0  1  1  1 | ? |/                                      |                     
//     |-------------------|---|                                       |
//     |  0  0  1  0  0  0 | ? |\                                      |
//     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  0  1  0 | ? | /                                     |
//     |  0  0  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  1  1  0  0 | ? |\                                      |
//     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1  1 | ? |/                                      |
//     -------------------------                                       |
//     |  0  1  0  0  0  0 | ? |\                                      |
//     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  0  1  0 | ? | /                                     |
//     |  0  1  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  0  1  0  0 | ? |\                                      |
//     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  1  0 | ? | /                                     |
//     |  0  1  0  1  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  0  0  0 | ? |\                                      |
//     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  0  1  0 | ? | /                                     |
//     |  0  1  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  1  0  0 | ? |\                                      |
//     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1  1 | ? |/                                      |
//     ------------------------              INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
							<Template label="LUT6_2" treetype="template">
//  Truth Table to determine INIT value for a LUT6_2
//      _____________________________
//     | I5 I4 I3 I2 I1 I0 | O6 | O5 |
//     |-----------------------------|
//     |  0  0  0  0  0  0 |    ?    |\
//     |  0  0  0  0  0  1 |    ?    | \ = 4'b???? = 4'h? -------------+
//     |  0  0  0  0  1  0 |    ?    | /                               |
//     |  0  0  0  0  1  1 |	?    |/				       |
//     |-------------------|---------|                                 |
//     |  0  0  0  1  0  0 |	?    |\                                |
//     |  0  0  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  0  1  1  0 |	?    | /                               |
//     |  0  0  0  1  1  1 |	?    |/                                |                     
//     |-------------------|---------|                                 |
//     |  0  0  1  0  0  0 |	?    |\                                |
//     |  0  0  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  0  1  0 |	?    | /                               |
//     |  0  0  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  0  1  1  0  0 |	?    |\                                |
//     |  0  0  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  1  1  0 |	?    | /                               |
//     |  0  0  1  1  1  1 |	?    |/                                |
//     -------------------------------                                 |
//     |  0  1  0  0  0  0 |	?    |\                                |
//     |  0  1  0  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  0  1  0 |	?    | /                               |
//     |  0  1  0  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  0  1  0  0 |	?    |\                                |
//     |  0  1  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  1  1  0 |	?    | /                               |
//     |  0  1  0  1  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  0  0  0 |	?    |\                                |
//     |  0  1  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  0  1  0 |	?    | /                               |
//     |  0  1  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  1  0  0 |	?    |\                                |
//     |  0  1  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  1  1  0 |	?    | /                               |
//     |  0  1  1  1  1  1 |	?    |/                                |
//     ------------------------------        INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT1" treetype="template">
//     LUT1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1: 1-input Look-Up Table with general output (Mapped to a LUT6)
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT1 #(
      .INIT(2'b00)  // Specify LUT Contents
   ) LUT1_inst (
      .O(O),   // LUT general output
      .I0(I0)  // LUT input
   );

   // End of LUT1_inst instantiation
					</Template>
					<Template label="LUT1_D" treetype="template">
//   LUT1_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1_D: 1-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT1_D #(
      .INIT(2'b00)  // Specify LUT Contents
   ) LUT1_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0)  // LUT input
   );

   // End of LUT1_D_inst instantiation
					</Template>
					<Template label="LUT1_L" treetype="template">
//   LUT1_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1_L: 1-input Look-Up Table with local output (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT1_L #(
      .INIT(2'b00)  // Specify LUT Contents
   ) LUT1_L_inst (
      .LO(LO), // LUT local output
      .I0(I0)  // LUT input
   );

   // End of LUT1_L_inst instantiation
					</Template>
					<Template label="LUT2" treetype="template">
//     LUT2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2: 2-input Look-Up Table with general output (Mapped to a LUT6)
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT2 #(
      .INIT(4'h0)  // Specify LUT Contents
   ) LUT2_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1)  // LUT input
   );

   // End of LUT2_inst instantiation
					</Template>
					<Template label="LUT2_D" treetype="template">
//   LUT2_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2_D: 2-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT2_D #(
      .INIT(4'h0)  // Specify LUT Contents
   ) LUT2_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1)  // LUT input
   );

   // End of LUT2_L_inst instantiation
					</Template>
					<Template label="LUT2_L" treetype="template">
//   LUT2_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2_L: 2-input Look-Up Table with local output (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT2_L #(
      .INIT(4'h0)  // Specify LUT Contents
   ) LUT2_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1)  // LUT input
   );

   // End of LUT2_L_inst instantiation
					</Template>
					<Template label="LUT3" treetype="template">
//     LUT3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3: 3-input Look-Up Table with general output (Mapped to a LUT6)
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT3 #(
      .INIT(8'h00)  // Specify LUT Contents
   ) LUT3_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2)  // LUT input
   );

   // End of LUT3_inst instantiation
					</Template>
					<Template label="LUT3_D" treetype="template">
//   LUT3_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3_D: 3-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT3_D #(
      .INIT(8'h00)  // Specify LUT Contents
   ) LUT3_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0),   // LUT input
      .I1(I1),   // LUT input
      .I2(I2)    // LUT input
   );

   // End of LUT3_D_inst instantiation
					</Template>
					<Template label="LUT3_L" treetype="template">
//   LUT3_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3_L: 3-input Look-Up Table with local output (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT3_L #(
      .INIT(8'h00)  // Specify LUT Contents
   ) LUT3_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2)  // LUT input
   );

   // End of LUT3_L_inst instantiation
					</Template>
					<Template label="LUT4" treetype="template">
//     LUT4    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT(16'h0000)  // Specify LUT Contents
   ) LUT4_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3)  // LUT input
   );

   // End of LUT4_inst instantiation
					</Template>
					<Template label="LUT4_D" treetype="template">
//   LUT4_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4_D: 4-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4_D #(
      .INIT(16'h0000)  // Specify LUT Contents
   ) LUT4_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3)  // LUT input
   );

   // End of LUT4_D_inst instantiation
					</Template>
					<Template label="LUT4_L" treetype="template">
//   LUT4_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4_L: 4-input Look-Up Table with local output (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4_L #(
      .INIT(16'h0000)  // Specify LUT Contents
   ) LUT4_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3)  // LUT input
   );

   // End of LUT4_L_inst instantiation
					</Template>
					<Template label="LUT5" treetype="template">
//    LUT5     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5: 5-input Look-Up Table with general output (Mapped to a LUT6)
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT5 #(
      .INIT(32'h00000000)  // Specify LUT Contents
   ) LUT5_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4)  // LUT input
   );

   // End of LUT5_inst instantiation
					</Template>
					<Template label="LUT5_D" treetype="template">
//   LUT5_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5_D: 5-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT5_D #(
      .INIT(32'h0000000)  // Specify LUT Contents
   ) LUT5_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4)  // LUT input
   );

   // End of LUT5_D_inst instantiation
					</Template>
					<Template label="LUT5_L" treetype="template">
//   LUT5_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5_L: 5-input Look-Up Table with local output (Mapped to a LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT5_L #(
      .INIT(32'h0000000)  // Specify LUT Contents
   ) LUT5_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4)  // LUT input
   );

   // End of LUT5_L_inst instantiation
					</Template>
					<Template label="LUT6" treetype="template">
//    LUT6     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6: 6-input Look-Up Table with general output
   //       Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6 #(
      .INIT(64'h0000000000000000)  // Specify LUT Contents
   ) LUT6_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4), // LUT input
      .I5(I5)  // LUT input
   );

   // End of LUT6_inst instantiation
					</Template>
					<Template label="LUT6_D" treetype="template">
//   LUT6_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_D: 6-input Look-Up Table with general and local outputs
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6_D #(
      .INIT(64'h0000000000000000)  // Specify LUT Contents
   ) LUT6_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4), // LUT input
      .I5(I5)  // LUT input
   );

   // End of LUT6_D_inst instantiation
					</Template>
					<Template label="LUT6_L" treetype="template">
//   LUT6_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_L: 6-input Look-Up Table with local output
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6_L #(
      .INIT(64'h0000000000000000)  // Specify LUT Contents
   ) LUT6_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4), // LUT input
      .I5(I5)  // LUT input
   );

   // End of LUT6_L_inst instantiation
					</Template>
					<Template label="LUT6_2" treetype="template">
//   LUT6_2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_2: 6-input, 2 output Look-Up Table
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6_2 #(
      .INIT(64'h0000000000000000) // Specify LUT Contents
   ) LUT6_2_inst (
      .O6(O6), // 1-bit LUT6 output
      .O5(O5), // 1-bit lower LUT5 output
      .I0(I0), // 1-bit LUT input
      .I1(I1), // 1-bit LUT input
      .I2(I2), // 1-bit LUT input
      .I3(I3), // 1-bit LUT input
      .I4(I4), // 1-bit LUT input
      .I5(I5)  // 1-bit LUT input (fast MUX select only available to O6 output)
   );

   // End of LUT6_2_inst instantiation
					</Template>
					<Template label="Reconfigurable LUT (CFGLUT5)" treetype="template">
//   CFGLUT5   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CFGLUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CFGLUT5: Reconfigurable 5-input LUT  (Mapped to a SliceM LUT6)
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   CFGLUT5 #(
      .INIT(32'h00000000) // Specify initial LUT contents
   ) CFGLUT5_inst (
      .CDO(CDO), // Reconfiguration cascade output
      .O5(O5),   // 4-LUT output
      .O6(O6),   // 5-LUT output
      .CDI(CDI), // Reconfiguration data input
      .CE(CE),   // Reconfiguration enable input
      .CLK(CLK), // Clock input
      .I0(I0),   // Logic data input
      .I1(I1),   // Logic data input
      .I2(I2),   // Logic data input
      .I3(I3),   // Logic data input
      .I4(I4)    // Logic data input
   );

   // End of CFGLUT5_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUXFx" treetype="folder">
					<Template label="MUXF7" treetype="template">
//    MUXF7    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7: CLB MUX to tie two LUT6's together with general output
   //        Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF7 MUXF7_inst (
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to LUT6 O6 pin)
      .I1(I1),  // Input (tie to LUT6 O6 pin)
      .S(S)     // Input select to MUX
   );

   // End of MUXF7_inst instantiation
					</Template>
					<Template label="MUXF7_D" treetype="template">
//   MUXF7_D   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7_D: CLB MUX to tie two LUT6's together with general and local outputs
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF7_D MUXF7_D_inst (
      .LO(LO),  // Output of MUX to local routing
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to LUT6 O6 pin)
      .I1(I1),  // Input (tie to LUT6 O6 pin)
      .S(S)     // Input select to MUX
   );

   // End of MUXF7_D_inst instantiation
					</Template>
					<Template label="MUXF7_L" treetype="template">
//   MUXF7_L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7_L: CLB MUX to tie two LUT6's together with local output
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF7_L MUXF7_L_inst (
      .LO(LO),  // Output of MUX to local routing
      .I0(I0),  // Input (tie to LUT6 O6 pin)
      .I1(I1),  // Input (tie to LUT6 O6 pin)
      .S(S)     // Input select to MUX
   );

   // End of MUXF7_L_inst instantiation
					</Template>
					<Template label="MUXF8" treetype="template">
//    MUXF8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8: CLB MUX to tie two MUXF7's together with general output
   //        Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF8 MUXF8_inst (
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to MUXF7 L/LO out)
      .I1(I1),  // Input (tie to MUXF7 L/LO out)
      .S(S)     // Input select to MUX
   );

   // End of MUXF8_inst instantiation
					</Template>
					<Template label="MUXF8_D" treetype="template">
//   MUXF8_D   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8_D: CLB MUX to tie two MUXF7's together with general and local outputs
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF8_D MUXF8_D_inst (
      .LO(LO),  // Output of MUX to local routing
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to MUXF7 L/LO out)
      .I1(I1),  // Input (tie to MUXF7 L/LO out)
      .S(S)     // Input select to MUX
   );

   // End of MUXF8_D_inst instantiation
					</Template>
					<Template label="MUXF8_L" treetype="template">
//   MUXF8_L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8_L: CLB MUX to tie two MUXF7's together with local output
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF8_L MUXF8_L_inst (
      .LO(LO),  // Output of MUX to local routing
      .I0(I0),  // Input (tie to MUXF7 L/LO out)
      .I1(I1),  // Input (tie to MUXF7 L/LO out)
      .S(S)     // Input select to MUX
   );

   // End of MUXF8_L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Shift Register LUT" treetype="folder">
					<Template label="16-bit w/ CE posedge SR (SRL16E)" treetype="template">
//  SRL16E     : In order to incorporate this function into the design,
//  Verilog    : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL16E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRL16E: 16-bit shift register LUT with clock enable operating
   //         on posedge of clock (Mapped to a SliceM LUT6)
   //         Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   SRL16E #(
      .INIT(16'h0000) // Initial Value of Shift Register
   ) SRL16E_inst (
      .Q(Q),       // SRL data output
      .A0(A0),     // Select[0] input
      .A1(A1),     // Select[1] input
      .A2(A2),     // Select[2] input
      .A3(A3),     // Select[3] input
      .CE(CE),     // Clock enable input
      .CLK(CLK),   // Clock input
      .D(D)        // SRL data input
   );

   // End of SRL16E_inst instantiation
					</Template>
					<Template label="32-bit w/ CE posedge SR (SRLC32E)" treetype="template">
//  SRLC32E     : In order to incorporate this function into the design,
//  Verilog    : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL32E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRLC32E: 32-bit variable length cascadable shift register LUT  (Mapped to a SliceM LUT6)
   //          with clock enable
   //          Kintex-7
   // Xilinx HDL Language Template, version 2016.4
   
   SRLC32E #(
      .INIT(32'h00000000) // Initial Value of Shift Register
   ) SRLC32E_inst (
      .Q(Q),     // SRL data output
      .Q31(Q31), // SRL cascade output pin
      .A(A),     // 5-bit shift depth select input
      .CE(CE),   // Clock enable input
      .CLK(CLK), // Clock input
      .D(D)      // SRL data input
   );

   // End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Virtex UltraScale" treetype="folder">
			<SubFolder label="ADVANCED" treetype="folder">
				<SubFolder label="GT" treetype="folder">
					<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE3)" treetype="template">
// IBUFDS_GTE3 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_GTE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_GTE3: Gigabit Transceiver Buffer
   //              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE3 #(
      .REFCLK_EN_TX_PATH(1'b0),   // Refer to Transceiver User Guide
      .REFCLK_HROW_CK_SEL(2'b00), // Refer to Transceiver User Guide
      .REFCLK_ICNTL_RX(2'b00)     // Refer to Transceiver User Guide
   )
   IBUFDS_GTE3_inst (
      .O(O),         // 1-bit output: Refer to Transceiver User Guide
      .ODIV2(ODIV2), // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),     // 1-bit input: Refer to Transceiver User Guide
      .I(I),         // 1-bit input: Refer to Transceiver User Guide
      .IB(IB)        // 1-bit input: Refer to Transceiver User Guide
   );

   // End of IBUFDS_GTE3_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE3_ADV)" treetype="template">
// OBUFDS_GTE3_ADV : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFDS_GTE3_ADV_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_GTE3_ADV: Gigabit Transceiver Buffer
   //                  Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE3_ADV #(
      .REFCLK_EN_TX_PATH(1'b1),   // Refer to Transceiver User Guide
      .REFCLK_ICNTL_TX(5'b00000)  // Refer to Transceiver User Guide
   )
   OBUFDS_GTE3_ADV_inst (
      .O(O),                       // 1-bit output: Refer to Transceiver User Guide
      .OB(OB),                     // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),                   // 1-bit input: Refer to Transceiver User Guide
      .I(I),                       // 4-bit input: Refer to Transceiver User Guide
      .RXRECCLK_SEL(RXRECCLK_SEL)  // 2-bit input: Refer to Transceiver User Guide
   );

   // End of OBUFDS_GTE3_ADV_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE3)" treetype="template">
// OBUFDS_GTE3 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_GTE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_GTE3: Gigabit Transceiver Buffer
   //              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE3 #(
      .REFCLK_EN_TX_PATH(1'b1),   // Refer to Transceiver User Guide
      .REFCLK_ICNTL_TX(5'b00000)  // Refer to Transceiver User Guide
   )
   OBUFDS_GTE3_inst (
      .O(O),     // 1-bit output: Refer to Transceiver User Guide
      .OB(OB),   // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB), // 1-bit input: Refer to Transceiver User Guide
      .I(I)      // 1-bit input: Refer to Transceiver User Guide
   );

   // End of OBUFDS_GTE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SYSMON" treetype="folder">
					<Template label="SYSMON Simulation File" treetype="template">
// Must use valid headers on all columns
// Comments can be added to the stimulus file using '//' or '#'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

// Time stamp data is in nano seconds (ns)
// Temperature is recorded in C (degrees centigrade)
// All other channels are recorded as V (Volts)
// Valid column headers are:
// TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
// VUSER0, VUSER1, VUSER2, VUSER3,
// VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
// External analog inputs are differential so VP = 0.5 and VN = 0.1 the
// input on channel VP/VN in 0.5 - 0.1 = 0.4V
					</Template>
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE1)" treetype="template">
//  SYSMONE1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SYSMONE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SYSMONE1: Xilinx Analog-to-Digital Converter and System Monitor
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   SYSMONE1 #(
      // INIT_40 - INIT_44: SYSMON configuration registers
      .INIT_40(16'h0000),
      .INIT_41(16'h0000),
      .INIT_42(16'h0000),
      .INIT_43(16'h0000),
      .INIT_44(16'h0000),
      .INIT_45(16'h0000),              // Analog Bus Register
      // INIT_46 - INIT_4F: Sequence Registers
      .INIT_46(16'h0000),
      .INIT_47(16'h0000),
      .INIT_48(16'h0000),
      .INIT_49(16'h0000),
      .INIT_4A(16'h0000),
      .INIT_4B(16'h0000),
      .INIT_4C(16'h0000),
      .INIT_4D(16'h0000),
      .INIT_4E(16'h0000),
      .INIT_4F(16'h0000),
      // INIT_50 - INIT_5F: Alarm Limit Registers
      .INIT_50(16'h0000),
      .INIT_51(16'h0000),
      .INIT_52(16'h0000),
      .INIT_53(16'h0000),
      .INIT_54(16'h0000),
      .INIT_55(16'h0000),
      .INIT_56(16'h0000),
      .INIT_57(16'h0000),
      .INIT_58(16'h0000),
      .INIT_59(16'h0000),
      .INIT_5A(16'h0000),
      .INIT_5B(16'h0000),
      .INIT_5C(16'h0000),
      .INIT_5D(16'h0000),
      .INIT_5E(16'h0000),
      .INIT_5F(16'h0000),
      // INIT_60 - INIT_6F: User Supply Alarms
      .INIT_60(16'h0000),
      .INIT_61(16'h0000),
      .INIT_62(16'h0000),
      .INIT_63(16'h0000),
      .INIT_64(16'h0000),
      .INIT_65(16'h0000),
      .INIT_66(16'h0000),
      .INIT_67(16'h0000),
      .INIT_68(16'h0000),
      .INIT_69(16'h0000),
      .INIT_6A(16'h0000),
      .INIT_6B(16'h0000),
      .INIT_6C(16'h0000),
      .INIT_6D(16'h0000),
      .INIT_6E(16'h0000),
      .INIT_6F(16'h0000),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      // specific pins
      .IS_CONVSTCLK_INVERTED(1'b0),    // Optional inversion for CONVSTCLK, 0-1
      .IS_DCLK_INVERTED(1'b0),         // Optional inversion for DCLK, 0-1
      // Simulation attributes: Set for proper simulation behavior
      .SIM_MONITOR_FILE("design.txt"), // Analog simulation data file name
      // User Voltage Monitor: SYSMON User voltage monitor
      .SYSMON_VUSER0_BANK(0),          // Specify IO Bank for User0
      .SYSMON_VUSER0_MONITOR("NONE"),  // Specify Voltage for User0
      .SYSMON_VUSER1_BANK(0),          // Specify IO Bank for User1
      .SYSMON_VUSER1_MONITOR("NONE"),  // Specify Voltage for User1
      .SYSMON_VUSER2_BANK(0),          // Specify IO Bank for User2
      .SYSMON_VUSER2_MONITOR("NONE"),  // Specify Voltage for User2
      .SYSMON_VUSER3_MONITOR("NONE")   // Specify Voltage for User3
   )
   SYSMONE1_inst (
      // ALARMS outputs: ALM, OT
      .ALM(ALM),                   // 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      .OT(OT),                     // 1-bit output: Over-Temperature alarm
      // Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      .DO(DO),                     // 16-bit output: DRP output data bus
      .DRDY(DRDY),                 // 1-bit output: DRP data ready
      // I2C Interface outputs: Ports used with the I2C DRP interface
      .I2C_SCLK_TS(I2C_SCLK_TS),   // 1-bit output: I2C_SCLK output port
      .I2C_SDA_TS(I2C_SDA_TS),     // 1-bit output: I2C_SDA_TS output port
      // STATUS outputs: SYSMON status ports
      .BUSY(BUSY),                 // 1-bit output: System Monitor busy output
      .CHANNEL(CHANNEL),           // 6-bit output: Channel selection outputs
      .EOC(EOC),                   // 1-bit output: End of Conversion
      .EOS(EOS),                   // 1-bit output: End of Sequence
      .JTAGBUSY(JTAGBUSY),         // 1-bit output: JTAG DRP transaction in progress output
      .JTAGLOCKED(JTAGLOCKED),     // 1-bit output: JTAG requested DRP port lock
      .JTAGMODIFIED(JTAGMODIFIED), // 1-bit output: JTAG Write to the DRP has occurred
      .MUXADDR(MUXADDR),           // 5-bit output: External MUX channel decode
      // Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      .VAUXN(VAUXN),               // 16-bit input: N-side auxiliary analog input
      .VAUXP(VAUXP),               // 16-bit input: P-side auxiliary analog input
      // CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      .CONVST(CONVST),             // 1-bit input: Convert start input
      .CONVSTCLK(CONVSTCLK),       // 1-bit input: Convert start input
      .RESET(RESET),               // 1-bit input: Active-High reset
      // Dedicated Analog Input Pair inputs: VP/VN
      .VN(VN),                     // 1-bit input: N-side analog input
      .VP(VP),                     // 1-bit input: P-side analog input
      // Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      .DADDR(DADDR),               // 8-bit input: DRP address bus
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable signal
      .DI(DI),                     // 16-bit input: DRP input data bus
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // I2C Interface inputs: Ports used with the I2C DRP interface
      .I2C_SCLK(I2C_SCLK),         // 1-bit input: I2C_SCLK input port
      .I2C_SDA(I2C_SDA)            // 1-bit input: I2C_SDA input port
   );

   // End of SYSMONE1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="ARITHMETIC" treetype="folder">
				<SubFolder label="DSP" treetype="folder">
					<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E2)" treetype="template">
//   DSP48E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DSP48E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DSP48E2: 48-bit Multi-Functional Arithmetic Block
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   DSP48E2 #(
      // Feature Control Attributes: Data Path Selection
      .AMULTSEL("A"),                    // Selects A input to multiplier (A, AD)
      .A_INPUT("DIRECT"),                // Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      .BMULTSEL("B"),                    // Selects B input to multiplier (AD, B)
      .B_INPUT("DIRECT"),                // Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      .PREADDINSEL("A"),                 // Selects input to pre-adder (A, B)
      .RND(48'h000000000000),            // Rounding Constant
      .USE_MULT("MULTIPLY"),             // Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
      .USE_SIMD("ONE48"),                // SIMD selection (FOUR12, ONE48, TWO24)
      .USE_WIDEXOR("FALSE"),             // Use the Wide XOR function (FALSE, TRUE)
      .XORSIMD("XOR24_48_96"),           // Mode of operation for the Wide XOR (XOR12, XOR24_48_96)
      // Pattern Detector Attributes: Pattern Detection Configuration
      .AUTORESET_PATDET("NO_RESET"),     // NO_RESET, RESET_MATCH, RESET_NOT_MATCH
      .AUTORESET_PRIORITY("RESET"),      // Priority of AUTORESET vs. CEP (CEP, RESET).
      .MASK(48'h3fffffffffff),           // 48-bit mask value for pattern detect (1=ignore)
      .PATTERN(48'h000000000000),        // 48-bit pattern match for pattern detect
      .SEL_MASK("MASK"),                 // C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
      .SEL_PATTERN("PATTERN"),           // Select pattern value (C, PATTERN)
      .USE_PATTERN_DETECT("NO_PATDET"),  // Enable pattern detect (NO_PATDET, PATDET)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_ALUMODE_INVERTED(4'b0000),     // Optional inversion for ALUMODE
      .IS_CARRYIN_INVERTED(1'b0),        // Optional inversion for CARRYIN
      .IS_CLK_INVERTED(1'b0),            // Optional inversion for CLK
      .IS_INMODE_INVERTED(5'b00000),     // Optional inversion for INMODE
      .IS_OPMODE_INVERTED(9'b000000000), // Optional inversion for OPMODE
      .IS_RSTALLCARRYIN_INVERTED(1'b0),  // Optional inversion for RSTALLCARRYIN
      .IS_RSTALUMODE_INVERTED(1'b0),     // Optional inversion for RSTALUMODE
      .IS_RSTA_INVERTED(1'b0),           // Optional inversion for RSTA
      .IS_RSTB_INVERTED(1'b0),           // Optional inversion for RSTB
      .IS_RSTCTRL_INVERTED(1'b0),        // Optional inversion for RSTCTRL
      .IS_RSTC_INVERTED(1'b0),           // Optional inversion for RSTC
      .IS_RSTD_INVERTED(1'b0),           // Optional inversion for RSTD
      .IS_RSTINMODE_INVERTED(1'b0),      // Optional inversion for RSTINMODE
      .IS_RSTM_INVERTED(1'b0),           // Optional inversion for RSTM
      .IS_RSTP_INVERTED(1'b0),           // Optional inversion for RSTP
      // Register Control Attributes: Pipeline Register Configuration
      .ACASCREG(1),                      // Number of pipeline stages between A/ACIN and ACOUT (0-2)
      .ADREG(1),                         // Pipeline stages for pre-adder (0-1)
      .ALUMODEREG(1),                    // Pipeline stages for ALUMODE (0-1)
      .AREG(1),                          // Pipeline stages for A (0-2)
      .BCASCREG(1),                      // Number of pipeline stages between B/BCIN and BCOUT (0-2)
      .BREG(1),                          // Pipeline stages for B (0-2)
      .CARRYINREG(1),                    // Pipeline stages for CARRYIN (0-1)
      .CARRYINSELREG(1),                 // Pipeline stages for CARRYINSEL (0-1)
      .CREG(1),                          // Pipeline stages for C (0-1)
      .DREG(1),                          // Pipeline stages for D (0-1)
      .INMODEREG(1),                     // Pipeline stages for INMODE (0-1)
      .MREG(1),                          // Multiplier pipeline stages (0-1)
      .OPMODEREG(1),                     // Pipeline stages for OPMODE (0-1)
      .PREG(1)                           // Number of pipeline stages for P (0-1)
   )
   DSP48E2_inst (
      // Cascade outputs: Cascade Ports
      .ACOUT(ACOUT),                   // 30-bit output: A port cascade
      .BCOUT(BCOUT),                   // 18-bit output: B cascade
      .CARRYCASCOUT(CARRYCASCOUT),     // 1-bit output: Cascade carry
      .MULTSIGNOUT(MULTSIGNOUT),       // 1-bit output: Multiplier sign cascade
      .PCOUT(PCOUT),                   // 48-bit output: Cascade output
      // Control outputs: Control Inputs/Status Bits
      .OVERFLOW(OVERFLOW),             // 1-bit output: Overflow in add/acc
      .PATTERNBDETECT(PATTERNBDETECT), // 1-bit output: Pattern bar detect
      .PATTERNDETECT(PATTERNDETECT),   // 1-bit output: Pattern detect
      .UNDERFLOW(UNDERFLOW),           // 1-bit output: Underflow in add/acc
      // Data outputs: Data Ports
      .CARRYOUT(CARRYOUT),             // 4-bit output: Carry
      .P(P),                           // 48-bit output: Primary data
      .XOROUT(XOROUT),                 // 8-bit output: XOR data
      // Cascade inputs: Cascade Ports
      .ACIN(ACIN),                     // 30-bit input: A cascade data
      .BCIN(BCIN),                     // 18-bit input: B cascade
      .CARRYCASCIN(CARRYCASCIN),       // 1-bit input: Cascade carry
      .MULTSIGNIN(MULTSIGNIN),         // 1-bit input: Multiplier sign cascade
      .PCIN(PCIN),                     // 48-bit input: P cascade
      // Control inputs: Control Inputs/Status Bits
      .ALUMODE(ALUMODE),               // 4-bit input: ALU control
      .CARRYINSEL(CARRYINSEL),         // 3-bit input: Carry select
      .CLK(CLK),                       // 1-bit input: Clock
      .INMODE(INMODE),                 // 5-bit input: INMODE control
      .OPMODE(OPMODE),                 // 9-bit input: Operation mode
      // Data inputs: Data Ports
      .A(A),                           // 30-bit input: A data
      .B(B),                           // 18-bit input: B data
      .C(C),                           // 48-bit input: C data
      .CARRYIN(CARRYIN),               // 1-bit input: Carry-in
      .D(D),                           // 27-bit input: D data
      // Reset/Clock Enable inputs: Reset/Clock Enable Inputs
      .CEA1(CEA1),                     // 1-bit input: Clock enable for 1st stage AREG
      .CEA2(CEA2),                     // 1-bit input: Clock enable for 2nd stage AREG
      .CEAD(CEAD),                     // 1-bit input: Clock enable for ADREG
      .CEALUMODE(CEALUMODE),           // 1-bit input: Clock enable for ALUMODE
      .CEB1(CEB1),                     // 1-bit input: Clock enable for 1st stage BREG
      .CEB2(CEB2),                     // 1-bit input: Clock enable for 2nd stage BREG
      .CEC(CEC),                       // 1-bit input: Clock enable for CREG
      .CECARRYIN(CECARRYIN),           // 1-bit input: Clock enable for CARRYINREG
      .CECTRL(CECTRL),                 // 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
      .CED(CED),                       // 1-bit input: Clock enable for DREG
      .CEINMODE(CEINMODE),             // 1-bit input: Clock enable for INMODEREG
      .CEM(CEM),                       // 1-bit input: Clock enable for MREG
      .CEP(CEP),                       // 1-bit input: Clock enable for PREG
      .RSTA(RSTA),                     // 1-bit input: Reset for AREG
      .RSTALLCARRYIN(RSTALLCARRYIN),   // 1-bit input: Reset for CARRYINREG
      .RSTALUMODE(RSTALUMODE),         // 1-bit input: Reset for ALUMODEREG
      .RSTB(RSTB),                     // 1-bit input: Reset for BREG
      .RSTC(RSTC),                     // 1-bit input: Reset for CREG
      .RSTCTRL(RSTCTRL),               // 1-bit input: Reset for OPMODEREG and CARRYINSELREG
      .RSTD(RSTD),                     // 1-bit input: Reset for DREG and ADREG
      .RSTINMODE(RSTINMODE),           // 1-bit input: Reset for INMODEREG
      .RSTM(RSTM),                     // 1-bit input: Reset for MREG
      .RSTP(RSTP)                      // 1-bit input: Reset for PREG
   );

   // End of DSP48E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="BLOCKRAM" treetype="folder">
				<SubFolder label="BRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E2)" treetype="template">
//  RAMB18E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB18E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB18E2: 18K-bit Configurable Synchronous Block RAM
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAMB18E2 #(
      // CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      .CASCADE_ORDER_A("NONE"),
      .CASCADE_ORDER_B("NONE"),
      // CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      .CLOCK_DOMAINS("INDEPENDENT"),
      // Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0, 1)
      .DOA_REG(1),
      .DOB_REG(1),
      // ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      .ENADDRENA("FALSE"),
      .ENADDRENB("FALSE"),
      // INITP_00 to INITP_07: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_3F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(18'h00000),
      .INIT_B(18'h00000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLKARDCLK_INVERTED(1'b0),
      .IS_CLKBWRCLK_INVERTED(1'b0),
      .IS_ENARDEN_INVERTED(1'b0),
      .IS_ENBWREN_INVERTED(1'b0),
      .IS_RSTRAMARSTRAM_INVERTED(1'b0),
      .IS_RSTRAMB_INVERTED(1'b0),
      .IS_RSTREGARSTREG_INVERTED(1'b0),
      .IS_RSTREGB_INVERTED(1'b0),
      // RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      .RDADDRCHANGEA("FALSE"),
      .RDADDRCHANGEB("FALSE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-9
      .READ_WIDTH_B(0),                                                                 // 0-9
      .WRITE_WIDTH_A(0),                                                                // 0-9
      .WRITE_WIDTH_B(0),                                                                // 0-9
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(18'h00000),
      .SRVAL_B(18'h00000),
      // Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      .SLEEP_ASYNC("FALSE"),
      // WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      .WRITE_MODE_A("NO_CHANGE"),
      .WRITE_MODE_B("NO_CHANGE") 
   )
   RAMB18E2_inst (
      // Cascade Signals outputs: Multi-BRAM cascade signals
      .CASDOUTA(CASDOUTA),               // 16-bit output: Port A cascade output data
      .CASDOUTB(CASDOUTB),               // 16-bit output: Port B cascade output data
      .CASDOUTPA(CASDOUTPA),             // 2-bit output: Port A cascade output parity data
      .CASDOUTPB(CASDOUTPB),             // 2-bit output: Port B cascade output parity data
      // Port A Data outputs: Port A data
      .DOUTADOUT(DOUTADOUT),             // 16-bit output: Port A data/LSB data
      .DOUTPADOUTP(DOUTPADOUTP),         // 2-bit output: Port A parity/LSB parity
      // Port B Data outputs: Port B data
      .DOUTBDOUT(DOUTBDOUT),             // 16-bit output: Port B data/MSB data
      .DOUTPBDOUTP(DOUTPBDOUTP),         // 2-bit output: Port B parity/MSB parity
      // Cascade Signals inputs: Multi-BRAM cascade signals
      .CASDIMUXA(CASDIMUXA),             // 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      .CASDIMUXB(CASDIMUXB),             // 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      .CASDINA(CASDINA),                 // 16-bit input: Port A cascade input data
      .CASDINB(CASDINB),                 // 16-bit input: Port B cascade input data
      .CASDINPA(CASDINPA),               // 2-bit input: Port A cascade input parity data
      .CASDINPB(CASDINPB),               // 2-bit input: Port B cascade input parity data
      .CASDOMUXA(CASDOMUXA),             // 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      .CASDOMUXB(CASDOMUXB),             // 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      .CASDOMUXEN_A(CASDOMUXEN_A),       // 1-bit input: Port A unregistered output data enable
      .CASDOMUXEN_B(CASDOMUXEN_B),       // 1-bit input: Port B unregistered output data enable
      .CASOREGIMUXA(CASOREGIMUXA),       // 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      .CASOREGIMUXB(CASOREGIMUXB),       // 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      .CASOREGIMUXEN_A(CASOREGIMUXEN_A), // 1-bit input: Port A registered output data enable
      .CASOREGIMUXEN_B(CASOREGIMUXEN_B), // 1-bit input: Port B registered output data enable
      // Port A Address/Control Signals inputs: Port A address and control signals
      .ADDRARDADDR(ADDRARDADDR),         // 14-bit input: A/Read port address
      .ADDRENA(ADDRENA),                 // 1-bit input: Active-High A/Read port address enable
      .CLKARDCLK(CLKARDCLK),             // 1-bit input: A/Read port clock
      .ENARDEN(ENARDEN),                 // 1-bit input: Port A enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),         // 1-bit input: Port A register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM),     // 1-bit input: Port A set/reset
      .RSTREGARSTREG(RSTREGARSTREG),     // 1-bit input: Port A register set/reset
      .WEA(WEA),                         // 2-bit input: Port A write enable
      // Port A Data inputs: Port A data
      .DINADIN(DINADIN),                 // 16-bit input: Port A data/LSB data
      .DINPADINP(DINPADINP),             // 2-bit input: Port A parity/LSB parity
      // Port B Address/Control Signals inputs: Port B address and control signals
      .ADDRBWRADDR(ADDRBWRADDR),         // 14-bit input: B/Write port address
      .ADDRENB(ADDRENB),                 // 1-bit input: Active-High B/Write port address enable
      .CLKBWRCLK(CLKBWRCLK),             // 1-bit input: B/Write port clock
      .ENBWREN(ENBWREN),                 // 1-bit input: Port B enable/Write enable
      .REGCEB(REGCEB),                   // 1-bit input: Port B register enable
      .RSTRAMB(RSTRAMB),                 // 1-bit input: Port B set/reset
      .RSTREGB(RSTREGB),                 // 1-bit input: Port B register set/reset
      .SLEEP(SLEEP),                     // 1-bit input: Sleep Mode
      .WEBWE(WEBWE),                     // 4-bit input: Port B write enable/Write enable
      // Port B Data inputs: Port B data
      .DINBDIN(DINBDIN),                 // 16-bit input: Port B data/MSB data
      .DINPBDINP(DINPBDINP)              // 2-bit input: Port B parity/MSB parity
   );

   // End of RAMB18E2_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E2)" treetype="template">
//  RAMB36E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB36E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB36E2: 36K-bit Configurable Synchronous Block RAM
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAMB36E2 #(
      // CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      .CASCADE_ORDER_A("NONE"),
      .CASCADE_ORDER_B("NONE"),
      // CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      .CLOCK_DOMAINS("INDEPENDENT"),
      .DOB_REG(1),
      // Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0, 1)
      .DOA_REG(1),
      // ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      .ENADDRENA("FALSE"),
      .ENADDRENB("FALSE"),
      // EN_ECC_PIPE: ECC pipeline register, "TRUE"/"FALSE" 
      .EN_ECC_PIPE("FALSE"),
      // EN_ECC_READ: Enable ECC decoder, "TRUE"/"FALSE" 
      .EN_ECC_READ("FALSE"),
      // EN_ECC_WRITE: Enable ECC encoder, "TRUE"/"FALSE" 
      .EN_ECC_WRITE("FALSE"),
      // INITP_00 to INITP_0F: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_7F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(36'h000000000),
      .INIT_B(36'h000000000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLKARDCLK_INVERTED(1'b0),
      .IS_CLKBWRCLK_INVERTED(1'b0),
      .IS_ENARDEN_INVERTED(1'b0),
      .IS_ENBWREN_INVERTED(1'b0),
      .IS_RSTRAMARSTRAM_INVERTED(1'b0),
      .IS_RSTRAMB_INVERTED(1'b0),
      .IS_RSTREGARSTREG_INVERTED(1'b0),
      .IS_RSTREGB_INVERTED(1'b0),
      // RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      .RDADDRCHANGEA("FALSE"),
      .RDADDRCHANGEB("FALSE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-9
      .READ_WIDTH_B(0),                                                                 // 0-9
      .WRITE_WIDTH_A(0),                                                                // 0-9
      .WRITE_WIDTH_B(0),                                                                // 0-9
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(36'h000000000),
      .SRVAL_B(36'h000000000),
      // Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      .SLEEP_ASYNC("FALSE"),
      // WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      .WRITE_MODE_A("NO_CHANGE"),
      .WRITE_MODE_B("NO_CHANGE") 
   )
   RAMB36E2_inst (
      // Cascade Signals outputs: Multi-BRAM cascade signals
      .CASDOUTA(CASDOUTA),               // 32-bit output: Port A cascade output data
      .CASDOUTB(CASDOUTB),               // 32-bit output: Port B cascade output data
      .CASDOUTPA(CASDOUTPA),             // 4-bit output: Port A cascade output parity data
      .CASDOUTPB(CASDOUTPB),             // 4-bit output: Port B cascade output parity data
      .CASOUTDBITERR(CASOUTDBITERR),     // 1-bit output: DBITERR cascade output
      .CASOUTSBITERR(CASOUTSBITERR),     // 1-bit output: SBITERR cascade output
      // ECC Signals outputs: Error Correction Circuitry ports
      .DBITERR(DBITERR),                 // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),             // 8-bit output: Generated error correction parity
      .RDADDRECC(RDADDRECC),             // 9-bit output: ECC Read Address
      .SBITERR(SBITERR),                 // 1-bit output: Single bit error status
      // Port A Data outputs: Port A data
      .DOUTADOUT(DOUTADOUT),             // 32-bit output: Port A ata/LSB data
      .DOUTPADOUTP(DOUTPADOUTP),         // 4-bit output: Port A parity/LSB parity
      // Port B Data outputs: Port B data
      .DOUTBDOUT(DOUTBDOUT),             // 32-bit output: Port B data/MSB data
      .DOUTPBDOUTP(DOUTPBDOUTP),         // 4-bit output: Port B parity/MSB parity
      // Cascade Signals inputs: Multi-BRAM cascade signals
      .CASDIMUXA(CASDIMUXA),             // 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      .CASDIMUXB(CASDIMUXB),             // 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      .CASDINA(CASDINA),                 // 32-bit input: Port A cascade input data
      .CASDINB(CASDINB),                 // 32-bit input: Port B cascade input data
      .CASDINPA(CASDINPA),               // 4-bit input: Port A cascade input parity data
      .CASDINPB(CASDINPB),               // 4-bit input: Port B cascade input parity data
      .CASDOMUXA(CASDOMUXA),             // 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      .CASDOMUXB(CASDOMUXB),             // 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      .CASDOMUXEN_A(CASDOMUXEN_A),       // 1-bit input: Port A unregistered output data enable
      .CASDOMUXEN_B(CASDOMUXEN_B),       // 1-bit input: Port B unregistered output data enable
      .CASINDBITERR(CASINDBITERR),       // 1-bit input: DBITERR cascade input
      .CASINSBITERR(CASINSBITERR),       // 1-bit input: SBITERR cascade input
      .CASOREGIMUXA(CASOREGIMUXA),       // 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      .CASOREGIMUXB(CASOREGIMUXB),       // 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      .CASOREGIMUXEN_A(CASOREGIMUXEN_A), // 1-bit input: Port A registered output data enable
      .CASOREGIMUXEN_B(CASOREGIMUXEN_B), // 1-bit input: Port B registered output data enable
      // ECC Signals inputs: Error Correction Circuitry ports
      .ECCPIPECE(ECCPIPECE),             // 1-bit input: ECC Pipeline Register Enable
      .INJECTDBITERR(INJECTDBITERR),     // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR),
      // Port A Address/Control Signals inputs: Port A address and control signals
      .ADDRARDADDR(ADDRARDADDR),         // 15-bit input: A/Read port address
      .ADDRENA(ADDRENA),                 // 1-bit input: Active-High A/Read port address enable
      .CLKARDCLK(CLKARDCLK),             // 1-bit input: A/Read port clock
      .ENARDEN(ENARDEN),                 // 1-bit input: Port A enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),         // 1-bit input: Port A register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM),     // 1-bit input: Port A set/reset
      .RSTREGARSTREG(RSTREGARSTREG),     // 1-bit input: Port A register set/reset
      .SLEEP(SLEEP),                     // 1-bit input: Sleep Mode
      .WEA(WEA),                         // 4-bit input: Port A write enable
      // Port A Data inputs: Port A data
      .DINADIN(DINADIN),                 // 32-bit input: Port A data/LSB data
      .DINPADINP(DINPADINP),             // 4-bit input: Port A parity/LSB parity
      // Port B Address/Control Signals inputs: Port B address and control signals
      .ADDRBWRADDR(ADDRBWRADDR),         // 15-bit input: B/Write port address
      .ADDRENB(ADDRENB),                 // 1-bit input: Active-High B/Write port address enable
      .CLKBWRCLK(CLKBWRCLK),             // 1-bit input: B/Write port clock
      .ENBWREN(ENBWREN),                 // 1-bit input: Port B enable/Write enable
      .REGCEB(REGCEB),                   // 1-bit input: Port B register enable
      .RSTRAMB(RSTRAMB),                 // 1-bit input: Port B set/reset
      .RSTREGB(RSTREGB),                 // 1-bit input: Port B register set/reset
      .WEBWE(WEBWE),                     // 8-bit input: Port B write enable/Write enable
      // Port B Data inputs: Port B data
      .DINBDIN(DINBDIN),                 // 32-bit input: Port B data/MSB data
      .DINPBDINP(DINPBDINP)              // 4-bit input: Port B parity/MSB parity
   );

   // End of RAMB36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E2)" treetype="template">
//  FIFO18E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO18E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO18E2: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FIFO18E2 #(
      .CASCADE_ORDER("NONE"),            // FIRST, LAST, MIDDLE, NONE, PARALLEL
      .CLOCK_DOMAINS("INDEPENDENT"),     // COMMON, INDEPENDENT
      .FIRST_WORD_FALL_THROUGH("FALSE"), // FALSE, TRUE
      .INIT(36'h000000000),              // Initial values on output port
      .PROG_EMPTY_THRESH(256),           // Programmable Empty Threshold
      .PROG_FULL_THRESH(256),            // Programmable Full Threshold
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_RDCLK_INVERTED(1'b0),          // Optional inversion for RDCLK
      .IS_RDEN_INVERTED(1'b0),           // Optional inversion for RDEN
      .IS_RSTREG_INVERTED(1'b0),         // Optional inversion for RSTREG
      .IS_RST_INVERTED(1'b0),            // Optional inversion for RST
      .IS_WRCLK_INVERTED(1'b0),          // Optional inversion for WRCLK
      .IS_WREN_INVERTED(1'b0),           // Optional inversion for WREN
      .RDCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .READ_WIDTH(4),                    // 18-9
      .REGISTER_MODE("UNREGISTERED"),    // DO_PIPELINED, REGISTERED, UNREGISTERED
      .RSTREG_PRIORITY("RSTREG"),        // REGCE, RSTREG
      .SLEEP_ASYNC("FALSE"),             // FALSE, TRUE
      .SRVAL(36'h000000000),             // SET/reset value of the FIFO outputs
      .WRCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .WRITE_WIDTH(4)                    // 18-9
   )
   FIFO18E2_inst (
      // Cascade Signals outputs: Multi-FIFO cascade signals
      .CASDOUT(CASDOUT),             // 32-bit output: Data cascade output bus
      .CASDOUTP(CASDOUTP),           // 4-bit output: Parity data cascade output bus
      .CASNXTEMPTY(CASNXTEMPTY),     // 1-bit output: Cascade next empty
      .CASPRVRDEN(CASPRVRDEN),       // 1-bit output: Cascade previous read enable
      // Read Data outputs: Read output data
      .DOUT(DOUT),                   // 32-bit output: FIFO data output bus
      .DOUTP(DOUTP),                 // 4-bit output: FIFO parity output bus.
      // Status outputs: Flags and other FIFO status outputs
      .EMPTY(EMPTY),                 // 1-bit output: Empty
      .FULL(FULL),                   // 1-bit output: Full
      .PROGEMPTY(PROGEMPTY),         // 1-bit output: Programmable empty
      .PROGFULL(PROGFULL),           // 1-bit output: Programmable full
      .RDCOUNT(RDCOUNT),             // 13-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .RDRSTBUSY(RDRSTBUSY),         // 1-bit output: Reset busy (sync to RDCLK)
      .WRCOUNT(WRCOUNT),             // 13-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write Error
      .WRRSTBUSY(WRRSTBUSY),         // 1-bit output: Reset busy (sync to WRCLK)
      // Cascade Signals inputs: Multi-FIFO cascade signals
      .CASDIN(CASDIN),               // 32-bit input: Data cascade input bus
      .CASDINP(CASDINP),             // 4-bit input: Parity data cascade input bus
      .CASDOMUX(CASDOMUX),           // 1-bit input: Cascade MUX select
      .CASDOMUXEN(CASDOMUXEN),       // 1-bit input: Enable for cascade MUX select
      .CASNXTRDEN(CASNXTRDEN),       // 1-bit input: Cascade next read enable
      .CASOREGIMUX(CASOREGIMUX),     // 1-bit input: Cascade output MUX select
      .CASOREGIMUXEN(CASOREGIMUXEN), // 1-bit input: Cascade output MUX select enable
      .CASPRVEMPTY(CASPRVEMPTY),     // 1-bit input: Cascade previous empty
      // Read Control Signals inputs: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Output register clock enable
      .RSTREG(RSTREG),               // 1-bit input: Output register reset
      .SLEEP(SLEEP),                 // 1-bit input: Sleep Mode
      // Write Control Signals inputs: Write clock and enable input signals
      .RST(RST),                     // 1-bit input: Reset
      .WRCLK(WRCLK),                 // 1-bit input: Write clock
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data inputs: Write input data
      .DIN(DIN),                     // 32-bit input: FIFO data input bus
      .DINP(DINP)                    // 4-bit input: FIFO parity input bus
   );

   // End of FIFO18E2_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E2)" treetype="template">
//  FIFO36E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO36E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO36E2: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FIFO36E2 #(
      .CASCADE_ORDER("NONE"),            // FIRST, LAST, MIDDLE, NONE, PARALLEL
      .CLOCK_DOMAINS("INDEPENDENT"),     // COMMON, INDEPENDENT
      .EN_ECC_PIPE("FALSE"),             // ECC pipeline register, (FALSE, TRUE)
      .EN_ECC_READ("FALSE"),             // Enable ECC decoder, (FALSE, TRUE)
      .EN_ECC_WRITE("FALSE"),            // Enable ECC encoder, (FALSE, TRUE)
      .FIRST_WORD_FALL_THROUGH("FALSE"), // FALSE, TRUE
      .INIT(72'h000000000000000000),     // Initial values on output port
      .PROG_EMPTY_THRESH(256),           // Programmable Empty Threshold
      .PROG_FULL_THRESH(256),            // Programmable Full Threshold
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_RDCLK_INVERTED(1'b0),          // Optional inversion for RDCLK
      .IS_RDEN_INVERTED(1'b0),           // Optional inversion for RDEN
      .IS_RSTREG_INVERTED(1'b0),         // Optional inversion for RSTREG
      .IS_RST_INVERTED(1'b0),            // Optional inversion for RST
      .IS_WRCLK_INVERTED(1'b0),          // Optional inversion for WRCLK
      .IS_WREN_INVERTED(1'b0),           // Optional inversion for WREN
      .RDCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .READ_WIDTH(4),                    // 18-9
      .REGISTER_MODE("UNREGISTERED"),    // DO_PIPELINED, REGISTERED, UNREGISTERED
      .RSTREG_PRIORITY("RSTREG"),        // REGCE, RSTREG
      .SLEEP_ASYNC("FALSE"),             // FALSE, TRUE
      .SRVAL(72'h000000000000000000),    // SET/reset value of the FIFO outputs
      .WRCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .WRITE_WIDTH(4)                    // 18-9
   )
   FIFO36E2_inst (
      // Cascade Signals outputs: Multi-FIFO cascade signals
      .CASDOUT(CASDOUT),             // 64-bit output: Data cascade output bus
      .CASDOUTP(CASDOUTP),           // 8-bit output: Parity data cascade output bus
      .CASNXTEMPTY(CASNXTEMPTY),     // 1-bit output: Cascade next empty
      .CASPRVRDEN(CASPRVRDEN),       // 1-bit output: Cascade previous read enable
      // ECC Signals outputs: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Read Data outputs: Read output data
      .DOUT(DOUT),                   // 64-bit output: FIFO data output bus
      .DOUTP(DOUTP),                 // 8-bit output: FIFO parity output bus.
      // Status outputs: Flags and other FIFO status outputs
      .EMPTY(EMPTY),                 // 1-bit output: Empty
      .FULL(FULL),                   // 1-bit output: Full
      .PROGEMPTY(PROGEMPTY),         // 1-bit output: Programmable empty
      .PROGFULL(PROGFULL),           // 1-bit output: Programmable full
      .RDCOUNT(RDCOUNT),             // 14-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .RDRSTBUSY(RDRSTBUSY),         // 1-bit output: Reset busy (sync to RDCLK)
      .WRCOUNT(WRCOUNT),             // 14-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write Error
      .WRRSTBUSY(WRRSTBUSY),         // 1-bit output: Reset busy (sync to WRCLK)
      // Cascade Signals inputs: Multi-FIFO cascade signals
      .CASDIN(CASDIN),               // 64-bit input: Data cascade input bus
      .CASDINP(CASDINP),             // 8-bit input: Parity data cascade input bus
      .CASDOMUX(CASDOMUX),           // 1-bit input: Cascade MUX select input
      .CASDOMUXEN(CASDOMUXEN),       // 1-bit input: Enable for cascade MUX select
      .CASNXTRDEN(CASNXTRDEN),       // 1-bit input: Cascade next read enable
      .CASOREGIMUX(CASOREGIMUX),     // 1-bit input: Cascade output MUX select
      .CASOREGIMUXEN(CASOREGIMUXEN), // 1-bit input: Cascade output MUX select enable
      .CASPRVEMPTY(CASPRVEMPTY),     // 1-bit input: Cascade previous empty
      // ECC Signals inputs: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR), // 1-bit input: Inject a single bit error
      // Read Control Signals inputs: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Output register clock enable
      .RSTREG(RSTREG),               // 1-bit input: Output register reset
      .SLEEP(SLEEP),                 // 1-bit input: Sleep Mode
      // Write Control Signals inputs: Write clock and enable input signals
      .RST(RST),                     // 1-bit input: Reset
      .WRCLK(WRCLK),                 // 1-bit input: Write clock
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data inputs: Write input data
      .DIN(DIN),                     // 64-bit input: FIFO data input bus
      .DINP(DINP)                    // 8-bit input: FIFO parity input bus
   );

   // End of FIFO36E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLB" treetype="folder">
				<SubFolder label="CARRY" treetype="folder">
					<Template label="Fast Carry Logic with Look Ahead (CARRY8)" treetype="template">
//   CARRY8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CARRY8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CARRY8: Fast Carry Logic with Look Ahead
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   CARRY8 #(
      .CARRY_TYPE("SINGLE_CY8")  // 8-bit or dual 4-bit carry (DUAL_CY4, SINGLE_CY8)
   )
   CARRY8_inst (
      .CO(CO),         // 8-bit output: Carry-out
      .O(O),           // 8-bit output: Carry chain XOR data out
      .CI(CI),         // 1-bit input: Lower Carry-In
      .CI_TOP(CI_TOP), // 1-bit input: Upper Carry-In
      .DI(DI),         // 8-bit input: Carry-MUX data in
      .S(S)            // 8-bit input: Carry-mux select
   );

   // End of CARRY8_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Two input AND gate implemented in place of a CLB Latch (AND2B1L)" treetype="template">
//   AND2B1L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (AND2B1L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // AND2B1L: Two input AND gate implemented in place of a CLB Latch
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   AND2B1L #(
      .IS_SRI_INVERTED(1'b0)  // Optional inversion for SRI
   )
   AND2B1L_inst (
      .O(O),     // 1-bit output: AND gate output
      .DI(DI),   // 1-bit input: Data input connected to LUT logic
      .SRI(SRI)  // 1-bit input: External CLB data
   );

   // End of AND2B1L_inst instantiation
					</Template>
					<Template label="Two input OR gate implemented in place of a CLB Latch (OR2L)" treetype="template">
//    OR2L     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OR2L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OR2L: Two input OR gate implemented in place of a CLB Latch
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OR2L #(
      .IS_SRI_INVERTED(1'b0)  // Optional inversion for SRI
   )
   OR2L_inst (
      .O(O),     // 1-bit output: OR gate output
      .DI(DI),   // 1-bit input: Data input connected to LUT logic
      .SRI(SRI)  // 1-bit input: External CLB data
   );

   // End of OR2L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUT" treetype="folder">
					<Template label="1-Bit Look-Up Table (LUT1)" treetype="template">
//    LUT1     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1: 1-Bit Look-Up Table
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT1 #(
      .INIT(2'h0)  // Logic function
   )
   LUT1_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0)  // 1-bit input: LUT
   );

   // End of LUT1_inst instantiation
					</Template>
					<Template label="2-Bit Look-Up Table (LUT2)" treetype="template">
//    LUT2     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2: 2-Bit Look-Up Table
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT2 #(
      .INIT(4'h0)  // Logic function
   )
   LUT2_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1)  // 1-bit input: LUT
   );

   // End of LUT2_inst instantiation
					</Template>
					<Template label="3-Bit Look-Up Table (LUT3)" treetype="template">
//    LUT3     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3: 3-Bit Look-Up Table
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT3 #(
      .INIT(8'h00)  // Logic function
   )
   LUT3_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2)  // 1-bit input: LUT
   );

   // End of LUT3_inst instantiation
					</Template>
					<Template label="4-Bit Look-Up Table (LUT4)" treetype="template">
//    LUT4     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4: 4-Bit Look-Up Table
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT(16'h0000)  // Logic function
   )
   LUT4_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3)  // 1-bit input: LUT
   );

   // End of LUT4_inst instantiation
					</Template>
					<Template label="5-Bit Look-Up Table (LUT5)" treetype="template">
//    LUT5     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5: 5-Bit Look-Up Table
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT5 #(
      .INIT(32'h00000000)  // Logic function
   )
   LUT5_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3), // 1-bit input: LUT
      .I4(I4)  // 1-bit input: LUT
   );

   // End of LUT5_inst instantiation
					</Template>
					<Template label="5-input Dynamically Reconfigurable Look-Up Table (LUT) (CFGLUT5)" treetype="template">
//   CFGLUT5   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CFGLUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CFGLUT5: 5-input Dynamically Reconfigurable Look-Up Table (LUT)
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   CFGLUT5 #(
      .INIT(32'h00000000),    // Initial logic function
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   CFGLUT5_inst (
      .CDO(CDO), // 1-bit output: Reconfiguration cascade
      .O5(O5),   // 1-bit output: 4-LUT
      .O6(O6),   // 1-bit output: 5-LUT
      .CDI(CDI), // 1-bit input: Reconfiguration data
      .CE(CE),   // 1-bit input: Reconfiguration enable
      .CLK(CLK), // 1-bit input: Clock
      // LUT Inputs inputs: Logic inputs
      .I0(I0),
      .I1(I1),
      .I2(I2),
      .I3(I3),
      .I4(I4) 
   );

   // End of CFGLUT5_inst instantiation
					</Template>
					<Template label="6-Bit Look-Up Table (LUT6)" treetype="template">
//    LUT6     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6: 6-Bit Look-Up Table
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT6 #(
      .INIT(64'h0000000000000000)  // Logic function
   )
   LUT6_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3), // 1-bit input: LUT
      .I4(I4), // 1-bit input: LUT
      .I5(I5)  // 1-bit input: LUT
   );

   // End of LUT6_inst instantiation
					</Template>
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
// The INIT parameter for the FPGA LUT primitive is what gives the LUT its 
// logical value. By default this value is zero thus driving the output to a  
// zero regardless of the input values (acting as a ground) however in most 
// cases an new INIT value must be determined in order to specify the logic 
// function for the LUT primitive.  There are a few methods in which the LUT 
// value can be determined and two of those methods will be discussed here.
//
// The Truth Table Method
// ----------------------
//
//  A common method to determine the desired INIT value for a LUT is using a 
// truth table.  To do so, simply create a binary truth table of all possible 
// inputs, specify the desired logic value of the output and then create the 
// INIT string from those output values.  An example is shown below:
//
// Example of determining an XOR INIT equation for a LUT4:
//
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | 0 |\
//     |  0  0  0  1 | 1 | \ = 4'b0110 = 4'h6 ---------------+
//     |  0  0  1  0 | 1 | /                                 |
//     |  0  0  1  1 | 0 |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | 1 |\                                  |
//     |  0  1  0  1 | 0 | \ = 4'b1001 = 4'h9                |
//     |  0  1  1  0 | 0 | /                                 |
//     |  0  1  1  1 | 1 |/                                  |                     
//     |-------------|---|                     INIT = 16'h6996
//     |  1  0  0  0 | 1 |\                               |
//     |  1  0  0  1 | 0 | \ = 4'b0110 = 4'h9             |
//     |  1  0  1  0 | 0 | /                              |
//     |  1  0  1  1 | 1 |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | 0 |\                               |
//     |  1  1  0  1 | 1 | \ = 4'b1001 = 4'h6 ------------+
//     |  1  1  1  0 | 1 | /
//     |  1  1  1  1 | 0 |/
//     -------------------
//
// Example of determining a 3-input AND gate:
//
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | 0 |\
//     |  0  0  1 | 0 | \ = 4'b0000 = 4'h0 --------------+
//     |  0  1  0 | 0 | /                                |
//     |  0  1  1 | 0 |/                                 |
//     |----------|---|                       INIT = 8'h80 
//     |  1  0  0 | 0 |\                                |
//     |  1  0  1 | 0 | \ = 4'b1000 = 4'h8 -------------+
//     |  1  1  0 | 0 | / 
//     |  1  1  1 | 1 |/                      
//     ----------------
//
// The Equation Method
// -------------------
//
// Another method to determine the LUT value is to define parameters for each 
// input to the LUT that correspond to their listed truth value and use those to
// build the logic equation you are after.  This method is easier to understand 
// once you have grasped the concept and more self-documenting that the above 
// method however does require the code to first specify the appropriate 
// parameters.  See the example below.
//
// Example of specifying the equation (A and B) or (C and D) for a LUT4:
//
   // The following parameters are defined to allow for
   //   equation-based INIT specification.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;

   // LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT((I0&amp;I1)|(I2&amp;I3))  // Specify LUT Contents
   ) LUT4_inst (
      .O(O_LUT), // LUT general output
      .I0(A),    // LUT input
      .I1(B),    // LUT input
      .I2(C),    // LUT input
      .I3(D)     // LUT input
   );

   // End of LUT4_inst instantiation

// With the parameters specifying all possible cases for the truth table, a 
// Verilog equation can be written to determine the end INIT value.
						</Template>
						<SubFolder label="INIT Parameters" treetype="folder">
							<Template label="LUT1" treetype="template">
   // The following parameter is defined to allow for
   //   equation-based INIT specification for a LUT1.
   parameter I0 = 2'b10;
							</Template>
							<Template label="LUT2" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT2.
   parameter I0 = 4'ha;
   parameter I1 = 4'hc;
							</Template>
							<Template label="LUT3" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT3.
   parameter I0 = 8'haa;
   parameter I1 = 8'hcc;
   parameter I2 = 8'hf0;
							</Template>
							<Template label="LUT4" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT4.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;
							</Template>
							<Template label="LUT5" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT5.
   parameter I0 = 32'haaaaaaaa;
   parameter I1 = 32'hcccccccc;
   parameter I2 = 32'hf0f0f0f0;
   parameter I3 = 32'hff00ff00;
   parameter I4 = 32'hffff0000;
							</Template>
							<Template label="LUT6" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT6.
   parameter I0 = 64'haaaaaaaaaaaaaaaa;
   parameter I1 = 64'hcccccccccccccccc;
   parameter I2 = 64'hf0f0f0f0f0f0f0f0;
   parameter I3 = 64'hff00ff00ff00ff00;
   parameter I4 = 64'hffff0000ffff0000;
   parameter I5 = 64'hffffffff00000000;
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
//  Truth Table to determine INIT value for a LUT1
//      ________
//     | I0 | O |
//     |--------|
//     |  0 | ? |\
//     |  1 | ? |/ = 2'b??
//     ----------
							</Template>
							<Template label="LUT2" treetype="template">
//  Truth Table to determine INIT value for a LUT2
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
//     |  0  1  0 | ? | /
//     |  0  1  1 | ? |/ 
//      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
//  Truth Table to determine INIT value for a LUT3
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
//     |  0  1  0 | ? | /                                |
//     |  0  1  1 | ? |/                                 |
//     |----------|---|                       INIT = 8'h?? 
//     |  1  0  0 | ? |\                                |
//     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
//     |  1  1  0 | ? | / 
//     |  1  1  1 | ? |/                      
//     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
//  Truth Table to determine INIT value for a LUT4
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | ? |\
//     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
//     |  0  0  1  0 | ? | /                                 |
//     |  0  0  1  1 | ? |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | ? |\                                  |
//     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
//     |  0  1  1  0 | ? | /                                 |
//     |  0  1  1  1 | ? |/                                  |                     
//     |-------------|---|                     INIT = 16'h????
//     |  1  0  0  0 | ? |\                               |
//     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  0 | ? | /                              |
//     |  1  0  1  1 | ? |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | ? |\                               |
//     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  0 | ? | /
//     |  1  1  1  1 | ? |/
//     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
//  Truth Table to determine INIT value for a LUT5
//      ____________________
//     | I4 I3 I2 I1 I0 | O |
//     |--------------------|
//     |  0  0  0  0  0 | ? |\
//     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  0  1  0  0 | ? |\                                      |
//     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1 | ? |/                                      |                     
//     |----------------|---|                                       |
//     |  0  1  0  0  0 | ? |\                                      |
//     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  0 | ? | /                                     |
//     |  0  1  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  1  1  0  0 | ? |\                                      |
//     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1 | ? |/                                      |
//     ----------------------                     INIT = 32'h????????
//     |  1  0  0  0  0 | ? |\                               |
//     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  0  1  0 | ? | /                              |
//     |  1  0  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  0  1  0  0 | ? |\                               |
//     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  1  0 | ? | /                              |
//     |  1  0  1  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  0  0  0 | ? |\                               |
//     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  1  0  1  0 | ? | /                              |
//     |  1  1  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  1  0  0 | ? |\                               |
//     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1 | ? |/
//     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
//  Truth Table to determine INIT value for a LUT6
//      _______________________
//     | I5 I4 I3 I2 I1 I0 | O |
//     |-----------------------|
//     |  0  0  0  0  0  0 | ? |\
//     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  0  1  0  0 | ? |\                                      |
//     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  0  1  1  0 | ? | /                                     |
//     |  0  0  0  1  1  1 | ? |/                                      |                     
//     |-------------------|---|                                       |
//     |  0  0  1  0  0  0 | ? |\                                      |
//     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  0  1  0 | ? | /                                     |
//     |  0  0  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  1  1  0  0 | ? |\                                      |
//     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1  1 | ? |/                                      |
//     -------------------------                                       |
//     |  0  1  0  0  0  0 | ? |\                                      |
//     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  0  1  0 | ? | /                                     |
//     |  0  1  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  0  1  0  0 | ? |\                                      |
//     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  1  0 | ? | /                                     |
//     |  0  1  0  1  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  0  0  0 | ? |\                                      |
//     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  0  1  0 | ? | /                                     |
//     |  0  1  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  1  0  0 | ? |\                                      |
//     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1  1 | ? |/                                      |
//     ------------------------              INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
							<Template label="LUT6_2" treetype="template">
//  Truth Table to determine INIT value for a LUT6_2
//      _____________________________
//     | I5 I4 I3 I2 I1 I0 | O6 | O5 |
//     |-----------------------------|
//     |  0  0  0  0  0  0 |    ?    |\
//     |  0  0  0  0  0  1 |    ?    | \ = 4'b???? = 4'h? -------------+
//     |  0  0  0  0  1  0 |    ?    | /                               |
//     |  0  0  0  0  1  1 |	?    |/				       |
//     |-------------------|---------|                                 |
//     |  0  0  0  1  0  0 |	?    |\                                |
//     |  0  0  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  0  1  1  0 |	?    | /                               |
//     |  0  0  0  1  1  1 |	?    |/                                |                     
//     |-------------------|---------|                                 |
//     |  0  0  1  0  0  0 |	?    |\                                |
//     |  0  0  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  0  1  0 |	?    | /                               |
//     |  0  0  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  0  1  1  0  0 |	?    |\                                |
//     |  0  0  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  1  1  0 |	?    | /                               |
//     |  0  0  1  1  1  1 |	?    |/                                |
//     -------------------------------                                 |
//     |  0  1  0  0  0  0 |	?    |\                                |
//     |  0  1  0  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  0  1  0 |	?    | /                               |
//     |  0  1  0  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  0  1  0  0 |	?    |\                                |
//     |  0  1  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  1  1  0 |	?    | /                               |
//     |  0  1  0  1  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  0  0  0 |	?    |\                                |
//     |  0  1  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  0  1  0 |	?    | /                               |
//     |  0  1  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  1  0  0 |	?    |\                                |
//     |  0  1  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  1  1  0 |	?    | /                               |
//     |  0  1  1  1  1  1 |	?    |/                                |
//     ------------------------------        INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT6_2" treetype="template">
//   LUT6_2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_2: 6-input, 2 output Look-Up Table
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LUT6_2 #(
      .INIT(64'h0000000000000000) // Specify LUT Contents
   ) LUT6_2_inst (
      .O6(O6), // 1-bit LUT6 output
      .O5(O5), // 1-bit lower LUT5 output
      .I0(I0), // 1-bit LUT input
      .I1(I1), // 1-bit LUT input
      .I2(I2), // 1-bit LUT input
      .I3(I3), // 1-bit LUT input
      .I4(I4), // 1-bit LUT input
      .I5(I5)  // 1-bit LUT input (fast MUX select only available to O6 output)
   );

   // End of LUT6_2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUTRAM" treetype="folder">
					<Template label="64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM) (RAM64X8SW)" treetype="template">
//  RAM64X8SW  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X8SW_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X8SW: 64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM)
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM64X8SW #(
      .INIT_A(64'h0000000000000000), // Initial contents of the RAM for Bit 7
      .INIT_B(64'h0000000000000000), // Initial contents of the RAM for Bit 6
      .INIT_C(64'h0000000000000000), // Initial contents of the RAM for Bit 5
      .INIT_D(64'h0000000000000000), // Initial contents of the RAM for Bit 4
      .INIT_E(64'h0000000000000000), // Initial contents of the RAM for Bit 3
      .INIT_F(64'h0000000000000000), // Initial contents of the RAM for Bit 2
      .INIT_G(64'h0000000000000000), // Initial contents of the RAM for Bit 1
      .INIT_H(64'h0000000000000000), // Initial contents of the RAM for Bit 0
      .IS_WCLK_INVERTED(1'b0)        // Optional inversion for WCLK
   )
   RAM64X8SW_inst (
      .O(O),       // 8-bit data output
      .A(A),       // 6-bit address input
      .D(D),       // 1-bit input: Write data input
      .WCLK(WCLK), // 1-bit input: Write clock input
      .WE(WE),     // 1-bit input: Write enable input
      .WSEL(WSEL)  // 3-bit write select
   );

   // End of RAM64X8SW_inst instantiation
					</Template>
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 X 1 negedge write (RAM32X1D_1)" treetype="template">
//  RAM32X1D_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_1_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D_1: 32 x 1 negative edge write, asynchronous read dual-port
   //             distributed RAM (Mapped to two LUT6s)
   //             Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1 #(
      .INIT(32'h00000000),    // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0) // Specifies active high/low WCLK
   ) RAM32X1D_1_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_1_inst instantiation
						</Template>
						<Template label="32 X 1 posedge write (RAM32X1D)" treetype="template">
//   RAM32X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D: 32 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to two LUT6s)
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D #(
      .INIT(32'h00000000),     // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM32X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_inst instantiation
						</Template>
						<Template label="64 X 1 posedge write (RAM64X1D)" treetype="template">
//   RAM64X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM64X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1D: 64 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to two LUT6s)
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1D #(
      .INIT(64'h0000000000000000), // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)      // Specifies active high/low WCLK
   ) RAM64X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .A5(A5),       // Rw/ address[5] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .DPRA5(DPRA5), // Read-only address[5] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM64X1D_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">
//  RAM128X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM128X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read
   //            dual-port distributed LUT RAM
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM128X1D #(
      .INIT(128'h00000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0) // Specifies active high/low WCLK
   ) RAM128X1D_inst (
      .DPO(DPO),   // Read port 1-bit output
      .SPO(SPO),   // Read/write port 1-bit output
      .A(A),       // Read/write port 7-bit address input
      .D(D),       // RAM data input
      .DPRA(DPRA), // Read port 7-bit address input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM128X1D_inst instantiation
						</Template>
						<Template label="256 X 1 posedge write (RAM256X1D)" treetype="template">
//  RAM256X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM256X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM256X1D: 256-deep by 1-wide positive edge write, asynchronous read
   //            dual-port distributed LUT RAM
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM256X1D #(
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM256X1D_inst (
      .DPO(DPO),   // Read port 1-bit output
      .SPO(SPO),   // Read/write port 1-bit output
      .A(A),       // Read/write port 8-bit address input
      .D(D),       // RAM data input
      .DPRA(DPRA), // Read port 8-bit address input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM256X1D_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">
//   RAM32M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32M: 32-deep by 8-wide Multi Port LUT RAM (Mapped to four LUT6s)
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4
      
   RAM32M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM32M_inst (
      .DOA(DOA),     // Read port A 2-bit output
      .DOB(DOB),     // Read port B 2-bit output
      .DOC(DOC),     // Read port C 2-bit output
      .DOD(DOD),     // Read/write port D 2-bit output
      .ADDRA(ADDRA), // Read port A 5-bit address input
      .ADDRB(ADDRB), // Read port B 5-bit address input
      .ADDRC(ADDRC), // Read port C 5-bit address input
      .ADDRD(ADDRD), // Read/write port D 5-bit address input
      .DIA(DIA),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );
   
   // End of RAM32M_inst instantiation
						</Template>
						<Template label="32 X 16 (RAM32M16)" treetype="template">
//   RAM32M16  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32M16_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32M16: 32-deep by 16-wide Multi Port LUT RAM (Mapped to eight LUT6s)
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4
      
   RAM32M16 #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .INIT_E(64'h0000000000000000), // Initial contents of E Port
      .INIT_F(64'h0000000000000000), // Initial contents of F Port
      .INIT_G(64'h0000000000000000), // Initial contents of G Port
      .INIT_H(64'h0000000000000000), // Initial contents of H Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM32M16_inst (
      .DOA(DOA),     // Read port A 2-bit output
      .DOB(DOB),     // Read port B 2-bit output
      .DOC(DOC),     // Read port C 2-bit output
      .DOD(DOD),     // Read port D 2-bit output
      .DOE(DOE),     // Read port E 2-bit output
      .DOF(DOF),     // Read port F 2-bit output
      .DOG(DOG),     // Read port G 2-bit output
      .DOH(DOH),     // Read/write port H 2-bit output
      .ADDRA(ADDRA), // Read port A 5-bit address input
      .ADDRB(ADDRB), // Read port B 5-bit address input
      .ADDRC(ADDRC), // Read port C 5-bit address input
      .ADDRD(ADDRD), // Read port D 5-bit address input
      .ADDRE(ADDRE), // Read port E 5-bit address input
      .ADDRF(ADDRF), // Read port F 5-bit address input
      .ADDRG(ADDRG), // Read port G 5-bit address input
      .ADDRH(ADDRH), // Read/write port H 5-bit address input
      .DIA(DIA),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .DIE(DIE),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRE
      .DIF(DIF),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRF
      .DIG(DIG),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRG
      .DIH(DIH),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRH
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );
   
   // End of RAM32M16_inst instantiation
						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">
//   RAM64M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64M: 64-deep by 4-wide Multi Port LUT RAM (Mapped to four LUT6s)
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM64M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM64M_inst (
      .DOA(DOA),     // Read port A 1-bit output
      .DOB(DOB),     // Read port B 1-bit output
      .DOC(DOC),     // Read port C 1-bit output
      .DOD(DOD),     // Read/write port D 1-bit output
      .DIA(DIA),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .ADDRA(ADDRA), // Read port A 6-bit address input
      .ADDRB(ADDRB), // Read port B 6-bit address input
      .ADDRC(ADDRC), // Read port C 6-bit address input
      .ADDRD(ADDRD), // Read/write port D 6-bit address input
      .WE(WE),       // Write enable input
      .WCLK(WCLK)    // Write clock input
   );

   // End of RAM64M_inst instantiation
						</Template>
						<Template label="64 X 8 (RAM64M8)" treetype="template">
//   RAM64M8   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64M8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64M8: 64-deep by 8-wide Multi Port LUT RAM (Mapped to eight LUT6s)
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM64M8 #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000), // Initial contents of D Port
      .INIT_E(64'h0000000000000000), // Initial contents of E Port
      .INIT_F(64'h0000000000000000), // Initial contents of F Port
      .INIT_G(64'h0000000000000000), // Initial contents of G Port
      .INIT_H(64'h0000000000000000), // Initial contents of H Port
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM64M8_inst (
      .DOA(DOA),     // Read port A 1-bit output
      .DOB(DOB),     // Read port B 1-bit output
      .DOC(DOC),     // Read port C 1-bit output
      .DOD(DOD),     // Read port D 1-bit output
      .DOE(DOE),     // Read port E 1-bit output
      .DOF(DOF),     // Read port F 1-bit output
      .DOG(DOG),     // Read port G 1-bit output
      .DOH(DOH),     // Read/write port H 1-bit output
      .DIA(DIA),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .DIE(DIE),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRE
      .DIF(DIF),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRF
      .DIG(DIG),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRG
      .DIH(DIH),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRH
      .ADDRA(ADDRA), // Read port A 6-bit address input
      .ADDRB(ADDRB), // Read port B 6-bit address input
      .ADDRC(ADDRC), // Read port C 6-bit address input
      .ADDRD(ADDRD), // Read port D 6-bit address input
      .ADDRE(ADDRE), // Read port E 6-bit address input
      .ADDRF(ADDRF), // Read port F 6-bit address input
      .ADDRG(ADDRG), // Read port G 6-bit address input
      .ADDRH(ADDRH), // Read/write port H 6-bit address input
      .WE(WE),       // Write enable input
      .WCLK(WCLK)    // Write clock input
   );

   // End of RAM64M8_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">
//  RAM32X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM (Mapped to a LUT6)
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1S #(
      .INIT(32'h00000000),    // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0) // Specifies active high/low WCLK
   ) RAM32X1S_inst (
      .O(O),       // RAM output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D(D),       // RAM data input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X1S_inst instantiation
						</Template>
						<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">
//  RAM64X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port
   //           distributed RAM (Mapped to a LUT6)
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1S #(
      .INIT(64'h0000000000000000), // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)      // Specifies active high/low WCLK
   ) RAM64X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM64X1S_inst instantiation
						</Template>
						<Template label="128 X 1 negedge write (RAM128X1S_1)" treetype="template">
// RAM128X1S_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S_1: 128 x 1 negative edge write, asynchronous read single-port
   //              distributed RAM (Mapped to two LUT6s)
   //              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1 #(
      .INIT(128'h00000000000000000000000000000000),  // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM128X1S_1_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_1_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1S)" treetype="template">
//  RAM128X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S: 128 x 1 positive edge write, asynchronous read single-port
   //            distributed RAM (Mapped to two LUT6s)
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S #(
      .INIT(128'h00000000000000000000000000000000), // Initial contents of RAM
      .IS_WCLK_INVERTED(1'b0)        // Specifies active high/low WCLK
   ) RAM128X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_inst instantiation
						</Template>
						<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">
//  RAM256X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM256X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read  (Mapped to four LUT6s)
   //            single-port distributed LUT RAM
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM256X1S #( 
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM256X1S_inst (
      .O(O),       // Read/write port 1-bit output
      .A(A),       // Read/write port 8-bit address input
      .WE(WE),     // Write enable input
      .WCLK(WCLK), // Write clock input
      .D(D)        // RAM data input
   );

   // End of RAM256X1S_inst instantiation
						</Template>
						<Template label="512 X 1 posedge write (RAM512X1S)" treetype="template">
//  RAM512X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM512X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM512X1S: 512-deep by 1-wide positive edge write, asynchronous read  (Mapped to eight LUT6s)
   //            single-port distributed LUT RAM
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4
   
   RAM512X1S #( 
      .INIT(512'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000),
      .IS_WCLK_INVERTED(1'b0)  // Specifies active high/low WCLK
   ) RAM512X1S_inst (
      .O(O),       // Read/write port 1-bit output
      .A(A),       // Read/write port 9-bit address input
      .WE(WE),     // Write enable input
      .WCLK(WCLK), // Write clock input
      .D(D)        // RAM data input
   );

   // End of RAM512X1S_inst instantiation
						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="MUXF" treetype="folder">
					<Template label="CLB MUX to connect two LUT6's Together (MUXF7)" treetype="template">
//    MUXF7    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7: CLB MUX to connect two LUT6's Together
   //        Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MUXF7 MUXF7_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to LUT6 output
      .I1(I1), // 1-bit input: Connect to LUT6 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF7_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF7's Together (MUXF8)" treetype="template">
//    MUXF8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8: CLB MUX to connect two MUXF7's Together
   //        Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MUXF8 MUXF8_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to MUXF7 output
      .I1(I1), // 1-bit input: Connect to MUXF7 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF8_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF8's Together (MUXF9)" treetype="template">
//    MUXF9    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF9_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF9: CLB MUX to connect two MUXF8's Together
   //        Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MUXF9 MUXF9_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to MUXF8 output
      .I1(I1), // 1-bit input: Connect to MUXF8 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF9_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="16-Bit Shift Register Look-Up Table (LUT) (SRL16E)" treetype="template">
//   SRL16E    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL16E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRL16E: 16-Bit Shift Register Look-Up Table (LUT)
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   SRL16E #(
      .INIT(16'h0000),        // Initial contents of shift register
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   SRL16E_inst (
      .Q(Q),     // 1-bit output: SRL Data
      .CE(CE),   // 1-bit input: Clock enable
      .CLK(CLK), // 1-bit input: Clock
      .D(D),     // 1-bit input: SRL Data
      // Depth Selection inputs: A0-A3 select SRL depth
      .A0(A0),
      .A1(A1),
      .A2(A2),
      .A3(A3) 
   );

   // End of SRL16E_inst instantiation
					</Template>
					<Template label="32-Bit Shift Register Look-Up Table (LUT) (SRLC32E)" treetype="template">
//   SRLC32E   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRLC32E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRLC32E: 32-Bit Shift Register Look-Up Table (LUT)
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   SRLC32E #(
      .INIT(32'h00000000),    // Initial contents of shift register
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   SRLC32E_inst (
      .Q(Q),     // 1-bit output: SRL Data
      .Q31(Q31), // 1-bit output: SRL Cascade Data
      .A(A),     // 5-bit input: Selects SRL depth
      .CE(CE),   // 1-bit input: Clock enable
      .CLK(CLK), // 1-bit input: Clock
      .D(D)      // 1-bit input: SRL Data
   );

   // End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLOCK" treetype="folder">
				<SubFolder label="BUFFER" treetype="folder">
					<Template label="Clock Buffer Driven by Gigabit Transceiver (BUFG_GT)" treetype="template">
//   BUFG_GT   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_GT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_GT: Clock Buffer Driven by Gigabit Transceiver
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFG_GT BUFG_GT_inst (
      .O(O),             // 1-bit output: Buffer
      .CE(CE),           // 1-bit input: Buffer enable
      .CEMASK(CEMASK),   // 1-bit input: CE Mask
      .CLR(CLR),         // 1-bit input: Asynchronous clear
      .CLRMASK(CLRMASK), // 1-bit input: CLR Mask
      .DIV(DIV),         // 3-bit input: Dynamic divide Value
      .I(I)              // 1-bit input: Buffer
   );

   // End of BUFG_GT_inst instantiation
					</Template>
					<Template label="General Clock Buffer (BUFG)" treetype="template">
//    BUFG     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG: General Clock Buffer
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFG BUFG_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFG_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
//   BUFGCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE: General Clock Buffer with Clock Enable
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE #(
      .CE_TYPE("SYNC"),      // ASYNC, SYNC
      .IS_CE_INVERTED(1'b0), // Programmable inversion on CE
      .IS_I_INVERTED(1'b0)   // Programmable inversion on I
   )
   BUFGCE_inst (
      .O(O),   // 1-bit output: Buffer
      .CE(CE), // 1-bit input: Buffer enable
      .I(I)    // 1-bit input: Buffer
   );

   // End of BUFGCE_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Divide (BUFGCE_DIV)" treetype="template">
// BUFGCE_DIV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_DIV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_DIV: General Clock Buffer with Divide Function
   //             Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_DIV #(
      .BUFGCE_DIVIDE(1),      // 1-8
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CE_INVERTED(1'b0),  // Optional inversion for CE
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_I_INVERTED(1'b0)    // Optional inversion for I
   )
   BUFGCE_DIV_inst (
      .O(O),     // 1-bit output: Buffer
      .CE(CE),   // 1-bit input: Buffer enable
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .I(I)      // 1-bit input: Buffer
   );

   // End of BUFGCE_DIV_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
//  BUFGCE_1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_1: General Clock Buffer with Clock Enable and Output State 1
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_1 BUFGCE_1_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock buffer active-High enable
      .I(I)    // 1-bit input: Clock input
   );

   // End of BUFGCE_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="CLOCK_SYNC" treetype="folder">
					<Template label="Synchronizer for BUFG_GT Control Signals (BUFG_GT_SYNC)" treetype="template">
// BUFG_GT_SYNC : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFG_GT_SYNC_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_GT_SYNC: Synchronizer for BUFG_GT Control Signals
   //               Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFG_GT_SYNC BUFG_GT_SYNC_inst (
      .CESYNC(CESYNC),   // 1-bit output: Synchronized CE
      .CLRSYNC(CLRSYNC), // 1-bit output: Synchronized CLR
      .CE(CE),           // 1-bit input: Asynchronous enable
      .CLK(CLK),         // 1-bit input: Clock
      .CLR(CLR)          // 1-bit input: Asynchronous clear
   );

   // End of BUFG_GT_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUX" treetype="folder">
					<Template label="2-to-1 General Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
// BUFGMUX_CTRL : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_CTRL: 2-to-1 General Clock MUX Buffer
   //               Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL BUFGMUX_CTRL_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="General Clock Control Buffer (BUFGCTRL)" treetype="template">
//  BUFGCTRL   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCTRL: General Clock Control Buffer
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGCTRL #(
      .INIT_OUT(0),               // Initial value of BUFGCTRL output, 0-1
      .PRESELECT_I0("FALSE"),     // BUFGCTRL output uses I0 input, FALSE, TRUE
      .PRESELECT_I1("FALSE"),     // BUFGCTRL output uses I1 input, FALSE, TRUE
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CE0_INVERTED(1'b0),     // Optional inversion for CE0
      .IS_CE1_INVERTED(1'b0),     // Optional inversion for CE1
      .IS_I0_INVERTED(1'b0),      // Optional inversion for I0
      .IS_I1_INVERTED(1'b0),      // Optional inversion for I1
      .IS_IGNORE0_INVERTED(1'b0), // Optional inversion for IGNORE0
      .IS_IGNORE1_INVERTED(1'b0), // Optional inversion for IGNORE1
      .IS_S0_INVERTED(1'b0),      // Optional inversion for S0
      .IS_S1_INVERTED(1'b0)       // Optional inversion for S1
   )
   BUFGCTRL_inst (
      .O(O),             // 1-bit output: Clock output
      .CE0(CE0),         // 1-bit input: Clock enable input for I0
      .CE1(CE1),         // 1-bit input: Clock enable input for I1
      .I0(I0),           // 1-bit input: Primary clock
      .I1(I1),           // 1-bit input: Secondary clock
      .IGNORE0(IGNORE0), // 1-bit input: Clock ignore input for I0
      .IGNORE1(IGNORE1), // 1-bit input: Clock ignore input for I1
      .S0(S0),           // 1-bit input: Clock select for I0
      .S1(S1)            // 1-bit input: Clock select for I1
   );

   // End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer (BUFGMUX)" treetype="template">
//   BUFGMUX   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX: General Clock Mux Buffer
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX #(
      .CLK_SEL_TYPE("SYNC")  // ASYNC, SYNC
   )
   BUFGMUX_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
//  BUFGMUX_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_1: General Clock Mux Buffer with Output State 1
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1 #(
      .CLK_SEL_TYPE("SYNC")  // ASYNC, SYNC
   )
   BUFGMUX_1_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME3_ADV)" treetype="template">
// MMCME3_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME3_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME3_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   //             Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MMCME3_ADV #(
      .BANDWIDTH("OPTIMIZED"),        // Jitter programming (HIGH, LOW, OPTIMIZED)
      .CLKFBOUT_MULT_F(5.0),          // Multiply value for all CLKOUT (2.000-64.000)
      .CLKFBOUT_PHASE(0.0),           // Phase offset in degrees of CLKFB (-360.000-360.000)
      // CLKIN_PERIOD: Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      .CLKOUT0_DIVIDE_F(1.0),         // Divide amount for CLKOUT0 (1.000-128.000)
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      // CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_CASCADE("FALSE"),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .COMPENSATION("AUTO"),          // AUTO, BUF_IN, EXTERNAL, INTERNAL, ZHOLD
      .DIVCLK_DIVIDE(1),              // Master division value (1-106)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0),     // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),      // Optional inversion for CLKIN1
      .IS_CLKIN2_INVERTED(1'b0),      // Optional inversion for CLKIN2
      .IS_CLKINSEL_INVERTED(1'b0),    // Optional inversion for CLKINSEL
      .IS_PSEN_INVERTED(1'b0),        // Optional inversion for PSEN
      .IS_PSINCDEC_INVERTED(1'b0),    // Optional inversion for PSINCDEC
      .IS_PWRDWN_INVERTED(1'b0),      // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE"),         // Delays DONE until MMCM is locked (FALSE, TRUE)
      // Spread Spectrum: Spread Spectrum Attributes
      .SS_EN("FALSE"),                // Enables spread spectrum (FALSE, TRUE)
      .SS_MODE("CENTER_HIGH"),        // CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      .SS_MOD_PERIOD(10000),          // Spread spectrum modulation period (ns) (4000-40000)
      // USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      .CLKFBOUT_USE_FINE_PS("FALSE"),
      .CLKOUT0_USE_FINE_PS("FALSE"),
      .CLKOUT1_USE_FINE_PS("FALSE"),
      .CLKOUT2_USE_FINE_PS("FALSE"),
      .CLKOUT3_USE_FINE_PS("FALSE"),
      .CLKOUT4_USE_FINE_PS("FALSE"),
      .CLKOUT5_USE_FINE_PS("FALSE"),
      .CLKOUT6_USE_FINE_PS("FALSE") 
   )
   MMCME3_ADV_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),           // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),         // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),           // 1-bit output: Primary clock
      .CLKOUT1B(CLKOUT1B),         // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),           // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),         // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),           // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),         // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),           // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),           // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),           // 1-bit output: CLKOUT6
      // DRP Ports outputs: Dynamic reconfiguration ports
      .DO(DO),                     // 16-bit output: DRP data
      .DRDY(DRDY),                 // 1-bit output: DRP ready
      // Dynamic Phase Shift Ports outputs: Ports used for dynamic phase shifting of the outputs
      .PSDONE(PSDONE),             // 1-bit output: Phase shift done
      // Feedback outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),         // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB),       // 1-bit output: Inverted CLKFBOUT
      // Status Ports outputs: MMCM status ports
      .CDDCDONE(CDDCDONE),         // 1-bit output: Clock dynamic divide done
      .CLKFBSTOPPED(CLKFBSTOPPED), // 1-bit output: Feedback clock stopped
      .CLKINSTOPPED(CLKINSTOPPED), // 1-bit output: Input clock stopped
      .LOCKED(LOCKED),             // 1-bit output: LOCK
      .CDDCREQ(CDDCREQ),           // 1-bit input: Request to dynamic divide clock
      // Clock Inputs inputs: Clock inputs
      .CLKIN1(CLKIN1),             // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),             // 1-bit input: Secondary clock
      // Control Ports inputs: MMCM control ports
      .CLKINSEL(CLKINSEL),         // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),             // 1-bit input: Power-down
      .RST(RST),                   // 1-bit input: Reset
      // DRP Ports inputs: Dynamic reconfiguration ports
      .DADDR(DADDR),               // 7-bit input: DRP address
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable
      .DI(DI),                     // 16-bit input: DRP data
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // Dynamic Phase Shift Ports inputs: Ports used for dynamic phase shifting of the outputs
      .PSCLK(PSCLK),               // 1-bit input: Phase shift clock
      .PSEN(PSEN),                 // 1-bit input: Phase shift enable
      .PSINCDEC(PSINCDEC),         // 1-bit input: Phase shift increment/decrement
      // Feedback inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)            // 1-bit input: Feedback clock
   );

   // End of MMCME3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE3_ADV)" treetype="template">
//  PLLE3_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE3_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE3_ADV: Advanced Phase-Locked Loop (PLL)
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   PLLE3_ADV #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT, (1-19)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB, (-360.000-360.000)
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0 (1-128)
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0 (0.001-0.999)
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0 (-360.000-360.000)
      // CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1 (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1 (0.001-0.999)
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1 (-360.000-360.000)
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      .COMPENSATION("AUTO"),      // AUTO, BUF_IN, INTERNAL
      .DIVCLK_DIVIDE(1),          // Master division value, (1-15)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked (FALSE, TRUE)
   )
   PLLE3_ADV_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      // DRP Ports outputs: Dynamic reconfiguration ports
      .DO(DO),                   // 16-bit output: DRP data
      .DRDY(DRDY),               // 1-bit output: DRP ready
      // Feedback Clocks outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      // Control Ports inputs: PLL control ports
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST),                 // 1-bit input: Reset
      // DRP Ports inputs: Dynamic reconfiguration ports
      .DADDR(DADDR),             // 7-bit input: DRP address
      .DCLK(DCLK),               // 1-bit input: DRP clock
      .DEN(DEN),                 // 1-bit input: DRP enable
      .DI(DI),                   // 16-bit input: DRP data
      .DWE(DWE),                 // 1-bit input: DRP write enable
      // Feedback Clocks inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)          // 1-bit input: Feedback clock
   );

   // End of PLLE3_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME3_BASE)" treetype="template">
// MMCME3_BASE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME3_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME3_BASE: Base Mixed Mode Clock Manager (MMCM)
   //              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MMCME3_BASE #(
      .BANDWIDTH("OPTIMIZED"),    // Jitter programming (HIGH, LOW, OPTIMIZED)
      .CLKFBOUT_MULT_F(5.0),      // Multiply value for all CLKOUT (2.000-64.000)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB (-360.000-360.000)
      .CLKIN1_PERIOD(0.0),        // Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE_F(1.0),     // Divide amount for CLKOUT0 (1.000-128.000)
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      // CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT4_CASCADE("FALSE"),  // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .DIVCLK_DIVIDE(1),          // Master division value (1-106)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),  // Optional inversion for CLKIN1
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER1(0.0),          // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   MMCME3_BASE_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),     // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),     // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6
      // Feedback outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),   // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT
      // Status Ports outputs: MMCM status ports
      .LOCKED(LOCKED),       // 1-bit output: LOCK
      // Clock Inputs inputs: Clock input
      .CLKIN1(CLKIN1),       // 1-bit input: Clock
      // Control Ports inputs: MMCM control ports
      .PWRDWN(PWRDWN),       // 1-bit input: Power-down
      .RST(RST),             // 1-bit input: Reset
      // Feedback inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)      // 1-bit input: Feedback clock
   );

   // End of MMCME3_BASE_inst instantiation
					</Template>
					<Template label="Base Phase-Locked Loop (PLL) (PLLE3_BASE)" treetype="template">
// PLLE3_BASE  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE3_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE3_BASE: Base Phase-Locked Loop (PLL)
   //             Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   PLLE3_BASE #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT, (1-19)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB, (-360.000-360.000)
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0 (1-128)
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0 (0.001-0.999)
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0 (-360.000-360.000)
      // CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1 (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1 (0.001-0.999)
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1 (-360.000-360.000)
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      .DIVCLK_DIVIDE(1),          // Master division value, (1-15)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked (FALSE, TRUE)
   )
   PLLE3_BASE_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      // Feedback Clocks outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      // Control Ports inputs: PLL control ports
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST),                 // 1-bit input: Reset
      // Feedback Clocks inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)          // 1-bit input: Feedback clock
   );

   // End of PLLE3_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CONFIGURATION" treetype="folder">
				<SubFolder label="BSCAN" treetype="folder">
					<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
//   BSCANE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BSCANE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BSCANE2: Boundary-Scan User Instruction
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BSCANE2 #(
      .JTAG_CHAIN(1)  // Value for USER command
   )
   BSCANE2_inst (
      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.
      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                         // SHIFT are asserted.

      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.
      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      .SEL(SEL),         // 1-bit output: USER instruction active output.
      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.
      .TCK(TCK),         // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.
      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.
      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller
      .TDO(TDO)          // 1-bit input: Test Data Output (TDO) input for USER function.
   );

   // End of BSCANE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DNA" treetype="folder">
					<Template label="Device DNA Access Port (DNA_PORTE2)" treetype="template">
// DNA_PORTE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DNA_PORTE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DNA_PORTE2: Device DNA Access Port
   //             Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   DNA_PORTE2 #(
      .SIM_DNA_VALUE(96'h000000000000000000000000)  // Specifies a sample 96-bit DNA value for simulation
   )
   DNA_PORTE2_inst (
      .DOUT(DOUT),   // 1-bit output: DNA output data
      .CLK(CLK),     // 1-bit input: Clock input
      .DIN(DIN),     // 1-bit input: User data input pin
      .READ(READ),   // 1-bit input: Active-High load DNA, active-Low read input
      .SHIFT(SHIFT)  // 1-bit input: Active-High shift enable input
   );

   // End of DNA_PORTE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="EFUSE" treetype="folder">
					<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
//  EFUSE_USR  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (EFUSE_USR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EFUSE_USR: 32-bit non-volatile design ID
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   EFUSE_USR #(
      .SIM_EFUSE_VALUE(32'h00000000)  // Value of the 32-bit non-volatile value used in simulation
   )
   EFUSE_USR_inst (
      .EFUSEUSR(EFUSEUSR)  // 32-bit output: User eFUSE register value output
   );

   // End of EFUSE_USR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="ICAP" treetype="folder">
					<Template label="Internal Configuration Access Port (ICAPE3)" treetype="template">
//   ICAPE3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ICAPE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ICAPE3: Internal Configuration Access Port
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   ICAPE3 #(
      .DEVICE_ID(32'h03628093),     // Specifies the pre-programmed Device ID value to be used for simulation
                                    // purposes.
      .ICAP_AUTO_SWITCH("DISABLE"), // Enable switch ICAP using sync word
      .SIM_CFG_FILE_NAME("NONE")    // Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                    // model
   )
   ICAPE3_inst (
      .AVAIL(AVAIL),     // 1-bit output: Availability status of ICAP
      .O(O),             // 32-bit output: Configuration data output bus
      .PRDONE(PRDONE),   // 1-bit output: Indicates completion of Partial Reconfiguration
      .PRERROR(PRERROR), // 1-bit output: Indicates Error during Partial Reconfiguration
      .CLK(CLK),         // 1-bit input: Clock input
      .CSIB(CSIB),       // 1-bit input: Active-Low ICAP enable
      .I(I),             // 32-bit input: Configuration data input bus
      .RDWRB(RDWRB)      // 1-bit input: Read/Write Select input
   );

   // End of ICAPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MASTER_JTAG" treetype="folder">
					<Template label="JTAG Port Access (MASTER_JTAG)" treetype="template">
// MASTER_JTAG : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MASTER_JTAG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MASTER_JTAG: JTAG Port Access
   //              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   MASTER_JTAG MASTER_JTAG_inst (
      .TDO(TDO), // 1-bit output: JTAG TDO output pin
      .TCK(TCK), // 1-bit input: JTAG TCK input pin
      .TDI(TDI), // 1-bit input: JTAG TDI input pin
      .TMS(TMS)  // 1-bit input: JTAG TMS input pin
   );

   // End of MASTER_JTAG_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="STARTUP" treetype="folder">
					<Template label="STARTUP Block (STARTUPE3)" treetype="template">
//  STARTUPE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (STARTUPE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // STARTUPE3: STARTUP Block
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   STARTUPE3 #(
      .PROG_USR("FALSE"),  // Activate program event security feature. Requires encrypted bitstreams.
      .SIM_CCLK_FREQ(0.0)  // Set the Configuration Clock Frequency (ns) for simulation
   )
   STARTUPE3_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration main clock output
      .CFGMCLK(CFGMCLK),     // 1-bit output: Configuration internal oscillator clock output
      .DI(DI),               // 4-bit output: Allow receiving on the D input pin
      .EOS(EOS),             // 1-bit output: Active-High output signal indicating the End Of Startup
      .PREQ(PREQ),           // 1-bit output: PROGRAM request to fabric output
      .DO(DO),               // 4-bit input: Allows control of the D pin output
      .DTS(DTS),             // 4-bit input: Allows tristate of the D pin
      .FCSBO(FCSBO),         // 1-bit input: Controls the FCS_B pin for flash access
      .FCSBTS(FCSBTS),       // 1-bit input: Tristate the FCS_B pin
      .GSR(GSR),             // 1-bit input: Global Set/Reset input (GSR cannot be used for the port)
      .GTS(GTS),             // 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      .KEYCLEARB(KEYCLEARB), // 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      .PACK(PACK),           // 1-bit input: PROGRAM acknowledge input
      .USRCCLKO(USRCCLKO),   // 1-bit input: User CCLK input
      .USRCCLKTS(USRCCLKTS), // 1-bit input: User CCLK 3-state enable input
      .USRDONEO(USRDONEO),   // 1-bit input: User DONE pin output control
      .USRDONETS(USRDONETS)  // 1-bit input: User DONE 3-state enable output
   );

   // End of STARTUPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="USR_ACCESS" treetype="folder">
					<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
// USR_ACCESSE2 : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (USR_ACCESSE2_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // USR_ACCESSE2: Configuration Data Access
   //               Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2 USR_ACCESSE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration Clock
      .DATA(DATA),           // 32-bit output: Configuration Data reflecting the contents of the AXSS register
      .DATAVALID(DATAVALID)  // 1-bit output: Active High Data Valid
   );

   // End of USR_ACCESSE2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="BIDIR_BUFFER" treetype="folder">
					<Template label="Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable (IOBUF_INTERMDISABLE)" treetype="template">
// IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog       : the following instance declaration needs to be placed
//      instance       : in the body of the design code.  The instance name
//     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code         : parenthesis may be changed to properly reference and
//                     : connect this function to the design.  All inputs
//                     : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_INTERMDISABLE: Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable
   //                      Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUF_INTERMDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUF_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)                          // 1-bit input: 3-state enable input
   );

   // End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Bidirectional I/O Buffer with Offset Calibration and VREF Tuning (IOBUFE3)" treetype="template">
//   IOBUFE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFE3: Bidirectional I/O Buffer with Offset Calibration and VREF Tuning
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFE3 #(
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IOBUFE3_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Buffer inout (connect directly to top-level port)
      .OSC(OSC),                       // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),                 // 1-bit input: Offset cancellation enable
      .T(T),                           // 1-bit input: 3-state enable input
      .VREF(VREF)                      // 1-bit input: Vref input from HPIO_VREF
   );

   // End of IOBUFE3_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog             : the following instance declaration needs to be placed
//            instance            : in the body of the design code.  The instance name
//          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//              code              : parenthesis may be changed to properly reference and
//                                : connect this function to the design.  All inputs
//                                : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable
   //                                 Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer diff_p output
      .OB(OB),                       // 1-bit output: Buffer diff_n output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Must be tied to a logic '0'
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                     // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),                       // 1-bit input: 3-state master enable input
      .TS(TS)                        // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
// IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
//        Verilog         : the following instance declaration needs to be placed
//        instance        : in the body of the design code.  The instance name
//      declaration       : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations within the
//          code          : parenthesis may be changed to properly reference and
//                        : connect this function to the design.  All inputs
//                        : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_DCIEN: Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable
   //                         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_DCIEN #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DIFF_OUT_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer diff_p output
      .OB(OB),                         // 1-bit output: Buffer diff_n output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Must be tied to a logic '0'
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),                         // 1-bit input: 3-state master enable input
      .TS(TS)                          // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input (IOBUFDS_INTERMDISABLE)" treetype="template">
// IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//        Verilog        : the following instance declaration needs to be placed
//       instance        : in the body of the design code.  The instance name
//      declaration      : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//         code          : parenthesis may be changed to properly reference and
//                       : connect this function to the design.  All inputs
//                       : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_INTERMDISABLE: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input
   //                        Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                     // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)                          // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DCIEN)" treetype="template">
// IOBUFDS_DCIEN : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  All inputs
//               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DCIEN: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DCIEN #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional I/O Buffer with Offset Calibration (IOBUFDSE3)" treetype="template">
//  IOBUFDSE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFDSE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDSE3: Differential Bidirectional I/O Buffer with Offset Calibration
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDSE3 #(
      .DQS_BIAS("FALSE"),          // (FALSE, TRUE)
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IOBUFDSE3_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .OSC(OSC),                       // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),                 // 2-bit input: Offset cancellation enable
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUFDSE3_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer (IOBUFDS)" treetype="template">
//   IOBUFDS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS: Differential Input/Output Buffer
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IOBUFDS_inst (
      .O(O),     // 1-bit output: Buffer output
      .I(I),     // 1-bit input: Buffer input
      .IO(IO),   // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)      // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer (IOBUFDS_DIFF_OUT)" treetype="template">
// IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT: Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer
   //                   Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IOBUFDS_DIFF_OUT_inst (
      .O(O),     // 1-bit output: Buffer diff_p output
      .OB(OB),   // 1-bit output: Buffer diff_n output
      .I(I),     // 1-bit input: Buffer input
      .IO(IO),   // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),   // 1-bit input: 3-state master enable input
      .TS(TS)    // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Input/Output Buffer DCI Enable (IOBUF_DCIEN)" treetype="template">
// IOBUF_DCIEN : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUF_DCIEN_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_DCIEN: Input/Output Buffer DCI Enable
   //              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUF_DCIEN #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUF_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Input/Output Buffer (IOBUF)" treetype="template">
//    IOBUF    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF: Input/Output Buffer
   //        Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IOBUF IOBUF_inst (
      .O(O),   // 1-bit output: Buffer output
      .I(I),   // 1-bit input: Buffer input
      .IO(IO), // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)    // 1-bit input: 3-state enable input
   );

   // End of IOBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="BITSLICE" treetype="folder">
					<Template label="BITSLICE_CONTROL (BITSLICE_CONTROL)" treetype="template">
// BITSLICE_CONTROL : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (BITSLICE_CONTROL_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BITSLICE_CONTROL: BITSLICE_CONTROL for control using Native Mode
   //                   Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   BITSLICE_CONTROL #(
      .DIV_MODE("DIV2"),               // Controller DIV2/DIV4 mode (DIV2, DIV4)
      .EN_CLK_TO_EXT_NORTH("DISABLE"), // Enable clock forwarding to north
      .EN_CLK_TO_EXT_SOUTH("DISABLE"), // Enable clock forwarding to south
      .EN_DYN_ODLY_MODE("FALSE"),      // Enable dynamic output delay mode
      .EN_OTHER_NCLK("FALSE"),         // Select the NCLK from the other BITSLICE_CONTROL in the nibble (FALSE,
                                       // TRUE)
      .EN_OTHER_PCLK("FALSE"),         // Select the PCLK from the other BITSLICE_CONTROL in the nibble (FALSE,
                                       // TRUE)
      .IDLY_VT_TRACK("TRUE"),          // Enable VT tracking for input delays
      .INV_RXCLK("FALSE"),             // Invert clock path from IOB to upper RX bitslice
      .ODLY_VT_TRACK("TRUE"),          // Enable VT tracking for output delays
      .QDLY_VT_TRACK("TRUE"),          // Enable VT tracking for clock delays
      .READ_IDLE_COUNT(6'h00),         // Gap count between read bursts for ODT control counter (0-3f)
      .REFCLK_SRC("PLLCLK"),           // Select the input clock for the delay control (PLLCLK, REFCLK)
      .ROUNDING_FACTOR(16),            // Rounding factor in BISC spec (128-8)
      .RXGATE_EXTEND("FALSE"),         // Reserved for use by MIG Memory Controller. Do Not Change.
      .RX_CLK_PHASE_N("SHIFT_0"),      // Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                       // SHIFT_90)
      .RX_CLK_PHASE_P("SHIFT_0"),      // Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                       // SHIFT_90)
      .RX_GATING("DISABLE"),           // ENABLE/DISABLE read DQS gating
      .SELF_CALIBRATE("ENABLE"),       // Enable BISC of nibble controlled by BITSLICE_CONTROL
      .SERIAL_MODE("FALSE"),           // Put BITSLICE read paths into serial mode (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE"),       // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                       // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TX_GATING("DISABLE")            // ENABLE/DISABLE clock gating in WClkgen
   )
   BITSLICE_CONTROL_inst (
      .CLK_TO_EXT_NORTH(CLK_TO_EXT_NORTH),       // 1-bit output: Inter-byte clock going to north
                                                 // BITSLICE_CONTROL

      .CLK_TO_EXT_SOUTH(CLK_TO_EXT_SOUTH),       // 1-bit output: Inter-byte clock going to south
                                                 // BITSLICE_CONTROL

      .DLY_RDY(DLY_RDY),                         // 1-bit output: Fixed delay calibration complete
      .DYN_DCI(DYN_DCI),                         // 7-bit output: Direct control of IOB DCI when using a memory
                                                 // interface

      .NCLK_NIBBLE_OUT(NCLK_NIBBLE_OUT),         // 1-bit output: Intra-byte DQS strobes/clock to other control
                                                 // block

      .PCLK_NIBBLE_OUT(PCLK_NIBBLE_OUT),         // 1-bit output: Intra-byte DQS strobes/clock to other control
                                                 // block

      .RIU_RD_DATA(RIU_RD_DATA),                 // 16-bit output: RIU Output Read data to the controller
      .RIU_VALID(RIU_VALID),                     // 1-bit output: Last data written has been accepted when High
      .RX_BIT_CTRL_OUT0(RX_BIT_CTRL_OUT0),       // 40-bit output: Output bus to Bitslice 0
      .RX_BIT_CTRL_OUT1(RX_BIT_CTRL_OUT1),       // 40-bit output: Output bus to Bitslice 1
      .RX_BIT_CTRL_OUT2(RX_BIT_CTRL_OUT2),       // 40-bit output: Output bus to Bitslice 2
      .RX_BIT_CTRL_OUT3(RX_BIT_CTRL_OUT3),       // 40-bit output: Output bus to Bitslice 3
      .RX_BIT_CTRL_OUT4(RX_BIT_CTRL_OUT4),       // 40-bit output: Output bus to Bitslice 4
      .RX_BIT_CTRL_OUT5(RX_BIT_CTRL_OUT5),       // 40-bit output: Output bus to Bitslice 5
      .RX_BIT_CTRL_OUT6(RX_BIT_CTRL_OUT6),       // 40-bit output: Output bus to Bitslice 6
      .TX_BIT_CTRL_OUT0(TX_BIT_CTRL_OUT0),       // 40-bit output: Output bus to Bitslice 0
      .TX_BIT_CTRL_OUT1(TX_BIT_CTRL_OUT1),       // 40-bit output: Output bus to Bitslice 1
      .TX_BIT_CTRL_OUT2(TX_BIT_CTRL_OUT2),       // 40-bit output: Output bus to Bitslice 2
      .TX_BIT_CTRL_OUT3(TX_BIT_CTRL_OUT3),       // 40-bit output: Output bus to Bitslice 3
      .TX_BIT_CTRL_OUT4(TX_BIT_CTRL_OUT4),       // 40-bit output: Output bus to Bitslice 4
      .TX_BIT_CTRL_OUT5(TX_BIT_CTRL_OUT5),       // 40-bit output: Output bus to Bitslice 5
      .TX_BIT_CTRL_OUT6(TX_BIT_CTRL_OUT6),       // 40-bit output: Output bus to Bitslice 6
      .TX_BIT_CTRL_OUT_TRI(TX_BIT_CTRL_OUT_TRI), // 40-bit output: Output bus to 3-state TX_BITSLICE_TRI
      .VTC_RDY(VTC_RDY),                         // 1-bit output: PHY calibration is complete
      .CLK_FROM_EXT(CLK_FROM_EXT),               // 1-bit input: Inter-byte clock coming from north or south
                                                 // BITSLICE_CONTROL

      .EN_VTC(EN_VTC),                           // 1-bit input: Enables voltage and temperature compensation
                                                 // when High

      .NCLK_NIBBLE_IN(NCLK_NIBBLE_IN),           // 1-bit input: Intra-byte DQS strobes from other/clock
                                                 // control block

      .PCLK_NIBBLE_IN(PCLK_NIBBLE_IN),           // 1-bit input: Intra-byte DQS strobes/clock from other
                                                 // control block

      .PHY_RDCS0(PHY_RDCS0),                     // 4-bit input: Rank select
      .PHY_RDCS1(PHY_RDCS1),                     // 4-bit input: Rank select
      .PHY_RDEN(PHY_RDEN),                       // 4-bit input: Read burst enable when using a memory interface
      .PHY_WRCS0(PHY_WRCS0),                     // 4-bit input: Rank select
      .PHY_WRCS1(PHY_WRCS1),                     // 4-bit input: Rank select
      .PLL_CLK(PLL_CLK),                         // 1-bit input: PLL clock input
      .REFCLK(REFCLK),                           // 1-bit input: Frequency reference clock for delay control
      .RIU_ADDR(RIU_ADDR),                       // 6-bit input: Address input for RIU
      .RIU_CLK(RIU_CLK),                         // 1-bit input: System clock from fabric for RIU access
      .RIU_NIBBLE_SEL(RIU_NIBBLE_SEL),           // 1-bit input: Nibble select to enable RIU read/write
      .RIU_WR_DATA(RIU_WR_DATA),                 // 16-bit input: RIU Input Write data from the controller
      .RIU_WR_EN(RIU_WR_EN),                     // 1-bit input: Enables write to RIU when High
      .RST(RST),                                 // 1-bit input: Asynchronous global reset
      .RX_BIT_CTRL_IN0(RX_BIT_CTRL_IN0),         // 40-bit input: Input bus from Bitslice 0
      .RX_BIT_CTRL_IN1(RX_BIT_CTRL_IN1),         // 40-bit input: Input bus from Bitslice 1
      .RX_BIT_CTRL_IN2(RX_BIT_CTRL_IN2),         // 40-bit input: Input bus from Bitslice 2
      .RX_BIT_CTRL_IN3(RX_BIT_CTRL_IN3),         // 40-bit input: Input bus from Bitslice 3
      .RX_BIT_CTRL_IN4(RX_BIT_CTRL_IN4),         // 40-bit input: Input bus from Bitslice 4
      .RX_BIT_CTRL_IN5(RX_BIT_CTRL_IN5),         // 40-bit input: Input bus from Bitslice 5
      .RX_BIT_CTRL_IN6(RX_BIT_CTRL_IN6),         // 40-bit input: Input bus from Bitslice 6
      .TBYTE_IN(TBYTE_IN),                       // 4-bit input: Output enable for 3-state control
      .TX_BIT_CTRL_IN0(TX_BIT_CTRL_IN0),         // 40-bit input: Input bus from Bitslice 0
      .TX_BIT_CTRL_IN1(TX_BIT_CTRL_IN1),         // 40-bit input: Input bus from Bitslice 1
      .TX_BIT_CTRL_IN2(TX_BIT_CTRL_IN2),         // 40-bit input: Input bus from Bitslice 2
      .TX_BIT_CTRL_IN3(TX_BIT_CTRL_IN3),         // 40-bit input: Input bus from Bitslice 3
      .TX_BIT_CTRL_IN4(TX_BIT_CTRL_IN4),         // 40-bit input: Input bus from Bitslice 4
      .TX_BIT_CTRL_IN5(TX_BIT_CTRL_IN5),         // 40-bit input: Input bus from Bitslice 5
      .TX_BIT_CTRL_IN6(TX_BIT_CTRL_IN6),         // 40-bit input: Input bus from Bitslice 6
      .TX_BIT_CTRL_IN_TRI(TX_BIT_CTRL_IN_TRI)    // 40-bit input: Input bus from 3-state TX_BITSLICE_TRI
   );

   // End of BITSLICE_CONTROL_inst instantiation
					</Template>
					<Template label="Register Interface Unit Selection Block (RIU_OR)" treetype="template">
//   RIU_OR    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RIU_OR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RIU_OR: Register Interface Unit Selection Block
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RIU_OR #(
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   RIU_OR_inst (
      .RIU_RD_DATA(RIU_RD_DATA),           // 16-bit output: RIU data bus to the controller
      .RIU_RD_VALID(RIU_RD_VALID),         // 1-bit output: Combined RIU read valid signal to the controller
      .RIU_RD_DATA_LOW(RIU_RD_DATA_LOW),   // 16-bit input: RIU data bus from the controller to the lower
                                           // nibble BITSLICE_CONTROL

      .RIU_RD_DATA_UPP(RIU_RD_DATA_UPP),   // 16-bit input: RIU data bus from the controller to the upper
                                           // nibble BITSLICE_CONTROL

      .RIU_RD_VALID_LOW(RIU_RD_VALID_LOW), // 1-bit input: RIU_VALID of the lower nibble BITSLICE_CONTROL
      .RIU_RD_VALID_UPP(RIU_RD_VALID_UPP)  // 1-bit input: RIU_VALID of the upper nibble BITSLICE_CONTROL
   );

   // End of RIU_OR_inst instantiation
					</Template>
					<Template label="RX_BITSLICE (RX_BITSLICE)" treetype="template">
// RX_BITSLICE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RX_BITSLICE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RX_BITSLICE: RX_BITSLICE for input using Native Mode
   //              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RX_BITSLICE #(
      .CASCADE("FALSE"),              // Enables cascading of IDELAY and ODELAY lines
      .DATA_TYPE("DATA"),             // Defines what the input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                      // SERIAL)
      .DATA_WIDTH(8),                 // Defines the width of the serial-to-parallel converter (4-8)
      .DELAY_FORMAT("TIME"),          // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),           // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),                // Input delay value setting in ps
      .DELAY_VALUE_EXT(0),            // Value of the extended input delay value in ps
      .FIFO_SYNC_MODE("FALSE"),       // Internal write clock and FIFO_RD_CLK are coming from a common source
      .IS_CLK_EXT_INVERTED(1'b0),     // Optional inversion for CLK_EXT
      .IS_CLK_INVERTED(1'b0),         // Optional inversion for CLK
      .IS_RST_DLY_EXT_INVERTED(1'b0), // Optional inversion for RST_DLY_EXT
      .IS_RST_DLY_INVERTED(1'b0),     // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),       // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),      // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC"),          // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      // SYNC)
      .UPDATE_MODE_EXT("ASYNC")       // Determines when updates to the extended input delay will take effect
                                      // (ASYNC, MANUAL, SYNC)
   )
   RX_BITSLICE_inst (
      .CNTVALUEOUT(CNTVALUEOUT),         // 9-bit output: Counter value to device logic
      .CNTVALUEOUT_EXT(CNTVALUEOUT_EXT), // 9-bit output: Optional extended (cascaded delay) counter value
                                         // going to the device logic

      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .FIFO_WRCLK_OUT(FIFO_WRCLK_OUT),   // 1-bit output: FIFO source synchronous write clock out to the device
                                         // logic (currently unsupported, do not connect)

      .Q(Q),                             // 8-bit output: Registered output data from FIFO
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .CE(CE),                           // 1-bit input: Clock enable for IDELAY
      .CE_EXT(CE_EXT),                   // 1-bit input: Optional extended (cascaded delay) clock enable
      .CLK(CLK),                         // 1-bit input: Clock used to sample LOAD, CE, INC
      .CLK_EXT(CLK_EXT),                 // 1-bit input: Optional extended (cascaded delay) clock
      .CNTVALUEIN(CNTVALUEIN),           // 9-bit input: Counter value from device logic
      .CNTVALUEIN_EXT(CNTVALUEIN_EXT),   // 9-bit input: Optional extended (cascaded delay) counter value from
                                         // device logic

      .DATAIN(DATAIN),                   // 1-bit input: Input signal from IBUF
      .EN_VTC(EN_VTC),                   // 1-bit input: Enable IDELAYCTRL to keep stable delay over VT
      .EN_VTC_EXT(EN_VTC_EXT),           // 1-bit input: Optional extended (cascaded delay) to keep stable
                                         // delay over VT

      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: FIFO read enable
      .INC(INC),                         // 1-bit input: Increment the current delay tap setting
      .INC_EXT(INC_EXT),                 // 1-bit input: Optional extended (cascaded delay) increments the
                                         // current delay tap setting

      .LOAD(LOAD),                       // 1-bit input: Load the CNTVALUEIN tap setting
      .LOAD_EXT(LOAD_EXT),               // 1-bit input: Optional extended (cascaded delay) load the
                                         // CNTVALUEIN_EXT tap setting

      .RST(RST),                         // 1-bit input: Asynchronous assert, synchronous deassert for
                                         // RX_BITSLICE ISERDES

      .RST_DLY(RST_DLY),                 // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      .RST_DLY_EXT(RST_DLY_EXT),         // 1-bit input: Optional extended (cascaded delay) reset delay to
                                         // DELAY_VALUE_EXT

      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN)    // 40-bit input: Input bus from BITSLICE_CONTROL
   );

   // End of RX_BITSLICE_inst instantiation
					</Template>
					<Template label="RXTX_BITSLICE (RXTX_BITSLICE)" treetype="template">
// RXTX_BITSLICE : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (RXTX_BITSLICE_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  All inputs
//               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RXTX_BITSLICE: RXTX_BITSLICE for bidirectional I/O using Native Mode
   //                Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   RXTX_BITSLICE #(
      .ENABLE_PRE_EMPHASIS("FALSE"), // Enable the pre-emphasis
      .FIFO_SYNC_MODE("FALSE"),      // Internal write clock and FIFO_RD_CLK are coming from a common source
      .INIT(1'b1),                   // Defines initial O value
      .IS_RX_CLK_INVERTED(1'b0),     // Optional inversion for RX_CLK
      .IS_RX_RST_DLY_INVERTED(1'b0), // Optional inversion for RX_RST_DLY
      .IS_RX_RST_INVERTED(1'b0),     // Optional inversion for RX_RST
      .IS_TX_CLK_INVERTED(1'b0),     // Optional inversion for TX_CLK
      .IS_TX_RST_DLY_INVERTED(1'b0), // Optional inversion for TX_RST_DLY
      .IS_TX_RST_INVERTED(1'b0),     // Optional inversion for TX_RST
      .RX_DATA_TYPE("DATA"),         // Defines what the RX input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                     // SERIAL)
      .RX_DATA_WIDTH(8),             // Defines the width of the serial-to-parallel converter (4-8)
      .RX_DELAY_FORMAT("TIME"),      // Units of the RX DELAY_VALUE (COUNT, TIME)
      .RX_DELAY_TYPE("FIXED"),       // Set the type of RX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .RX_DELAY_VALUE(0),            // RX Input delay value setting in ps
      .RX_REFCLK_FREQUENCY(300.0),   // Specification of the RX reference clock frequency in MHz (200.0-2667.0)
      .RX_UPDATE_MODE("ASYNC"),      // Determines when updates to the RX delay will take effect (ASYNC,
                                     // MANUAL, SYNC)
      .SIM_DEVICE("ULTRASCALE"),     // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                     // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TBYTE_CTL("TBYTE_IN"),        // Select between T and TBYTE_IN inputs
      .TX_DATA_WIDTH(8),             // Parallel data input width (4-8)
      .TX_DELAY_FORMAT("TIME"),      // Units of the TX DELAY_VALUE (COUNT, TIME)
      .TX_DELAY_TYPE("FIXED"),       // Set the type of TX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .TX_DELAY_VALUE(0),            // TX Input delay value setting in ps
      .TX_OUTPUT_PHASE_90("FALSE"),  // Delays the output phase by 90-degrees
      .TX_REFCLK_FREQUENCY(300.0),   // Specification of the TX reference clock frequency in MHz (200.0-2667.0)
      .TX_UPDATE_MODE("ASYNC")       // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                     // SYNC)
   )
   RXTX_BITSLICE_inst (
      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .FIFO_WRCLK_OUT(FIFO_WRCLK_OUT),   // 1-bit output: FIFO source synchronous write clock out to the device
                                         // logic (currently unsupported, do not connect)

      .O(O),                             // 1-bit output: Serialized output going to output buffer
      .Q(Q),                             // 8-bit output: Registered output data from FIFO
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: RX Output bus to BITSLICE_CONTROL
      .RX_CNTVALUEOUT(RX_CNTVALUEOUT),   // 9-bit output: RX Counter value from device logic
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL for TX
      .TX_CNTVALUEOUT(TX_CNTVALUEOUT),   // 9-bit output: TX Counter value to device logic
      .T_OUT(T_OUT),                     // 1-bit output: Byte group 3-state output
      .D(D),                             // 8-bit input: Data from device logic
      .DATAIN(DATAIN),                   // 1-bit input: Input signal from IOBUF
      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: FIFO read enable
      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: RX Input bus from BITSLICE_CONTROL
      .RX_CE(RX_CE),                     // 1-bit input: Clock enable for IDELAY
      .RX_CLK(RX_CLK),                   // 1-bit input: RX Clock used to sample LOAD, CE, INC
      .RX_CNTVALUEIN(RX_CNTVALUEIN),     // 9-bit input: RX Counter value from device logic
      .RX_EN_VTC(RX_EN_VTC),             // 1-bit input: RX Enable to keep stable delay over VT
      .RX_INC(RX_INC),                   // 1-bit input: RX Increment the current delay tap setting
      .RX_LOAD(RX_LOAD),                 // 1-bit input: RX Load the CNTVALUEIN tap setting
      .RX_RST(RX_RST),                   // 1-bit input: RX Asynchronous assert, synchronous deassert for
                                         // RXTX_BITSLICE ISERDES

      .RX_RST_DLY(RX_RST_DLY),           // 1-bit input: RX Reset the internal DELAY value to DELAY_VALUE
      .T(T),                             // 1-bit input: Legacy T byte input from device logic
      .TBYTE_IN(TBYTE_IN),               // 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN),   // 40-bit input: TX Input bus from BITSLICE_CONTROL
      .TX_CE(TX_CE),                     // 1-bit input: Clock enable for ODELAY
      .TX_CLK(TX_CLK),                   // 1-bit input: TX Clock used to sample LOAD, CE, INC
      .TX_CNTVALUEIN(TX_CNTVALUEIN),     // 9-bit input: TX Counter value from device logic
      .TX_EN_VTC(TX_EN_VTC),             // 1-bit input: TX Enable to keep stable delay over VT
      .TX_INC(TX_INC),                   // 1-bit input: TX Increment the current delay tap setting
      .TX_LOAD(TX_LOAD),                 // 1-bit input: TX Load the CNTVALUEIN tap setting
      .TX_RST(TX_RST),                   // 1-bit input: TX Asynchronous assert, synchronous deassert for
                                         // RXTX_BITSLICE OSERDES

      .TX_RST_DLY(TX_RST_DLY)            // 1-bit input: TX Reset the internal DELAY value to DELAY_VALUE
   );

   // End of RXTX_BITSLICE_inst instantiation
					</Template>
					<Template label="TX_BITSLICE_TRI (TX_BITSLICE_TRI)" treetype="template">
// TX_BITSLICE_TRI : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (TX_BITSLICE_TRI_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // TX_BITSLICE_TRI: TX_BITSLICE_TRI for tristate using Native Mode
   //                  Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_TRI #(
      .DATA_WIDTH(8),             // Parallel data input width (4-8)
      .DELAY_FORMAT("TIME"),      // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),       // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),            // Output delay value setting
      .INIT(1'b1),                // Defines initial O value
      .IS_CLK_INVERTED(1'b0),     // Optional inversion for CLK
      .IS_RST_DLY_INVERTED(1'b0), // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .OUTPUT_PHASE_90("FALSE"),  // Delays the output phase by 90-degrees
      .REFCLK_FREQUENCY(300.0),   // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")       // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  // SYNC)
   )
   TX_BITSLICE_TRI_inst (
      .BIT_CTRL_OUT(BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .CNTVALUEOUT(CNTVALUEOUT),   // 9-bit output: Counter value to device logic
      .TRI_OUT(TRI_OUT),           // 1-bit output: Output to the TBYTE_IN pins of the bitslices
      .BIT_CTRL_IN(BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .CE(CE),                     // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                   // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),     // 9-bit input: Counter value input
      .EN_VTC(EN_VTC),             // 1-bit input: Enable to keep stable delay over VT
      .INC(INC),                   // 1-bit input: Increment the current delay tap setting
      .LOAD(LOAD),                 // 1-bit input: Load the CNTVALUEIN tap setting
      .RST(RST),                   // 1-bit input: Asynchronous assert, synchronous deassert
      .RST_DLY(RST_DLY)            // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
   );

   // End of TX_BITSLICE_TRI_inst instantiation
					</Template>
					<Template label="TX_BITSLICE (TX_BITSLICE)" treetype="template">
// TX_BITSLICE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (TX_BITSLICE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // TX_BITSLICE: TX_BITSLICE for output using Native Mode
   //              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE #(
      .DATA_WIDTH(8),                // Parallel data input width (4-8)
      .DELAY_FORMAT("TIME"),         // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),          // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),               // Output delay value setting
      .ENABLE_PRE_EMPHASIS("FALSE"), // Enable the pre-emphasis
      .INIT(1'b1),                   // Defines initial O value
      .IS_CLK_INVERTED(1'b0),        // Optional inversion for CLK
      .IS_RST_DLY_INVERTED(1'b0),    // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),        // Optional inversion for RST
      .OUTPUT_PHASE_90("FALSE"),     // Delays the output phase by 90-degrees
      .REFCLK_FREQUENCY(300.0),      // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),     // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                     // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TBYTE_CTL("TBYTE_IN"),        // Select between T and TBYTE_IN inputs
      .UPDATE_MODE("ASYNC")          // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                     // SYNC)
   )
   TX_BITSLICE_inst (
      .CNTVALUEOUT(CNTVALUEOUT),         // 9-bit output: Counter value to device logic
      .O(O),                             // 1-bit output: Serialized output going to output buffer
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .T_OUT(T_OUT),                     // 1-bit output: Byte group 3-state output
      .CE(CE),                           // 1-bit input: Clock enable for ODELAY
      .CLK(CLK),                         // 1-bit input: Clock used to sample LOAD, CE, INC
      .CNTVALUEIN(CNTVALUEIN),           // 9-bit input: Counter value from device logic
      .D(D),                             // 8-bit input: Data from device logic
      .EN_VTC(EN_VTC),                   // 1-bit input: Enable to keep stable delay over VT
      .INC(INC),                         // 1-bit input: Increment the current delay tap setting
      .LOAD(LOAD),                       // 1-bit input: Load the CNTVALUEIN tap setting
      .RST(RST),                         // 1-bit input: Asynchronous assert, synchronous deassert for
                                         // TX_BITSLICE OSERDES

      .RST_DLY(RST_DLY),                 // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .T(T),                             // 1-bit input: Legacy T byte input from device logic
      .TBYTE_IN(TBYTE_IN),               // 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN)    // 40-bit input: Input bus from BITSLICE_CONTROL
   );

   // End of TX_BITSLICE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DCI_RESET" treetype="folder">
					<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
//  DCIRESET   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DCIRESET_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DCIRESET: Digitally Controlled Impedance Reset Component
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   DCIRESET DCIRESET_inst (
      .LOCKED(LOCKED), // 1-bit output: LOCK status output
      .RST(RST)        // 1-bit input: Active-High asynchronous reset input
   );

   // End of DCIRESET_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DELAY" treetype="folder">
					<Template label="IDELAYE3/ODELAYE3 Tap Delay Value Control (IDELAYCTRL)" treetype="template">
// IDELAYCTRL  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYCTRL: IDELAYE3/ODELAYE3 Tap Delay Value Control
   //             Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL #(
      .SIM_DEVICE("7SERIES")  // Set the device version (7SERIES, ULTRASCALE)
   )
   IDELAYCTRL_inst (
      .RDY(RDY),       // 1-bit output: Ready output
      .REFCLK(REFCLK), // 1-bit input: Reference clock input
      .RST(RST)        // 1-bit input: Active high reset input. Asynchronous assert, synchronous deassert to
                       // REFCLK.

   );

   // End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE3)" treetype="template">
//  IDELAYE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYE3: Input Fixed or Variable Delay Element
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IDELAYE3 #(
      .CASCADE("NONE"),          // Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      .DELAY_FORMAT("TIME"),     // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_SRC("IDATAIN"),     // Delay input (DATAIN, IDATAIN)
      .DELAY_TYPE("FIXED"),      // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),           // Input delay value setting
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),  // IDELAYCTRL clock input frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"), // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")      // Determines when updates to the delay will take effect (ASYNC, MANUAL, SYNC)
   )
   IDELAYE3_inst (
      .CASC_OUT(CASC_OUT),       // 1-bit output: Cascade delay output to ODELAY input cascade
      .CNTVALUEOUT(CNTVALUEOUT), // 9-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data output
      .CASC_IN(CASC_IN),         // 1-bit input: Cascade delay input from slave ODELAY CASCADE_OUT
      .CASC_RETURN(CASC_RETURN), // 1-bit input: Cascade delay returning from slave ODELAY DATAOUT
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                 // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),   // 9-bit input: Counter value input
      .DATAIN(DATAIN),           // 1-bit input: Data input from the logic
      .EN_VTC(EN_VTC),           // 1-bit input: Keep delay constant over VT
      .IDATAIN(IDATAIN),         // 1-bit input: Data input from the IOBUF
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LOAD(LOAD),               // 1-bit input: Load DELAY_VALUE input
      .RST(RST)                  // 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   // End of IDELAYE3_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE3)" treetype="template">
//  ODELAYE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODELAYE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODELAYE3: Output Fixed or Variable Delay Element
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   ODELAYE3 #(
      .CASCADE("NONE"),          // Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      .DELAY_FORMAT("TIME"),     // (COUNT, TIME)
      .DELAY_TYPE("FIXED"),      // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),           // Output delay tap setting
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),  // IDELAYCTRL clock input frequency in MHz (200.0-2667.0).
      .SIM_DEVICE("ULTRASCALE"), // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")      // Determines when updates to the delay will take effect (ASYNC, MANUAL, SYNC)
   )
   ODELAYE3_inst (
      .CASC_OUT(CASC_OUT),       // 1-bit output: Cascade delay output to IDELAY input cascade
      .CNTVALUEOUT(CNTVALUEOUT), // 9-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data from ODATAIN input port
      .CASC_IN(CASC_IN),         // 1-bit input: Cascade delay input from slave IDELAY CASCADE_OUT
      .CASC_RETURN(CASC_RETURN), // 1-bit input: Cascade delay returning from slave IDELAY DATAOUT
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                 // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),   // 9-bit input: Counter value input
      .EN_VTC(EN_VTC),           // 1-bit input: Keep delay constant over VT
      .INC(INC),                 // 1-bit input: Increment/Decrement tap delay input
      .LOAD(LOAD),               // 1-bit input: Load DELAY_VALUE input
      .ODATAIN(ODATAIN),         // 1-bit input: Data input
      .RST(RST)                  // 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   // End of ODELAYE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="INPUT_BUFFER" treetype="folder">
					<Template label="Analog Auxiliary SYSMON Input Buffer (IBUF_ANALOG)" treetype="template">
// IBUF_ANALOG : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUF_ANALOG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_ANALOG: Analog Auxiliary SYSMON Input Buffer
   //              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUF_ANALOG IBUF_ANALOG_inst (
      .O(O), // 1-bit output: Connect to a VAUXP/VAUXN port of the SYSMONE1
      .I(I)  // 1-bit input: Connect to a top-level design port
   );

   // End of IBUF_ANALOG_inst instantiation
					</Template>
					<Template label="Differential Input Buffer (IBUFDS)" treetype="template">
//   IBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS: Differential Input Buffer
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IBUFDS_inst (
      .O(O),   // 1-bit output: Buffer output
      .I(I),   // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs and Input Buffer Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
//           Verilog           : the following instance declaration needs to be placed
//          instance           : in the body of the design code.  The instance name
//         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations within the
//            code             : parenthesis may be changed to properly reference and
//                             : connect this function to the design.  All inputs
//                             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer With Complementary Outputs and Input Buffer Disable
   //                              Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_DIFF_OUT_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer diff_p output
      .OB(OB),                   // 1-bit output: Buffer diff_n output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Must be tied to a logic '0'
   );

   // End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs (IBUFDS_DIFF_OUT)" treetype="template">
// IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT: Differential Input Buffer With Complementary Outputs
   //                  Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IBUFDS_DIFF_OUT_inst (
      .O(O),   // 1-bit output: Buffer diff_p output
      .OB(OB), // 1-bit output: Buffer diff_n output
      .I(I),   // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog            : the following instance declaration needs to be placed
//           instance            : in the body of the design code.  The instance name
//          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code              : parenthesis may be changed to properly reference and
//                               : connect this function to the design.  All inputs
//                               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable
   //                                Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer diff_p output
      .OB(OB),                       // 1-bit output: Buffer diff_n output
      .I(I),                         // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                       // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Must be tied to a logic '0'
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Buffer termination disable, high=disable
   );

   // End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
// IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog        : the following instance declaration needs to be placed
//       instance       : in the body of the design code.  The instance name
//     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//         code         : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_INTERMDISABLE: Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                       // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer input disable, high=disable
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Buffer termination disable, high=disable
   );

   // End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable (IBUFDS_IBUFDISABLE)" treetype="template">
// IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//      instance      : in the body of the design code.  The instance name
//    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations within the
//        code        : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_IBUFDISABLE: Differential Input Buffer With Input Buffer Disable
   //                     Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Must be tied to a logic '0'
   );

   // End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Offset Calibration (IBUFDSE3)" treetype="template">
//  IBUFDSE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDSE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDSE3: Differential Input Buffer with Offset Calibration
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFDSE3 #(
      .DQS_BIAS("FALSE"),          // (FALSE, TRUE)
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IBUFDSE3_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE), // 1-bit input: Buffer disable input, high=disable
      .OSC(OSC),                 // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN)            // 2-bit input: Offset cancellation enable
   );

   // End of IBUFDSE3_inst instantiation
					</Template>
					<Template label="Input Buffer (IBUF)" treetype="template">
//    IBUF     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF: Input Buffer
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUF IBUF_inst (
      .O(O), // 1-bit output: Buffer output
      .I(I)  // 1-bit input: Buffer input
   );

   // End of IBUF_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
// IBUF_INTERMDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//      instance      : in the body of the design code.  The instance name
//    declaration     : (IBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code        : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_INTERMDISABLE: Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                     Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUF_INTERMDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUF_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Input Termination Disable
   );

   // End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable (IBUF_IBUFDISABLE)" treetype="template">
// IBUF_IBUFDISABLE : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_IBUFDISABLE: Input Buffer With Input Buffer Disable
   //                   Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUF_IBUFDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUF_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Buffer disable input, high=disable
   );

   // End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer with Offset Calibration and VREF Tuning (IBUFE3)" treetype="template">
//   IBUFE3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFE3: Input Buffer with Offset Calibration and VREF Tuning
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IBUFE3 #(
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IBUFE3_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE), // 1-bit input: Buffer disable input, high=disable
      .OSC(OSC),                 // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),           // 1-bit input: Offset cancellation enable
      .VREF(VREF)                // 1-bit input: Vref input from HPIO_VREF
   );

   // End of IBUFE3_inst instantiation
					</Template>
					<Template label="VREF Scan (HPIO_VREF)" treetype="template">
//  HPIO_VREF  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (HPIO_VREF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // HPIO_VREF: VREF Scan
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   HPIO_VREF #(
      .VREF_CNTR("OFF")  // FABRIC_RANGE1, FABRIC_RANGE2, OFF
   )
   HPIO_VREF_inst (
      .VREF(VREF),                         // 1-bit output: Tuned output (connect to associated IBUFE3
                                           // component)

      .FABRIC_VREF_TUNE(FABRIC_VREF_TUNE)  // 7-bit input: VREF tuning value
   );

   // End of HPIO_VREF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="OUTPUT_BUFFER" treetype="folder">
					<Template label="3-State Output Buffer (OBUFT)" treetype="template">
//    OBUFT    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFT: 3-State Output Buffer
   //        Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFT OBUFT_inst (
      .O(O), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(I), // 1-bit input: Buffer input
      .T(T)  // 1-bit input: 3-state enable input
   );

   // End of OBUFT_inst instantiation
					</Template>
					<Template label="Differential Output Buffer (OBUFDS)" treetype="template">
//   OBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS: Differential Output Buffer
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS OBUFDS_inst (
      .O(O),   // 1-bit output: Diff_p output (connect directly to top-level port)
      .OB(OB), // 1-bit output: Diff_n output (connect directly to top-level port)
      .I(I)    // 1-bit input: Buffer input
   );

   // End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential 3-state Output Buffer (OBUFTDS)" treetype="template">
//   OBUFTDS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFTDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFTDS: Differential 3-state Output Buffer
   //          Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUFTDS OBUFTDS_inst (
      .O(O),   // 1-bit output: Diff_p output (connect directly to top-level port)
      .OB(OB), // 1-bit output: Diff_n output (connect directly to top-level port)
      .I(I),   // 1-bit input: Buffer input
      .T(T)    // 1-bit input: 3-state enable input
   );

   // End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Output Buffer (OBUF)" treetype="template">
//    OBUF     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUF: Output Buffer
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OBUF OBUF_inst (
      .O(O), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(I)  // 1-bit input: Buffer input
   );

   // End of OBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer (ISERDESE3)" treetype="template">
//  ISERDESE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ISERDESE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ISERDESE3: Input SERial/DESerializer
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   ISERDESE3 #(
      .DATA_WIDTH(8),            // Parallel data width (4,8)
      .FIFO_ENABLE("FALSE"),     // Enables the use of the FIFO
      .FIFO_SYNC_MODE("FALSE"),  // Enables the use of internal 2-stage synchronizers on the FIFO
      .IS_CLK_B_INVERTED(1'b0),  // Optional inversion for CLK_B
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   ISERDESE3_inst (
      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .INTERNAL_DIVCLK(INTERNAL_DIVCLK), // 1-bit output: Internally divided down clock used when FIFO is
                                         // disabled (do not connect)

      .Q(Q),                             // 8-bit registered output
      .CLK(CLK),                         // 1-bit input: High-speed clock
      .CLKDIV(CLKDIV),                   // 1-bit input: Divided Clock
      .CLK_B(CLK_B),                     // 1-bit input: Inversion of High-speed clock CLK
      .D(D),                             // 1-bit input: Serial Data Input
      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: Enables reading the FIFO when asserted
      .RST(RST)                          // 1-bit input: Asynchronous Reset
   );

   // End of ISERDESE3_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer (OSERDESE3)" treetype="template">
//  OSERDESE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OSERDESE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OSERDESE3: Output SERial/DESerializer
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   OSERDESE3 #(
      .DATA_WIDTH(8),            // Parallel Data Width (4-8)
      .INIT(1'b0),               // Initialization value of the OSERDES flip-flops
      .IS_CLKDIV_INVERTED(1'b0), // Optional inversion for CLKDIV
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   OSERDESE3_inst (
      .OQ(OQ),         // 1-bit output: Serial Output Data
      .T_OUT(T_OUT),   // 1-bit output: 3-state control output to IOB
      .CLK(CLK),       // 1-bit input: High-speed clock
      .CLKDIV(CLKDIV), // 1-bit input: Divided Clock
      .D(D),           // 8-bit input: Parallel Data Input
      .RST(RST),       // 1-bit input: Asynchronous Reset
      .T(T)            // 1-bit input: Tristate input from fabric
   );

   // End of OSERDESE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="WEAK_DRIVER" treetype="folder">
					<Template label="I/O Pulldown (PULLDOWN)" treetype="template">
//  PULLDOWN   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PULLDOWN_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PULLDOWN: I/O Pulldown
   //           Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   PULLDOWN PULLDOWN_inst (
      .O(O)  // 1-bit output: Pulldown output (connect directly to top-level port)
   );

   // End of PULLDOWN_inst instantiation
					</Template>
					<Template label="I/O Pullup (PULLUP)" treetype="template">
//   PULLUP    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PULLUP_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PULLUP: I/O Pullup
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   PULLUP PULLUP_inst (
      .O(O)  // 1-bit output: Pullup output (connect directly to top-level port)
   );

   // End of PULLUP_inst instantiation
					</Template>
					<Template label="I/O Weak Keeper (KEEPER)" treetype="template">
//   KEEPER    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (KEEPER_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // KEEPER: I/O Weak Keeper
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   KEEPER KEEPER_inst (
      .O(O)  // 1-bit inout: Keeper output (connect directly to top-level port)
   );

   // End of KEEPER_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="REGISTER" treetype="folder">
				<SubFolder label="DDR" treetype="folder">
					<Template label="Input DDR (IDDRE1)" treetype="template">
//   IDDRE1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDDRE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDDRE1: Dedicated Dual Data Rate (DDR) Input Register
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   IDDRE1 #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // IDDRE1 mode (OPPOSITE_EDGE, SAME_EDGE, SAME_EDGE_PIPELINED)
      .IS_CB_INVERTED(1'b0),          // Optional inversion for CB
      .IS_C_INVERTED(1'b0)            // Optional inversion for C
   )
   IDDRE1_inst (
      .Q1(Q1), // 1-bit output: Registered parallel output 1
      .Q2(Q2), // 1-bit output: Registered parallel output 2
      .C(C),   // 1-bit input: High-speed clock
      .CB(CB), // 1-bit input: Inversion of High-speed clock C
      .D(D),   // 1-bit input: Serial Data Input
      .R(R)    // 1-bit input: Active High Async Reset
   );

   // End of IDDRE1_inst instantiation
					</Template>
					<Template label="Output DDR (ODDRE1)" treetype="template">
//   ODDRE1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODDRE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODDRE1: Dedicated Dual Data Rate (DDR) Output Register
   //         Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   ODDRE1 #(
      .IS_C_INVERTED(1'b0),  // Optional inversion for C
      .IS_D1_INVERTED(1'b0), // Optional inversion for D1
      .IS_D2_INVERTED(1'b0), // Optional inversion for D2
      .SRVAL(1'b0)           // Initializes the ODDRE1 Flip-Flops to the specified value (1'b0, 1'b1)
   )
   ODDRE1_inst (
      .Q(Q),   // 1-bit output: Data output to IOB
      .C(C),   // 1-bit input: High-speed clock input
      .D1(D1), // 1-bit input: Parallel data input 1
      .D2(D2), // 1-bit input: Parallel data input 2
      .SR(SR)  // 1-bit input: Active High Async Reset
   );

   // End of ODDRE1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Transparent Latch with Clock Enable and Asynchronous Clear (LDCE)" treetype="template">
//    LDCE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LDCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LDCE: Transparent Latch with Clock Enable and Asynchronous Clear
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LDCE #(
      .INIT(1'b0),            // Initial value of latch, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_G_INVERTED(1'b0)    // Optional inversion for G
   )
   LDCE_inst (
      .Q(Q),     // 1-bit output: Data
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .D(D),     // 1-bit input: Data
      .G(G),     // 1-bit input: Gate
      .GE(GE)    // 1-bit input: Gate enable
   );

   // End of LDCE_inst instantiation
					</Template>
					<Template label="Transparent Latch with Clock Enable and Asynchronous Preset (LDPE)" treetype="template">
//    LDPE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LDPE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LDPE: Transparent Latch with Clock Enable and Asynchronous Preset
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   LDPE #(
      .INIT(1'b1),            // Initial value of latch, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_G_INVERTED(1'b0),   // Optional inversion for G
      .IS_PRE_INVERTED(1'b0)  // Optional inversion for PRE
   )
   LDPE_inst (
      .Q(Q),     // 1-bit output: Data
      .D(D),     // 1-bit input: Data
      .G(G),     // 1-bit input: Gate
      .GE(GE),   // 1-bit input: Gate enable
      .PRE(PRE)  // 1-bit input: Asynchronous preset
   );

   // End of LDPE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="METASTABILITY" treetype="folder">
					<Template label="Metastability Hardened Registers (HARD_SYNC)" treetype="template">
//  HARD_SYNC  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (HARD_SYNC_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // HARD_SYNC: Metastability Hardened Registers
   //            Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   HARD_SYNC #(
      .INIT(1'b0),            // Initial values, 1'b0, 1'b1
      .IS_CLK_INVERTED(1'b0), // Programmable inversion on CLK input
      .LATENCY(2)             // 2-3
   )
   HARD_SYNC_inst (
      .DOUT(DOUT), // 1-bit output: Data
      .CLK(CLK),   // 1-bit input: Clock
      .DIN(DIN)    // 1-bit input: Data
   );

   // End of HARD_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SDR" treetype="folder">
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Clear (FDCE)" treetype="template">
//    FDCE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDCE: D Flip-Flop with Clock Enable and Asynchronous Clear
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FDCE #(
      .INIT(1'b0),            // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_C_INVERTED(1'b0),   // Optional inversion for C
      .IS_D_INVERTED(1'b0)    // Optional inversion for D
   )
   FDCE_inst (
      .Q(Q),     // 1-bit output: Data
      .C(C),     // 1-bit input: Clock
      .CE(CE),   // 1-bit input: Clock enable
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .D(D)      // 1-bit input: Data
   );

   // End of FDCE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Preset (FDPE)" treetype="template">
//    FDPE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDPE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDPE: D Flip-Flop with Clock Enable and Asynchronous Preset
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FDPE #(
      .INIT(1'b1),            // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0),   // Optional inversion for C
      .IS_D_INVERTED(1'b0),   // Optional inversion for D
      .IS_PRE_INVERTED(1'b0)  // Optional inversion for PRE
   )
   FDPE_inst (
      .Q(Q),     // 1-bit output: Data
      .C(C),     // 1-bit input: Clock
      .CE(CE),   // 1-bit input: Clock enable
      .D(D),     // 1-bit input: Data
      .PRE(PRE)  // 1-bit input: Asynchronous preset
   );

   // End of FDPE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Reset (FDRE)" treetype="template">
//    FDRE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDRE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDRE: D Flip-Flop with Clock Enable and Synchronous Reset
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FDRE #(
      .INIT(1'b0),          // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0), // Optional inversion for C
      .IS_D_INVERTED(1'b0), // Optional inversion for D
      .IS_R_INVERTED(1'b0)  // Optional inversion for R
   )
   FDRE_inst (
      .Q(Q),   // 1-bit output: Data
      .C(C),   // 1-bit input: Clock
      .CE(CE), // 1-bit input: Clock enable
      .D(D),   // 1-bit input: Data
      .R(R)    // 1-bit input: Synchronous reset
   );

   // End of FDRE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Set (FDSE)" treetype="template">
//    FDSE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDSE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDSE: D Flip-Flop with Clock Enable and Synchronous Set
   //       Virtex UltraScale
   // Xilinx HDL Language Template, version 2016.4

   FDSE #(
      .INIT(1'b1),          // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0), // Optional inversion for C
      .IS_D_INVERTED(1'b0), // Optional inversion for D
      .IS_S_INVERTED(1'b0)  // Optional inversion for S
   )
   FDSE_inst (
      .Q(Q),   // 1-bit output: Data
      .C(C),   // 1-bit input: Clock
      .CE(CE), // 1-bit input: Clock enable
      .D(D),   // 1-bit input: Data
      .S(S)    // 1-bit input: Synchronous set
   );

   // End of FDSE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Virtex UltraScale+" treetype="folder">
			<SubFolder label="ADVANCED" treetype="folder">
				<SubFolder label="GT" treetype="folder">
					<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE4)" treetype="template">
// IBUFDS_GTE4 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_GTE4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_GTE4: Gigabit Transceiver Buffer
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE4 #(
      .REFCLK_EN_TX_PATH(1'b0),   // Refer to Transceiver User Guide
      .REFCLK_HROW_CK_SEL(2'b00), // Refer to Transceiver User Guide
      .REFCLK_ICNTL_RX(2'b00)     // Refer to Transceiver User Guide
   )
   IBUFDS_GTE4_inst (
      .O(O),         // 1-bit output: Refer to Transceiver User Guide
      .ODIV2(ODIV2), // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),     // 1-bit input: Refer to Transceiver User Guide
      .I(I),         // 1-bit input: Refer to Transceiver User Guide
      .IB(IB)        // 1-bit input: Refer to Transceiver User Guide
   );

   // End of IBUFDS_GTE4_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE4_ADV)" treetype="template">
// OBUFDS_GTE4_ADV : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFDS_GTE4_ADV_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_GTE4_ADV: Gigabit Transceiver Buffer
   //                  Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE4_ADV #(
      .REFCLK_EN_TX_PATH(1'b1),   // Refer to Transceiver User Guide
      .REFCLK_ICNTL_TX(5'b00000)  // Refer to Transceiver User Guide
   )
   OBUFDS_GTE4_ADV_inst (
      .O(O),                       // 1-bit output: Refer to Transceiver User Guide
      .OB(OB),                     // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),                   // 1-bit input: Refer to Transceiver User Guide
      .I(I),                       // 4-bit input: Refer to Transceiver User Guide
      .RXRECCLK_SEL(RXRECCLK_SEL)  // 2-bit input: Refer to Transceiver User Guide
   );

   // End of OBUFDS_GTE4_ADV_inst instantiation
					</Template>
					<Template label="Gigabit Transceiver Buffer (OBUFDS_GTE4)" treetype="template">
// OBUFDS_GTE4 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_GTE4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_GTE4: Gigabit Transceiver Buffer
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_GTE4 #(
      .REFCLK_EN_TX_PATH(1'b1),   // Refer to Transceiver User Guide
      .REFCLK_ICNTL_TX(5'b00000)  // Refer to Transceiver User Guide
   )
   OBUFDS_GTE4_inst (
      .O(O),     // 1-bit output: Refer to Transceiver User Guide
      .OB(OB),   // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB), // 1-bit input: Refer to Transceiver User Guide
      .I(I)      // 1-bit input: Refer to Transceiver User Guide
   );

   // End of OBUFDS_GTE4_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SYSMON" treetype="folder">
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE1)" treetype="template">
//  SYSMONE1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SYSMONE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SYSMONE1: Xilinx Analog-to-Digital Converter and System Monitor
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   SYSMONE1 #(
      // INIT_40 - INIT_44: SYSMON configuration registers
      .INIT_40(16'h0000),
      .INIT_41(16'h0000),
      .INIT_42(16'h0000),
      .INIT_43(16'h0000),
      .INIT_44(16'h0000),
      .INIT_45(16'h0000),              // Analog Bus Register
      // INIT_46 - INIT_4F: Sequence Registers
      .INIT_46(16'h0000),
      .INIT_47(16'h0000),
      .INIT_48(16'h0000),
      .INIT_49(16'h0000),
      .INIT_4A(16'h0000),
      .INIT_4B(16'h0000),
      .INIT_4C(16'h0000),
      .INIT_4D(16'h0000),
      .INIT_4E(16'h0000),
      .INIT_4F(16'h0000),
      // INIT_50 - INIT_5F: Alarm Limit Registers
      .INIT_50(16'h0000),
      .INIT_51(16'h0000),
      .INIT_52(16'h0000),
      .INIT_53(16'h0000),
      .INIT_54(16'h0000),
      .INIT_55(16'h0000),
      .INIT_56(16'h0000),
      .INIT_57(16'h0000),
      .INIT_58(16'h0000),
      .INIT_59(16'h0000),
      .INIT_5A(16'h0000),
      .INIT_5B(16'h0000),
      .INIT_5C(16'h0000),
      .INIT_5D(16'h0000),
      .INIT_5E(16'h0000),
      .INIT_5F(16'h0000),
      // INIT_60 - INIT_6F: User Supply Alarms
      .INIT_60(16'h0000),
      .INIT_61(16'h0000),
      .INIT_62(16'h0000),
      .INIT_63(16'h0000),
      .INIT_64(16'h0000),
      .INIT_65(16'h0000),
      .INIT_66(16'h0000),
      .INIT_67(16'h0000),
      .INIT_68(16'h0000),
      .INIT_69(16'h0000),
      .INIT_6A(16'h0000),
      .INIT_6B(16'h0000),
      .INIT_6C(16'h0000),
      .INIT_6D(16'h0000),
      .INIT_6E(16'h0000),
      .INIT_6F(16'h0000),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      // specific pins
      .IS_CONVSTCLK_INVERTED(1'b0),    // Optional inversion for CONVSTCLK, 0-1
      .IS_DCLK_INVERTED(1'b0),         // Optional inversion for DCLK, 0-1
      // Simulation attributes: Set for proper simulation behavior
      .SIM_MONITOR_FILE("design.txt"), // Analog simulation data file name
      // User Voltage Monitor: SYSMON User voltage monitor
      .SYSMON_VUSER0_BANK(0),          // Specify IO Bank for User0
      .SYSMON_VUSER0_MONITOR("NONE"),  // Specify Voltage for User0
      .SYSMON_VUSER1_BANK(0),          // Specify IO Bank for User1
      .SYSMON_VUSER1_MONITOR("NONE"),  // Specify Voltage for User1
      .SYSMON_VUSER2_BANK(0),          // Specify IO Bank for User2
      .SYSMON_VUSER2_MONITOR("NONE"),  // Specify Voltage for User2
      .SYSMON_VUSER3_MONITOR("NONE")   // Specify Voltage for User3
   )
   SYSMONE1_inst (
      // ALARMS outputs: ALM, OT
      .ALM(ALM),                   // 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      .OT(OT),                     // 1-bit output: Over-Temperature alarm
      // Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      .DO(DO),                     // 16-bit output: DRP output data bus
      .DRDY(DRDY),                 // 1-bit output: DRP data ready
      // I2C Interface outputs: Ports used with the I2C DRP interface
      .I2C_SCLK_TS(I2C_SCLK_TS),   // 1-bit output: I2C_SCLK output port
      .I2C_SDA_TS(I2C_SDA_TS),     // 1-bit output: I2C_SDA_TS output port
      // STATUS outputs: SYSMON status ports
      .BUSY(BUSY),                 // 1-bit output: System Monitor busy output
      .CHANNEL(CHANNEL),           // 6-bit output: Channel selection outputs
      .EOC(EOC),                   // 1-bit output: End of Conversion
      .EOS(EOS),                   // 1-bit output: End of Sequence
      .JTAGBUSY(JTAGBUSY),         // 1-bit output: JTAG DRP transaction in progress output
      .JTAGLOCKED(JTAGLOCKED),     // 1-bit output: JTAG requested DRP port lock
      .JTAGMODIFIED(JTAGMODIFIED), // 1-bit output: JTAG Write to the DRP has occurred
      .MUXADDR(MUXADDR),           // 5-bit output: External MUX channel decode
      // Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      .VAUXN(VAUXN),               // 16-bit input: N-side auxiliary analog input
      .VAUXP(VAUXP),               // 16-bit input: P-side auxiliary analog input
      // CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      .CONVST(CONVST),             // 1-bit input: Convert start input
      .CONVSTCLK(CONVSTCLK),       // 1-bit input: Convert start input
      .RESET(RESET),               // 1-bit input: Active-High reset
      // Dedicated Analog Input Pair inputs: VP/VN
      .VN(VN),                     // 1-bit input: N-side analog input
      .VP(VP),                     // 1-bit input: P-side analog input
      // Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      .DADDR(DADDR),               // 8-bit input: DRP address bus
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable signal
      .DI(DI),                     // 16-bit input: DRP input data bus
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // I2C Interface inputs: Ports used with the I2C DRP interface
      .I2C_SCLK(I2C_SCLK),         // 1-bit input: I2C_SCLK input port
      .I2C_SDA(I2C_SDA)            // 1-bit input: I2C_SDA input port
   );

   // End of SYSMONE1_inst instantiation
					</Template>
					<Template label="Xilinx Analog-to-Digital Converter and System Monitor (SYSMONE4)" treetype="template">
//  SYSMONE4   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SYSMONE4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SYSMONE4: Xilinx Analog-to-Digital Converter and System Monitor
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   SYSMONE4 #(
      // INIT_40 - INIT_44: SYSMON configuration registers
      .INIT_40(16'h0000),
      .INIT_41(16'h0000),
      .INIT_42(16'h0000),
      .INIT_43(16'h0000),
      .INIT_44(16'h0000),
      .INIT_45(16'h0000),              // Analog Bus Register
      // INIT_46 - INIT_4F: Sequence Registers
      .INIT_46(16'h0000),
      .INIT_47(16'h0000),
      .INIT_48(16'h0000),
      .INIT_49(16'h0000),
      .INIT_4A(16'h0000),
      .INIT_4B(16'h0000),
      .INIT_4C(16'h0000),
      .INIT_4D(16'h0000),
      .INIT_4E(16'h0000),
      .INIT_4F(16'h0000),
      // INIT_50 - INIT_5F: Alarm Limit Registers
      .INIT_50(16'h0000),
      .INIT_51(16'h0000),
      .INIT_52(16'h0000),
      .INIT_53(16'h0000),
      .INIT_54(16'h0000),
      .INIT_55(16'h0000),
      .INIT_56(16'h0000),
      .INIT_57(16'h0000),
      .INIT_58(16'h0000),
      .INIT_59(16'h0000),
      .INIT_5A(16'h0000),
      .INIT_5B(16'h0000),
      .INIT_5C(16'h0000),
      .INIT_5D(16'h0000),
      .INIT_5E(16'h0000),
      .INIT_5F(16'h0000),
      // INIT_60 - INIT_6F: User Supply Alarms
      .INIT_60(16'h0000),
      .INIT_61(16'h0000),
      .INIT_62(16'h0000),
      .INIT_63(16'h0000),
      .INIT_64(16'h0000),
      .INIT_65(16'h0000),
      .INIT_66(16'h0000),
      .INIT_67(16'h0000),
      .INIT_68(16'h0000),
      .INIT_69(16'h0000),
      .INIT_6A(16'h0000),
      .INIT_6B(16'h0000),
      .INIT_6C(16'h0000),
      .INIT_6D(16'h0000),
      .INIT_6E(16'h0000),
      .INIT_6F(16'h0000),
      // Primitive attributes: Primitive Attributes
      .COMMON_N_SOURCE(16'hffff),      // Sets the auxiliary analog input that is used for the Common-N input.
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion on
      // specific pins
      .IS_CONVSTCLK_INVERTED(1'b0),    // Optional inversion for CONVSTCLK, 0-1
      .IS_DCLK_INVERTED(1'b0),         // Optional inversion for DCLK, 0-1
      // Simulation attributes: Set for proper simulation behavior
      .SIM_DEVICE("ULTRASCALE_PLUS"),  // Sets the correct target device for simulation functionality.
      .SIM_MONITOR_FILE("design.txt"), // Analog simulation data file name
      // User Voltage Monitor: SYSMON User voltage monitor
      .SYSMON_VUSER0_BANK(0),          // Specify IO Bank for User0
      .SYSMON_VUSER0_MONITOR("NONE"),  // Specify Voltage for User0
      .SYSMON_VUSER1_BANK(0),          // Specify IO Bank for User1
      .SYSMON_VUSER1_MONITOR("NONE"),  // Specify Voltage for User1
      .SYSMON_VUSER2_BANK(0),          // Specify IO Bank for User2
      .SYSMON_VUSER2_MONITOR("NONE"),  // Specify Voltage for User2
      .SYSMON_VUSER3_MONITOR("NONE")   // Specify Voltage for User3
   )
   SYSMONE4_inst (
      // ALARMS outputs: ALM, OT
      .ALM(ALM),                   // 16-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      .OT(OT),                     // 1-bit output: Over-Temperature alarm
      // Direct Data Out outputs: ADC_DATA
      .ADC_DATA(ADC_DATA),         // 16-bit output: Direct Data Out
      // Dynamic Reconfiguration Port (DRP) outputs: Dynamic Reconfiguration Ports
      .DO(DO),                     // 16-bit output: DRP output data bus
      .DRDY(DRDY),                 // 1-bit output: DRP data ready
      // I2C Interface outputs: Ports used with the I2C DRP interface
      .I2C_SCLK_TS(I2C_SCLK_TS),   // 1-bit output: I2C_SCLK output port
      .I2C_SDA_TS(I2C_SDA_TS),     // 1-bit output: I2C_SDA_TS output port
      .SMBALERT_TS(SMBALERT_TS),   // 1-bit output: Output control signal for SMBALERT.
      // STATUS outputs: SYSMON status ports
      .BUSY(BUSY),                 // 1-bit output: System Monitor busy output
      .CHANNEL(CHANNEL),           // 6-bit output: Channel selection outputs
      .EOC(EOC),                   // 1-bit output: End of Conversion
      .EOS(EOS),                   // 1-bit output: End of Sequence
      .JTAGBUSY(JTAGBUSY),         // 1-bit output: JTAG DRP transaction in progress output
      .JTAGLOCKED(JTAGLOCKED),     // 1-bit output: JTAG requested DRP port lock
      .JTAGMODIFIED(JTAGMODIFIED), // 1-bit output: JTAG Write to the DRP has occurred
      .MUXADDR(MUXADDR),           // 5-bit output: External MUX channel decode
      // Auxiliary Analog-Input Pairs inputs: VAUXP[15:0], VAUXN[15:0]
      .VAUXN(VAUXN),               // 16-bit input: N-side auxiliary analog input
      .VAUXP(VAUXP),               // 16-bit input: P-side auxiliary analog input
      // CONTROL and CLOCK inputs: Reset, conversion start and clock inputs
      .CONVST(CONVST),             // 1-bit input: Convert start input
      .CONVSTCLK(CONVSTCLK),       // 1-bit input: Convert start input
      .RESET(RESET),               // 1-bit input: Active-High reset
      // Dedicated Analog Input Pair inputs: VP/VN
      .VN(VN),                     // 1-bit input: N-side analog input
      .VP(VP),                     // 1-bit input: P-side analog input
      // Dynamic Reconfiguration Port (DRP) inputs: Dynamic Reconfiguration Ports
      .DADDR(DADDR),               // 8-bit input: DRP address bus
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable signal
      .DI(DI),                     // 16-bit input: DRP input data bus
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // I2C Interface inputs: Ports used with the I2C DRP interface
      .I2C_SCLK(I2C_SCLK),         // 1-bit input: I2C_SCLK input port
      .I2C_SDA(I2C_SDA)            // 1-bit input: I2C_SDA input port
   );

   // End of SYSMONE4_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="ARITHMETIC" treetype="folder">
				<SubFolder label="DSP" treetype="folder">
					<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E2)" treetype="template">
//   DSP48E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DSP48E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DSP48E2: 48-bit Multi-Functional Arithmetic Block
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   DSP48E2 #(
      // Feature Control Attributes: Data Path Selection
      .AMULTSEL("A"),                    // Selects A input to multiplier (A, AD)
      .A_INPUT("DIRECT"),                // Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      .BMULTSEL("B"),                    // Selects B input to multiplier (AD, B)
      .B_INPUT("DIRECT"),                // Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      .PREADDINSEL("A"),                 // Selects input to pre-adder (A, B)
      .RND(48'h000000000000),            // Rounding Constant
      .USE_MULT("MULTIPLY"),             // Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
      .USE_SIMD("ONE48"),                // SIMD selection (FOUR12, ONE48, TWO24)
      .USE_WIDEXOR("FALSE"),             // Use the Wide XOR function (FALSE, TRUE)
      .XORSIMD("XOR24_48_96"),           // Mode of operation for the Wide XOR (XOR12, XOR24_48_96)
      // Pattern Detector Attributes: Pattern Detection Configuration
      .AUTORESET_PATDET("NO_RESET"),     // NO_RESET, RESET_MATCH, RESET_NOT_MATCH
      .AUTORESET_PRIORITY("RESET"),      // Priority of AUTORESET vs. CEP (CEP, RESET).
      .MASK(48'h3fffffffffff),           // 48-bit mask value for pattern detect (1=ignore)
      .PATTERN(48'h000000000000),        // 48-bit pattern match for pattern detect
      .SEL_MASK("MASK"),                 // C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
      .SEL_PATTERN("PATTERN"),           // Select pattern value (C, PATTERN)
      .USE_PATTERN_DETECT("NO_PATDET"),  // Enable pattern detect (NO_PATDET, PATDET)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_ALUMODE_INVERTED(4'b0000),     // Optional inversion for ALUMODE
      .IS_CARRYIN_INVERTED(1'b0),        // Optional inversion for CARRYIN
      .IS_CLK_INVERTED(1'b0),            // Optional inversion for CLK
      .IS_INMODE_INVERTED(5'b00000),     // Optional inversion for INMODE
      .IS_OPMODE_INVERTED(9'b000000000), // Optional inversion for OPMODE
      .IS_RSTALLCARRYIN_INVERTED(1'b0),  // Optional inversion for RSTALLCARRYIN
      .IS_RSTALUMODE_INVERTED(1'b0),     // Optional inversion for RSTALUMODE
      .IS_RSTA_INVERTED(1'b0),           // Optional inversion for RSTA
      .IS_RSTB_INVERTED(1'b0),           // Optional inversion for RSTB
      .IS_RSTCTRL_INVERTED(1'b0),        // Optional inversion for RSTCTRL
      .IS_RSTC_INVERTED(1'b0),           // Optional inversion for RSTC
      .IS_RSTD_INVERTED(1'b0),           // Optional inversion for RSTD
      .IS_RSTINMODE_INVERTED(1'b0),      // Optional inversion for RSTINMODE
      .IS_RSTM_INVERTED(1'b0),           // Optional inversion for RSTM
      .IS_RSTP_INVERTED(1'b0),           // Optional inversion for RSTP
      // Register Control Attributes: Pipeline Register Configuration
      .ACASCREG(1),                      // Number of pipeline stages between A/ACIN and ACOUT (0-2)
      .ADREG(1),                         // Pipeline stages for pre-adder (0-1)
      .ALUMODEREG(1),                    // Pipeline stages for ALUMODE (0-1)
      .AREG(1),                          // Pipeline stages for A (0-2)
      .BCASCREG(1),                      // Number of pipeline stages between B/BCIN and BCOUT (0-2)
      .BREG(1),                          // Pipeline stages for B (0-2)
      .CARRYINREG(1),                    // Pipeline stages for CARRYIN (0-1)
      .CARRYINSELREG(1),                 // Pipeline stages for CARRYINSEL (0-1)
      .CREG(1),                          // Pipeline stages for C (0-1)
      .DREG(1),                          // Pipeline stages for D (0-1)
      .INMODEREG(1),                     // Pipeline stages for INMODE (0-1)
      .MREG(1),                          // Multiplier pipeline stages (0-1)
      .OPMODEREG(1),                     // Pipeline stages for OPMODE (0-1)
      .PREG(1)                           // Number of pipeline stages for P (0-1)
   )
   DSP48E2_inst (
      // Cascade outputs: Cascade Ports
      .ACOUT(ACOUT),                   // 30-bit output: A port cascade
      .BCOUT(BCOUT),                   // 18-bit output: B cascade
      .CARRYCASCOUT(CARRYCASCOUT),     // 1-bit output: Cascade carry
      .MULTSIGNOUT(MULTSIGNOUT),       // 1-bit output: Multiplier sign cascade
      .PCOUT(PCOUT),                   // 48-bit output: Cascade output
      // Control outputs: Control Inputs/Status Bits
      .OVERFLOW(OVERFLOW),             // 1-bit output: Overflow in add/acc
      .PATTERNBDETECT(PATTERNBDETECT), // 1-bit output: Pattern bar detect
      .PATTERNDETECT(PATTERNDETECT),   // 1-bit output: Pattern detect
      .UNDERFLOW(UNDERFLOW),           // 1-bit output: Underflow in add/acc
      // Data outputs: Data Ports
      .CARRYOUT(CARRYOUT),             // 4-bit output: Carry
      .P(P),                           // 48-bit output: Primary data
      .XOROUT(XOROUT),                 // 8-bit output: XOR data
      // Cascade inputs: Cascade Ports
      .ACIN(ACIN),                     // 30-bit input: A cascade data
      .BCIN(BCIN),                     // 18-bit input: B cascade
      .CARRYCASCIN(CARRYCASCIN),       // 1-bit input: Cascade carry
      .MULTSIGNIN(MULTSIGNIN),         // 1-bit input: Multiplier sign cascade
      .PCIN(PCIN),                     // 48-bit input: P cascade
      // Control inputs: Control Inputs/Status Bits
      .ALUMODE(ALUMODE),               // 4-bit input: ALU control
      .CARRYINSEL(CARRYINSEL),         // 3-bit input: Carry select
      .CLK(CLK),                       // 1-bit input: Clock
      .INMODE(INMODE),                 // 5-bit input: INMODE control
      .OPMODE(OPMODE),                 // 9-bit input: Operation mode
      // Data inputs: Data Ports
      .A(A),                           // 30-bit input: A data
      .B(B),                           // 18-bit input: B data
      .C(C),                           // 48-bit input: C data
      .CARRYIN(CARRYIN),               // 1-bit input: Carry-in
      .D(D),                           // 27-bit input: D data
      // Reset/Clock Enable inputs: Reset/Clock Enable Inputs
      .CEA1(CEA1),                     // 1-bit input: Clock enable for 1st stage AREG
      .CEA2(CEA2),                     // 1-bit input: Clock enable for 2nd stage AREG
      .CEAD(CEAD),                     // 1-bit input: Clock enable for ADREG
      .CEALUMODE(CEALUMODE),           // 1-bit input: Clock enable for ALUMODE
      .CEB1(CEB1),                     // 1-bit input: Clock enable for 1st stage BREG
      .CEB2(CEB2),                     // 1-bit input: Clock enable for 2nd stage BREG
      .CEC(CEC),                       // 1-bit input: Clock enable for CREG
      .CECARRYIN(CECARRYIN),           // 1-bit input: Clock enable for CARRYINREG
      .CECTRL(CECTRL),                 // 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
      .CED(CED),                       // 1-bit input: Clock enable for DREG
      .CEINMODE(CEINMODE),             // 1-bit input: Clock enable for INMODEREG
      .CEM(CEM),                       // 1-bit input: Clock enable for MREG
      .CEP(CEP),                       // 1-bit input: Clock enable for PREG
      .RSTA(RSTA),                     // 1-bit input: Reset for AREG
      .RSTALLCARRYIN(RSTALLCARRYIN),   // 1-bit input: Reset for CARRYINREG
      .RSTALUMODE(RSTALUMODE),         // 1-bit input: Reset for ALUMODEREG
      .RSTB(RSTB),                     // 1-bit input: Reset for BREG
      .RSTC(RSTC),                     // 1-bit input: Reset for CREG
      .RSTCTRL(RSTCTRL),               // 1-bit input: Reset for OPMODEREG and CARRYINSELREG
      .RSTD(RSTD),                     // 1-bit input: Reset for DREG and ADREG
      .RSTINMODE(RSTINMODE),           // 1-bit input: Reset for INMODEREG
      .RSTM(RSTM),                     // 1-bit input: Reset for MREG
      .RSTP(RSTP)                      // 1-bit input: Reset for PREG
   );

   // End of DSP48E2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="BLOCKRAM" treetype="folder">
				<SubFolder label="BRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E2)" treetype="template">
//  RAMB18E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB18E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB18E2: 18K-bit Configurable Synchronous Block RAM
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAMB18E2 #(
      // CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      .CASCADE_ORDER_A("NONE"),
      .CASCADE_ORDER_B("NONE"),
      // CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      .CLOCK_DOMAINS("INDEPENDENT"),
      // Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0, 1)
      .DOA_REG(1),
      .DOB_REG(1),
      // ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      .ENADDRENA("FALSE"),
      .ENADDRENB("FALSE"),
      // INITP_00 to INITP_07: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_3F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(18'h00000),
      .INIT_B(18'h00000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLKARDCLK_INVERTED(1'b0),
      .IS_CLKBWRCLK_INVERTED(1'b0),
      .IS_ENARDEN_INVERTED(1'b0),
      .IS_ENBWREN_INVERTED(1'b0),
      .IS_RSTRAMARSTRAM_INVERTED(1'b0),
      .IS_RSTRAMB_INVERTED(1'b0),
      .IS_RSTREGARSTREG_INVERTED(1'b0),
      .IS_RSTREGB_INVERTED(1'b0),
      // RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      .RDADDRCHANGEA("FALSE"),
      .RDADDRCHANGEB("FALSE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-9
      .READ_WIDTH_B(0),                                                                 // 0-9
      .WRITE_WIDTH_A(0),                                                                // 0-9
      .WRITE_WIDTH_B(0),                                                                // 0-9
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(18'h00000),
      .SRVAL_B(18'h00000),
      // Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      .SLEEP_ASYNC("FALSE"),
      // WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      .WRITE_MODE_A("NO_CHANGE"),
      .WRITE_MODE_B("NO_CHANGE") 
   )
   RAMB18E2_inst (
      // Cascade Signals outputs: Multi-BRAM cascade signals
      .CASDOUTA(CASDOUTA),               // 16-bit output: Port A cascade output data
      .CASDOUTB(CASDOUTB),               // 16-bit output: Port B cascade output data
      .CASDOUTPA(CASDOUTPA),             // 2-bit output: Port A cascade output parity data
      .CASDOUTPB(CASDOUTPB),             // 2-bit output: Port B cascade output parity data
      // Port A Data outputs: Port A data
      .DOUTADOUT(DOUTADOUT),             // 16-bit output: Port A data/LSB data
      .DOUTPADOUTP(DOUTPADOUTP),         // 2-bit output: Port A parity/LSB parity
      // Port B Data outputs: Port B data
      .DOUTBDOUT(DOUTBDOUT),             // 16-bit output: Port B data/MSB data
      .DOUTPBDOUTP(DOUTPBDOUTP),         // 2-bit output: Port B parity/MSB parity
      // Cascade Signals inputs: Multi-BRAM cascade signals
      .CASDIMUXA(CASDIMUXA),             // 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      .CASDIMUXB(CASDIMUXB),             // 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      .CASDINA(CASDINA),                 // 16-bit input: Port A cascade input data
      .CASDINB(CASDINB),                 // 16-bit input: Port B cascade input data
      .CASDINPA(CASDINPA),               // 2-bit input: Port A cascade input parity data
      .CASDINPB(CASDINPB),               // 2-bit input: Port B cascade input parity data
      .CASDOMUXA(CASDOMUXA),             // 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      .CASDOMUXB(CASDOMUXB),             // 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      .CASDOMUXEN_A(CASDOMUXEN_A),       // 1-bit input: Port A unregistered output data enable
      .CASDOMUXEN_B(CASDOMUXEN_B),       // 1-bit input: Port B unregistered output data enable
      .CASOREGIMUXA(CASOREGIMUXA),       // 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      .CASOREGIMUXB(CASOREGIMUXB),       // 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      .CASOREGIMUXEN_A(CASOREGIMUXEN_A), // 1-bit input: Port A registered output data enable
      .CASOREGIMUXEN_B(CASOREGIMUXEN_B), // 1-bit input: Port B registered output data enable
      // Port A Address/Control Signals inputs: Port A address and control signals
      .ADDRARDADDR(ADDRARDADDR),         // 14-bit input: A/Read port address
      .ADDRENA(ADDRENA),                 // 1-bit input: Active-High A/Read port address enable
      .CLKARDCLK(CLKARDCLK),             // 1-bit input: A/Read port clock
      .ENARDEN(ENARDEN),                 // 1-bit input: Port A enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),         // 1-bit input: Port A register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM),     // 1-bit input: Port A set/reset
      .RSTREGARSTREG(RSTREGARSTREG),     // 1-bit input: Port A register set/reset
      .WEA(WEA),                         // 2-bit input: Port A write enable
      // Port A Data inputs: Port A data
      .DINADIN(DINADIN),                 // 16-bit input: Port A data/LSB data
      .DINPADINP(DINPADINP),             // 2-bit input: Port A parity/LSB parity
      // Port B Address/Control Signals inputs: Port B address and control signals
      .ADDRBWRADDR(ADDRBWRADDR),         // 14-bit input: B/Write port address
      .ADDRENB(ADDRENB),                 // 1-bit input: Active-High B/Write port address enable
      .CLKBWRCLK(CLKBWRCLK),             // 1-bit input: B/Write port clock
      .ENBWREN(ENBWREN),                 // 1-bit input: Port B enable/Write enable
      .REGCEB(REGCEB),                   // 1-bit input: Port B register enable
      .RSTRAMB(RSTRAMB),                 // 1-bit input: Port B set/reset
      .RSTREGB(RSTREGB),                 // 1-bit input: Port B register set/reset
      .SLEEP(SLEEP),                     // 1-bit input: Sleep Mode
      .WEBWE(WEBWE),                     // 4-bit input: Port B write enable/Write enable
      // Port B Data inputs: Port B data
      .DINBDIN(DINBDIN),                 // 16-bit input: Port B data/MSB data
      .DINPBDINP(DINPBDINP)              // 2-bit input: Port B parity/MSB parity
   );

   // End of RAMB18E2_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E2)" treetype="template">
//  RAMB36E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB36E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB36E2: 36K-bit Configurable Synchronous Block RAM
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAMB36E2 #(
      // CASCADE_ORDER_A, CASCADE_ORDER_B: "FIRST", "MIDDLE", "LAST", "NONE" 
      .CASCADE_ORDER_A("NONE"),
      .CASCADE_ORDER_B("NONE"),
      // CLOCK_DOMAINS: "COMMON", "INDEPENDENT" 
      .CLOCK_DOMAINS("INDEPENDENT"),
      .DOB_REG(1),
      // Collision check: "ALL", "GENERATE_X_ONLY", "NONE", "WARNING_ONLY" 
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0, 1)
      .DOA_REG(1),
      // ENADDRENA/ENADDRENB: Address enable pin enable, "TRUE", "FALSE" 
      .ENADDRENA("FALSE"),
      .ENADDRENB("FALSE"),
      // EN_ECC_PIPE: ECC pipeline register, "TRUE"/"FALSE" 
      .EN_ECC_PIPE("FALSE"),
      // EN_ECC_READ: Enable ECC decoder, "TRUE"/"FALSE" 
      .EN_ECC_READ("FALSE"),
      // EN_ECC_WRITE: Enable ECC encoder, "TRUE"/"FALSE" 
      .EN_ECC_WRITE("FALSE"),
      // INITP_00 to INITP_0F: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_7F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(36'h000000000),
      .INIT_B(36'h000000000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLKARDCLK_INVERTED(1'b0),
      .IS_CLKBWRCLK_INVERTED(1'b0),
      .IS_ENARDEN_INVERTED(1'b0),
      .IS_ENBWREN_INVERTED(1'b0),
      .IS_RSTRAMARSTRAM_INVERTED(1'b0),
      .IS_RSTRAMB_INVERTED(1'b0),
      .IS_RSTREGARSTREG_INVERTED(1'b0),
      .IS_RSTREGB_INVERTED(1'b0),
      // RDADDRCHANGE: Disable memory access when output value does not change ("TRUE", "FALSE")
      .RDADDRCHANGEA("FALSE"),
      .RDADDRCHANGEB("FALSE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-9
      .READ_WIDTH_B(0),                                                                 // 0-9
      .WRITE_WIDTH_A(0),                                                                // 0-9
      .WRITE_WIDTH_B(0),                                                                // 0-9
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG", "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(36'h000000000),
      .SRVAL_B(36'h000000000),
      // Sleep Async: Sleep function asynchronous or synchronous ("TRUE", "FALSE")
      .SLEEP_ASYNC("FALSE"),
      // WriteMode: "WRITE_FIRST", "NO_CHANGE", "READ_FIRST" 
      .WRITE_MODE_A("NO_CHANGE"),
      .WRITE_MODE_B("NO_CHANGE") 
   )
   RAMB36E2_inst (
      // Cascade Signals outputs: Multi-BRAM cascade signals
      .CASDOUTA(CASDOUTA),               // 32-bit output: Port A cascade output data
      .CASDOUTB(CASDOUTB),               // 32-bit output: Port B cascade output data
      .CASDOUTPA(CASDOUTPA),             // 4-bit output: Port A cascade output parity data
      .CASDOUTPB(CASDOUTPB),             // 4-bit output: Port B cascade output parity data
      .CASOUTDBITERR(CASOUTDBITERR),     // 1-bit output: DBITERR cascade output
      .CASOUTSBITERR(CASOUTSBITERR),     // 1-bit output: SBITERR cascade output
      // ECC Signals outputs: Error Correction Circuitry ports
      .DBITERR(DBITERR),                 // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),             // 8-bit output: Generated error correction parity
      .RDADDRECC(RDADDRECC),             // 9-bit output: ECC Read Address
      .SBITERR(SBITERR),                 // 1-bit output: Single bit error status
      // Port A Data outputs: Port A data
      .DOUTADOUT(DOUTADOUT),             // 32-bit output: Port A ata/LSB data
      .DOUTPADOUTP(DOUTPADOUTP),         // 4-bit output: Port A parity/LSB parity
      // Port B Data outputs: Port B data
      .DOUTBDOUT(DOUTBDOUT),             // 32-bit output: Port B data/MSB data
      .DOUTPBDOUTP(DOUTPBDOUTP),         // 4-bit output: Port B parity/MSB parity
      // Cascade Signals inputs: Multi-BRAM cascade signals
      .CASDIMUXA(CASDIMUXA),             // 1-bit input: Port A input data (0=DINA, 1=CASDINA)
      .CASDIMUXB(CASDIMUXB),             // 1-bit input: Port B input data (0=DINB, 1=CASDINB)
      .CASDINA(CASDINA),                 // 32-bit input: Port A cascade input data
      .CASDINB(CASDINB),                 // 32-bit input: Port B cascade input data
      .CASDINPA(CASDINPA),               // 4-bit input: Port A cascade input parity data
      .CASDINPB(CASDINPB),               // 4-bit input: Port B cascade input parity data
      .CASDOMUXA(CASDOMUXA),             // 1-bit input: Port A unregistered data (0=BRAM data, 1=CASDINA)
      .CASDOMUXB(CASDOMUXB),             // 1-bit input: Port B unregistered data (0=BRAM data, 1=CASDINB)
      .CASDOMUXEN_A(CASDOMUXEN_A),       // 1-bit input: Port A unregistered output data enable
      .CASDOMUXEN_B(CASDOMUXEN_B),       // 1-bit input: Port B unregistered output data enable
      .CASINDBITERR(CASINDBITERR),       // 1-bit input: DBITERR cascade input
      .CASINSBITERR(CASINSBITERR),       // 1-bit input: SBITERR cascade input
      .CASOREGIMUXA(CASOREGIMUXA),       // 1-bit input: Port A registered data (0=BRAM data, 1=CASDINA)
      .CASOREGIMUXB(CASOREGIMUXB),       // 1-bit input: Port B registered data (0=BRAM data, 1=CASDINB)
      .CASOREGIMUXEN_A(CASOREGIMUXEN_A), // 1-bit input: Port A registered output data enable
      .CASOREGIMUXEN_B(CASOREGIMUXEN_B), // 1-bit input: Port B registered output data enable
      // ECC Signals inputs: Error Correction Circuitry ports
      .ECCPIPECE(ECCPIPECE),             // 1-bit input: ECC Pipeline Register Enable
      .INJECTDBITERR(INJECTDBITERR),     // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR),
      // Port A Address/Control Signals inputs: Port A address and control signals
      .ADDRARDADDR(ADDRARDADDR),         // 15-bit input: A/Read port address
      .ADDRENA(ADDRENA),                 // 1-bit input: Active-High A/Read port address enable
      .CLKARDCLK(CLKARDCLK),             // 1-bit input: A/Read port clock
      .ENARDEN(ENARDEN),                 // 1-bit input: Port A enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),         // 1-bit input: Port A register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM),     // 1-bit input: Port A set/reset
      .RSTREGARSTREG(RSTREGARSTREG),     // 1-bit input: Port A register set/reset
      .SLEEP(SLEEP),                     // 1-bit input: Sleep Mode
      .WEA(WEA),                         // 4-bit input: Port A write enable
      // Port A Data inputs: Port A data
      .DINADIN(DINADIN),                 // 32-bit input: Port A data/LSB data
      .DINPADINP(DINPADINP),             // 4-bit input: Port A parity/LSB parity
      // Port B Address/Control Signals inputs: Port B address and control signals
      .ADDRBWRADDR(ADDRBWRADDR),         // 15-bit input: B/Write port address
      .ADDRENB(ADDRENB),                 // 1-bit input: Active-High B/Write port address enable
      .CLKBWRCLK(CLKBWRCLK),             // 1-bit input: B/Write port clock
      .ENBWREN(ENBWREN),                 // 1-bit input: Port B enable/Write enable
      .REGCEB(REGCEB),                   // 1-bit input: Port B register enable
      .RSTRAMB(RSTRAMB),                 // 1-bit input: Port B set/reset
      .RSTREGB(RSTREGB),                 // 1-bit input: Port B register set/reset
      .WEBWE(WEBWE),                     // 8-bit input: Port B write enable/Write enable
      // Port B Data inputs: Port B data
      .DINBDIN(DINBDIN),                 // 32-bit input: Port B data/MSB data
      .DINPBDINP(DINPBDINP)              // 4-bit input: Port B parity/MSB parity
   );

   // End of RAMB36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E2)" treetype="template">
//  FIFO18E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO18E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO18E2: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FIFO18E2 #(
      .CASCADE_ORDER("NONE"),            // FIRST, LAST, MIDDLE, NONE, PARALLEL
      .CLOCK_DOMAINS("INDEPENDENT"),     // COMMON, INDEPENDENT
      .FIRST_WORD_FALL_THROUGH("FALSE"), // FALSE, TRUE
      .INIT(36'h000000000),              // Initial values on output port
      .PROG_EMPTY_THRESH(256),           // Programmable Empty Threshold
      .PROG_FULL_THRESH(256),            // Programmable Full Threshold
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_RDCLK_INVERTED(1'b0),          // Optional inversion for RDCLK
      .IS_RDEN_INVERTED(1'b0),           // Optional inversion for RDEN
      .IS_RSTREG_INVERTED(1'b0),         // Optional inversion for RSTREG
      .IS_RST_INVERTED(1'b0),            // Optional inversion for RST
      .IS_WRCLK_INVERTED(1'b0),          // Optional inversion for WRCLK
      .IS_WREN_INVERTED(1'b0),           // Optional inversion for WREN
      .RDCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .READ_WIDTH(4),                    // 18-9
      .REGISTER_MODE("UNREGISTERED"),    // DO_PIPELINED, REGISTERED, UNREGISTERED
      .RSTREG_PRIORITY("RSTREG"),        // REGCE, RSTREG
      .SLEEP_ASYNC("FALSE"),             // FALSE, TRUE
      .SRVAL(36'h000000000),             // SET/reset value of the FIFO outputs
      .WRCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .WRITE_WIDTH(4)                    // 18-9
   )
   FIFO18E2_inst (
      // Cascade Signals outputs: Multi-FIFO cascade signals
      .CASDOUT(CASDOUT),             // 32-bit output: Data cascade output bus
      .CASDOUTP(CASDOUTP),           // 4-bit output: Parity data cascade output bus
      .CASNXTEMPTY(CASNXTEMPTY),     // 1-bit output: Cascade next empty
      .CASPRVRDEN(CASPRVRDEN),       // 1-bit output: Cascade previous read enable
      // Read Data outputs: Read output data
      .DOUT(DOUT),                   // 32-bit output: FIFO data output bus
      .DOUTP(DOUTP),                 // 4-bit output: FIFO parity output bus.
      // Status outputs: Flags and other FIFO status outputs
      .EMPTY(EMPTY),                 // 1-bit output: Empty
      .FULL(FULL),                   // 1-bit output: Full
      .PROGEMPTY(PROGEMPTY),         // 1-bit output: Programmable empty
      .PROGFULL(PROGFULL),           // 1-bit output: Programmable full
      .RDCOUNT(RDCOUNT),             // 13-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .RDRSTBUSY(RDRSTBUSY),         // 1-bit output: Reset busy (sync to RDCLK)
      .WRCOUNT(WRCOUNT),             // 13-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write Error
      .WRRSTBUSY(WRRSTBUSY),         // 1-bit output: Reset busy (sync to WRCLK)
      // Cascade Signals inputs: Multi-FIFO cascade signals
      .CASDIN(CASDIN),               // 32-bit input: Data cascade input bus
      .CASDINP(CASDINP),             // 4-bit input: Parity data cascade input bus
      .CASDOMUX(CASDOMUX),           // 1-bit input: Cascade MUX select
      .CASDOMUXEN(CASDOMUXEN),       // 1-bit input: Enable for cascade MUX select
      .CASNXTRDEN(CASNXTRDEN),       // 1-bit input: Cascade next read enable
      .CASOREGIMUX(CASOREGIMUX),     // 1-bit input: Cascade output MUX select
      .CASOREGIMUXEN(CASOREGIMUXEN), // 1-bit input: Cascade output MUX select enable
      .CASPRVEMPTY(CASPRVEMPTY),     // 1-bit input: Cascade previous empty
      // Read Control Signals inputs: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Output register clock enable
      .RSTREG(RSTREG),               // 1-bit input: Output register reset
      .SLEEP(SLEEP),                 // 1-bit input: Sleep Mode
      // Write Control Signals inputs: Write clock and enable input signals
      .RST(RST),                     // 1-bit input: Reset
      .WRCLK(WRCLK),                 // 1-bit input: Write clock
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data inputs: Write input data
      .DIN(DIN),                     // 32-bit input: FIFO data input bus
      .DINP(DINP)                    // 4-bit input: FIFO parity input bus
   );

   // End of FIFO18E2_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E2)" treetype="template">
//  FIFO36E2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO36E2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO36E2: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FIFO36E2 #(
      .CASCADE_ORDER("NONE"),            // FIRST, LAST, MIDDLE, NONE, PARALLEL
      .CLOCK_DOMAINS("INDEPENDENT"),     // COMMON, INDEPENDENT
      .EN_ECC_PIPE("FALSE"),             // ECC pipeline register, (FALSE, TRUE)
      .EN_ECC_READ("FALSE"),             // Enable ECC decoder, (FALSE, TRUE)
      .EN_ECC_WRITE("FALSE"),            // Enable ECC encoder, (FALSE, TRUE)
      .FIRST_WORD_FALL_THROUGH("FALSE"), // FALSE, TRUE
      .INIT(72'h000000000000000000),     // Initial values on output port
      .PROG_EMPTY_THRESH(256),           // Programmable Empty Threshold
      .PROG_FULL_THRESH(256),            // Programmable Full Threshold
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_RDCLK_INVERTED(1'b0),          // Optional inversion for RDCLK
      .IS_RDEN_INVERTED(1'b0),           // Optional inversion for RDEN
      .IS_RSTREG_INVERTED(1'b0),         // Optional inversion for RSTREG
      .IS_RST_INVERTED(1'b0),            // Optional inversion for RST
      .IS_WRCLK_INVERTED(1'b0),          // Optional inversion for WRCLK
      .IS_WREN_INVERTED(1'b0),           // Optional inversion for WREN
      .RDCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .READ_WIDTH(4),                    // 18-9
      .REGISTER_MODE("UNREGISTERED"),    // DO_PIPELINED, REGISTERED, UNREGISTERED
      .RSTREG_PRIORITY("RSTREG"),        // REGCE, RSTREG
      .SLEEP_ASYNC("FALSE"),             // FALSE, TRUE
      .SRVAL(72'h000000000000000000),    // SET/reset value of the FIFO outputs
      .WRCOUNT_TYPE("RAW_PNTR"),         // EXTENDED_DATACOUNT, RAW_PNTR, SIMPLE_DATACOUNT, SYNC_PNTR
      .WRITE_WIDTH(4)                    // 18-9
   )
   FIFO36E2_inst (
      // Cascade Signals outputs: Multi-FIFO cascade signals
      .CASDOUT(CASDOUT),             // 64-bit output: Data cascade output bus
      .CASDOUTP(CASDOUTP),           // 8-bit output: Parity data cascade output bus
      .CASNXTEMPTY(CASNXTEMPTY),     // 1-bit output: Cascade next empty
      .CASPRVRDEN(CASPRVRDEN),       // 1-bit output: Cascade previous read enable
      // ECC Signals outputs: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Read Data outputs: Read output data
      .DOUT(DOUT),                   // 64-bit output: FIFO data output bus
      .DOUTP(DOUTP),                 // 8-bit output: FIFO parity output bus.
      // Status outputs: Flags and other FIFO status outputs
      .EMPTY(EMPTY),                 // 1-bit output: Empty
      .FULL(FULL),                   // 1-bit output: Full
      .PROGEMPTY(PROGEMPTY),         // 1-bit output: Programmable empty
      .PROGFULL(PROGFULL),           // 1-bit output: Programmable full
      .RDCOUNT(RDCOUNT),             // 14-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .RDRSTBUSY(RDRSTBUSY),         // 1-bit output: Reset busy (sync to RDCLK)
      .WRCOUNT(WRCOUNT),             // 14-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write Error
      .WRRSTBUSY(WRRSTBUSY),         // 1-bit output: Reset busy (sync to WRCLK)
      // Cascade Signals inputs: Multi-FIFO cascade signals
      .CASDIN(CASDIN),               // 64-bit input: Data cascade input bus
      .CASDINP(CASDINP),             // 8-bit input: Parity data cascade input bus
      .CASDOMUX(CASDOMUX),           // 1-bit input: Cascade MUX select input
      .CASDOMUXEN(CASDOMUXEN),       // 1-bit input: Enable for cascade MUX select
      .CASNXTRDEN(CASNXTRDEN),       // 1-bit input: Cascade next read enable
      .CASOREGIMUX(CASOREGIMUX),     // 1-bit input: Cascade output MUX select
      .CASOREGIMUXEN(CASOREGIMUXEN), // 1-bit input: Cascade output MUX select enable
      .CASPRVEMPTY(CASPRVEMPTY),     // 1-bit input: Cascade previous empty
      // ECC Signals inputs: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR), // 1-bit input: Inject a single bit error
      // Read Control Signals inputs: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Output register clock enable
      .RSTREG(RSTREG),               // 1-bit input: Output register reset
      .SLEEP(SLEEP),                 // 1-bit input: Sleep Mode
      // Write Control Signals inputs: Write clock and enable input signals
      .RST(RST),                     // 1-bit input: Reset
      .WRCLK(WRCLK),                 // 1-bit input: Write clock
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data inputs: Write input data
      .DIN(DIN),                     // 64-bit input: FIFO data input bus
      .DINP(DINP)                    // 8-bit input: FIFO parity input bus
   );

   // End of FIFO36E2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="URAM" treetype="folder">
					<Template label="288K-bit High-Density Base Memory Building Block (URAM288_BASE)" treetype="template">
// URAM288_BASE : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (URAM288_BASE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // URAM288_BASE: 288K-bit High-Density Base Memory Building Block
   //               Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   URAM288_BASE #(
      .AUTO_SLEEP_LATENCY(8),            // Latency requirement to enter sleep mode
      .AVG_CONS_INACTIVE_CYCLES(10),     // Average concecutive inactive cycles when is SLEEP mode for power
                                         // estimation
      .BWE_MODE_A("PARITY_INTERLEAVED"), // Port A Byte write control
      .BWE_MODE_B("PARITY_INTERLEAVED"), // Port B Byte write control
      .EN_AUTO_SLEEP_MODE("FALSE"),      // Enable to automatically enter sleep mode
      .EN_ECC_RD_A("FALSE"),             // Port A ECC encoder
      .EN_ECC_RD_B("FALSE"),             // Port B ECC encoder
      .EN_ECC_WR_A("FALSE"),             // Port A ECC decoder
      .EN_ECC_WR_B("FALSE"),             // Port B ECC decoder
      .IREG_PRE_A("FALSE"),              // Optional Port A input pipeline registers
      .IREG_PRE_B("FALSE"),              // Optional Port B input pipeline registers
      .IS_CLK_INVERTED(1'b0),            // Optional inverter for CLK
      .IS_EN_A_INVERTED(1'b0),           // Optional inverter for Port A enable
      .IS_EN_B_INVERTED(1'b0),           // Optional inverter for Port B enable
      .IS_RDB_WR_A_INVERTED(1'b0),       // Optional inverter for Port A read/write select
      .IS_RDB_WR_B_INVERTED(1'b0),       // Optional inverter for Port B read/write select
      .IS_RST_A_INVERTED(1'b0),          // Optional inverter for Port A reset
      .IS_RST_B_INVERTED(1'b0),          // Optional inverter for Port B reset
      .MATRIX_ID("NONE"),
      .NUM_UNIQUE_SELF_ADDR_A(1),
      .NUM_UNIQUE_SELF_ADDR_B(1),
      .NUM_URAM_IN_MATRIX(1),
      .OREG_A("FALSE"),                  // Optional Port A output pipeline registers
      .OREG_B("FALSE"),                  // Optional Port B output pipeline registers
      .OREG_ECC_A("FALSE"),              // Port A ECC decoder output
      .OREG_ECC_B("FALSE"),              // Port B output ECC decoder
      .RST_MODE_A("SYNC"),               // Port A reset mode
      .RST_MODE_B("SYNC"),               // Port B reset mode
      .USE_EXT_CE_A("FALSE"),            // Enable Port A external CE inputs for output registers
      .USE_EXT_CE_B("FALSE")             // Enable Port B external CE inputs for output registers
   )
   URAM288_BASE_inst (
      .DBITERR_A(DBITERR_A),               // 1-bit output: Port A double-bit error flag status
      .DBITERR_B(DBITERR_B),               // 1-bit output: Port B double-bit error flag status
      .DOUT_A(DOUT_A),                     // 72-bit output: Port A read data output
      .DOUT_B(DOUT_B),                     // 72-bit output: Port B read data output
      .SBITERR_A(SBITERR_A),               // 1-bit output: Port A single-bit error flag status
      .SBITERR_B(SBITERR_B),               // 1-bit output: Port B single-bit error flag status
      .ADDR_A(ADDR_A),                     // 23-bit input: Port A address
      .ADDR_B(ADDR_B),                     // 23-bit input: Port B address
      .BWE_A(BWE_A),                       // 9-bit input: Port A Byte-write enable
      .BWE_B(BWE_B),                       // 9-bit input: Port B Byte-write enable
      .CLK(CLK),                           // 1-bit input: Clock source
      .DIN_A(DIN_A),                       // 72-bit input: Port A write data input
      .DIN_B(DIN_B),                       // 72-bit input: Port B write data input
      .EN_A(EN_A),                         // 1-bit input: Port A enable
      .EN_B(EN_B),                         // 1-bit input: Port B enable
      .INJECT_DBITERR_A(INJECT_DBITERR_A), // 1-bit input: Port A double-bit error injection
      .INJECT_DBITERR_B(INJECT_DBITERR_B), // 1-bit input: Port B double-bit error injection
      .INJECT_SBITERR_A(INJECT_SBITERR_A), // 1-bit input: Port A single-bit error injection
      .INJECT_SBITERR_B(INJECT_SBITERR_B), // 1-bit input: Port B single-bit error injection
      .OREG_CE_A(OREG_CE_A),               // 1-bit input: Port A output register clock enable
      .OREG_CE_B(OREG_CE_B),               // 1-bit input: Port B output register clock enable
      .OREG_ECC_CE_A(OREG_ECC_CE_A),       // 1-bit input: Port A ECC decoder output register clock enable
      .OREG_ECC_CE_B(OREG_ECC_CE_B),       // 1-bit input: Port B ECC decoder output register clock enable
      .RDB_WR_A(RDB_WR_A),                 // 1-bit input: Port A read/write select
      .RDB_WR_B(RDB_WR_B),                 // 1-bit input: Port B read/write select
      .RST_A(RST_A),                       // 1-bit input: Port A asynchronous or synchronous reset for output
                                           // registers

      .RST_B(RST_B),                       // 1-bit input: Port B asynchronous or synchronous reset for output
                                           // registers

      .SLEEP(SLEEP)                        // 1-bit input: Dynamic power gating control
   );

   // End of URAM288_BASE_inst instantiation
					</Template>
					<Template label="288K-bit High-Density Memory Building Block (URAM288)" treetype="template">
//   URAM288   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (URAM288_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // URAM288: 288K-bit High-Density Memory Building Block
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   URAM288 #(
      .AUTO_SLEEP_LATENCY(8),            // Latency requirement to enter sleep mode
      .AVG_CONS_INACTIVE_CYCLES(10),     // Average concecutive inactive cycles when is SLEEP mode for power
                                         // estimation
      .BWE_MODE_A("PARITY_INTERLEAVED"), // Port A Byte write control
      .BWE_MODE_B("PARITY_INTERLEAVED"), // Port B Byte write control
      .CASCADE_ORDER_A("NONE"),          // Port A position in cascade chain
      .CASCADE_ORDER_B("NONE"),          // Port B position in cascade chain
      .EN_AUTO_SLEEP_MODE("FALSE"),      // Enable to automatically enter sleep mode
      .EN_ECC_RD_A("FALSE"),             // Port A ECC encoder
      .EN_ECC_RD_B("FALSE"),             // Port B ECC encoder
      .EN_ECC_WR_A("FALSE"),             // Port A ECC decoder
      .EN_ECC_WR_B("FALSE"),             // Port B ECC decoder
      .IREG_PRE_A("FALSE"),              // Optional Port A input pipeline registers
      .IREG_PRE_B("FALSE"),              // Optional Port B input pipeline registers
      .IS_CLK_INVERTED(1'b0),            // Optional inverter for CLK
      .IS_EN_A_INVERTED(1'b0),           // Optional inverter for Port A enable
      .IS_EN_B_INVERTED(1'b0),           // Optional inverter for Port B enable
      .IS_RDB_WR_A_INVERTED(1'b0),       // Optional inverter for Port A read/write select
      .IS_RDB_WR_B_INVERTED(1'b0),       // Optional inverter for Port B read/write select
      .IS_RST_A_INVERTED(1'b0),          // Optional inverter for Port A reset
      .IS_RST_B_INVERTED(1'b0),          // Optional inverter for Port B reset
      .MATRIX_ID("NONE"),                // Custom label to set a matrix ID name used by the power reporting
                                         // tools to tag all of the UltraRAM blocks that belong to a cascade
                                         // chain or matrix.
      .NUM_UNIQUE_SELF_ADDR_A(1),        // The number of unique SELF_ADDR_A UltraRAM blocks in a cascade chain
                                         // or matrix.
      .NUM_UNIQUE_SELF_ADDR_B(1),        // The number of unique SELF_ADDR_B UltraRAM blocks in a cascade chain
                                         // or matrix.
      .NUM_URAM_IN_MATRIX(1),            // Defines the cascade/matrix size (the number of UltraRAMs in a
                                         // matrix).
      .OREG_A("FALSE"),                  // Optional Port A output pipeline registers
      .OREG_B("FALSE"),                  // Optional Port B output pipeline registers
      .OREG_ECC_A("FALSE"),              // Port A ECC decoder output
      .OREG_ECC_B("FALSE"),              // Port B output ECC decoder
      .REG_CAS_A("FALSE"),               // Optional Port A cascade register
      .REG_CAS_B("FALSE"),               // Optional Port B cascade register
      .RST_MODE_A("SYNC"),               // Port A reset mode
      .RST_MODE_B("SYNC"),               // Port B reset mode
      .SELF_ADDR_A(11'h000),             // Port A self-address value
      .SELF_ADDR_B(11'h000),             // Port B self-address value
      .SELF_MASK_A(11'h7ff),             // Port A self-address mask
      .SELF_MASK_B(11'h7ff),             // Port B self-address mask
      .USE_EXT_CE_A("FALSE"),            // Enable Port A external CE inputs for output registers
      .USE_EXT_CE_B("FALSE")             // Enable Port B external CE inputs for output registers
   )
   URAM288_inst (
      .CAS_OUT_ADDR_A(CAS_OUT_ADDR_A),         // 23-bit output: Port A cascade output address
      .CAS_OUT_ADDR_B(CAS_OUT_ADDR_B),         // 23-bit output: Port B cascade output address
      .CAS_OUT_BWE_A(CAS_OUT_BWE_A),           // 9-bit output: Port A cascade Byte-write enable output
      .CAS_OUT_BWE_B(CAS_OUT_BWE_B),           // 9-bit output: Port B cascade Byte-write enable output
      .CAS_OUT_DBITERR_A(CAS_OUT_DBITERR_A),   // 1-bit output: Port A cascade double-bit error flag output
      .CAS_OUT_DBITERR_B(CAS_OUT_DBITERR_B),   // 1-bit output: Port B cascade double-bit error flag output
      .CAS_OUT_DIN_A(CAS_OUT_DIN_A),           // 72-bit output: Port A cascade output write mode data
      .CAS_OUT_DIN_B(CAS_OUT_DIN_B),           // 72-bit output: Port B cascade output write mode data
      .CAS_OUT_DOUT_A(CAS_OUT_DOUT_A),         // 72-bit output: Port A cascade output read mode data
      .CAS_OUT_DOUT_B(CAS_OUT_DOUT_B),         // 72-bit output: Port B cascade output read mode data
      .CAS_OUT_EN_A(CAS_OUT_EN_A),             // 1-bit output: Port A cascade output enable
      .CAS_OUT_EN_B(CAS_OUT_EN_B),             // 1-bit output: Port B cascade output enable
      .CAS_OUT_RDACCESS_A(CAS_OUT_RDACCESS_A), // 1-bit output: Port A cascade read status output
      .CAS_OUT_RDACCESS_B(CAS_OUT_RDACCESS_B), // 1-bit output: Port B cascade read status output
      .CAS_OUT_RDB_WR_A(CAS_OUT_RDB_WR_A),     // 1-bit output: Port A cascade read/write select output
      .CAS_OUT_RDB_WR_B(CAS_OUT_RDB_WR_B),     // 1-bit output: Port B cascade read/write select output
      .CAS_OUT_SBITERR_A(CAS_OUT_SBITERR_A),   // 1-bit output: Port A cascade single-bit error flag output
      .CAS_OUT_SBITERR_B(CAS_OUT_SBITERR_B),   // 1-bit output: Port B cascade single-bit error flag output
      .DBITERR_A(DBITERR_A),                   // 1-bit output: Port A double-bit error flag status
      .DBITERR_B(DBITERR_B),                   // 1-bit output: Port B double-bit error flag status
      .DOUT_A(DOUT_A),                         // 72-bit output: Port A read data output
      .DOUT_B(DOUT_B),                         // 72-bit output: Port B read data output
      .RDACCESS_A(RDACCESS_A),                 // 1-bit output: Port A read status
      .RDACCESS_B(RDACCESS_B),                 // 1-bit output: Port B read status
      .SBITERR_A(SBITERR_A),                   // 1-bit output: Port A single-bit error flag status
      .SBITERR_B(SBITERR_B),                   // 1-bit output: Port B single-bit error flag status
      .ADDR_A(ADDR_A),                         // 23-bit input: Port A address
      .ADDR_B(ADDR_B),                         // 23-bit input: Port B address
      .BWE_A(BWE_A),                           // 9-bit input: Port A Byte-write enable
      .BWE_B(BWE_B),                           // 9-bit input: Port B Byte-write enable
      .CAS_IN_ADDR_A(CAS_IN_ADDR_A),           // 23-bit input: Port A cascade input address
      .CAS_IN_ADDR_B(CAS_IN_ADDR_B),           // 23-bit input: Port B cascade input address
      .CAS_IN_BWE_A(CAS_IN_BWE_A),             // 9-bit input: Port A cascade Byte-write enable input
      .CAS_IN_BWE_B(CAS_IN_BWE_B),             // 9-bit input: Port B cascade Byte-write enable input
      .CAS_IN_DBITERR_A(CAS_IN_DBITERR_A),     // 1-bit input: Port A cascade double-bit error flag input
      .CAS_IN_DBITERR_B(CAS_IN_DBITERR_B),     // 1-bit input: Port B cascade double-bit error flag input
      .CAS_IN_DIN_A(CAS_IN_DIN_A),             // 72-bit input: Port A cascade input write mode data
      .CAS_IN_DIN_B(CAS_IN_DIN_B),             // 72-bit input: Port B cascade input write mode data
      .CAS_IN_DOUT_A(CAS_IN_DOUT_A),           // 72-bit input: Port A cascade input read mode data
      .CAS_IN_DOUT_B(CAS_IN_DOUT_B),           // 72-bit input: Port B cascade input read mode data
      .CAS_IN_EN_A(CAS_IN_EN_A),               // 1-bit input: Port A cascade enable input
      .CAS_IN_EN_B(CAS_IN_EN_B),               // 1-bit input: Port B cascade enable input
      .CAS_IN_RDACCESS_A(CAS_IN_RDACCESS_A),   // 1-bit input: Port A cascade read status input
      .CAS_IN_RDACCESS_B(CAS_IN_RDACCESS_B),   // 1-bit input: Port B cascade read status input
      .CAS_IN_RDB_WR_A(CAS_IN_RDB_WR_A),       // 1-bit input: Port A cascade read/write select input
      .CAS_IN_RDB_WR_B(CAS_IN_RDB_WR_B),       // 1-bit input: Port A cascade read/write select input
      .CAS_IN_SBITERR_A(CAS_IN_SBITERR_A),     // 1-bit input: Port A cascade single-bit error flag input
      .CAS_IN_SBITERR_B(CAS_IN_SBITERR_B),     // 1-bit input: Port B cascade single-bit error flag input
      .CLK(CLK),                               // 1-bit input: Clock source
      .DIN_A(DIN_A),                           // 72-bit input: Port A write data input
      .DIN_B(DIN_B),                           // 72-bit input: Port B write data input
      .EN_A(EN_A),                             // 1-bit input: Port A enable
      .EN_B(EN_B),                             // 1-bit input: Port B enable
      .INJECT_DBITERR_A(INJECT_DBITERR_A),     // 1-bit input: Port A double-bit error injection
      .INJECT_DBITERR_B(INJECT_DBITERR_B),     // 1-bit input: Port B double-bit error injection
      .INJECT_SBITERR_A(INJECT_SBITERR_A),     // 1-bit input: Port A single-bit error injection
      .INJECT_SBITERR_B(INJECT_SBITERR_B),     // 1-bit input: Port B single-bit error injection
      .OREG_CE_A(OREG_CE_A),                   // 1-bit input: Port A output register clock enable
      .OREG_CE_B(OREG_CE_B),                   // 1-bit input: Port B output register clock enable
      .OREG_ECC_CE_A(OREG_ECC_CE_A),           // 1-bit input: Port A ECC decoder output register clock enable
      .OREG_ECC_CE_B(OREG_ECC_CE_B),           // 1-bit input: Port B ECC decoder output register clock enable
      .RDB_WR_A(RDB_WR_A),                     // 1-bit input: Port A read/write select
      .RDB_WR_B(RDB_WR_B),                     // 1-bit input: Port B read/write select
      .RST_A(RST_A),                           // 1-bit input: Port A asynchronous or synchronous reset for
                                               // output registers

      .RST_B(RST_B),                           // 1-bit input: Port B asynchronous or synchronous reset for
                                               // output registers

      .SLEEP(SLEEP)                            // 1-bit input: Dynamic power gating control
   );

   // End of URAM288_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLB" treetype="folder">
				<SubFolder label="CARRY" treetype="folder">
					<Template label="Fast Carry Logic with Look Ahead (CARRY8)" treetype="template">
//   CARRY8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CARRY8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CARRY8: Fast Carry Logic with Look Ahead
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   CARRY8 #(
      .CARRY_TYPE("SINGLE_CY8")  // 8-bit or dual 4-bit carry (DUAL_CY4, SINGLE_CY8)
   )
   CARRY8_inst (
      .CO(CO),         // 8-bit output: Carry-out
      .O(O),           // 8-bit output: Carry chain XOR data out
      .CI(CI),         // 1-bit input: Lower Carry-In
      .CI_TOP(CI_TOP), // 1-bit input: Upper Carry-In
      .DI(DI),         // 8-bit input: Carry-MUX data in
      .S(S)            // 8-bit input: Carry-mux select
   );

   // End of CARRY8_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Two input AND gate implemented in place of a CLB Latch (AND2B1L)" treetype="template">
//   AND2B1L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (AND2B1L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // AND2B1L: Two input AND gate implemented in place of a CLB Latch
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   AND2B1L #(
      .IS_SRI_INVERTED(1'b0)  // Optional inversion for SRI
   )
   AND2B1L_inst (
      .O(O),     // 1-bit output: AND gate output
      .DI(DI),   // 1-bit input: Data input connected to LUT logic
      .SRI(SRI)  // 1-bit input: External CLB data
   );

   // End of AND2B1L_inst instantiation
					</Template>
					<Template label="Two input OR gate implemented in place of a CLB Latch (OR2L)" treetype="template">
//    OR2L     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OR2L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OR2L: Two input OR gate implemented in place of a CLB Latch
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OR2L #(
      .IS_SRI_INVERTED(1'b0)  // Optional inversion for SRI
   )
   OR2L_inst (
      .O(O),     // 1-bit output: OR gate output
      .DI(DI),   // 1-bit input: Data input connected to LUT logic
      .SRI(SRI)  // 1-bit input: External CLB data
   );

   // End of OR2L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUT" treetype="folder">
					<Template label="1-Bit Look-Up Table (LUT1)" treetype="template">
//    LUT1     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1: 1-Bit Look-Up Table
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT1 #(
      .INIT(2'h0)  // Logic function
   )
   LUT1_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0)  // 1-bit input: LUT
   );

   // End of LUT1_inst instantiation
					</Template>
					<Template label="2-Bit Look-Up Table (LUT2)" treetype="template">
//    LUT2     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2: 2-Bit Look-Up Table
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT2 #(
      .INIT(4'h0)  // Logic function
   )
   LUT2_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1)  // 1-bit input: LUT
   );

   // End of LUT2_inst instantiation
					</Template>
					<Template label="3-Bit Look-Up Table (LUT3)" treetype="template">
//    LUT3     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3: 3-Bit Look-Up Table
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT3 #(
      .INIT(8'h00)  // Logic function
   )
   LUT3_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2)  // 1-bit input: LUT
   );

   // End of LUT3_inst instantiation
					</Template>
					<Template label="4-Bit Look-Up Table (LUT4)" treetype="template">
//    LUT4     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4: 4-Bit Look-Up Table
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT(16'h0000)  // Logic function
   )
   LUT4_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3)  // 1-bit input: LUT
   );

   // End of LUT4_inst instantiation
					</Template>
					<Template label="5-Bit Look-Up Table (LUT5)" treetype="template">
//    LUT5     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5: 5-Bit Look-Up Table
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT5 #(
      .INIT(32'h00000000)  // Logic function
   )
   LUT5_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3), // 1-bit input: LUT
      .I4(I4)  // 1-bit input: LUT
   );

   // End of LUT5_inst instantiation
					</Template>
					<Template label="5-input Dynamically Reconfigurable Look-Up Table (LUT) (CFGLUT5)" treetype="template">
//   CFGLUT5   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CFGLUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CFGLUT5: 5-input Dynamically Reconfigurable Look-Up Table (LUT)
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   CFGLUT5 #(
      .INIT(32'h00000000),    // Initial logic function
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   CFGLUT5_inst (
      .CDO(CDO), // 1-bit output: Reconfiguration cascade
      .O5(O5),   // 1-bit output: 4-LUT
      .O6(O6),   // 1-bit output: 5-LUT
      .CDI(CDI), // 1-bit input: Reconfiguration data
      .CE(CE),   // 1-bit input: Reconfiguration enable
      .CLK(CLK), // 1-bit input: Clock
      // LUT Inputs inputs: Logic inputs
      .I0(I0),
      .I1(I1),
      .I2(I2),
      .I3(I3),
      .I4(I4) 
   );

   // End of CFGLUT5_inst instantiation
					</Template>
					<Template label="6-Bit Look-Up Table (LUT6)" treetype="template">
//    LUT6     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6: 6-Bit Look-Up Table
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LUT6 #(
      .INIT(64'h0000000000000000)  // Logic function
   )
   LUT6_inst (
      .O(O),   // 1-bit output: LUT
      .I0(I0), // 1-bit input: LUT
      .I1(I1), // 1-bit input: LUT
      .I2(I2), // 1-bit input: LUT
      .I3(I3), // 1-bit input: LUT
      .I4(I4), // 1-bit input: LUT
      .I5(I5)  // 1-bit input: LUT
   );

   // End of LUT6_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LUTRAM" treetype="folder">
					<Template label="64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM) (RAM64X8SW)" treetype="template">
//  RAM64X8SW  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X8SW_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X8SW: 64-Deep by 8-bit Wide Random Access Memory with Single-Bit Write (Select RAM)
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RAM64X8SW #(
      .INIT_A(64'h0000000000000000), // Initial contents of the RAM for Bit 7
      .INIT_B(64'h0000000000000000), // Initial contents of the RAM for Bit 6
      .INIT_C(64'h0000000000000000), // Initial contents of the RAM for Bit 5
      .INIT_D(64'h0000000000000000), // Initial contents of the RAM for Bit 4
      .INIT_E(64'h0000000000000000), // Initial contents of the RAM for Bit 3
      .INIT_F(64'h0000000000000000), // Initial contents of the RAM for Bit 2
      .INIT_G(64'h0000000000000000), // Initial contents of the RAM for Bit 1
      .INIT_H(64'h0000000000000000), // Initial contents of the RAM for Bit 0
      .IS_WCLK_INVERTED(1'b0)        // Optional inversion for WCLK
   )
   RAM64X8SW_inst (
      .O(O),       // 8-bit data output
      .A(A),       // 6-bit address input
      .D(D),       // 1-bit input: Write data input
      .WCLK(WCLK), // 1-bit input: Write clock input
      .WE(WE),     // 1-bit input: Write enable input
      .WSEL(WSEL)  // 3-bit write select
   );

   // End of RAM64X8SW_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUXF" treetype="folder">
					<Template label="CLB MUX to connect two LUT6's Together (MUXF7)" treetype="template">
//    MUXF7    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7: CLB MUX to connect two LUT6's Together
   //        Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MUXF7 MUXF7_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to LUT6 output
      .I1(I1), // 1-bit input: Connect to LUT6 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF7_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF7's Together (MUXF8)" treetype="template">
//    MUXF8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8: CLB MUX to connect two MUXF7's Together
   //        Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MUXF8 MUXF8_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to MUXF7 output
      .I1(I1), // 1-bit input: Connect to MUXF7 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF8_inst instantiation
					</Template>
					<Template label="CLB MUX to connect two MUXF8's Together (MUXF9)" treetype="template">
//    MUXF9    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF9_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF9: CLB MUX to connect two MUXF8's Together
   //        Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MUXF9 MUXF9_inst (
      .O(O),   // 1-bit output: Output of MUX
      .I0(I0), // 1-bit input: Connect to MUXF8 output
      .I1(I1), // 1-bit input: Connect to MUXF8 output
      .S(S)    // 1-bit input: Input select to MUX
   );

   // End of MUXF9_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="16-Bit Shift Register Look-Up Table (LUT) (SRL16E)" treetype="template">
//   SRL16E    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL16E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRL16E: 16-Bit Shift Register Look-Up Table (LUT)
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   SRL16E #(
      .INIT(16'h0000),        // Initial contents of shift register
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   SRL16E_inst (
      .Q(Q),     // 1-bit output: SRL Data
      .CE(CE),   // 1-bit input: Clock enable
      .CLK(CLK), // 1-bit input: Clock
      .D(D),     // 1-bit input: SRL Data
      // Depth Selection inputs: A0-A3 select SRL depth
      .A0(A0),
      .A1(A1),
      .A2(A2),
      .A3(A3) 
   );

   // End of SRL16E_inst instantiation
					</Template>
					<Template label="32-Bit Shift Register Look-Up Table (LUT) (SRLC32E)" treetype="template">
//   SRLC32E   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRLC32E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRLC32E: 32-Bit Shift Register Look-Up Table (LUT)
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   SRLC32E #(
      .INIT(32'h00000000),    // Initial contents of shift register
      .IS_CLK_INVERTED(1'b0)  // Optional inversion for CLK
   )
   SRLC32E_inst (
      .Q(Q),     // 1-bit output: SRL Data
      .Q31(Q31), // 1-bit output: SRL Cascade Data
      .A(A),     // 5-bit input: Selects SRL depth
      .CE(CE),   // 1-bit input: Clock enable
      .CLK(CLK), // 1-bit input: Clock
      .D(D)      // 1-bit input: SRL Data
   );

   // End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CLOCK" treetype="folder">
				<SubFolder label="BUFFER" treetype="folder">
					<Template label="A high-fanout buffer for low-skew distribution of the PS Clock signals (BUFG_PS)" treetype="template">
//   BUFG_PS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_PS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_PS: A high-fanout buffer for low-skew distribution of the PS Clock signals
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFG_PS BUFG_PS_inst (
      .O(O), // 1-bit output: Clock buffer output
      .I(I)  // 1-bit input: Clock buffer input
   );

   // End of BUFG_PS_inst instantiation
					</Template>
					<Template label="Clock Buffer Driven by Gigabit Transceiver (BUFG_GT)" treetype="template">
//   BUFG_GT   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_GT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_GT: Clock Buffer Driven by Gigabit Transceiver
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFG_GT BUFG_GT_inst (
      .O(O),             // 1-bit output: Buffer
      .CE(CE),           // 1-bit input: Buffer enable
      .CEMASK(CEMASK),   // 1-bit input: CE Mask
      .CLR(CLR),         // 1-bit input: Asynchronous clear
      .CLRMASK(CLRMASK), // 1-bit input: CLR Mask
      .DIV(DIV),         // 3-bit input: Dynamic divide Value
      .I(I)              // 1-bit input: Buffer
   );

   // End of BUFG_GT_inst instantiation
					</Template>
					<Template label="General Clock Buffer (BUFG)" treetype="template">
//    BUFG     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG: General Clock Buffer
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFG BUFG_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFG_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
//   BUFGCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE: General Clock Buffer with Clock Enable
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE #(
      .CE_TYPE("SYNC"),      // ASYNC, SYNC
      .IS_CE_INVERTED(1'b0), // Programmable inversion on CE
      .IS_I_INVERTED(1'b0)   // Programmable inversion on I
   )
   BUFGCE_inst (
      .O(O),   // 1-bit output: Buffer
      .CE(CE), // 1-bit input: Buffer enable
      .I(I)    // 1-bit input: Buffer
   );

   // End of BUFGCE_inst instantiation
					</Template>
					<Template label="General Clock Buffer with Divide (BUFGCE_DIV)" treetype="template">
// BUFGCE_DIV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_DIV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_DIV: General Clock Buffer with Divide Function
   //             Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_DIV #(
      .BUFGCE_DIVIDE(1),      // 1-8
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CE_INVERTED(1'b0),  // Optional inversion for CE
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_I_INVERTED(1'b0)    // Optional inversion for I
   )
   BUFGCE_DIV_inst (
      .O(O),     // 1-bit output: Buffer
      .CE(CE),   // 1-bit input: Buffer enable
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .I(I)      // 1-bit input: Buffer
   );

   // End of BUFGCE_DIV_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
//  BUFGCE_1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_1: General Clock Buffer with Clock Enable and Output State 1
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_1 BUFGCE_1_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock buffer active-High enable
      .I(I)    // 1-bit input: Clock input
   );

   // End of BUFGCE_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="CLOCK_SYNC" treetype="folder">
					<Template label="Synchronizer for BUFG_GT Control Signals (BUFG_GT_SYNC)" treetype="template">
// BUFG_GT_SYNC : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFG_GT_SYNC_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG_GT_SYNC: Synchronizer for BUFG_GT Control Signals
   //               Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFG_GT_SYNC BUFG_GT_SYNC_inst (
      .CESYNC(CESYNC),   // 1-bit output: Synchronized CE
      .CLRSYNC(CLRSYNC), // 1-bit output: Synchronized CLR
      .CE(CE),           // 1-bit input: Asynchronous enable
      .CLK(CLK),         // 1-bit input: Clock
      .CLR(CLR)          // 1-bit input: Asynchronous clear
   );

   // End of BUFG_GT_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUX" treetype="folder">
					<Template label="2-to-1 General Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
// BUFGMUX_CTRL : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_CTRL: 2-to-1 General Clock MUX Buffer
   //               Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL BUFGMUX_CTRL_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="General Clock Control Buffer (BUFGCTRL)" treetype="template">
//  BUFGCTRL   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCTRL: General Clock Control Buffer
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGCTRL #(
      .INIT_OUT(0),               // Initial value of BUFGCTRL output, 0-1
      .PRESELECT_I0("FALSE"),     // BUFGCTRL output uses I0 input, FALSE, TRUE
      .PRESELECT_I1("FALSE"),     // BUFGCTRL output uses I1 input, FALSE, TRUE
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CE0_INVERTED(1'b0),     // Optional inversion for CE0
      .IS_CE1_INVERTED(1'b0),     // Optional inversion for CE1
      .IS_I0_INVERTED(1'b0),      // Optional inversion for I0
      .IS_I1_INVERTED(1'b0),      // Optional inversion for I1
      .IS_IGNORE0_INVERTED(1'b0), // Optional inversion for IGNORE0
      .IS_IGNORE1_INVERTED(1'b0), // Optional inversion for IGNORE1
      .IS_S0_INVERTED(1'b0),      // Optional inversion for S0
      .IS_S1_INVERTED(1'b0)       // Optional inversion for S1
   )
   BUFGCTRL_inst (
      .O(O),             // 1-bit output: Clock output
      .CE0(CE0),         // 1-bit input: Clock enable input for I0
      .CE1(CE1),         // 1-bit input: Clock enable input for I1
      .I0(I0),           // 1-bit input: Primary clock
      .I1(I1),           // 1-bit input: Secondary clock
      .IGNORE0(IGNORE0), // 1-bit input: Clock ignore input for I0
      .IGNORE1(IGNORE1), // 1-bit input: Clock ignore input for I1
      .S0(S0),           // 1-bit input: Clock select for I0
      .S1(S1)            // 1-bit input: Clock select for I1
   );

   // End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer (BUFGMUX)" treetype="template">
//   BUFGMUX   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX: General Clock Mux Buffer
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX #(
      .CLK_SEL_TYPE("SYNC")  // ASYNC, SYNC
   )
   BUFGMUX_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_inst instantiation
					</Template>
					<Template label="General Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
//  BUFGMUX_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_1: General Clock Mux Buffer with Output State 1
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1 #(
      .CLK_SEL_TYPE("SYNC")  // ASYNC, SYNC
   )
   BUFGMUX_1_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME3_ADV)" treetype="template">
// MMCME3_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME3_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME3_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   //             Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MMCME3_ADV #(
      .BANDWIDTH("OPTIMIZED"),        // Jitter programming (HIGH, LOW, OPTIMIZED)
      .CLKFBOUT_MULT_F(5.0),          // Multiply value for all CLKOUT (2.000-64.000)
      .CLKFBOUT_PHASE(0.0),           // Phase offset in degrees of CLKFB (-360.000-360.000)
      // CLKIN_PERIOD: Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      .CLKOUT0_DIVIDE_F(1.0),         // Divide amount for CLKOUT0 (1.000-128.000)
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      // CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_CASCADE("FALSE"),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .COMPENSATION("AUTO"),          // AUTO, BUF_IN, EXTERNAL, INTERNAL, ZHOLD
      .DIVCLK_DIVIDE(1),              // Master division value (1-106)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0),     // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),      // Optional inversion for CLKIN1
      .IS_CLKIN2_INVERTED(1'b0),      // Optional inversion for CLKIN2
      .IS_CLKINSEL_INVERTED(1'b0),    // Optional inversion for CLKINSEL
      .IS_PSEN_INVERTED(1'b0),        // Optional inversion for PSEN
      .IS_PSINCDEC_INVERTED(1'b0),    // Optional inversion for PSINCDEC
      .IS_PWRDWN_INVERTED(1'b0),      // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE"),         // Delays DONE until MMCM is locked (FALSE, TRUE)
      // Spread Spectrum: Spread Spectrum Attributes
      .SS_EN("FALSE"),                // Enables spread spectrum (FALSE, TRUE)
      .SS_MODE("CENTER_HIGH"),        // CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      .SS_MOD_PERIOD(10000),          // Spread spectrum modulation period (ns) (4000-40000)
      // USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      .CLKFBOUT_USE_FINE_PS("FALSE"),
      .CLKOUT0_USE_FINE_PS("FALSE"),
      .CLKOUT1_USE_FINE_PS("FALSE"),
      .CLKOUT2_USE_FINE_PS("FALSE"),
      .CLKOUT3_USE_FINE_PS("FALSE"),
      .CLKOUT4_USE_FINE_PS("FALSE"),
      .CLKOUT5_USE_FINE_PS("FALSE"),
      .CLKOUT6_USE_FINE_PS("FALSE") 
   )
   MMCME3_ADV_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),           // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),         // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),           // 1-bit output: Primary clock
      .CLKOUT1B(CLKOUT1B),         // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),           // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),         // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),           // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),         // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),           // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),           // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),           // 1-bit output: CLKOUT6
      // DRP Ports outputs: Dynamic reconfiguration ports
      .DO(DO),                     // 16-bit output: DRP data
      .DRDY(DRDY),                 // 1-bit output: DRP ready
      // Dynamic Phase Shift Ports outputs: Ports used for dynamic phase shifting of the outputs
      .PSDONE(PSDONE),             // 1-bit output: Phase shift done
      // Feedback outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),         // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB),       // 1-bit output: Inverted CLKFBOUT
      // Status Ports outputs: MMCM status ports
      .CDDCDONE(CDDCDONE),         // 1-bit output: Clock dynamic divide done
      .CLKFBSTOPPED(CLKFBSTOPPED), // 1-bit output: Feedback clock stopped
      .CLKINSTOPPED(CLKINSTOPPED), // 1-bit output: Input clock stopped
      .LOCKED(LOCKED),             // 1-bit output: LOCK
      .CDDCREQ(CDDCREQ),           // 1-bit input: Request to dynamic divide clock
      // Clock Inputs inputs: Clock inputs
      .CLKIN1(CLKIN1),             // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),             // 1-bit input: Secondary clock
      // Control Ports inputs: MMCM control ports
      .CLKINSEL(CLKINSEL),         // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),             // 1-bit input: Power-down
      .RST(RST),                   // 1-bit input: Reset
      // DRP Ports inputs: Dynamic reconfiguration ports
      .DADDR(DADDR),               // 7-bit input: DRP address
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable
      .DI(DI),                     // 16-bit input: DRP data
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // Dynamic Phase Shift Ports inputs: Ports used for dynamic phase shifting of the outputs
      .PSCLK(PSCLK),               // 1-bit input: Phase shift clock
      .PSEN(PSEN),                 // 1-bit input: Phase shift enable
      .PSINCDEC(PSINCDEC),         // 1-bit input: Phase shift increment/decrement
      // Feedback inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)            // 1-bit input: Feedback clock
   );

   // End of MMCME3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Mixed Mode Clock Manager (MMCM) (MMCME4_ADV)" treetype="template">
// MMCME4_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME4_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME4_ADV: Advanced Mixed Mode Clock Manager (MMCM)
   //             Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MMCME4_ADV #(
      .BANDWIDTH("OPTIMIZED"),        // Jitter programming
      .CLKFBOUT_MULT_F(5.0),          // Multiply value for all CLKOUT
      .CLKFBOUT_PHASE(0.0),           // Phase offset in degrees of CLKFB
      .CLKFBOUT_USE_FINE_PS("FALSE"), // Fine phase shift enable (TRUE/FALSE)
      .CLKIN1_PERIOD(0.0),            // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN2_PERIOD(0.0),            // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE_F(1.0),         // Divide amount for CLKOUT0
      .CLKOUT0_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT0
      .CLKOUT0_PHASE(0.0),            // Phase offset for CLKOUT0
      .CLKOUT0_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT1_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT1_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT1_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT2_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT2_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT2_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT2_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT3_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT3_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT3_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT3_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT4_CASCADE("FALSE"),      // Divide amount for CLKOUT (1-128)
      .CLKOUT4_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT4_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT4_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT4_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT5_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT5_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT5_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT5_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .CLKOUT6_DIVIDE(1),             // Divide amount for CLKOUT (1-128)
      .CLKOUT6_DUTY_CYCLE(0.5),       // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT6_PHASE(0.0),            // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT6_USE_FINE_PS("FALSE"),  // Fine phase shift enable (TRUE/FALSE)
      .COMPENSATION("AUTO"),          // Clock input compensation
      .DIVCLK_DIVIDE(1),              // Master division value
      .IS_CLKFBIN_INVERTED(1'b0),     // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),      // Optional inversion for CLKIN1
      .IS_CLKIN2_INVERTED(1'b0),      // Optional inversion for CLKIN2
      .IS_CLKINSEL_INVERTED(1'b0),    // Optional inversion for CLKINSEL
      .IS_PSEN_INVERTED(1'b0),        // Optional inversion for PSEN
      .IS_PSINCDEC_INVERTED(1'b0),    // Optional inversion for PSINCDEC
      .IS_PWRDWN_INVERTED(1'b0),      // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      .REF_JITTER1(0.0),              // Reference input jitter in UI (0.000-0.999).
      .REF_JITTER2(0.0),              // Reference input jitter in UI (0.000-0.999).
      .SS_EN("FALSE"),                // Enables spread spectrum
      .SS_MODE("CENTER_HIGH"),        // Spread spectrum frequency deviation and the spread type
      .SS_MOD_PERIOD(10000),          // Spread spectrum modulation period (ns)
      .STARTUP_WAIT("FALSE")          // Delays DONE until MMCM is locked
   )
   MMCME4_ADV_inst (
      .CDDCDONE(CDDCDONE),         // 1-bit output: Clock dynamic divide done
      .CLKFBOUT(CLKFBOUT),         // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB),       // 1-bit output: Inverted CLKFBOUT
      .CLKFBSTOPPED(CLKFBSTOPPED), // 1-bit output: Feedback clock stopped
      .CLKINSTOPPED(CLKINSTOPPED), // 1-bit output: Input clock stopped
      .CLKOUT0(CLKOUT0),           // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),         // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),           // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),         // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),           // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),         // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),           // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),         // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),           // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),           // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),           // 1-bit output: CLKOUT6
      .DO(DO),                     // 16-bit output: DRP data output
      .DRDY(DRDY),                 // 1-bit output: DRP ready
      .LOCKED(LOCKED),             // 1-bit output: LOCK
      .PSDONE(PSDONE),             // 1-bit output: Phase shift done
      .CDDCREQ(CDDCREQ),           // 1-bit input: Request to dynamic divide clock
      .CLKFBIN(CLKFBIN),           // 1-bit input: Feedback clock
      .CLKIN1(CLKIN1),             // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),             // 1-bit input: Secondary clock
      .CLKINSEL(CLKINSEL),         // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .DADDR(DADDR),               // 7-bit input: DRP address
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable
      .DI(DI),                     // 16-bit input: DRP data input
      .DWE(DWE),                   // 1-bit input: DRP write enable
      .PSCLK(PSCLK),               // 1-bit input: Phase shift clock
      .PSEN(PSEN),                 // 1-bit input: Phase shift enable
      .PSINCDEC(PSINCDEC),         // 1-bit input: Phase shift increment/decrement
      .PWRDWN(PWRDWN),             // 1-bit input: Power-down
      .RST(RST)                    // 1-bit input: Reset
   );

   // End of MMCME4_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE3_ADV)" treetype="template">
//  PLLE3_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE3_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE3_ADV: Advanced Phase-Locked Loop (PLL)
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PLLE3_ADV #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT, (1-19)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB, (-360.000-360.000)
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0 (1-128)
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0 (0.001-0.999)
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0 (-360.000-360.000)
      // CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1 (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1 (0.001-0.999)
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1 (-360.000-360.000)
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      .COMPENSATION("AUTO"),      // AUTO, BUF_IN, INTERNAL
      .DIVCLK_DIVIDE(1),          // Master division value, (1-15)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked (FALSE, TRUE)
   )
   PLLE3_ADV_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      // DRP Ports outputs: Dynamic reconfiguration ports
      .DO(DO),                   // 16-bit output: DRP data
      .DRDY(DRDY),               // 1-bit output: DRP ready
      // Feedback Clocks outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      // Control Ports inputs: PLL control ports
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST),                 // 1-bit input: Reset
      // DRP Ports inputs: Dynamic reconfiguration ports
      .DADDR(DADDR),             // 7-bit input: DRP address
      .DCLK(DCLK),               // 1-bit input: DRP clock
      .DEN(DEN),                 // 1-bit input: DRP enable
      .DI(DI),                   // 16-bit input: DRP data
      .DWE(DWE),                 // 1-bit input: DRP write enable
      // Feedback Clocks inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)          // 1-bit input: Feedback clock
   );

   // End of PLLE3_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE4_ADV)" treetype="template">
//  PLLE4_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE4_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE4_ADV: Advanced Phase-Locked Loop (PLL)
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PLLE4_ADV #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY
      .COMPENSATION("AUTO"),      // Clock input compensation
      .DIVCLK_DIVIDE(1),          // Master division value
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked
   )
   PLLE4_ADV_inst (
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      .DO(DO),                   // 16-bit output: DRP data output
      .DRDY(DRDY),               // 1-bit output: DRP ready
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKFBIN(CLKFBIN),         // 1-bit input: Feedback clock
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .DADDR(DADDR),             // 7-bit input: DRP address
      .DCLK(DCLK),               // 1-bit input: DRP clock
      .DEN(DEN),                 // 1-bit input: DRP enable
      .DI(DI),                   // 16-bit input: DRP data input
      .DWE(DWE),                 // 1-bit input: DRP write enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST)                  // 1-bit input: Reset
   );

   // End of PLLE4_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase-Locked Loop (PLL) (PLLE4_BASE)" treetype="template">
// PLLE4_BASE  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE4_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE4_BASE: Advanced Phase-Locked Loop (PLL)
   //             Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PLLE4_BASE #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY
      .DIVCLK_DIVIDE(1),          // Master division value
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked
   )
   PLLE4_BASE_inst (
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKFBIN(CLKFBIN),         // 1-bit input: Feedback clock
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST)                  // 1-bit input: Reset
   );

   // End of PLLE4_BASE_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME3_BASE)" treetype="template">
// MMCME3_BASE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME3_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME3_BASE: Base Mixed Mode Clock Manager (MMCM)
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MMCME3_BASE #(
      .BANDWIDTH("OPTIMIZED"),    // Jitter programming (HIGH, LOW, OPTIMIZED)
      .CLKFBOUT_MULT_F(5.0),      // Multiply value for all CLKOUT (2.000-64.000)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB (-360.000-360.000)
      .CLKIN1_PERIOD(0.0),        // Input clock period in ns units, ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE_F(1.0),     // Divide amount for CLKOUT0 (1.000-128.000)
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      // CLKOUT1_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT4_CASCADE("FALSE"),  // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .DIVCLK_DIVIDE(1),          // Master division value (1-106)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),  // Optional inversion for CLKIN1
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER1(0.0),          // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   MMCME3_BASE_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),     // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),     // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6
      // Feedback outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),   // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT
      // Status Ports outputs: MMCM status ports
      .LOCKED(LOCKED),       // 1-bit output: LOCK
      // Clock Inputs inputs: Clock input
      .CLKIN1(CLKIN1),       // 1-bit input: Clock
      // Control Ports inputs: MMCM control ports
      .PWRDWN(PWRDWN),       // 1-bit input: Power-down
      .RST(RST),             // 1-bit input: Reset
      // Feedback inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)      // 1-bit input: Feedback clock
   );

   // End of MMCME3_BASE_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCM) (MMCME4_BASE)" treetype="template">
// MMCME4_BASE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME4_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME4_BASE: Base Mixed Mode Clock Manager (MMCM)
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MMCME4_BASE #(
      .BANDWIDTH("OPTIMIZED"),    // Jitter programming
      .CLKFBOUT_MULT_F(5.0),      // Multiply value for all CLKOUT
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB
      .CLKIN1_PERIOD(0.0),        // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKOUT0_DIVIDE_F(1.0),     // Divide amount for CLKOUT0
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT2_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT2_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT2_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT3_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT3_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT3_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT4_CASCADE("FALSE"),  // Divide amount for CLKOUT (1-128)
      .CLKOUT4_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT4_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT4_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT5_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT5_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT5_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT6_DIVIDE(1),         // Divide amount for CLKOUT (1-128)
      .CLKOUT6_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT6_PHASE(0.0),        // Phase offset for CLKOUT outputs (-360.000-360.000).
      .DIVCLK_DIVIDE(1),          // Master division value
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN1_INVERTED(1'b0),  // Optional inversion for CLKIN1
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER1(0.0),          // Reference input jitter in UI (0.000-0.999).
      .STARTUP_WAIT("FALSE")      // Delays DONE until MMCM is locked
   )
   MMCME4_BASE_inst (
      .CLKFBOUT(CLKFBOUT),   // 1-bit output: Feedback clock pin to the MMCM
      .CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT
      .CLKOUT0(CLKOUT0),     // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),     // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6
      .LOCKED(LOCKED),       // 1-bit output: LOCK
      .CLKFBIN(CLKFBIN),     // 1-bit input: Feedback clock pin to the MMCM
      .CLKIN1(CLKIN1),       // 1-bit input: Primary clock
      .PWRDWN(PWRDWN),       // 1-bit input: Power-down
      .RST(RST)              // 1-bit input: Reset
   );

   // End of MMCME4_BASE_inst instantiation
					</Template>
					<Template label="Base Phase-Locked Loop (PLL) (PLLE3_BASE)" treetype="template">
// PLLE3_BASE  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE3_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE3_BASE: Base Phase-Locked Loop (PLL)
   //             Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PLLE3_BASE #(
      .CLKFBOUT_MULT(5),          // Multiply value for all CLKOUT, (1-19)
      .CLKFBOUT_PHASE(0.0),       // Phase offset in degrees of CLKFB, (-360.000-360.000)
      .CLKIN_PERIOD(0.0),         // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0 Attributes: Divide, Phase and Duty Cycle for the CLKOUT0 output
      .CLKOUT0_DIVIDE(1),         // Divide amount for CLKOUT0 (1-128)
      .CLKOUT0_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT0 (0.001-0.999)
      .CLKOUT0_PHASE(0.0),        // Phase offset for CLKOUT0 (-360.000-360.000)
      // CLKOUT1 Attributes: Divide, Phase and Duty Cycle for the CLKOUT1 output
      .CLKOUT1_DIVIDE(1),         // Divide amount for CLKOUT1 (1-128)
      .CLKOUT1_DUTY_CYCLE(0.5),   // Duty cycle for CLKOUT1 (0.001-0.999)
      .CLKOUT1_PHASE(0.0),        // Phase offset for CLKOUT1 (-360.000-360.000)
      .CLKOUTPHY_MODE("VCO_2X"),  // Frequency of the CLKOUTPHY (VCO, VCO_2X, VCO_HALF)
      .DIVCLK_DIVIDE(1),          // Master division value, (1-15)
      // Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
      .IS_CLKFBIN_INVERTED(1'b0), // Optional inversion for CLKFBIN
      .IS_CLKIN_INVERTED(1'b0),   // Optional inversion for CLKIN
      .IS_PWRDWN_INVERTED(1'b0),  // Optional inversion for PWRDWN
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .REF_JITTER(0.0),           // Reference input jitter in UI (0.000-0.999)
      .STARTUP_WAIT("FALSE")      // Delays DONE until PLL is locked (FALSE, TRUE)
   )
   PLLE3_BASE_inst (
      // Clock Outputs outputs: User configurable clock outputs
      .CLKOUT0(CLKOUT0),         // 1-bit output: General Clock output
      .CLKOUT0B(CLKOUT0B),       // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),         // 1-bit output: General Clock output
      .CLKOUT1B(CLKOUT1B),       // 1-bit output: Inverted CLKOUT1
      .CLKOUTPHY(CLKOUTPHY),     // 1-bit output: Bitslice clock
      // Feedback Clocks outputs: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),       // 1-bit output: Feedback clock
      .LOCKED(LOCKED),           // 1-bit output: LOCK
      .CLKIN(CLKIN),             // 1-bit input: Input clock
      // Control Ports inputs: PLL control ports
      .CLKOUTPHYEN(CLKOUTPHYEN), // 1-bit input: CLKOUTPHY enable
      .PWRDWN(PWRDWN),           // 1-bit input: Power-down
      .RST(RST),                 // 1-bit input: Reset
      // Feedback Clocks inputs: Clock feedback ports
      .CLKFBIN(CLKFBIN)          // 1-bit input: Feedback clock
   );

   // End of PLLE3_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="CONFIGURATION" treetype="folder">
				<SubFolder label="BSCAN" treetype="folder">
					<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
//   BSCANE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BSCANE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BSCANE2: Boundary-Scan User Instruction
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BSCANE2 #(
      .JTAG_CHAIN(1)  // Value for USER command
   )
   BSCANE2_inst (
      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.
      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                         // SHIFT are asserted.

      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.
      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      .SEL(SEL),         // 1-bit output: USER instruction active output.
      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.
      .TCK(TCK),         // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.
      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.
      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller
      .TDO(TDO)          // 1-bit input: Test Data Output (TDO) input for USER function.
   );

   // End of BSCANE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DNA" treetype="folder">
					<Template label="Device DNA Access Port (DNA_PORTE2)" treetype="template">
// DNA_PORTE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DNA_PORTE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DNA_PORTE2: Device DNA Access Port
   //             Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   DNA_PORTE2 #(
      .SIM_DNA_VALUE(96'h000000000000000000000000)  // Specifies a sample 96-bit DNA value for simulation
   )
   DNA_PORTE2_inst (
      .DOUT(DOUT),   // 1-bit output: DNA output data
      .CLK(CLK),     // 1-bit input: Clock input
      .DIN(DIN),     // 1-bit input: User data input pin
      .READ(READ),   // 1-bit input: Active-High load DNA, active-Low read input
      .SHIFT(SHIFT)  // 1-bit input: Active-High shift enable input
   );

   // End of DNA_PORTE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="EFUSE" treetype="folder">
					<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
//  EFUSE_USR  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (EFUSE_USR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EFUSE_USR: 32-bit non-volatile design ID
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   EFUSE_USR #(
      .SIM_EFUSE_VALUE(32'h00000000)  // Value of the 32-bit non-volatile value used in simulation
   )
   EFUSE_USR_inst (
      .EFUSEUSR(EFUSEUSR)  // 32-bit output: User eFUSE register value output
   );

   // End of EFUSE_USR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="ICAP" treetype="folder">
					<Template label="Internal Configuration Access Port (ICAPE3)" treetype="template">
//   ICAPE3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ICAPE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ICAPE3: Internal Configuration Access Port
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   ICAPE3 #(
      .DEVICE_ID(32'h03628093),     // Specifies the pre-programmed Device ID value to be used for simulation
                                    // purposes.
      .ICAP_AUTO_SWITCH("DISABLE"), // Enable switch ICAP using sync word
      .SIM_CFG_FILE_NAME("NONE")    // Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                    // model
   )
   ICAPE3_inst (
      .AVAIL(AVAIL),     // 1-bit output: Availability status of ICAP
      .O(O),             // 32-bit output: Configuration data output bus
      .PRDONE(PRDONE),   // 1-bit output: Indicates completion of Partial Reconfiguration
      .PRERROR(PRERROR), // 1-bit output: Indicates Error during Partial Reconfiguration
      .CLK(CLK),         // 1-bit input: Clock input
      .CSIB(CSIB),       // 1-bit input: Active-Low ICAP enable
      .I(I),             // 32-bit input: Configuration data input bus
      .RDWRB(RDWRB)      // 1-bit input: Read/Write Select input
   );

   // End of ICAPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MASTER_JTAG" treetype="folder">
					<Template label="JTAG Port Access (MASTER_JTAG)" treetype="template">
// MASTER_JTAG : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MASTER_JTAG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MASTER_JTAG: JTAG Port Access
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   MASTER_JTAG MASTER_JTAG_inst (
      .TDO(TDO), // 1-bit output: JTAG TDO output pin
      .TCK(TCK), // 1-bit input: JTAG TCK input pin
      .TDI(TDI), // 1-bit input: JTAG TDI input pin
      .TMS(TMS)  // 1-bit input: JTAG TMS input pin
   );

   // End of MASTER_JTAG_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="STARTUP" treetype="folder">
					<Template label="STARTUP Block (STARTUPE3)" treetype="template">
//  STARTUPE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (STARTUPE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // STARTUPE3: STARTUP Block
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   STARTUPE3 #(
      .PROG_USR("FALSE"),  // Activate program event security feature. Requires encrypted bitstreams.
      .SIM_CCLK_FREQ(0.0)  // Set the Configuration Clock Frequency (ns) for simulation
   )
   STARTUPE3_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration main clock output
      .CFGMCLK(CFGMCLK),     // 1-bit output: Configuration internal oscillator clock output
      .DI(DI),               // 4-bit output: Allow receiving on the D input pin
      .EOS(EOS),             // 1-bit output: Active-High output signal indicating the End Of Startup
      .PREQ(PREQ),           // 1-bit output: PROGRAM request to fabric output
      .DO(DO),               // 4-bit input: Allows control of the D pin output
      .DTS(DTS),             // 4-bit input: Allows tristate of the D pin
      .FCSBO(FCSBO),         // 1-bit input: Controls the FCS_B pin for flash access
      .FCSBTS(FCSBTS),       // 1-bit input: Tristate the FCS_B pin
      .GSR(GSR),             // 1-bit input: Global Set/Reset input (GSR cannot be used for the port)
      .GTS(GTS),             // 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      .KEYCLEARB(KEYCLEARB), // 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      .PACK(PACK),           // 1-bit input: PROGRAM acknowledge input
      .USRCCLKO(USRCCLKO),   // 1-bit input: User CCLK input
      .USRCCLKTS(USRCCLKTS), // 1-bit input: User CCLK 3-state enable input
      .USRDONEO(USRDONEO),   // 1-bit input: User DONE pin output control
      .USRDONETS(USRDONETS)  // 1-bit input: User DONE 3-state enable output
   );

   // End of STARTUPE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="USR_ACCESS" treetype="folder">
					<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
// USR_ACCESSE2 : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (USR_ACCESSE2_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // USR_ACCESSE2: Configuration Data Access
   //               Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2 USR_ACCESSE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration Clock
      .DATA(DATA),           // 32-bit output: Configuration Data reflecting the contents of the AXSS register
      .DATAVALID(DATAVALID)  // 1-bit output: Active High Data Valid
   );

   // End of USR_ACCESSE2_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="BIDIR_BUFFER" treetype="folder">
					<Template label="Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable (IOBUF_INTERMDISABLE)" treetype="template">
// IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog       : the following instance declaration needs to be placed
//      instance       : in the body of the design code.  The instance name
//     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code         : parenthesis may be changed to properly reference and
//                     : connect this function to the design.  All inputs
//                     : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_INTERMDISABLE: Bidirectional Buffer with Input Path Disable and On-die Input Termination Disable
   //                      Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUF_INTERMDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUF_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)                          // 1-bit input: 3-state enable input
   );

   // End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Bidirectional I/O Buffer with Offset Calibration and VREF Tuning (IOBUFE3)" treetype="template">
//   IOBUFE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFE3: Bidirectional I/O Buffer with Offset Calibration and VREF Tuning
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFE3 #(
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IOBUFE3_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Buffer inout (connect directly to top-level port)
      .OSC(OSC),                       // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),                 // 1-bit input: Offset cancellation enable
      .T(T),                           // 1-bit input: 3-state enable input
      .VREF(VREF)                      // 1-bit input: Vref input from HPIO_VREF
   );

   // End of IOBUFE3_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog             : the following instance declaration needs to be placed
//            instance            : in the body of the design code.  The instance name
//          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//              code              : parenthesis may be changed to properly reference and
//                                : connect this function to the design.  All inputs
//                                : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Bidirectional Buffer with Complementary Outputs, Input Buffer Disable and On-die Input Termination Disable
   //                                 Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer diff_p output
      .OB(OB),                       // 1-bit output: Buffer diff_n output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Must be tied to a logic '0'
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                     // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),                       // 1-bit input: 3-state master enable input
      .TS(TS)                        // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
// IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
//        Verilog         : the following instance declaration needs to be placed
//        instance        : in the body of the design code.  The instance name
//      declaration       : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations within the
//          code          : parenthesis may be changed to properly reference and
//                        : connect this function to the design.  All inputs
//                        : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_DCIEN: Differential Bidirectional Buffer with Complementary Outputs, Input Path Disable, and On-die Input Termination Disable
   //                         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_DCIEN #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DIFF_OUT_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer diff_p output
      .OB(OB),                         // 1-bit output: Buffer diff_n output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Must be tied to a logic '0'
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),                         // 1-bit input: 3-state master enable input
      .TS(TS)                          // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input (IOBUFDS_INTERMDISABLE)" treetype="template">
// IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//        Verilog        : the following instance declaration needs to be placed
//       instance        : in the body of the design code.  The instance name
//      declaration      : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//         code          : parenthesis may be changed to properly reference and
//                       : connect this function to the design.  All inputs
//                       : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_INTERMDISABLE: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input
   //                        Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // 1-bit input: Input Termination Disable
      .IO(IO),                       // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                     // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)                          // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable (IOBUFDS_DCIEN)" treetype="template">
// IOBUFDS_DCIEN : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  All inputs
//               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DCIEN: Differential Bidirectional Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DCIEN #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUFDS_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Bidirectional I/O Buffer with Offset Calibration (IOBUFDSE3)" treetype="template">
//  IOBUFDSE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFDSE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDSE3: Differential Bidirectional I/O Buffer with Offset Calibration
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDSE3 #(
      .DQS_BIAS("FALSE"),          // (FALSE, TRUE)
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IOBUFDSE3_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB),                       // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .OSC(OSC),                       // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),                 // 2-bit input: Offset cancellation enable
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUFDSE3_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer (IOBUFDS)" treetype="template">
//   IOBUFDS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS: Differential Input/Output Buffer
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IOBUFDS_inst (
      .O(O),     // 1-bit output: Buffer output
      .I(I),     // 1-bit input: Buffer input
      .IO(IO),   // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .T(T)      // 1-bit input: 3-state enable input
   );

   // End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer (IOBUFDS_DIFF_OUT)" treetype="template">
// IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT: Differential Input/Output Buffer Primitive With Complementary Outputs for the Input Buffer
   //                   Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IOBUFDS_DIFF_OUT_inst (
      .O(O),     // 1-bit output: Buffer diff_p output
      .OB(OB),   // 1-bit output: Buffer diff_n output
      .I(I),     // 1-bit input: Buffer input
      .IO(IO),   // 1-bit inout: Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // 1-bit inout: Diff_n inout (connect directly to top-level port)
      .TM(TM),   // 1-bit input: 3-state master enable input
      .TS(TS)    // 1-bit input: 3-state slave enable input
   );

   // End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Input/Output Buffer DCI Enable (IOBUF_DCIEN)" treetype="template">
// IOBUF_DCIEN : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUF_DCIEN_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_DCIEN: Input/Output Buffer DCI Enable
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUF_DCIEN #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IOBUF_DCIEN_inst (
      .O(O),                           // 1-bit output: Buffer output
      .DCITERMDISABLE(DCITERMDISABLE), // 1-bit input: DCI Termination Disable
      .I(I),                           // 1-bit input: Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // 1-bit input: Buffer disable input, high=disable
      .IO(IO),                         // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)                            // 1-bit input: 3-state enable input
   );

   // End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Input/Output Buffer (IOBUF)" treetype="template">
//    IOBUF    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IOBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF: Input/Output Buffer
   //        Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IOBUF IOBUF_inst (
      .O(O),   // 1-bit output: Buffer output
      .I(I),   // 1-bit input: Buffer input
      .IO(IO), // 1-bit inout: Buffer inout (connect directly to top-level port)
      .T(T)    // 1-bit input: 3-state enable input
   );

   // End of IOBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="BITSLICE" treetype="folder">
					<Template label="BITSLICE_CONTROL (BITSLICE_CONTROL)" treetype="template">
// BITSLICE_CONTROL : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (BITSLICE_CONTROL_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BITSLICE_CONTROL: BITSLICE_CONTROL for control using Native Mode
   //                   Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   BITSLICE_CONTROL #(
      .DIV_MODE("DIV2"),               // Controller DIV2/DIV4 mode (DIV2, DIV4)
      .EN_CLK_TO_EXT_NORTH("DISABLE"), // Enable clock forwarding to north
      .EN_CLK_TO_EXT_SOUTH("DISABLE"), // Enable clock forwarding to south
      .EN_DYN_ODLY_MODE("FALSE"),      // Enable dynamic output delay mode
      .EN_OTHER_NCLK("FALSE"),         // Select the NCLK from the other BITSLICE_CONTROL in the nibble (FALSE,
                                       // TRUE)
      .EN_OTHER_PCLK("FALSE"),         // Select the PCLK from the other BITSLICE_CONTROL in the nibble (FALSE,
                                       // TRUE)
      .IDLY_VT_TRACK("TRUE"),          // Enable VT tracking for input delays
      .INV_RXCLK("FALSE"),             // Invert clock path from IOB to upper RX bitslice
      .ODLY_VT_TRACK("TRUE"),          // Enable VT tracking for output delays
      .QDLY_VT_TRACK("TRUE"),          // Enable VT tracking for clock delays
      .READ_IDLE_COUNT(6'h00),         // Gap count between read bursts for ODT control counter (0-3f)
      .REFCLK_SRC("PLLCLK"),           // Select the input clock for the delay control (PLLCLK, REFCLK)
      .ROUNDING_FACTOR(16),            // Rounding factor in BISC spec (128-8)
      .RXGATE_EXTEND("FALSE"),         // Reserved for use by MIG Memory Controller. Do Not Change.
      .RX_CLK_PHASE_N("SHIFT_0"),      // Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                       // SHIFT_90)
      .RX_CLK_PHASE_P("SHIFT_0"),      // Shift the Read CLK relative to read DQ during calibration (SHIFT_0,
                                       // SHIFT_90)
      .RX_GATING("DISABLE"),           // ENABLE/DISABLE read DQS gating
      .SELF_CALIBRATE("ENABLE"),       // Enable BISC of nibble controlled by BITSLICE_CONTROL
      .SERIAL_MODE("FALSE"),           // Put BITSLICE read paths into serial mode (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE"),       // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                       // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TX_GATING("DISABLE")            // ENABLE/DISABLE clock gating in WClkgen
   )
   BITSLICE_CONTROL_inst (
      .CLK_TO_EXT_NORTH(CLK_TO_EXT_NORTH),       // 1-bit output: Inter-byte clock going to north
                                                 // BITSLICE_CONTROL

      .CLK_TO_EXT_SOUTH(CLK_TO_EXT_SOUTH),       // 1-bit output: Inter-byte clock going to south
                                                 // BITSLICE_CONTROL

      .DLY_RDY(DLY_RDY),                         // 1-bit output: Fixed delay calibration complete
      .DYN_DCI(DYN_DCI),                         // 7-bit output: Direct control of IOB DCI when using a memory
                                                 // interface

      .NCLK_NIBBLE_OUT(NCLK_NIBBLE_OUT),         // 1-bit output: Intra-byte DQS strobes/clock to other control
                                                 // block

      .PCLK_NIBBLE_OUT(PCLK_NIBBLE_OUT),         // 1-bit output: Intra-byte DQS strobes/clock to other control
                                                 // block

      .RIU_RD_DATA(RIU_RD_DATA),                 // 16-bit output: RIU Output Read data to the controller
      .RIU_VALID(RIU_VALID),                     // 1-bit output: Last data written has been accepted when High
      .RX_BIT_CTRL_OUT0(RX_BIT_CTRL_OUT0),       // 40-bit output: Output bus to Bitslice 0
      .RX_BIT_CTRL_OUT1(RX_BIT_CTRL_OUT1),       // 40-bit output: Output bus to Bitslice 1
      .RX_BIT_CTRL_OUT2(RX_BIT_CTRL_OUT2),       // 40-bit output: Output bus to Bitslice 2
      .RX_BIT_CTRL_OUT3(RX_BIT_CTRL_OUT3),       // 40-bit output: Output bus to Bitslice 3
      .RX_BIT_CTRL_OUT4(RX_BIT_CTRL_OUT4),       // 40-bit output: Output bus to Bitslice 4
      .RX_BIT_CTRL_OUT5(RX_BIT_CTRL_OUT5),       // 40-bit output: Output bus to Bitslice 5
      .RX_BIT_CTRL_OUT6(RX_BIT_CTRL_OUT6),       // 40-bit output: Output bus to Bitslice 6
      .TX_BIT_CTRL_OUT0(TX_BIT_CTRL_OUT0),       // 40-bit output: Output bus to Bitslice 0
      .TX_BIT_CTRL_OUT1(TX_BIT_CTRL_OUT1),       // 40-bit output: Output bus to Bitslice 1
      .TX_BIT_CTRL_OUT2(TX_BIT_CTRL_OUT2),       // 40-bit output: Output bus to Bitslice 2
      .TX_BIT_CTRL_OUT3(TX_BIT_CTRL_OUT3),       // 40-bit output: Output bus to Bitslice 3
      .TX_BIT_CTRL_OUT4(TX_BIT_CTRL_OUT4),       // 40-bit output: Output bus to Bitslice 4
      .TX_BIT_CTRL_OUT5(TX_BIT_CTRL_OUT5),       // 40-bit output: Output bus to Bitslice 5
      .TX_BIT_CTRL_OUT6(TX_BIT_CTRL_OUT6),       // 40-bit output: Output bus to Bitslice 6
      .TX_BIT_CTRL_OUT_TRI(TX_BIT_CTRL_OUT_TRI), // 40-bit output: Output bus to 3-state TX_BITSLICE_TRI
      .VTC_RDY(VTC_RDY),                         // 1-bit output: PHY calibration is complete
      .CLK_FROM_EXT(CLK_FROM_EXT),               // 1-bit input: Inter-byte clock coming from north or south
                                                 // BITSLICE_CONTROL

      .EN_VTC(EN_VTC),                           // 1-bit input: Enables voltage and temperature compensation
                                                 // when High

      .NCLK_NIBBLE_IN(NCLK_NIBBLE_IN),           // 1-bit input: Intra-byte DQS strobes from other/clock
                                                 // control block

      .PCLK_NIBBLE_IN(PCLK_NIBBLE_IN),           // 1-bit input: Intra-byte DQS strobes/clock from other
                                                 // control block

      .PHY_RDCS0(PHY_RDCS0),                     // 4-bit input: Rank select
      .PHY_RDCS1(PHY_RDCS1),                     // 4-bit input: Rank select
      .PHY_RDEN(PHY_RDEN),                       // 4-bit input: Read burst enable when using a memory interface
      .PHY_WRCS0(PHY_WRCS0),                     // 4-bit input: Rank select
      .PHY_WRCS1(PHY_WRCS1),                     // 4-bit input: Rank select
      .PLL_CLK(PLL_CLK),                         // 1-bit input: PLL clock input
      .REFCLK(REFCLK),                           // 1-bit input: Frequency reference clock for delay control
      .RIU_ADDR(RIU_ADDR),                       // 6-bit input: Address input for RIU
      .RIU_CLK(RIU_CLK),                         // 1-bit input: System clock from fabric for RIU access
      .RIU_NIBBLE_SEL(RIU_NIBBLE_SEL),           // 1-bit input: Nibble select to enable RIU read/write
      .RIU_WR_DATA(RIU_WR_DATA),                 // 16-bit input: RIU Input Write data from the controller
      .RIU_WR_EN(RIU_WR_EN),                     // 1-bit input: Enables write to RIU when High
      .RST(RST),                                 // 1-bit input: Asynchronous global reset
      .RX_BIT_CTRL_IN0(RX_BIT_CTRL_IN0),         // 40-bit input: Input bus from Bitslice 0
      .RX_BIT_CTRL_IN1(RX_BIT_CTRL_IN1),         // 40-bit input: Input bus from Bitslice 1
      .RX_BIT_CTRL_IN2(RX_BIT_CTRL_IN2),         // 40-bit input: Input bus from Bitslice 2
      .RX_BIT_CTRL_IN3(RX_BIT_CTRL_IN3),         // 40-bit input: Input bus from Bitslice 3
      .RX_BIT_CTRL_IN4(RX_BIT_CTRL_IN4),         // 40-bit input: Input bus from Bitslice 4
      .RX_BIT_CTRL_IN5(RX_BIT_CTRL_IN5),         // 40-bit input: Input bus from Bitslice 5
      .RX_BIT_CTRL_IN6(RX_BIT_CTRL_IN6),         // 40-bit input: Input bus from Bitslice 6
      .TBYTE_IN(TBYTE_IN),                       // 4-bit input: Output enable for 3-state control
      .TX_BIT_CTRL_IN0(TX_BIT_CTRL_IN0),         // 40-bit input: Input bus from Bitslice 0
      .TX_BIT_CTRL_IN1(TX_BIT_CTRL_IN1),         // 40-bit input: Input bus from Bitslice 1
      .TX_BIT_CTRL_IN2(TX_BIT_CTRL_IN2),         // 40-bit input: Input bus from Bitslice 2
      .TX_BIT_CTRL_IN3(TX_BIT_CTRL_IN3),         // 40-bit input: Input bus from Bitslice 3
      .TX_BIT_CTRL_IN4(TX_BIT_CTRL_IN4),         // 40-bit input: Input bus from Bitslice 4
      .TX_BIT_CTRL_IN5(TX_BIT_CTRL_IN5),         // 40-bit input: Input bus from Bitslice 5
      .TX_BIT_CTRL_IN6(TX_BIT_CTRL_IN6),         // 40-bit input: Input bus from Bitslice 6
      .TX_BIT_CTRL_IN_TRI(TX_BIT_CTRL_IN_TRI)    // 40-bit input: Input bus from 3-state TX_BITSLICE_TRI
   );

   // End of BITSLICE_CONTROL_inst instantiation
					</Template>
					<Template label="Register Interface Unit Selection Block (RIU_OR)" treetype="template">
//   RIU_OR    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RIU_OR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RIU_OR: Register Interface Unit Selection Block
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RIU_OR #(
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   RIU_OR_inst (
      .RIU_RD_DATA(RIU_RD_DATA),           // 16-bit output: RIU data bus to the controller
      .RIU_RD_VALID(RIU_RD_VALID),         // 1-bit output: Combined RIU read valid signal to the controller
      .RIU_RD_DATA_LOW(RIU_RD_DATA_LOW),   // 16-bit input: RIU data bus from the controller to the lower
                                           // nibble BITSLICE_CONTROL

      .RIU_RD_DATA_UPP(RIU_RD_DATA_UPP),   // 16-bit input: RIU data bus from the controller to the upper
                                           // nibble BITSLICE_CONTROL

      .RIU_RD_VALID_LOW(RIU_RD_VALID_LOW), // 1-bit input: RIU_VALID of the lower nibble BITSLICE_CONTROL
      .RIU_RD_VALID_UPP(RIU_RD_VALID_UPP)  // 1-bit input: RIU_VALID of the upper nibble BITSLICE_CONTROL
   );

   // End of RIU_OR_inst instantiation
					</Template>
					<Template label="RX_BITSLICE (RX_BITSLICE)" treetype="template">
// RX_BITSLICE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RX_BITSLICE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RX_BITSLICE: RX_BITSLICE for input using Native Mode
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RX_BITSLICE #(
      .CASCADE("FALSE"),              // Enables cascading of IDELAY and ODELAY lines
      .DATA_TYPE("DATA"),             // Defines what the input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                      // SERIAL)
      .DATA_WIDTH(8),                 // Defines the width of the serial-to-parallel converter (4-8)
      .DELAY_FORMAT("TIME"),          // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),           // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),                // Input delay value setting in ps
      .DELAY_VALUE_EXT(0),            // Value of the extended input delay value in ps
      .FIFO_SYNC_MODE("FALSE"),       // Internal write clock and FIFO_RD_CLK are coming from a common source
      .IS_CLK_EXT_INVERTED(1'b0),     // Optional inversion for CLK_EXT
      .IS_CLK_INVERTED(1'b0),         // Optional inversion for CLK
      .IS_RST_DLY_EXT_INVERTED(1'b0), // Optional inversion for RST_DLY_EXT
      .IS_RST_DLY_INVERTED(1'b0),     // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),         // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),       // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),      // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                      // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC"),          // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                      // SYNC)
      .UPDATE_MODE_EXT("ASYNC")       // Determines when updates to the extended input delay will take effect
                                      // (ASYNC, MANUAL, SYNC)
   )
   RX_BITSLICE_inst (
      .CNTVALUEOUT(CNTVALUEOUT),         // 9-bit output: Counter value to device logic
      .CNTVALUEOUT_EXT(CNTVALUEOUT_EXT), // 9-bit output: Optional extended (cascaded delay) counter value
                                         // going to the device logic

      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .FIFO_WRCLK_OUT(FIFO_WRCLK_OUT),   // 1-bit output: FIFO source synchronous write clock out to the device
                                         // logic (currently unsupported, do not connect)

      .Q(Q),                             // 8-bit output: Registered output data from FIFO
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .CE(CE),                           // 1-bit input: Clock enable for IDELAY
      .CE_EXT(CE_EXT),                   // 1-bit input: Optional extended (cascaded delay) clock enable
      .CLK(CLK),                         // 1-bit input: Clock used to sample LOAD, CE, INC
      .CLK_EXT(CLK_EXT),                 // 1-bit input: Optional extended (cascaded delay) clock
      .CNTVALUEIN(CNTVALUEIN),           // 9-bit input: Counter value from device logic
      .CNTVALUEIN_EXT(CNTVALUEIN_EXT),   // 9-bit input: Optional extended (cascaded delay) counter value from
                                         // device logic

      .DATAIN(DATAIN),                   // 1-bit input: Input signal from IBUF
      .EN_VTC(EN_VTC),                   // 1-bit input: Enable IDELAYCTRL to keep stable delay over VT
      .EN_VTC_EXT(EN_VTC_EXT),           // 1-bit input: Optional extended (cascaded delay) to keep stable
                                         // delay over VT

      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: FIFO read enable
      .INC(INC),                         // 1-bit input: Increment the current delay tap setting
      .INC_EXT(INC_EXT),                 // 1-bit input: Optional extended (cascaded delay) increments the
                                         // current delay tap setting

      .LOAD(LOAD),                       // 1-bit input: Load the CNTVALUEIN tap setting
      .LOAD_EXT(LOAD_EXT),               // 1-bit input: Optional extended (cascaded delay) load the
                                         // CNTVALUEIN_EXT tap setting

      .RST(RST),                         // 1-bit input: Asynchronous assert, synchronous deassert for
                                         // RX_BITSLICE ISERDES

      .RST_DLY(RST_DLY),                 // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      .RST_DLY_EXT(RST_DLY_EXT),         // 1-bit input: Optional extended (cascaded delay) reset delay to
                                         // DELAY_VALUE_EXT

      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN)    // 40-bit input: Input bus from BITSLICE_CONTROL
   );

   // End of RX_BITSLICE_inst instantiation
					</Template>
					<Template label="RXTX_BITSLICE (RXTX_BITSLICE)" treetype="template">
// RXTX_BITSLICE : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (RXTX_BITSLICE_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  All inputs
//               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RXTX_BITSLICE: RXTX_BITSLICE for bidirectional I/O using Native Mode
   //                Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   RXTX_BITSLICE #(
      .ENABLE_PRE_EMPHASIS("FALSE"), // Enable the pre-emphasis
      .FIFO_SYNC_MODE("FALSE"),      // Internal write clock and FIFO_RD_CLK are coming from a common source
      .INIT(1'b1),                   // Defines initial O value
      .IS_RX_CLK_INVERTED(1'b0),     // Optional inversion for RX_CLK
      .IS_RX_RST_DLY_INVERTED(1'b0), // Optional inversion for RX_RST_DLY
      .IS_RX_RST_INVERTED(1'b0),     // Optional inversion for RX_RST
      .IS_TX_CLK_INVERTED(1'b0),     // Optional inversion for TX_CLK
      .IS_TX_RST_DLY_INVERTED(1'b0), // Optional inversion for TX_RST_DLY
      .IS_TX_RST_INVERTED(1'b0),     // Optional inversion for TX_RST
      .RX_DATA_TYPE("DATA"),         // Defines what the RX input pin is carrying (CLOCK, DATA, DATA_AND_CLOCK,
                                     // SERIAL)
      .RX_DATA_WIDTH(8),             // Defines the width of the serial-to-parallel converter (4-8)
      .RX_DELAY_FORMAT("TIME"),      // Units of the RX DELAY_VALUE (COUNT, TIME)
      .RX_DELAY_TYPE("FIXED"),       // Set the type of RX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .RX_DELAY_VALUE(0),            // RX Input delay value setting in ps
      .RX_REFCLK_FREQUENCY(300.0),   // Specification of the RX reference clock frequency in MHz (200.0-2667.0)
      .RX_UPDATE_MODE("ASYNC"),      // Determines when updates to the RX delay will take effect (ASYNC,
                                     // MANUAL, SYNC)
      .SIM_DEVICE("ULTRASCALE"),     // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                     // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TBYTE_CTL("TBYTE_IN"),        // Select between T and TBYTE_IN inputs
      .TX_DATA_WIDTH(8),             // Parallel data input width (4-8)
      .TX_DELAY_FORMAT("TIME"),      // Units of the TX DELAY_VALUE (COUNT, TIME)
      .TX_DELAY_TYPE("FIXED"),       // Set the type of TX tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .TX_DELAY_VALUE(0),            // TX Input delay value setting in ps
      .TX_OUTPUT_PHASE_90("FALSE"),  // Delays the output phase by 90-degrees
      .TX_REFCLK_FREQUENCY(300.0),   // Specification of the TX reference clock frequency in MHz (200.0-2667.0)
      .TX_UPDATE_MODE("ASYNC")       // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                     // SYNC)
   )
   RXTX_BITSLICE_inst (
      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .FIFO_WRCLK_OUT(FIFO_WRCLK_OUT),   // 1-bit output: FIFO source synchronous write clock out to the device
                                         // logic (currently unsupported, do not connect)

      .O(O),                             // 1-bit output: Serialized output going to output buffer
      .Q(Q),                             // 8-bit output: Registered output data from FIFO
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: RX Output bus to BITSLICE_CONTROL
      .RX_CNTVALUEOUT(RX_CNTVALUEOUT),   // 9-bit output: RX Counter value from device logic
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL for TX
      .TX_CNTVALUEOUT(TX_CNTVALUEOUT),   // 9-bit output: TX Counter value to device logic
      .T_OUT(T_OUT),                     // 1-bit output: Byte group 3-state output
      .D(D),                             // 8-bit input: Data from device logic
      .DATAIN(DATAIN),                   // 1-bit input: Input signal from IOBUF
      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: FIFO read enable
      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: RX Input bus from BITSLICE_CONTROL
      .RX_CE(RX_CE),                     // 1-bit input: Clock enable for IDELAY
      .RX_CLK(RX_CLK),                   // 1-bit input: RX Clock used to sample LOAD, CE, INC
      .RX_CNTVALUEIN(RX_CNTVALUEIN),     // 9-bit input: RX Counter value from device logic
      .RX_EN_VTC(RX_EN_VTC),             // 1-bit input: RX Enable to keep stable delay over VT
      .RX_INC(RX_INC),                   // 1-bit input: RX Increment the current delay tap setting
      .RX_LOAD(RX_LOAD),                 // 1-bit input: RX Load the CNTVALUEIN tap setting
      .RX_RST(RX_RST),                   // 1-bit input: RX Asynchronous assert, synchronous deassert for
                                         // RXTX_BITSLICE ISERDES

      .RX_RST_DLY(RX_RST_DLY),           // 1-bit input: RX Reset the internal DELAY value to DELAY_VALUE
      .T(T),                             // 1-bit input: Legacy T byte input from device logic
      .TBYTE_IN(TBYTE_IN),               // 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN),   // 40-bit input: TX Input bus from BITSLICE_CONTROL
      .TX_CE(TX_CE),                     // 1-bit input: Clock enable for ODELAY
      .TX_CLK(TX_CLK),                   // 1-bit input: TX Clock used to sample LOAD, CE, INC
      .TX_CNTVALUEIN(TX_CNTVALUEIN),     // 9-bit input: TX Counter value from device logic
      .TX_EN_VTC(TX_EN_VTC),             // 1-bit input: TX Enable to keep stable delay over VT
      .TX_INC(TX_INC),                   // 1-bit input: TX Increment the current delay tap setting
      .TX_LOAD(TX_LOAD),                 // 1-bit input: TX Load the CNTVALUEIN tap setting
      .TX_RST(TX_RST),                   // 1-bit input: TX Asynchronous assert, synchronous deassert for
                                         // RXTX_BITSLICE OSERDES

      .TX_RST_DLY(TX_RST_DLY)            // 1-bit input: TX Reset the internal DELAY value to DELAY_VALUE
   );

   // End of RXTX_BITSLICE_inst instantiation
					</Template>
					<Template label="TX_BITSLICE_TRI (TX_BITSLICE_TRI)" treetype="template">
// TX_BITSLICE_TRI : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (TX_BITSLICE_TRI_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // TX_BITSLICE_TRI: TX_BITSLICE_TRI for tristate using Native Mode
   //                  Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE_TRI #(
      .DATA_WIDTH(8),             // Parallel data input width (4-8)
      .DELAY_FORMAT("TIME"),      // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),       // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),            // Output delay value setting
      .INIT(1'b1),                // Defines initial O value
      .IS_CLK_INVERTED(1'b0),     // Optional inversion for CLK
      .IS_RST_DLY_INVERTED(1'b0), // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),     // Optional inversion for RST
      .OUTPUT_PHASE_90("FALSE"),  // Delays the output phase by 90-degrees
      .REFCLK_FREQUENCY(300.0),   // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                  // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")       // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                  // SYNC)
   )
   TX_BITSLICE_TRI_inst (
      .BIT_CTRL_OUT(BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .CNTVALUEOUT(CNTVALUEOUT),   // 9-bit output: Counter value to device logic
      .TRI_OUT(TRI_OUT),           // 1-bit output: Output to the TBYTE_IN pins of the bitslices
      .BIT_CTRL_IN(BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .CE(CE),                     // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                   // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),     // 9-bit input: Counter value input
      .EN_VTC(EN_VTC),             // 1-bit input: Enable to keep stable delay over VT
      .INC(INC),                   // 1-bit input: Increment the current delay tap setting
      .LOAD(LOAD),                 // 1-bit input: Load the CNTVALUEIN tap setting
      .RST(RST),                   // 1-bit input: Asynchronous assert, synchronous deassert
      .RST_DLY(RST_DLY)            // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
   );

   // End of TX_BITSLICE_TRI_inst instantiation
					</Template>
					<Template label="TX_BITSLICE (TX_BITSLICE)" treetype="template">
// TX_BITSLICE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (TX_BITSLICE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // TX_BITSLICE: TX_BITSLICE for output using Native Mode
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   TX_BITSLICE #(
      .DATA_WIDTH(8),                // Parallel data input width (4-8)
      .DELAY_FORMAT("TIME"),         // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_TYPE("FIXED"),          // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),               // Output delay value setting
      .ENABLE_PRE_EMPHASIS("FALSE"), // Enable the pre-emphasis
      .INIT(1'b1),                   // Defines initial O value
      .IS_CLK_INVERTED(1'b0),        // Optional inversion for CLK
      .IS_RST_DLY_INVERTED(1'b0),    // Optional inversion for RST_DLY
      .IS_RST_INVERTED(1'b0),        // Optional inversion for RST
      .OUTPUT_PHASE_90("FALSE"),     // Delays the output phase by 90-degrees
      .REFCLK_FREQUENCY(300.0),      // Specification of the reference clock frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"),     // Set the device version (ULTRASCALE, ULTRASCALE_PLUS,
                                     // ULTRASCALE_PLUS_ES1, ULTRASCALE_PLUS_ES2)
      .TBYTE_CTL("TBYTE_IN"),        // Select between T and TBYTE_IN inputs
      .UPDATE_MODE("ASYNC")          // Determines when updates to the delay will take effect (ASYNC, MANUAL,
                                     // SYNC)
   )
   TX_BITSLICE_inst (
      .CNTVALUEOUT(CNTVALUEOUT),         // 9-bit output: Counter value to device logic
      .O(O),                             // 1-bit output: Serialized output going to output buffer
      .RX_BIT_CTRL_OUT(RX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .TX_BIT_CTRL_OUT(TX_BIT_CTRL_OUT), // 40-bit output: Output bus to BITSLICE_CONTROL
      .T_OUT(T_OUT),                     // 1-bit output: Byte group 3-state output
      .CE(CE),                           // 1-bit input: Clock enable for ODELAY
      .CLK(CLK),                         // 1-bit input: Clock used to sample LOAD, CE, INC
      .CNTVALUEIN(CNTVALUEIN),           // 9-bit input: Counter value from device logic
      .D(D),                             // 8-bit input: Data from device logic
      .EN_VTC(EN_VTC),                   // 1-bit input: Enable to keep stable delay over VT
      .INC(INC),                         // 1-bit input: Increment the current delay tap setting
      .LOAD(LOAD),                       // 1-bit input: Load the CNTVALUEIN tap setting
      .RST(RST),                         // 1-bit input: Asynchronous assert, synchronous deassert for
                                         // TX_BITSLICE OSERDES

      .RST_DLY(RST_DLY),                 // 1-bit input: Reset the internal DELAY value to DELAY_VALUE
      .RX_BIT_CTRL_IN(RX_BIT_CTRL_IN),   // 40-bit input: Input bus from BITSLICE_CONTROL
      .T(T),                             // 1-bit input: Legacy T byte input from device logic
      .TBYTE_IN(TBYTE_IN),               // 1-bit input: Byte group 3-state input from TX_BITSLICE_TRI
      .TX_BIT_CTRL_IN(TX_BIT_CTRL_IN)    // 40-bit input: Input bus from BITSLICE_CONTROL
   );

   // End of TX_BITSLICE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DCI_RESET" treetype="folder">
					<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
//  DCIRESET   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DCIRESET_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DCIRESET: Digitally Controlled Impedance Reset Component
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   DCIRESET DCIRESET_inst (
      .LOCKED(LOCKED), // 1-bit output: LOCK status output
      .RST(RST)        // 1-bit input: Active-High asynchronous reset input
   );

   // End of DCIRESET_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DELAY" treetype="folder">
					<Template label="IDELAYE3/ODELAYE3 Tap Delay Value Control (IDELAYCTRL)" treetype="template">
// IDELAYCTRL  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYCTRL: IDELAYE3/ODELAYE3 Tap Delay Value Control
   //             Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IDELAYCTRL #(
      .SIM_DEVICE("7SERIES")  // Set the device version (7SERIES, ULTRASCALE)
   )
   IDELAYCTRL_inst (
      .RDY(RDY),       // 1-bit output: Ready output
      .REFCLK(REFCLK), // 1-bit input: Reference clock input
      .RST(RST)        // 1-bit input: Active high reset input. Asynchronous assert, synchronous deassert to
                       // REFCLK.

   );

   // End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE3)" treetype="template">
//  IDELAYE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYE3: Input Fixed or Variable Delay Element
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IDELAYE3 #(
      .CASCADE("NONE"),          // Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      .DELAY_FORMAT("TIME"),     // Units of the DELAY_VALUE (COUNT, TIME)
      .DELAY_SRC("IDATAIN"),     // Delay input (DATAIN, IDATAIN)
      .DELAY_TYPE("FIXED"),      // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),           // Input delay value setting
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),  // IDELAYCTRL clock input frequency in MHz (200.0-2667.0)
      .SIM_DEVICE("ULTRASCALE"), // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")      // Determines when updates to the delay will take effect (ASYNC, MANUAL, SYNC)
   )
   IDELAYE3_inst (
      .CASC_OUT(CASC_OUT),       // 1-bit output: Cascade delay output to ODELAY input cascade
      .CNTVALUEOUT(CNTVALUEOUT), // 9-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data output
      .CASC_IN(CASC_IN),         // 1-bit input: Cascade delay input from slave ODELAY CASCADE_OUT
      .CASC_RETURN(CASC_RETURN), // 1-bit input: Cascade delay returning from slave ODELAY DATAOUT
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                 // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),   // 9-bit input: Counter value input
      .DATAIN(DATAIN),           // 1-bit input: Data input from the logic
      .EN_VTC(EN_VTC),           // 1-bit input: Keep delay constant over VT
      .IDATAIN(IDATAIN),         // 1-bit input: Data input from the IOBUF
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LOAD(LOAD),               // 1-bit input: Load DELAY_VALUE input
      .RST(RST)                  // 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   // End of IDELAYE3_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE3)" treetype="template">
//  ODELAYE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODELAYE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODELAYE3: Output Fixed or Variable Delay Element
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   ODELAYE3 #(
      .CASCADE("NONE"),          // Cascade setting (MASTER, NONE, SLAVE_END, SLAVE_MIDDLE)
      .DELAY_FORMAT("TIME"),     // (COUNT, TIME)
      .DELAY_TYPE("FIXED"),      // Set the type of tap delay line (FIXED, VARIABLE, VAR_LOAD)
      .DELAY_VALUE(0),           // Output delay tap setting
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .REFCLK_FREQUENCY(300.0),  // IDELAYCTRL clock input frequency in MHz (200.0-2667.0).
      .SIM_DEVICE("ULTRASCALE"), // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
      .UPDATE_MODE("ASYNC")      // Determines when updates to the delay will take effect (ASYNC, MANUAL, SYNC)
   )
   ODELAYE3_inst (
      .CASC_OUT(CASC_OUT),       // 1-bit output: Cascade delay output to IDELAY input cascade
      .CNTVALUEOUT(CNTVALUEOUT), // 9-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data from ODATAIN input port
      .CASC_IN(CASC_IN),         // 1-bit input: Cascade delay input from slave IDELAY CASCADE_OUT
      .CASC_RETURN(CASC_RETURN), // 1-bit input: Cascade delay returning from slave IDELAY DATAOUT
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CLK(CLK),                 // 1-bit input: Clock input
      .CNTVALUEIN(CNTVALUEIN),   // 9-bit input: Counter value input
      .EN_VTC(EN_VTC),           // 1-bit input: Keep delay constant over VT
      .INC(INC),                 // 1-bit input: Increment/Decrement tap delay input
      .LOAD(LOAD),               // 1-bit input: Load DELAY_VALUE input
      .ODATAIN(ODATAIN),         // 1-bit input: Data input
      .RST(RST)                  // 1-bit input: Asynchronous Reset to the DELAY_VALUE
   );

   // End of ODELAYE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="INPUT_BUFFER" treetype="folder">
					<Template label="Analog Auxiliary SYSMON Input Buffer (IBUF_ANALOG)" treetype="template">
// IBUF_ANALOG : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUF_ANALOG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_ANALOG: Analog Auxiliary SYSMON Input Buffer
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUF_ANALOG IBUF_ANALOG_inst (
      .O(O), // 1-bit output: Connect to a VAUXP/VAUXN port of the SYSMONE1
      .I(I)  // 1-bit input: Connect to a top-level design port
   );

   // End of IBUF_ANALOG_inst instantiation
					</Template>
					<Template label="Differential Input Buffer (IBUFDS)" treetype="template">
//   IBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS: Differential Input Buffer
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IBUFDS_inst (
      .O(O),   // 1-bit output: Buffer output
      .I(I),   // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs and Input Buffer Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
//           Verilog           : the following instance declaration needs to be placed
//          instance           : in the body of the design code.  The instance name
//         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations within the
//            code             : parenthesis may be changed to properly reference and
//                             : connect this function to the design.  All inputs
//                             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer With Complementary Outputs and Input Buffer Disable
   //                              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_DIFF_OUT_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer diff_p output
      .OB(OB),                   // 1-bit output: Buffer diff_n output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Must be tied to a logic '0'
   );

   // End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Complementary Outputs (IBUFDS_DIFF_OUT)" treetype="template">
// IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT: Differential Input Buffer With Complementary Outputs
   //                  Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT #(
      .DQS_BIAS("FALSE")  // (FALSE, TRUE)
   )
   IBUFDS_DIFF_OUT_inst (
      .O(O),   // 1-bit output: Buffer diff_p output
      .OB(OB), // 1-bit output: Buffer diff_n output
      .I(I),   // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // 1-bit input: Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog            : the following instance declaration needs to be placed
//           instance            : in the body of the design code.  The instance name
//          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code              : parenthesis may be changed to properly reference and
//                               : connect this function to the design.  All inputs
//                               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Complementary Outputs, Input Path Disable and On-die Input Termination Disable
   //                                Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer diff_p output
      .OB(OB),                       // 1-bit output: Buffer diff_n output
      .I(I),                         // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                       // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Must be tied to a logic '0'
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Buffer termination disable, high=disable
   );

   // End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
// IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog        : the following instance declaration needs to be placed
//       instance       : in the body of the design code.  The instance name
//     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//         code         : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_INTERMDISABLE: Differential Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                       // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer input disable, high=disable
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Buffer termination disable, high=disable
   );

   // End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer With Input Buffer Disable (IBUFDS_IBUFDISABLE)" treetype="template">
// IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//      instance      : in the body of the design code.  The instance name
//    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations within the
//        code        : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_IBUFDISABLE: Differential Input Buffer With Input Buffer Disable
   //                     Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE #(
      .DQS_BIAS("FALSE"),        // (FALSE, TRUE)
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUFDS_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Must be tied to a logic '0'
   );

   // End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with MIPI support (IBUFDS_DPHY)" treetype="template">
// IBUFDS_DPHY : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_DPHY_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DPHY: Differential Input Buffer with MIPI support
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DPHY #(
      .DIFF_TERM("TRUE"),     // Differential termination
      .IOSTANDARD("DEFAULT")  // I/O standard
   )
   IBUFDS_DPHY_inst (
      .HSRX_O(HSRX_O),             // 1-bit output: HS RX output
      .LPRX_O_N(LPRX_O_N),         // 1-bit output: LP RX output (Slave)
      .LPRX_O_P(LPRX_O_P),         // 1-bit output: LP RX output (Master)
      .HSRX_DISABLE(HSRX_DISABLE), // 1-bit input: Disable control for HS mode
      .I(I),                       // 1-bit input: Data input0 PAD
      .IB(IB),                     // 1-bit input: Data input1 PAD
      .LPRX_DISABLE(LPRX_DISABLE)  // 1-bit input: Disable control for LP mode
   );

   // End of IBUFDS_DPHY_inst instantiation
					</Template>
					<Template label="Differential Input Buffer with Offset Calibration (IBUFDSE3)" treetype="template">
//  IBUFDSE3   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDSE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDSE3: Differential Input Buffer with Offset Calibration
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFDSE3 #(
      .DQS_BIAS("FALSE"),          // (FALSE, TRUE)
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IBUFDSE3_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Diff_p buffer input (connect directly to top-level port)
      .IB(IB),                   // 1-bit input: Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE), // 1-bit input: Buffer disable input, high=disable
      .OSC(OSC),                 // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN)            // 2-bit input: Offset cancellation enable
   );

   // End of IBUFDSE3_inst instantiation
					</Template>
					<Template label="Input Buffer (IBUF)" treetype="template">
//    IBUF     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF: Input Buffer
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUF IBUF_inst (
      .O(O), // 1-bit output: Buffer output
      .I(I)  // 1-bit input: Buffer input
   );

   // End of IBUF_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable and On-die Input Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
// IBUF_INTERMDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//      instance      : in the body of the design code.  The instance name
//    declaration     : (IBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code        : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_INTERMDISABLE: Input Buffer With Input Buffer Disable and On-die Input Termination Disable
   //                     Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUF_INTERMDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUF_INTERMDISABLE_inst (
      .O(O),                         // 1-bit output: Buffer output
      .I(I),                         // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),     // 1-bit input: Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE)  // 1-bit input: Input Termination Disable
   );

   // End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer With Input Buffer Disable (IBUF_IBUFDISABLE)" treetype="template">
// IBUF_IBUFDISABLE : In order to incorporate this function into the design,
//     Verilog      : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//   declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  All inputs
//                  : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_IBUFDISABLE: Input Buffer With Input Buffer Disable
   //                   Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUF_IBUFDISABLE #(
      .SIM_DEVICE("ULTRASCALE")  // Must be set to "ULTRASCALE" 
   )
   IBUF_IBUFDISABLE_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // 1-bit input: Buffer disable input, high=disable
   );

   // End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Input Buffer with Offset Calibration and VREF Tuning (IBUFE3)" treetype="template">
//   IBUFE3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFE3: Input Buffer with Offset Calibration and VREF Tuning
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IBUFE3 #(
      .SIM_INPUT_BUFFER_OFFSET(0)  // Offset value for simulation (-50-50)
   )
   IBUFE3_inst (
      .O(O),                     // 1-bit output: Buffer output
      .I(I),                     // 1-bit input: Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE), // 1-bit input: Buffer disable input, high=disable
      .OSC(OSC),                 // 4-bit input: Offset cancellation value
      .OSC_EN(OSC_EN),           // 1-bit input: Offset cancellation enable
      .VREF(VREF)                // 1-bit input: Vref input from HPIO_VREF
   );

   // End of IBUFE3_inst instantiation
					</Template>
					<Template label="VREF Scan (HPIO_VREF)" treetype="template">
//  HPIO_VREF  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (HPIO_VREF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // HPIO_VREF: VREF Scan
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   HPIO_VREF #(
      .VREF_CNTR("OFF")  // FABRIC_RANGE1, FABRIC_RANGE2, OFF
   )
   HPIO_VREF_inst (
      .VREF(VREF),                         // 1-bit output: Tuned output (connect to associated IBUFE3
                                           // component)

      .FABRIC_VREF_TUNE(FABRIC_VREF_TUNE)  // 7-bit input: VREF tuning value
   );

   // End of HPIO_VREF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="OUTPUT_BUFFER" treetype="folder">
					<Template label="3-State Output Buffer (OBUFT)" treetype="template">
//    OBUFT    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFT: 3-State Output Buffer
   //        Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFT OBUFT_inst (
      .O(O), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(I), // 1-bit input: Buffer input
      .T(T)  // 1-bit input: 3-state enable input
   );

   // End of OBUFT_inst instantiation
					</Template>
					<Template label="Differential Output Buffer (OBUFDS)" treetype="template">
//   OBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS: Differential Output Buffer
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS OBUFDS_inst (
      .O(O),   // 1-bit output: Diff_p output (connect directly to top-level port)
      .OB(OB), // 1-bit output: Diff_n output (connect directly to top-level port)
      .I(I)    // 1-bit input: Buffer input
   );

   // End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential Output Buffer with MIPI support (OBUFDS_DPHY)" treetype="template">
// OBUFDS_DPHY : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFDS_DPHY_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS_DPHY: Differential Output Buffer with MIPI support
   //              Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFDS_DPHY #(
      .IOSTANDARD("DEFAULT")  // I/O standard
   )
   OBUFDS_DPHY_inst (
      .O(O),               // 1-bit output: Diff_P Data output
      .OB(OB),             // 1-bit output: Diff_N Data output
      .HSTX_I(HSTX_I),     // 1-bit input: Data input (HS TX)
      .HSTX_T(HSTX_T),     // 1-bit input: Tristate Control input (HS TX)
      .LPTX_I_N(LPTX_I_N), // 1-bit input: Data input (LP TX) (Master-N)
      .LPTX_I_P(LPTX_I_P), // 1-bit input: Data input (LP TX) (Master-P)
      .LPTX_T(LPTX_T)      // 1-bit input: Tristate Control input (LP TX)
   );

   // End of OBUFDS_DPHY_inst instantiation
					</Template>
					<Template label="Differential 3-state Output Buffer (OBUFTDS)" treetype="template">
//   OBUFTDS   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUFTDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUFTDS: Differential 3-state Output Buffer
   //          Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUFTDS OBUFTDS_inst (
      .O(O),   // 1-bit output: Diff_p output (connect directly to top-level port)
      .OB(OB), // 1-bit output: Diff_n output (connect directly to top-level port)
      .I(I),   // 1-bit input: Buffer input
      .T(T)    // 1-bit input: 3-state enable input
   );

   // End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Output Buffer (OBUF)" treetype="template">
//    OBUF     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OBUF_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OBUF: Output Buffer
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OBUF OBUF_inst (
      .O(O), // 1-bit output: Buffer output (connect directly to top-level port)
      .I(I)  // 1-bit input: Buffer input
   );

   // End of OBUF_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer (ISERDESE3)" treetype="template">
//  ISERDESE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ISERDESE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ISERDESE3: Input SERial/DESerializer
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   ISERDESE3 #(
      .DATA_WIDTH(8),            // Parallel data width (4,8)
      .FIFO_ENABLE("FALSE"),     // Enables the use of the FIFO
      .FIFO_SYNC_MODE("FALSE"),  // Enables the use of internal 2-stage synchronizers on the FIFO
      .IS_CLK_B_INVERTED(1'b0),  // Optional inversion for CLK_B
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   ISERDESE3_inst (
      .FIFO_EMPTY(FIFO_EMPTY),           // 1-bit output: FIFO empty flag
      .INTERNAL_DIVCLK(INTERNAL_DIVCLK), // 1-bit output: Internally divided down clock used when FIFO is
                                         // disabled (do not connect)

      .Q(Q),                             // 8-bit registered output
      .CLK(CLK),                         // 1-bit input: High-speed clock
      .CLKDIV(CLKDIV),                   // 1-bit input: Divided Clock
      .CLK_B(CLK_B),                     // 1-bit input: Inversion of High-speed clock CLK
      .D(D),                             // 1-bit input: Serial Data Input
      .FIFO_RD_CLK(FIFO_RD_CLK),         // 1-bit input: FIFO read clock
      .FIFO_RD_EN(FIFO_RD_EN),           // 1-bit input: Enables reading the FIFO when asserted
      .RST(RST)                          // 1-bit input: Asynchronous Reset
   );

   // End of ISERDESE3_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer (OSERDESE3)" treetype="template">
//  OSERDESE3  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OSERDESE3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OSERDESE3: Output SERial/DESerializer
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   OSERDESE3 #(
      .DATA_WIDTH(8),            // Parallel Data Width (4-8)
      .INIT(1'b0),               // Initialization value of the OSERDES flip-flops
      .IS_CLKDIV_INVERTED(1'b0), // Optional inversion for CLKDIV
      .IS_CLK_INVERTED(1'b0),    // Optional inversion for CLK
      .IS_RST_INVERTED(1'b0),    // Optional inversion for RST
      .SIM_DEVICE("ULTRASCALE")  // Set the device version (ULTRASCALE, ULTRASCALE_PLUS, ULTRASCALE_PLUS_ES1,
                                 // ULTRASCALE_PLUS_ES2)
   )
   OSERDESE3_inst (
      .OQ(OQ),         // 1-bit output: Serial Output Data
      .T_OUT(T_OUT),   // 1-bit output: 3-state control output to IOB
      .CLK(CLK),       // 1-bit input: High-speed clock
      .CLKDIV(CLKDIV), // 1-bit input: Divided Clock
      .D(D),           // 8-bit input: Parallel Data Input
      .RST(RST),       // 1-bit input: Asynchronous Reset
      .T(T)            // 1-bit input: Tristate input from fabric
   );

   // End of OSERDESE3_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="WEAK_DRIVER" treetype="folder">
					<Template label="I/O Pulldown (PULLDOWN)" treetype="template">
//  PULLDOWN   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PULLDOWN_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PULLDOWN: I/O Pulldown
   //           Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PULLDOWN PULLDOWN_inst (
      .O(O)  // 1-bit output: Pulldown output (connect directly to top-level port)
   );

   // End of PULLDOWN_inst instantiation
					</Template>
					<Template label="I/O Pullup (PULLUP)" treetype="template">
//   PULLUP    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PULLUP_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PULLUP: I/O Pullup
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   PULLUP PULLUP_inst (
      .O(O)  // 1-bit output: Pullup output (connect directly to top-level port)
   );

   // End of PULLUP_inst instantiation
					</Template>
					<Template label="I/O Weak Keeper (KEEPER)" treetype="template">
//   KEEPER    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (KEEPER_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // KEEPER: I/O Weak Keeper
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   KEEPER KEEPER_inst (
      .O(O)  // 1-bit inout: Keeper output (connect directly to top-level port)
   );

   // End of KEEPER_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="REGISTER" treetype="folder">
				<SubFolder label="DDR" treetype="folder">
					<Template label="Input DDR (IDDRE1)" treetype="template">
//   IDDRE1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDDRE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDDRE1: Dedicated Dual Data Rate (DDR) Input Register
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   IDDRE1 #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // IDDRE1 mode (OPPOSITE_EDGE, SAME_EDGE, SAME_EDGE_PIPELINED)
      .IS_CB_INVERTED(1'b0),          // Optional inversion for CB
      .IS_C_INVERTED(1'b0)            // Optional inversion for C
   )
   IDDRE1_inst (
      .Q1(Q1), // 1-bit output: Registered parallel output 1
      .Q2(Q2), // 1-bit output: Registered parallel output 2
      .C(C),   // 1-bit input: High-speed clock
      .CB(CB), // 1-bit input: Inversion of High-speed clock C
      .D(D),   // 1-bit input: Serial Data Input
      .R(R)    // 1-bit input: Active High Async Reset
   );

   // End of IDDRE1_inst instantiation
					</Template>
					<Template label="Output DDR (ODDRE1)" treetype="template">
//   ODDRE1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODDRE1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODDRE1: Dedicated Dual Data Rate (DDR) Output Register
   //         Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   ODDRE1 #(
      .IS_C_INVERTED(1'b0),  // Optional inversion for C
      .IS_D1_INVERTED(1'b0), // Optional inversion for D1
      .IS_D2_INVERTED(1'b0), // Optional inversion for D2
      .SRVAL(1'b0)           // Initializes the ODDRE1 Flip-Flops to the specified value (1'b0, 1'b1)
   )
   ODDRE1_inst (
      .Q(Q),   // 1-bit output: Data output to IOB
      .C(C),   // 1-bit input: High-speed clock input
      .D1(D1), // 1-bit input: Parallel data input 1
      .D2(D2), // 1-bit input: Parallel data input 2
      .SR(SR)  // 1-bit input: Active High Async Reset
   );

   // End of ODDRE1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="LATCH" treetype="folder">
					<Template label="Transparent Latch with Clock Enable and Asynchronous Clear (LDCE)" treetype="template">
//    LDCE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LDCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LDCE: Transparent Latch with Clock Enable and Asynchronous Clear
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LDCE #(
      .INIT(1'b0),            // Initial value of latch, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_G_INVERTED(1'b0)    // Optional inversion for G
   )
   LDCE_inst (
      .Q(Q),     // 1-bit output: Data
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .D(D),     // 1-bit input: Data
      .G(G),     // 1-bit input: Gate
      .GE(GE)    // 1-bit input: Gate enable
   );

   // End of LDCE_inst instantiation
					</Template>
					<Template label="Transparent Latch with Clock Enable and Asynchronous Preset (LDPE)" treetype="template">
//    LDPE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LDPE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LDPE: Transparent Latch with Clock Enable and Asynchronous Preset
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   LDPE #(
      .INIT(1'b1),            // Initial value of latch, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_G_INVERTED(1'b0),   // Optional inversion for G
      .IS_PRE_INVERTED(1'b0)  // Optional inversion for PRE
   )
   LDPE_inst (
      .Q(Q),     // 1-bit output: Data
      .D(D),     // 1-bit input: Data
      .G(G),     // 1-bit input: Gate
      .GE(GE),   // 1-bit input: Gate enable
      .PRE(PRE)  // 1-bit input: Asynchronous preset
   );

   // End of LDPE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="METASTABILITY" treetype="folder">
					<Template label="Metastability Hardened Registers (HARD_SYNC)" treetype="template">
//  HARD_SYNC  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (HARD_SYNC_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // HARD_SYNC: Metastability Hardened Registers
   //            Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   HARD_SYNC #(
      .INIT(1'b0),            // Initial values, 1'b0, 1'b1
      .IS_CLK_INVERTED(1'b0), // Programmable inversion on CLK input
      .LATENCY(2)             // 2-3
   )
   HARD_SYNC_inst (
      .DOUT(DOUT), // 1-bit output: Data
      .CLK(CLK),   // 1-bit input: Clock
      .DIN(DIN)    // 1-bit input: Data
   );

   // End of HARD_SYNC_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="SDR" treetype="folder">
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Clear (FDCE)" treetype="template">
//    FDCE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDCE: D Flip-Flop with Clock Enable and Asynchronous Clear
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FDCE #(
      .INIT(1'b0),            // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_CLR_INVERTED(1'b0), // Optional inversion for CLR
      .IS_C_INVERTED(1'b0),   // Optional inversion for C
      .IS_D_INVERTED(1'b0)    // Optional inversion for D
   )
   FDCE_inst (
      .Q(Q),     // 1-bit output: Data
      .C(C),     // 1-bit input: Clock
      .CE(CE),   // 1-bit input: Clock enable
      .CLR(CLR), // 1-bit input: Asynchronous clear
      .D(D)      // 1-bit input: Data
   );

   // End of FDCE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Asynchronous Preset (FDPE)" treetype="template">
//    FDPE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDPE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDPE: D Flip-Flop with Clock Enable and Asynchronous Preset
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FDPE #(
      .INIT(1'b1),            // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0),   // Optional inversion for C
      .IS_D_INVERTED(1'b0),   // Optional inversion for D
      .IS_PRE_INVERTED(1'b0)  // Optional inversion for PRE
   )
   FDPE_inst (
      .Q(Q),     // 1-bit output: Data
      .C(C),     // 1-bit input: Clock
      .CE(CE),   // 1-bit input: Clock enable
      .D(D),     // 1-bit input: Data
      .PRE(PRE)  // 1-bit input: Asynchronous preset
   );

   // End of FDPE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Reset (FDRE)" treetype="template">
//    FDRE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDRE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDRE: D Flip-Flop with Clock Enable and Synchronous Reset
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FDRE #(
      .INIT(1'b0),          // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0), // Optional inversion for C
      .IS_D_INVERTED(1'b0), // Optional inversion for D
      .IS_R_INVERTED(1'b0)  // Optional inversion for R
   )
   FDRE_inst (
      .Q(Q),   // 1-bit output: Data
      .C(C),   // 1-bit input: Clock
      .CE(CE), // 1-bit input: Clock enable
      .D(D),   // 1-bit input: Data
      .R(R)    // 1-bit input: Synchronous reset
   );

   // End of FDRE_inst instantiation
					</Template>
					<Template label="D Flip-Flop with Clock Enable and Synchronous Set (FDSE)" treetype="template">
//    FDSE     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FDSE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FDSE: D Flip-Flop with Clock Enable and Synchronous Set
   //       Virtex UltraScale+
   // Xilinx HDL Language Template, version 2016.4

   FDSE #(
      .INIT(1'b1),          // Initial value of register, 1'b0, 1'b1
      // Programmable Inversion Attributes: Specifies the use of the built-in programmable inversion
      .IS_C_INVERTED(1'b0), // Optional inversion for C
      .IS_D_INVERTED(1'b0), // Optional inversion for D
      .IS_S_INVERTED(1'b0)  // Optional inversion for S
   )
   FDSE_inst (
      .Q(Q),   // 1-bit output: Data
      .C(C),   // 1-bit input: Clock
      .CE(CE), // 1-bit input: Clock enable
      .D(D),   // 1-bit input: Data
      .S(S)    // 1-bit input: Synchronous set
   );

   // End of FDSE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Virtex-7" treetype="folder">
			<SubFolder label="Advanced" treetype="folder">
				<Template label="Gigabit Transceiver Buffer (IBUFDS_GTE2)" treetype="template">
// IBUFDS_GTE2 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_GTE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_GTE2: Gigabit Transceiver Buffer
   //              Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_GTE2 #(
      .CLKCM_CFG("TRUE"),   // Refer to Transceiver User Guide
      .CLKRCV_TRST("TRUE"), // Refer to Transceiver User Guide
      .CLKSWING_CFG(2'b11)  // Refer to Transceiver User Guide
   )
   IBUFDS_GTE2_inst (
      .O(O),         // 1-bit output: Refer to Transceiver User Guide
      .ODIV2(ODIV2), // 1-bit output: Refer to Transceiver User Guide
      .CEB(CEB),     // 1-bit input: Refer to Transceiver User Guide
      .I(I),         // 1-bit input: Refer to Transceiver User Guide
      .IB(IB)        // 1-bit input: Refer to Transceiver User Guide
   );

   // End of IBUFDS_GTE2_inst instantiation
				</Template>
				<Template label="XADC Simulation File" treetype="template">
// Must use valid headers on all columns
// Comments can be added to the stimulus file using '//'

TIME TEMP VCCAUX VCCINT VCCBRAM VP VN VAUXP[0] VAUXN[0]
00000 45 1.8 1.0 1.0 0.5 0.0 0.7 0.0
05000 85 1.77 1.01 1.01 0.3 0.0 0.2 0.0

// Time stamp data is in nano seconds (ns)
// Temperature is recorded in C (degrees centigrade)
// All other channels are recorded as V (Volts)
// Valid column headers are:
// TIME, TEMP, VCCAUX, VCCINT, VCCBRAM, VCCPINT, VCCPAUX, VCCDDRO, VP, VN,
// VAUXP[0], VAUXN[0],...............VAUXP[15], VAUXN[15]
// External analog inputs are differential so VP = 0.5 and VN = 0.1 the
// input on channel VP/VN in 0.5 - 0.1 = 0.4V
				</Template>
				<Template label="Xilinx Analog-to-Digital Converter (XADC)" treetype="template">
//    XADC     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (XADC_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // XADC: Dual 12-Bit 1MSPS Analog-to-Digital Converter
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   XADC #(
      // INIT_40 - INIT_42: XADC configuration registers
      .INIT_40(16'h0000),
      .INIT_41(16'h0000),
      .INIT_42(16'h0800),
      // INIT_48 - INIT_4F: Sequence Registers
      .INIT_48(16'h0000),
      .INIT_49(16'h0000),
      .INIT_4A(16'h0000),
      .INIT_4B(16'h0000),
      .INIT_4C(16'h0000),
      .INIT_4D(16'h0000),
      .INIT_4F(16'h0000),
      .INIT_4E(16'h0000),                // Sequence register 6
      // INIT_50 - INIT_58, INIT5C: Alarm Limit Registers
      .INIT_50(16'h0000),
      .INIT_51(16'h0000),
      .INIT_52(16'h0000),
      .INIT_53(16'h0000),
      .INIT_54(16'h0000),
      .INIT_55(16'h0000),
      .INIT_56(16'h0000),
      .INIT_57(16'h0000),
      .INIT_58(16'h0000),
      .INIT_5C(16'h0000),
      // Simulation attributes: Set for proper simulation behavior
      .SIM_DEVICE("7SERIES"),            // Select target device (values)
      .SIM_MONITOR_FILE("design.txt")  // Analog simulation data file name
   )
   XADC_inst (
      // ALARMS: 8-bit (each) output: ALM, OT
      .ALM(ALM),                   // 8-bit output: Output alarm for temp, Vccint, Vccaux and Vccbram
      .OT(OT),                     // 1-bit output: Over-Temperature alarm
      // Dynamic Reconfiguration Port (DRP): 16-bit (each) output: Dynamic Reconfiguration Ports
      .DO(DO),                     // 16-bit output: DRP output data bus
      .DRDY(DRDY),                 // 1-bit output: DRP data ready
      // STATUS: 1-bit (each) output: XADC status ports
      .BUSY(BUSY),                 // 1-bit output: ADC busy output
      .CHANNEL(CHANNEL),           // 5-bit output: Channel selection outputs
      .EOC(EOC),                   // 1-bit output: End of Conversion
      .EOS(EOS),                   // 1-bit output: End of Sequence
      .JTAGBUSY(JTAGBUSY),         // 1-bit output: JTAG DRP transaction in progress output
      .JTAGLOCKED(JTAGLOCKED),     // 1-bit output: JTAG requested DRP port lock
      .JTAGMODIFIED(JTAGMODIFIED), // 1-bit output: JTAG Write to the DRP has occurred
      .MUXADDR(MUXADDR),           // 5-bit output: External MUX channel decode
      // Auxiliary Analog-Input Pairs: 16-bit (each) input: VAUXP[15:0], VAUXN[15:0]
      .VAUXN(VAUXN),               // 16-bit input: N-side auxiliary analog input
      .VAUXP(VAUXP),               // 16-bit input: P-side auxiliary analog input
      // CONTROL and CLOCK: 1-bit (each) input: Reset, conversion start and clock inputs
      .CONVST(CONVST),             // 1-bit input: Convert start input
      .CONVSTCLK(CONVSTCLK),       // 1-bit input: Convert start input
      .RESET(RESET),               // 1-bit input: Active-high reset
      // Dedicated Analog Input Pair: 1-bit (each) input: VP/VN
      .VN(VN),                     // 1-bit input: N-side analog input
      .VP(VP),                     // 1-bit input: P-side analog input
      // Dynamic Reconfiguration Port (DRP): 7-bit (each) input: Dynamic Reconfiguration Ports
      .DADDR(DADDR),               // 7-bit input: DRP address bus
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable signal
      .DI(DI),                     // 16-bit input: DRP input data bus
      .DWE(DWE)                    // 1-bit input: DRP write enable
   );

   // End of XADC_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Arithmetic Functions" treetype="folder">
				<Template label="48-bit Multi-Functional Arithmetic Block (DSP48E1)" treetype="template">
//   DSP48E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DSP48E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DSP48E1: 48-bit Multi-Functional Arithmetic Block
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   DSP48E1 #(
      // Feature Control Attributes: Data Path Selection
      .A_INPUT("DIRECT"),               // Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
      .B_INPUT("DIRECT"),               // Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
      .USE_DPORT("FALSE"),              // Select D port usage (TRUE or FALSE)
      .USE_MULT("MULTIPLY"),            // Select multiplier usage ("MULTIPLY", "DYNAMIC", or "NONE")
      .USE_SIMD("ONE48"),               // SIMD selection ("ONE48", "TWO24", "FOUR12")
      // Pattern Detector Attributes: Pattern Detection Configuration
      .AUTORESET_PATDET("NO_RESET"),    // "NO_RESET", "RESET_MATCH", "RESET_NOT_MATCH" 
      .MASK(48'h3fffffffffff),          // 48-bit mask value for pattern detect (1=ignore)
      .PATTERN(48'h000000000000),       // 48-bit pattern match for pattern detect
      .SEL_MASK("MASK"),                // "C", "MASK", "ROUNDING_MODE1", "ROUNDING_MODE2" 
      .SEL_PATTERN("PATTERN"),          // Select pattern value ("PATTERN" or "C")
      .USE_PATTERN_DETECT("NO_PATDET"), // Enable pattern detect ("PATDET" or "NO_PATDET")
      // Register Control Attributes: Pipeline Register Configuration
      .ACASCREG(1),                     // Number of pipeline stages between A/ACIN and ACOUT (0, 1 or 2)
      .ADREG(1),                        // Number of pipeline stages for pre-adder (0 or 1)
      .ALUMODEREG(1),                   // Number of pipeline stages for ALUMODE (0 or 1)
      .AREG(1),                         // Number of pipeline stages for A (0, 1 or 2)
      .BCASCREG(1),                     // Number of pipeline stages between B/BCIN and BCOUT (0, 1 or 2)
      .BREG(1),                         // Number of pipeline stages for B (0, 1 or 2)
      .CARRYINREG(1),                   // Number of pipeline stages for CARRYIN (0 or 1)
      .CARRYINSELREG(1),                // Number of pipeline stages for CARRYINSEL (0 or 1)
      .CREG(1),                         // Number of pipeline stages for C (0 or 1)
      .DREG(1),                         // Number of pipeline stages for D (0 or 1)
      .INMODEREG(1),                    // Number of pipeline stages for INMODE (0 or 1)
      .MREG(1),                         // Number of multiplier pipeline stages (0 or 1)
      .OPMODEREG(1),                    // Number of pipeline stages for OPMODE (0 or 1)
      .PREG(1)                          // Number of pipeline stages for P (0 or 1)
   )
   DSP48E1_inst (
      // Cascade: 30-bit (each) output: Cascade Ports
      .ACOUT(ACOUT),                   // 30-bit output: A port cascade output
      .BCOUT(BCOUT),                   // 18-bit output: B port cascade output
      .CARRYCASCOUT(CARRYCASCOUT),     // 1-bit output: Cascade carry output
      .MULTSIGNOUT(MULTSIGNOUT),       // 1-bit output: Multiplier sign cascade output
      .PCOUT(PCOUT),                   // 48-bit output: Cascade output
      // Control: 1-bit (each) output: Control Inputs/Status Bits
      .OVERFLOW(OVERFLOW),             // 1-bit output: Overflow in add/acc output
      .PATTERNBDETECT(PATTERNBDETECT), // 1-bit output: Pattern bar detect output
      .PATTERNDETECT(PATTERNDETECT),   // 1-bit output: Pattern detect output
      .UNDERFLOW(UNDERFLOW),           // 1-bit output: Underflow in add/acc output
      // Data: 4-bit (each) output: Data Ports
      .CARRYOUT(CARRYOUT),             // 4-bit output: Carry output
      .P(P),                           // 48-bit output: Primary data output
      // Cascade: 30-bit (each) input: Cascade Ports
      .ACIN(ACIN),                     // 30-bit input: A cascade data input
      .BCIN(BCIN),                     // 18-bit input: B cascade input
      .CARRYCASCIN(CARRYCASCIN),       // 1-bit input: Cascade carry input
      .MULTSIGNIN(MULTSIGNIN),         // 1-bit input: Multiplier sign input
      .PCIN(PCIN),                     // 48-bit input: P cascade input
      // Control: 4-bit (each) input: Control Inputs/Status Bits
      .ALUMODE(ALUMODE),               // 4-bit input: ALU control input
      .CARRYINSEL(CARRYINSEL),         // 3-bit input: Carry select input
      .CLK(CLK),                       // 1-bit input: Clock input
      .INMODE(INMODE),                 // 5-bit input: INMODE control input
      .OPMODE(OPMODE),                 // 7-bit input: Operation mode input
      // Data: 30-bit (each) input: Data Ports
      .A(A),                           // 30-bit input: A data input
      .B(B),                           // 18-bit input: B data input
      .C(C),                           // 48-bit input: C data input
      .CARRYIN(CARRYIN),               // 1-bit input: Carry input signal
      .D(D),                           // 25-bit input: D data input
      // Reset/Clock Enable: 1-bit (each) input: Reset/Clock Enable Inputs
      .CEA1(CEA1),                     // 1-bit input: Clock enable input for 1st stage AREG
      .CEA2(CEA2),                     // 1-bit input: Clock enable input for 2nd stage AREG
      .CEAD(CEAD),                     // 1-bit input: Clock enable input for ADREG
      .CEALUMODE(CEALUMODE),           // 1-bit input: Clock enable input for ALUMODE
      .CEB1(CEB1),                     // 1-bit input: Clock enable input for 1st stage BREG
      .CEB2(CEB2),                     // 1-bit input: Clock enable input for 2nd stage BREG
      .CEC(CEC),                       // 1-bit input: Clock enable input for CREG
      .CECARRYIN(CECARRYIN),           // 1-bit input: Clock enable input for CARRYINREG
      .CECTRL(CECTRL),                 // 1-bit input: Clock enable input for OPMODEREG and CARRYINSELREG
      .CED(CED),                       // 1-bit input: Clock enable input for DREG
      .CEINMODE(CEINMODE),             // 1-bit input: Clock enable input for INMODEREG
      .CEM(CEM),                       // 1-bit input: Clock enable input for MREG
      .CEP(CEP),                       // 1-bit input: Clock enable input for PREG
      .RSTA(RSTA),                     // 1-bit input: Reset input for AREG
      .RSTALLCARRYIN(RSTALLCARRYIN),   // 1-bit input: Reset input for CARRYINREG
      .RSTALUMODE(RSTALUMODE),         // 1-bit input: Reset input for ALUMODEREG
      .RSTB(RSTB),                     // 1-bit input: Reset input for BREG
      .RSTC(RSTC),                     // 1-bit input: Reset input for CREG
      .RSTCTRL(RSTCTRL),               // 1-bit input: Reset input for OPMODEREG and CARRYINSELREG
      .RSTD(RSTD),                     // 1-bit input: Reset input for DREG and ADREG
      .RSTINMODE(RSTINMODE),           // 1-bit input: Reset input for INMODEREG
      .RSTM(RSTM),                     // 1-bit input: Reset input for MREG
      .RSTP(RSTP)                      // 1-bit input: Reset input for PREG
   );

   // End of DSP48E1_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="Clock Components" treetype="folder">
				<SubFolder label="Clock Buffers" treetype="folder">
					<Template label="Global Clock Buffer with Clock Enable and Output State 1 (BUFGCE_1)" treetype="template">
//  BUFGCE_1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE_1: Global Clock Buffer with Clock Enable and Output State 1
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE_1 BUFGCE_1_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock enable input for I0
      .I(I)    // 1-bit input: Primary clock
   );

   // End of BUFGCE_1_inst instantiation
					</Template>
					<Template label="Global Clock Buffer with Clock Enable (BUFGCE)" treetype="template">
//   BUFGCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCE: Global Clock Buffer with Clock Enable
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGCE BUFGCE_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Clock enable input for I0
      .I(I)    // 1-bit input: Primary clock
   );

   // End of BUFGCE_inst instantiation
					</Template>
					<Template label="Global Clock Simple Buffer (BUFG)" treetype="template">
//    BUFG     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFG_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFG: Global Clock Simple Buffer
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFG BUFG_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFG_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer (BUFH)" treetype="template">
//    BUFH     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFH_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFH: HROW Clock Buffer for a Single Clocking Region
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFH BUFH_inst (
      .O(O), // 1-bit output: Clock output
      .I(I)  // 1-bit input: Clock input
   );

   // End of BUFH_inst instantiation
					</Template>
					<Template label="HROW Clock Buffer with Clock Enable (BUFHCE)" treetype="template">
//   BUFHCE    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFHCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFHCE: HROW Clock Buffer for a Single Clocking Region with Clock Enable
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFHCE #(
      .CE_TYPE("SYNC"), // "SYNC" (glitchless switching) or "ASYNC" (immediate switch)
      .INIT_OUT(0)      // Initial output value (0-1)
   )
   BUFHCE_inst (
      .O(O),   // 1-bit output: Clock output
      .CE(CE), // 1-bit input: Active high enable
      .I(I)    // 1-bit input: Clock input
   );

   // End of BUFHCE_inst instantiation
					</Template>
					<Template label="I/O Clock Buffer (BUFIO)" treetype="template">
//    BUFIO    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFIO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFIO: Local Clock Buffer for I/O
   //        Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFIO BUFIO_inst (
      .O(O), // 1-bit output: Clock output (connect to I/O clock loads).
      .I(I)  // 1-bit input: Clock input (connect to an IBUF or BUFMR).
   );

   // End of BUFIO_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer (BUFMR)" treetype="template">
//    BUFMR    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFMR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFMR: Multi-Region Clock Buffer
   //        Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFMR BUFMR_inst (
      .O(O), // 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      .I(I)  // 1-bit input: Clock input (Connect to IBUF)
   );

   // End of BUFMR_inst instantiation
					</Template>
					<Template label="Multi-Region Clock Buffer with Clock Enable (BUFMRCE)" treetype="template">
//   BUFMRCE   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFMRCE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFMRCE: Multi-Region Clock Buffer with Clock Enable
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFMRCE #(
      .CE_TYPE("SYNC"), // SYNC, ASYNC
      .INIT_OUT(0)      // Initial output and stopped polarity, (0-1)
   )
   BUFMRCE_inst (
      .O(O),   // 1-bit output: Clock output (connect to BUFIOs/BUFRs)
      .CE(CE), // 1-bit input: Active high buffer enable
      .I(I)    // 1-bit input: Clock input (Connect to IBUF)
   );

   // End of BUFMRCE_inst instantiation
					</Template>
					<Template label="Regional Clock Buffer (BUFR)" treetype="template">
//    BUFR     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFR: Regional Clock Buffer for I/O and Logic Resources within a Clock Region
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFR #(
      .BUFR_DIVIDE("BYPASS"),   // Values: "BYPASS, 1, 2, 3, 4, 5, 6, 7, 8" 
      .SIM_DEVICE("7SERIES")  // Must be set to "7SERIES" 
   )
   BUFR_inst (
      .O(O),     // 1-bit output: Clock output port
      .CE(CE),   // 1-bit input: Active high, clock enable (Divided modes only)
      .CLR(CLR), // 1-bit input: Active high, asynchronous clear (Divided modes only)
      .I(I)      // 1-bit input: Clock buffer input driven by an IBUF, MMCM or local interconnect
   );

   // End of BUFR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Clock MUXes" treetype="folder">
					<Template label="2-to-1 Global Clock MUX Buffer (BUFGMUX_CTRL)" treetype="template">
// BUFGMUX_CTRL : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (BUFGMUX_CTRL_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_CTRL: 2-to-1 Global Clock MUX Buffer
   //               Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_CTRL BUFGMUX_CTRL_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_CTRL_inst instantiation
					</Template>
					<Template label="Global Clock Control Buffer (BUFGCTRL)" treetype="template">
//  BUFGCTRL   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGCTRL: Global Clock Control Buffer
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGCTRL #(
      .INIT_OUT(0),           // Initial value of BUFGCTRL output ($VALUES;)
      .PRESELECT_I0("FALSE"), // BUFGCTRL output uses I0 input ($VALUES;)
      .PRESELECT_I1("FALSE")  // BUFGCTRL output uses I1 input ($VALUES;)
   )
   BUFGCTRL_inst (
      .O(O),             // 1-bit output: Clock output
      .CE0(CE0),         // 1-bit input: Clock enable input for I0
      .CE1(CE1),         // 1-bit input: Clock enable input for I1
      .I0(I0),           // 1-bit input: Primary clock
      .I1(I1),           // 1-bit input: Secondary clock
      .IGNORE0(IGNORE0), // 1-bit input: Clock ignore input for I0
      .IGNORE1(IGNORE1), // 1-bit input: Clock ignore input for I1
      .S0(S0),           // 1-bit input: Clock select for I0
      .S1(S1)            // 1-bit input: Clock select for I1
   );

   // End of BUFGCTRL_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer (BUFGMUX)" treetype="template">
//   BUFGMUX   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX: Global Clock Mux Buffer
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX #(
   )
   BUFGMUX_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_inst instantiation
					</Template>
					<Template label="Global Clock Mux Buffer with Output State 1 (BUFGMUX_1)" treetype="template">
//  BUFGMUX_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BUFGMUX_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BUFGMUX_1: Global Clock Mux Buffer with Output State 1
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BUFGMUX_1 #(
   )
   BUFGMUX_1_inst (
      .O(O),   // 1-bit output: Clock output
      .I0(I0), // 1-bit input: Clock input (S=0)
      .I1(I1), // 1-bit input: Clock input (S=1)
      .S(S)    // 1-bit input: Clock select
   );

   // End of BUFGMUX_1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MMCM / PLL" treetype="folder">
					<Template label="Advanced Mixed Mode Clock Manager (MMCME2_ADV)" treetype="template">
// MMCME2_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME2_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME2_ADV: Advanced Mixed Mode Clock Manager
   //             Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   MMCME2_ADV #(
      .BANDWIDTH("OPTIMIZED"),        // Jitter programming (OPTIMIZED, HIGH, LOW)
      .CLKFBOUT_MULT_F(5.0),          // Multiply value for all CLKOUT (2.000-64.000).
      .CLKFBOUT_PHASE(0.0),           // Phase offset in degrees of CLKFB (-360.000-360.000).
      // CLKIN_PERIOD: Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      // CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT0_DIVIDE_F(1.0),         // Divide amount for CLKOUT0 (1.000-128.000).
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.01-0.99).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      .CLKOUT4_CASCADE("FALSE"),      // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .COMPENSATION("ZHOLD"),         // ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      .DIVCLK_DIVIDE(1),              // Master division value (1-106)
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE"),         // Delays DONE until MMCM is locked (FALSE, TRUE)
      // Spread Spectrum: Spread Spectrum Attributes
      .SS_EN("FALSE"),                // Enables spread spectrum (FALSE, TRUE)
      .SS_MODE("CENTER_HIGH"),        // CENTER_HIGH, CENTER_LOW, DOWN_HIGH, DOWN_LOW
      .SS_MOD_PERIOD(10000),          // Spread spectrum modulation period (ns) (VALUES)
      // USE_FINE_PS: Fine phase shift enable (TRUE/FALSE)
      .CLKFBOUT_USE_FINE_PS("FALSE"),
      .CLKOUT0_USE_FINE_PS("FALSE"),
      .CLKOUT1_USE_FINE_PS("FALSE"),
      .CLKOUT2_USE_FINE_PS("FALSE"),
      .CLKOUT3_USE_FINE_PS("FALSE"),
      .CLKOUT4_USE_FINE_PS("FALSE"),
      .CLKOUT5_USE_FINE_PS("FALSE"),
      .CLKOUT6_USE_FINE_PS("FALSE") 
   )
   MMCME2_ADV_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),           // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),         // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),           // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),         // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),           // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),         // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),           // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),         // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),           // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),           // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),           // 1-bit output: CLKOUT6
      // DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      .DO(DO),                     // 16-bit output: DRP data
      .DRDY(DRDY),                 // 1-bit output: DRP ready
      // Dynamic Phase Shift Ports: 1-bit (each) output: Ports used for dynamic phase shifting of the outputs
      .PSDONE(PSDONE),             // 1-bit output: Phase shift done
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),         // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB),       // 1-bit output: Inverted CLKFBOUT
      // Status Ports: 1-bit (each) output: MMCM status ports
      .CLKFBSTOPPED(CLKFBSTOPPED), // 1-bit output: Feedback clock stopped
      .CLKINSTOPPED(CLKINSTOPPED), // 1-bit output: Input clock stopped
      .LOCKED(LOCKED),             // 1-bit output: LOCK
      // Clock Inputs: 1-bit (each) input: Clock inputs
      .CLKIN1(CLKIN1),             // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),             // 1-bit input: Secondary clock
      // Control Ports: 1-bit (each) input: MMCM control ports
      .CLKINSEL(CLKINSEL),         // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),             // 1-bit input: Power-down
      .RST(RST),                   // 1-bit input: Reset
      // DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      .DADDR(DADDR),               // 7-bit input: DRP address
      .DCLK(DCLK),                 // 1-bit input: DRP clock
      .DEN(DEN),                   // 1-bit input: DRP enable
      .DI(DI),                     // 16-bit input: DRP data
      .DWE(DWE),                   // 1-bit input: DRP write enable
      // Dynamic Phase Shift Ports: 1-bit (each) input: Ports used for dynamic phase shifting of the outputs
      .PSCLK(PSCLK),               // 1-bit input: Phase shift clock
      .PSEN(PSEN),                 // 1-bit input: Phase shift enable
      .PSINCDEC(PSINCDEC),         // 1-bit input: Phase shift increment/decrement
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)            // 1-bit input: Feedback clock
   );

   // End of MMCME2_ADV_inst instantiation
					</Template>
					<Template label="Advanced Phase Locked Loop (PLLE2_ADV)" treetype="template">
//  PLLE2_ADV  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE2_ADV_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE2_ADV: Advanced Phase Locked Loop (PLL)
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   PLLE2_ADV #(
      .BANDWIDTH("OPTIMIZED"),  // OPTIMIZED, HIGH, LOW
      .CLKFBOUT_MULT(5),        // Multiply value for all CLKOUT, (2-64)
      .CLKFBOUT_PHASE(0.0),     // Phase offset in degrees of CLKFB, (-360.000-360.000).
      // CLKIN_PERIOD: Input clock period in nS to ps resolution (i.e. 33.333 is 30 MHz).
      .CLKIN1_PERIOD(0.0),
      .CLKIN2_PERIOD(0.0),
      // CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for CLKOUT (1-128)
      .CLKOUT0_DIVIDE(1),
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      // CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for CLKOUT outputs (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for CLKOUT outputs (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .COMPENSATION("ZHOLD"),   // ZHOLD, BUF_IN, EXTERNAL, INTERNAL
      .DIVCLK_DIVIDE(1),        // Master division value (1-56)
      // REF_JITTER: Reference input jitter in UI (0.000-0.999).
      .REF_JITTER1(0.0),
      .REF_JITTER2(0.0),
      .STARTUP_WAIT("FALSE")    // Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   PLLE2_ADV_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),   // 1-bit output: CLKOUT0
      .CLKOUT1(CLKOUT1),   // 1-bit output: CLKOUT1
      .CLKOUT2(CLKOUT2),   // 1-bit output: CLKOUT2
      .CLKOUT3(CLKOUT3),   // 1-bit output: CLKOUT3
      .CLKOUT4(CLKOUT4),   // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),   // 1-bit output: CLKOUT5
      // DRP Ports: 16-bit (each) output: Dynamic reconfiguration ports
      .DO(DO),             // 16-bit output: DRP data
      .DRDY(DRDY),         // 1-bit output: DRP ready
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT), // 1-bit output: Feedback clock
      .LOCKED(LOCKED),     // 1-bit output: LOCK
      // Clock Inputs: 1-bit (each) input: Clock inputs
      .CLKIN1(CLKIN1),     // 1-bit input: Primary clock
      .CLKIN2(CLKIN2),     // 1-bit input: Secondary clock
      // Control Ports: 1-bit (each) input: PLL control ports
      .CLKINSEL(CLKINSEL), // 1-bit input: Clock select, High=CLKIN1 Low=CLKIN2
      .PWRDWN(PWRDWN),     // 1-bit input: Power-down
      .RST(RST),           // 1-bit input: Reset
      // DRP Ports: 7-bit (each) input: Dynamic reconfiguration ports
      .DADDR(DADDR),       // 7-bit input: DRP address
      .DCLK(DCLK),         // 1-bit input: DRP clock
      .DEN(DEN),           // 1-bit input: DRP enable
      .DI(DI),             // 16-bit input: DRP data
      .DWE(DWE),           // 1-bit input: DRP write enable
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)    // 1-bit input: Feedback clock
   );

   // End of PLLE2_ADV_inst instantiation
					</Template>
					<Template label="Base Mixed Mode Clock Manager (MMCME2_BASE)" treetype="template">
// MMCME2_BASE : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MMCME2_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MMCME2_BASE: Base Mixed Mode Clock Manager
   //              Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   MMCME2_BASE #(
      .BANDWIDTH("OPTIMIZED"),   // Jitter programming (OPTIMIZED, HIGH, LOW)
      .CLKFBOUT_MULT_F(5.0),     // Multiply value for all CLKOUT (2.000-64.000).
      .CLKFBOUT_PHASE(0.0),      // Phase offset in degrees of CLKFB (-360.000-360.000).
      .CLKIN1_PERIOD(0.0),       // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0_DIVIDE - CLKOUT6_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      .CLKOUT6_DIVIDE(1),
      .CLKOUT0_DIVIDE_F(1.0),    // Divide amount for CLKOUT0 (1.000-128.000).
      // CLKOUT0_DUTY_CYCLE - CLKOUT6_DUTY_CYCLE: Duty cycle for each CLKOUT (0.01-0.99).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      .CLKOUT6_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT6_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .CLKOUT6_PHASE(0.0),
      .CLKOUT4_CASCADE("FALSE"), // Cascade CLKOUT4 counter with CLKOUT6 (FALSE, TRUE)
      .DIVCLK_DIVIDE(1),         // Master division value (1-106)
      .REF_JITTER1(0.0),         // Reference input jitter in UI (0.000-0.999).
      .STARTUP_WAIT("FALSE")     // Delays DONE until MMCM is locked (FALSE, TRUE)
   )
   MMCME2_BASE_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),     // 1-bit output: CLKOUT0
      .CLKOUT0B(CLKOUT0B),   // 1-bit output: Inverted CLKOUT0
      .CLKOUT1(CLKOUT1),     // 1-bit output: CLKOUT1
      .CLKOUT1B(CLKOUT1B),   // 1-bit output: Inverted CLKOUT1
      .CLKOUT2(CLKOUT2),     // 1-bit output: CLKOUT2
      .CLKOUT2B(CLKOUT2B),   // 1-bit output: Inverted CLKOUT2
      .CLKOUT3(CLKOUT3),     // 1-bit output: CLKOUT3
      .CLKOUT3B(CLKOUT3B),   // 1-bit output: Inverted CLKOUT3
      .CLKOUT4(CLKOUT4),     // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),     // 1-bit output: CLKOUT5
      .CLKOUT6(CLKOUT6),     // 1-bit output: CLKOUT6
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT),   // 1-bit output: Feedback clock
      .CLKFBOUTB(CLKFBOUTB), // 1-bit output: Inverted CLKFBOUT
      // Status Ports: 1-bit (each) output: MMCM status ports
      .LOCKED(LOCKED),       // 1-bit output: LOCK
      // Clock Inputs: 1-bit (each) input: Clock input
      .CLKIN1(CLKIN1),       // 1-bit input: Clock
      // Control Ports: 1-bit (each) input: MMCM control ports
      .PWRDWN(PWRDWN),       // 1-bit input: Power-down
      .RST(RST),             // 1-bit input: Reset
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)      // 1-bit input: Feedback clock
   );

   // End of MMCME2_BASE_inst instantiation
					</Template>
					<Template label="Base Phase Locked Loop (PLLE2_BASE)" treetype="template">
// PLLE2_BASE  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (PLLE2_BASE_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // PLLE2_BASE: Base Phase Locked Loop (PLL)
   //             Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   PLLE2_BASE #(
      .BANDWIDTH("OPTIMIZED"),  // OPTIMIZED, HIGH, LOW
      .CLKFBOUT_MULT(5),        // Multiply value for all CLKOUT, (2-64)
      .CLKFBOUT_PHASE(0.0),     // Phase offset in degrees of CLKFB, (-360.000-360.000).
      .CLKIN1_PERIOD(0.0),      // Input clock period in ns to ps resolution (i.e. 33.333 is 30 MHz).
      // CLKOUT0_DIVIDE - CLKOUT5_DIVIDE: Divide amount for each CLKOUT (1-128)
      .CLKOUT0_DIVIDE(1),
      .CLKOUT1_DIVIDE(1),
      .CLKOUT2_DIVIDE(1),
      .CLKOUT3_DIVIDE(1),
      .CLKOUT4_DIVIDE(1),
      .CLKOUT5_DIVIDE(1),
      // CLKOUT0_DUTY_CYCLE - CLKOUT5_DUTY_CYCLE: Duty cycle for each CLKOUT (0.001-0.999).
      .CLKOUT0_DUTY_CYCLE(0.5),
      .CLKOUT1_DUTY_CYCLE(0.5),
      .CLKOUT2_DUTY_CYCLE(0.5),
      .CLKOUT3_DUTY_CYCLE(0.5),
      .CLKOUT4_DUTY_CYCLE(0.5),
      .CLKOUT5_DUTY_CYCLE(0.5),
      // CLKOUT0_PHASE - CLKOUT5_PHASE: Phase offset for each CLKOUT (-360.000-360.000).
      .CLKOUT0_PHASE(0.0),
      .CLKOUT1_PHASE(0.0),
      .CLKOUT2_PHASE(0.0),
      .CLKOUT3_PHASE(0.0),
      .CLKOUT4_PHASE(0.0),
      .CLKOUT5_PHASE(0.0),
      .DIVCLK_DIVIDE(1),        // Master division value, (1-56)
      .REF_JITTER1(0.0),        // Reference input jitter in UI, (0.000-0.999).
      .STARTUP_WAIT("FALSE")    // Delay DONE until PLL Locks, ("TRUE"/"FALSE")
   )
   PLLE2_BASE_inst (
      // Clock Outputs: 1-bit (each) output: User configurable clock outputs
      .CLKOUT0(CLKOUT0),   // 1-bit output: CLKOUT0
      .CLKOUT1(CLKOUT1),   // 1-bit output: CLKOUT1
      .CLKOUT2(CLKOUT2),   // 1-bit output: CLKOUT2
      .CLKOUT3(CLKOUT3),   // 1-bit output: CLKOUT3
      .CLKOUT4(CLKOUT4),   // 1-bit output: CLKOUT4
      .CLKOUT5(CLKOUT5),   // 1-bit output: CLKOUT5
      // Feedback Clocks: 1-bit (each) output: Clock feedback ports
      .CLKFBOUT(CLKFBOUT), // 1-bit output: Feedback clock
      .LOCKED(LOCKED),     // 1-bit output: LOCK
      .CLKIN1(CLKIN1),     // 1-bit input: Input clock
      // Control Ports: 1-bit (each) input: PLL control ports
      .PWRDWN(PWRDWN),     // 1-bit input: Power-down
      .RST(RST),           // 1-bit input: Reset
      // Feedback Clocks: 1-bit (each) input: Clock feedback ports
      .CLKFBIN(CLKFBIN)    // 1-bit input: Feedback clock
   );

   // End of PLLE2_BASE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Config/BSCAN Components" treetype="folder">
				<Template label="32-bit non-volatile design ID (EFUSE_USR)" treetype="template">
//  EFUSE_USR  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (EFUSE_USR_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // EFUSE_USR: 32-bit non-volatile design ID
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   EFUSE_USR #(
      .SIM_EFUSE_VALUE(32'h00000000)  // Value of the 32-bit non-volatile value used in simulation
   )
   EFUSE_USR_inst (
      .EFUSEUSR(EFUSEUSR)  // 32-bit output: User eFUSE register value output
   );

   // End of EFUSE_USR_inst instantiation
				</Template>
				<Template label="Boundary-Scan User Instruction (BSCANE2)" treetype="template">
//   BSCANE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (BSCANE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // BSCANE2: Boundary-Scan User Instruction
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   BSCANE2 #(
      .JTAG_CHAIN(1)  // Value for USER command.
   )
   BSCANE2_inst (
      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.
      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or
                         // SHIFT are asserted.

      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.
      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.
      .SEL(SEL),         // 1-bit output: USER instruction active output.
      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.
      .TCK(TCK),         // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.
      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.
      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.
      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller
      .TDO(TDO)          // 1-bit input: Test Data Output (TDO) input for USER function.
   );

   // End of BSCANE2_inst instantiation
				</Template>
				<Template label="Configuration Data Access (USR_ACCESSE2)" treetype="template">
// USR_ACCESSE2 : In order to incorporate this function into the design,
//   Verilog    : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
// declaration  : (USR_ACCESSE2_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  All inputs
//              : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // USR_ACCESSE2: Configuration Data Access
   //               Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   USR_ACCESSE2 USR_ACCESSE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration Clock output
      .DATA(DATA),           // 32-bit output: Configuration Data output
      .DATAVALID(DATAVALID)  // 1-bit output: Active high data valid output
   );

   // End of USR_ACCESSE2_inst instantiation
				</Template>
				<Template label="Configuration Frame Error Correction (FRAME_ECCE2)" treetype="template">
// FRAME_ECCE2 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FRAME_ECCE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FRAME_ECCE2: Configuration Frame Error Correction
   //              Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   FRAME_ECCE2 #(
      .FARSRC("EFAR"),                // Determines if the output of FAR[25:0] configuration register points to
                                      // the FAR or EFAR. Sets configuration option register bit CTL0[7].
      .FRAME_RBT_IN_FILENAME("None")  // This file is output by the ICAP_E2 model and it contains Frame Data
                                      // information for the Raw Bitstream (RBT) file. The FRAME_ECCE2 model
                                      // will parse this file, calculate ECC and output any error conditions.
   )
   FRAME_ECCE2_inst (
      .CRCERROR(CRCERROR),             // 1-bit output: Output indicating a CRC error.
      .ECCERROR(ECCERROR),             // 1-bit output: Output indicating an ECC error.
      .ECCERRORSINGLE(ECCERRORSINGLE), // 1-bit output: Output Indicating single-bit Frame ECC error detected.
      .FAR(FAR),                       // 26-bit output: Frame Address Register Value output.
      .SYNBIT(SYNBIT),                 // 5-bit output: Output bit address of error.
      .SYNDROME(SYNDROME),             // 13-bit output: Output location of erroneous bit.
      .SYNDROMEVALID(SYNDROMEVALID),   // 1-bit output: Frame ECC output indicating the SYNDROME output is
                                       // valid.

      .SYNWORD(SYNWORD)                // 7-bit output: Word output in the frame where an ECC error has been
                                       // detected.

   );

   // End of FRAME_ECCE2_inst instantiation
				</Template>
				<Template label="Device DNA Access Port (DNA_PORT)" treetype="template">
//  DNA_PORT   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DNA_PORT_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DNA_PORT: Device DNA Access Port
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   DNA_PORT #(
      .SIM_DNA_VALUE(57'h000000000000000)  // Specifies a sample 57-bit DNA value for simulation
   )
   DNA_PORT_inst (
      .DOUT(DOUT),   // 1-bit output: DNA output data.
      .CLK(CLK),     // 1-bit input: Clock input.
      .DIN(DIN),     // 1-bit input: User data input pin.
      .READ(READ),   // 1-bit input: Active high load DNA, active low read input.
      .SHIFT(SHIFT)  // 1-bit input: Active high shift enable input.
   );

   // End of DNA_PORT_inst instantiation
				</Template>
				<Template label="Internal Configuration Access Port (ICAPE2)" treetype="template">
//   ICAPE2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ICAPE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ICAPE2: Internal Configuration Access Port
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   ICAPE2 #(
      .DEVICE_ID(0'h3651093),     // Specifies the pre-programmed Device ID value to be used for simulation
                                  // purposes.
      .ICAP_WIDTH("X32"),         // Specifies the input and output data width.
      .SIM_CFG_FILE_NAME("None")  // Specifies the Raw Bitstream (RBT) file to be parsed by the simulation
                                  // model.
   )
   ICAPE2_inst (
      .O(O),         // 32-bit output: Configuration data output bus
      .CLK(CLK),     // 1-bit input: Clock Input
      .CSIB(CSIB),   // 1-bit input: Active-Low ICAP Enable
      .I(I),         // 32-bit input: Configuration data input bus
      .RDWRB(RDWRB)  // 1-bit input: Read/Write Select input
   );

   // End of ICAPE2_inst instantiation
				</Template>
				<Template label="Register Capture (CAPTUREE2)" treetype="template">
//  CAPTUREE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CAPTUREE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CAPTUREE2: Register Capture
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   CAPTUREE2 #(
      .ONESHOT("TRUE")  // Specifies the procedure for performing single readback per CAP trigger.
   )
   CAPTUREE2_inst (
      .CAP(CAP), // 1-bit input: Capture Input
      .CLK(CLK)  // 1-bit input: Clock Input
   );

   // End of CAPTUREE2_inst instantiation
				</Template>
				<Template label="STARTUP Block (STARTUPE2)" treetype="template">
//  STARTUPE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (STARTUPE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // STARTUPE2: STARTUP Block
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   STARTUPE2 #(
      .PROG_USR("FALSE"),  // Activate program event security feature. Requires encrypted bitstreams.
      .SIM_CCLK_FREQ(0.0)  // Set the Configuration Clock Frequency(ns) for simulation.
   )
   STARTUPE2_inst (
      .CFGCLK(CFGCLK),       // 1-bit output: Configuration main clock output
      .CFGMCLK(CFGMCLK),     // 1-bit output: Configuration internal oscillator clock output
      .EOS(EOS),             // 1-bit output: Active high output signal indicating the End Of Startup.
      .PREQ(PREQ),           // 1-bit output: PROGRAM request to fabric output
      .CLK(CLK),             // 1-bit input: User start-up clock input
      .GSR(GSR),             // 1-bit input: Global Set/Reset input (GSR cannot be used for the port name)
      .GTS(GTS),             // 1-bit input: Global 3-state input (GTS cannot be used for the port name)
      .KEYCLEARB(KEYCLEARB), // 1-bit input: Clear AES Decrypter Key input from Battery-Backed RAM (BBRAM)
      .PACK(PACK),           // 1-bit input: PROGRAM acknowledge input
      .USRCCLKO(USRCCLKO),   // 1-bit input: User CCLK input
      .USRCCLKTS(USRCCLKTS), // 1-bit input: User CCLK 3-state enable input
      .USRDONEO(USRDONEO),   // 1-bit input: User DONE pin output control
      .USRDONETS(USRDONETS)  // 1-bit input: User DONE 3-state enable output
   );

   // End of STARTUPE2_inst instantiation
				</Template>
			</SubFolder>
			<SubFolder label="I/O Components" treetype="folder">
				<SubFolder label="Bi-directional Buffers" treetype="folder">
					<Template label="Differential Buffer (IOBUFDS)" treetype="template">
//     IOBUFDS   : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IOBUFDS_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS: Differential Bi-directional Buffer
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .SLEW("SLOW")            // Specify the output slew rate
   ) IOBUFDS_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ Differential Output, input and DCI disable (IOBUFDS_DIFF_OUT_DCIEN)" treetype="template">
// IOBUFDS_DIFF_OUT_DCIEN : In order to incorporate this function into the design,
//         Verilog        : the following instance declaration needs to be placed
//        instance        : in the body of the design code.  The instance name
//       declaration      : (IOBUFDS_DIFF_OUT_DCIEN_inst) and/or the port declarations within the
//          code          : parenthesis may be changed to properly reference and
//                        : connect this function to the design.  Delete or comment
//                        : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_DCIEN: Differential Bi-directional Buffer with Differential Output,
   //                         Digital Controlled Impedance (DCI)and Input path enable/disable
   //                         May only be placed in High Performance (HP) Banks
   //                         Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT_DCIEN #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUFDS_DIFF_OUT_DCIEN_inst (
      .O(O),     // Buffer p-side output
      .OB(OB),   // Buffer n-side output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .DCITERMDISABLE(DCITERMDISABLE), //  DCI Termination enable input
      .I(I),                           // Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // Input disable input, high=disable
      .TM(TM),   // 3-state enable input, high=input, low=output
      .TS(TS)    // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_DIFF_OUT_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ input and DCI disable (IOBUFDS_DCIEN)" treetype="template">
// IOBUFDS_DCIEN : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (IOBUFDS_DCIEN_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DCIEN: Differential Bi-directional Buffer with Digital Controlled Impedance (DCI)
   //                and Input path enable/disable
   //                May only be placed in High Performance (HP) Banks
   //                Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DCIEN #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .SLEW("SLOW"),           // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUFDS_DCIEN_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .DCITERMDISABLE(DCITERMDISABLE), // DCI Termination enable input
      .I(I),                           // Buffer input
      .IBUFDISABLE(IBUFDISABLE),       // Input disable input, high=disable
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_DCIEN_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ input and input termination disable (IOBUFDS_INTERMDISABLE)" treetype="template">
// IOBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//    Verilog    : the following instance declaration needs to be placed
//   instance    : in the body of the design code.  The instance name
//  declaration  : (IOBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//     code      : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_INTERMDISABLE: Differential Bi-directional Buffer with Input Termination
   //                        and Input path enable/disable
   //                        May only be placed in High Range (HR) Banks
   //                        Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_INTERMDISABLE #(
      .DIFF_TERM("FALSE"),     // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),   // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25"), // Specify the I/O standard
      .SLEW("SLOW"),           // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUFDS_INTERMDISABLE_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .IBUFDISABLE(IBUFDISABLE),     // Input disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // Input termination disable input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output (IOBUFDS_DIFF_OUT)" treetype="template">
// IOBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//      Verilog     : the following instance declaration needs to be placed
//     instance     : in the body of the design code.  The instance name
//    declaration   : (IOBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//       code       : parenthesis may be changed to properly reference and
//                  : connect this function to the design.  Delete or comment
//                  : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT: Differential Bi-directional Buffer with Differential Output
   //                   Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUFDS_DIFF_OUT #(
      .DIFF_TERM("FALSE"),    // Differential Termination ("TRUE"/"FALSE")
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("BLVDS_25") // Specify the I/O standard
   ) IOBUFDS_DIFF_OUT_inst (
      .O(O),     // Buffer p-side output
      .OB(OB),   // Buffer n-side output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .TM(TM),   // 3-state enable input, high=input, low=output
      .TS(TS)    // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Global Clock Buffer w/ Differential Output, INTERM and IBUF disable (IOBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IOBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog             : the following instance declaration needs to be placed
//           instance             : in the body of the design code.  The instance name
//          declaration           : (IOBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code               : parenthesis may be changed to properly reference and
//                                : connect this function to the design.  All inputs
//                                : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IOBUFDS_DIFF_OUT_INTERMDISABLE: Differential Global Clock Buffer with Differential Output
   //                                 Input Termination and Input Path Disable
   //                                 May only be placed in High Range (HR) Banks
   //                                 Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IOBUFDS_DIFF_OUT_INTERMDISABLE #(
      .DIFF_TERM("FALSE"),     // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"),   // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IOBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),     // Buffer p-side output
      .OB(OB),   // Buffer n-side output
      .IO(IO),   // Diff_p inout (connect directly to top-level port)
      .IOB(IOB), // Diff_n inout (connect directly to top-level port)
      .I(I),     // Buffer input
      .INTERMDISABLE(INTERMDISABLE), //  Input termination disable input
      .IBUFDISABLE(IBUFDISABLE),     // Input disable input, high=disable
      .TM(TM),   // 3-state enable input, high=input, low=output
      .TS(TS)    // 3-state enable input, high=input, low=output
   );

   // End of IOBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Single-ended Buffer (IOBUF)" treetype="template">
//      IOBUF      : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IOBUF_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF: Single-ended Bi-directional Buffer
   //        All devices
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUF #(
      .DRIVE(12), // Specify the output drive strength
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("DEFAULT"), // Specify the I/O standard
      .SLEW("SLOW") // Specify the output slew rate
   ) IOBUF_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Buffer inout port (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUF_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ input and DCI disable (IOBUF_DCIEN)" treetype="template">
//   IOBUF_DCIEN   : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IOBUF_DCIEN_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_DCIEN: Single-ended Bi-directional Buffer with Digital Controlled Impedance (DCI)
   //              and Input path enable/disable
   //              May only be placed in High Performance (HP) Banks
   //              Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUF_DCIEN #(
      .DRIVE(12), // Specify the output drive strength
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("DEFAULT"), // Specify the I/O standard
      .SLEW("SLOW"),          // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUF_DCIEN_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Buffer inout port (connect directly to top-level port)
      .DCITERMDISABLE(DCITERMDISABLE), // DCI Termination enable input
      .I(I),     // Buffer input
      .IBUFDISABLE(IBUFDISABLE), // Input disable input, high=disable
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUF_DCIEN_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ input and INTERM disable (IOBUF_INTERMDISABLE)" treetype="template">
// IOBUF_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog       : the following instance declaration needs to be placed
//      instance       : in the body of the design code.  The instance name
//     declaration     : (IOBUF_INTERMDISABLE_inst) and/or the port declarations within the
//        code         : parenthesis may be changed to properly reference and
//                     : connect this function to the design.  Delete or comment
//                     : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IOBUF_INTERMDISABLE: Single-ended Bi-directional Buffer with Input Termination
   //                      and Input path enable/disable
   //                      May only be placed in High Range (HR) Banks
   //                      Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IOBUF_INTERMDISABLE #(
      .DRIVE(12), // Specify the output drive strength
      .IBUF_LOW_PWR("TRUE"),  // Low Power - "TRUE", High Performance = "FALSE" 
      .IOSTANDARD("DEFAULT"), // Specify the I/O standard
      .SLEW("SLOW"),          // Specify the output slew rate
      .USE_IBUFDISABLE("TRUE") // Use IBUFDISABLE function, "TRUE" or "FALSE" 
   ) IOBUF_INTERMDISABLE_inst (
      .O(O),     // Buffer output
      .IO(IO),   // Buffer inout port (connect directly to top-level port)
      .I(I),     // Buffer input
      .IBUFDISABLE(IBUFDISABLE), // Input disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE), // Input termination disable input
      .T(T)      // 3-state enable input, high=input, low=output
   );
  
   // End of IOBUF_INTERMDISABLE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="DDR Registers" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
//    IDDR_2CLK  : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   //            Set, Reset and Clock Enable.
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_2CLK_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit primary clock input
      .CB(CB), // 1-bit secondary clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_2CLK_inst instantiation
					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
//      IDDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR: Input Double Data Rate Input Register with Set, Reset
   //       and Clock Enable.
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_inst instantiation
					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
//      ODDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (ODDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // ODDR: Output Double Data Rate Output Register with Set, Reset
   //       and Clock Enable.
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   ODDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE" or "SAME_EDGE" 
      .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) ODDR_inst (
      .Q(Q),   // 1-bit DDR output
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D1(D1), // 1-bit data input (positive edge)
      .D2(D2), // 1-bit data input (negative edge)
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of ODDR_inst instantiation
					</Template>
				</SubFolder>
				<Template label="Digitally Controlled Impedance Reset Component (DCIRESET)" treetype="template">
//  DCIRESET   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (DCIRESET_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // DCIRESET: Digitally Controlled Impedance Reset Component
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   DCIRESET DCIRESET_inst (
      .LOCKED(LOCKED), // 1-bit output: LOCK status output
      .RST(RST)        // 1-bit input: Active-high asynchronous reset input
   );

   // End of DCIRESET_inst instantiation
				</Template>
				<SubFolder label="FIFOs" treetype="folder">
					<Template label="Input FIFO (IN_FIFO)" treetype="template">
//   IN_FIFO   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IN_FIFO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IN_FIFO: Input First-In, First-Out (FIFO)
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IN_FIFO #(
      .ALMOST_EMPTY_VALUE(1),          // Almost empty offset (1-2)
      .ALMOST_FULL_VALUE(1),           // Almost full offset (1-2)
      .ARRAY_MODE("ARRAY_MODE_4_X_8"), // ARRAY_MODE_4_X_8, ARRAY_MODE_4_X_4
      .SYNCHRONOUS_MODE("FALSE")       // Clock synchronous (FALSE)
   )
   IN_FIFO_inst (
      // FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output: Almost empty
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output: Almost full
      .EMPTY(EMPTY),             // 1-bit output: Empty
      .FULL(FULL),               // 1-bit output: Full
      // Q0-Q9: 8-bit (each) output: FIFO Outputs
      .Q0(Q0),                   // 8-bit output: Channel 0
      .Q1(Q1),                   // 8-bit output: Channel 1
      .Q2(Q2),                   // 8-bit output: Channel 2
      .Q3(Q3),                   // 8-bit output: Channel 3
      .Q4(Q4),                   // 8-bit output: Channel 4
      .Q5(Q5),                   // 8-bit output: Channel 5
      .Q6(Q6),                   // 8-bit output: Channel 6
      .Q7(Q7),                   // 8-bit output: Channel 7
      .Q8(Q8),                   // 8-bit output: Channel 8
      .Q9(Q9),                   // 8-bit output: Channel 9
      // D0-D9: 4-bit (each) input: FIFO inputs
      .D0(D0),                   // 4-bit input: Channel 0
      .D1(D1),                   // 4-bit input: Channel 1
      .D2(D2),                   // 4-bit input: Channel 2
      .D3(D3),                   // 4-bit input: Channel 3
      .D4(D4),                   // 4-bit input: Channel 4
      .D5(D5),                   // 8-bit input: Channel 5
      .D6(D6),                   // 8-bit input: Channel 6
      .D7(D7),                   // 4-bit input: Channel 7
      .D8(D8),                   // 4-bit input: Channel 8
      .D9(D9),                   // 4-bit input: Channel 9
      // FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      .RDCLK(RDCLK),             // 1-bit input: Read clock
      .RDEN(RDEN),               // 1-bit input: Read enable
      .RESET(RESET),             // 1-bit input: Reset
      .WRCLK(WRCLK),             // 1-bit input: Write clock
      .WREN(WREN)                // 1-bit input: Write enable
   );

   // End of IN_FIFO_inst instantiation
					</Template>
					<Template label="Output FIFO (OUT_FIFO)" treetype="template">
//  OUT_FIFO   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OUT_FIFO_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OUT_FIFO: Output First-In, First-Out (FIFO) Buffer
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   OUT_FIFO #(
      .ALMOST_EMPTY_VALUE(1),          // Almost empty offset (1-2)
      .ALMOST_FULL_VALUE(1),           // Almost full offset (1-2)
      .ARRAY_MODE("ARRAY_MODE_8_X_4"), // ARRAY_MODE_8_X_4, ARRAY_MODE_4_X_4
      .OUTPUT_DISABLE("FALSE"),        // Disable output (FALSE, TRUE)
      .SYNCHRONOUS_MODE("FALSE")       // Must always be set to false.
   )
   OUT_FIFO_inst (
      // FIFO Status Flags: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output: Almost empty flag
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output: Almost full flag
      .EMPTY(EMPTY),             // 1-bit output: Empty flag
      .FULL(FULL),               // 1-bit output: Full flag
      // Q0-Q9: 4-bit (each) output: FIFO Outputs
      .Q0(Q0),                   // 4-bit output: Channel 0 output bus
      .Q1(Q1),                   // 4-bit output: Channel 1 output bus
      .Q2(Q2),                   // 4-bit output: Channel 2 output bus
      .Q3(Q3),                   // 4-bit output: Channel 3 output bus
      .Q4(Q4),                   // 4-bit output: Channel 4 output bus
      .Q5(Q5),                   // 8-bit output: Channel 5 output bus
      .Q6(Q6),                   // 8-bit output: Channel 6 output bus
      .Q7(Q7),                   // 4-bit output: Channel 7 output bus
      .Q8(Q8),                   // 4-bit output: Channel 8 output bus
      .Q9(Q9),                   // 4-bit output: Channel 9 output bus
      // D0-D9: 8-bit (each) input: FIFO inputs
      .D0(D0),                   // 8-bit input: Channel 0 input bus
      .D1(D1),                   // 8-bit input: Channel 1 input bus
      .D2(D2),                   // 8-bit input: Channel 2 input bus
      .D3(D3),                   // 8-bit input: Channel 3 input bus
      .D4(D4),                   // 8-bit input: Channel 4 input bus
      .D5(D5),                   // 8-bit input: Channel 5 input bus
      .D6(D6),                   // 8-bit input: Channel 6 input bus
      .D7(D7),                   // 8-bit input: Channel 7 input bus
      .D8(D8),                   // 8-bit input: Channel 8 input bus
      .D9(D9),                   // 8-bit input: Channel 9 input bus
      // FIFO Control Signals: 1-bit (each) input: Clocks, Resets and Enables
      .RDCLK(RDCLK),             // 1-bit input: Read clock
      .RDEN(RDEN),               // 1-bit input: Read enable
      .RESET(RESET),             // 1-bit input: Active high reset
      .WRCLK(WRCLK),             // 1-bit input: Write clock
      .WREN(WREN)                // 1-bit input: Write enable
   );

   // End of OUT_FIFO_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Input Buffers" treetype="folder">
					<Template label="Differential Buffer (IBUFDS)" treetype="template">
//   IBUFDS    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IBUFDS_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS: Differential Input Buffer
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS #(
      .DIFF_TERM("FALSE"),       // Differential Termination
      .IBUF_LOW_PWR("TRUE"),     // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT")     // Specify the input I/O standard
   ) IBUFDS_inst (
      .O(O),  // Buffer output
      .I(I),  // Diff_p buffer input (connect directly to top-level port)
      .IB(IB) // Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ Disable (IBUFDS_IBUFDISABLE)" treetype="template">
// IBUFDS_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog       : the following instance declaration needs to be placed
//     instance       : in the body of the design code.  The instance name
//    declaration     : (IBUFDS_IBUFDISABLE_inst) and/or the port declarations within the
//       code         : parenthesis may be changed to properly reference and
//                    : connect this function to the design.  All inputs
//                    : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_IBUFDISABLE: Differential Input Buffer with Input Disable
   //                     Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_IBUFDISABLE #(
      .DIFF_TERM("FALSE"),      // Differential Termination
      .IBUF_LOW_PWR("TRUE"),    // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),   // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE")  // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_IBUFDISABLE_inst (
      .O(O),   // Buffer output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE) // Buffer disable input, high=disable
   );

   // End of IBUFDS_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output (IBUFDS_DIFF_OUT)" treetype="template">
// IBUFDS_DIFF_OUT : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUFDS_DIFF_OUT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  All inputs
//                 : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT: Differential Input Buffer with Differential Output
   //                  Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT #(
      .DIFF_TERM("FALSE"),   // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"), // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT") // Specify the input I/O standard
   ) IBUFDS_DIFF_OUT_inst (
      .O(O),   // Buffer diff_p output
      .OB(OB), // Buffer diff_n output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB)  // Diff_n buffer input (connect directly to top-level port)
   );

   // End of IBUFDS_DIFF_OUT_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output w/ Input Disable (IBUFDS_DIFF_OUT_IBUFDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_IBUFDISABLE : In order to incorporate this function into the design,
//           Verilog           : the following instance declaration needs to be placed
//          instance           : in the body of the design code.  The instance name
//         declaration         : (IBUFDS_DIFF_OUT_IBUFDISABLE_inst) and/or the port declarations within the
//            code             : parenthesis may be changed to properly reference and
//                             : connect this function to the design.  All inputs
//                             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_IBUFDISABLE: Differential Input Buffer with Differential Output with Input Disable
   //                              Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_IBUFDISABLE #(
      .DIFF_TERM("FALSE"),     // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"),   // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_DIFF_OUT_IBUFDISABLE_inst (
      .O(O),   // Buffer diff_p output
      .OB(OB), // Buffer diff_n output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE)  // Buffer disable input, high=disable
   );

   // End of IBUFDS_DIFF_OUT_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer with Differential Output w/ Input Termination Disable (IBUFDS_DIFF_OUT_INTERMDISABLE)" treetype="template">
// IBUFDS_DIFF_OUT_INTERMDISABLE : In order to incorporate this function into the design,
//            Verilog            : the following instance declaration needs to be placed
//           instance            : in the body of the design code.  The instance name
//          declaration          : (IBUFDS_DIFF_OUT_INTERMDISABLE_inst) and/or the port declarations within the
//             code              : parenthesis may be changed to properly reference and
//                               : connect this function to the design.  All inputs
//                               : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_DIFF_OUT_INTERMDISABLE: Differential Input Buffer with Differential Output with Input Termination Disable
   //                                May only be placed in High Range (HR) Banks
   //                                Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_DIFF_OUT_INTERMDISABLE  #(
      .DIFF_TERM("FALSE"),     // Differential Termination, "TRUE"/"FALSE" 
      .IBUF_LOW_PWR("TRUE"),   // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_DIFF_OUT_INTERMDISABLE_inst (
      .O(O),   // Buffer diff_p output
      .OB(OB), // Buffer diff_n output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),    // Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE) // Input Termination Disable
   );

   // End of IBUFDS_DIFF_OUT_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Differential Buffer w/ Termination Disable (IBUFDS_INTERMDISABLE)" treetype="template">
// IBUFDS_INTERMDISABLE : In order to incorporate this function into the design,
//       Verilog        : the following instance declaration needs to be placed
//      instance        : in the body of the design code.  The instance name
//     declaration      : (IBUFDS_INTERMDISABLE_inst) and/or the port declarations within the
//        code          : parenthesis may be changed to properly reference and
//                      : connect this function to the design.  All inputs
//                      : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IBUFDS_INTERMDISABLE: Differential Input Buffer with Input Termination Disable
   //                       May only be placed in High Range (HR) Banks
   //                       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IBUFDS_INTERMDISABLE #(
      .DIFF_TERM("FALSE"),      // Differential Termination
      .IBUF_LOW_PWR("TRUE"),    // Low power="TRUE", Highest performance="FALSE" 
      .IOSTANDARD("DEFAULT"),   // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE")  // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUFDS_INTERMDISABLE_inst (
      .O(O),   // Buffer output
      .I(I),   // Diff_p buffer input (connect directly to top-level port)
      .IB(IB), // Diff_n buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),    // Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE) // Input Termination Disable
   );

   // End of IBUFDS_INTERMDISABLE_inst instantiation
					</Template>
					<Template label="Single-ended Buffer (IBUF)" treetype="template">
//      IBUF       : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (IBUF_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IBUF: Single-ended Input Buffer
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IBUF #(
      .IBUF_LOW_PWR("TRUE"),  // Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards 
      .IOSTANDARD("DEFAULT")  // Specify the input I/O standard
   ) IBUF_inst (
      .O(O),     // Buffer output
      .I(I)      // Buffer input (connect directly to top-level port)
   );
  
   // End of IBUF_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ Disable (IBUF_IBUFDISABLE)" treetype="template">
//  IBUF_IBUFDISABLE : In order to incorporate this function into the design,
//      Verilog      : the following instance declaration needs to be placed
//     instance      : in the body of the design code.  The instance name
//    declaration    : (IBUF_IBUFDISABLE_inst) and/or the port declarations within the
//       code        : parenthesis may be changed to properly reference and
//                   : connect this function to the design.  Delete or comment
//                   : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_IBUFDISABLE: Single-ended Input Buffer with Disable
   //                   Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IBUF_IBUFDISABLE #(
      .IBUF_LOW_PWR("TRUE"),   // Low power ("TRUE") vs. performance ("FALSE") for referenced I/O standards 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUF_IBUFDISABLE_inst (
      .O(O),                    // Buffer output
      .I(I),                    // Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE) // Buffer disable input, high=disable
   );
  
   // End of IBUF_IBUFDISABLE_inst instantiation
					</Template>
					<Template label="Single-ended Buffer w/ Termination Disable (IBUF_INTERMDISABLE)" treetype="template">
//  IBUF_INTERMDISABLE : In order to incorporate this function into the design,
//      Verilog      : the following instance declaration needs to be placed
//     instance      : in the body of the design code.  The instance name
//    declaration    : (IBUF_INTERMDISABLE_inst) and/or the port declarations within the
//       code        : parenthesis may be changed to properly reference and
//                   : connect this function to the design.  Delete or comment
//                   : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IBUF_INTERMDISABLE: Single-ended Input Buffer with Termination Input Disable
   //                     May only be placed in High Range (HR) Banks
   //                     Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   IBUF_INTERMDISABLE #(
      .IBUF_LOW_PWR("TRUE"),   // Low power ("TRUE") vs. performance ("FALSE") for referenced I/O standards 
      .IOSTANDARD("DEFAULT"),  // Specify the input I/O standard
      .USE_IBUFDISABLE("TRUE") // Set to "TRUE" to enable IBUFDISABLE feature
   ) IBUF_INTERMDISABLE_inst (
      .O(O),                    // Buffer output
      .I(I),                    // Buffer input (connect directly to top-level port)
      .IBUFDISABLE(IBUFDISABLE),    // Buffer disable input, high=disable
      .INTERMDISABLE(INTERMDISABLE) // Input Termination Disable
   );
  
   // End of IBUF_INTERMDISABLE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="I/O Delay Components" treetype="folder">
					<Template label="Delay Calibration (IDELAYCTRL)" treetype="template">
// IDELAYCTRL  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYCTRL_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYCTRL: IDELAYE2/ODELAYE2 Tap Delay Value Control
   //             Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   (* IODELAY_GROUP = &lt;iodelay_group_name&gt; *) // Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

   IDELAYCTRL IDELAYCTRL_inst (
      .RDY(RDY),       // 1-bit output: Ready output
      .REFCLK(REFCLK), // 1-bit input: Reference clock input
      .RST(RST)        // 1-bit input: Active high reset input
   );

   // End of IDELAYCTRL_inst instantiation
					</Template>
					<Template label="Input Delay Element (IDELAYE2)" treetype="template">
//  IDELAYE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (IDELAYE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // IDELAYE2: Input Fixed or Variable Delay Element
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   (* IODELAY_GROUP = &lt;iodelay_group_name&gt; *) // Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

   IDELAYE2 #(
      .CINVCTRL_SEL("FALSE"),          // Enable dynamic clock inversion (FALSE, TRUE)
      .DELAY_SRC("IDATAIN"),           // Delay input (IDATAIN, DATAIN)
      .HIGH_PERFORMANCE_MODE("FALSE"), // Reduced jitter ("TRUE"), Reduced power ("FALSE")
      .IDELAY_TYPE("FIXED"),           // FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      .IDELAY_VALUE(0),                // Input delay tap setting (0-31)
      .PIPE_SEL("FALSE"),              // Select pipelined mode, FALSE, TRUE
      .REFCLK_FREQUENCY(200.0),        // IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      .SIGNAL_PATTERN("DATA")          // DATA, CLOCK input signal
   )
   IDELAYE2_inst (
      .CNTVALUEOUT(CNTVALUEOUT), // 5-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data output
      .C(C),                     // 1-bit input: Clock input
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CINVCTRL(CINVCTRL),       // 1-bit input: Dynamic clock inversion input
      .CNTVALUEIN(CNTVALUEIN),   // 5-bit input: Counter value input
      .DATAIN(DATAIN),           // 1-bit input: Internal delay data input
      .IDATAIN(IDATAIN),         // 1-bit input: Data input from the I/O
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LD(LD),                   // 1-bit input: Load IDELAY_VALUE input
      .LDPIPEEN(LDPIPEEN),       // 1-bit input: Enable PIPELINE register to load data input
      .REGRST(REGRST)            // 1-bit input: Active-high reset tap-delay input
   );

   // End of IDELAYE2_inst instantiation
					</Template>
					<Template label="Output Delay Element (ODELAYE2)" treetype="template">
//  ODELAYE2   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ODELAYE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ODELAYE2: Output Fixed or Variable Delay Element
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   (* IODELAY_GROUP = &lt;iodelay_group_name&gt; *) // Specifies group name for associated IDELAYs/ODELAYs and IDELAYCTRL

   ODELAYE2 #(
      .CINVCTRL_SEL("FALSE"),          // Enable dynamic clock inversion (FALSE, TRUE)
      .DELAY_SRC("ODATAIN"),           // Delay input (ODATAIN, CLKIN)
      .HIGH_PERFORMANCE_MODE("FALSE"), // Reduced jitter ("TRUE"), Reduced power ("FALSE")
      .ODELAY_TYPE("FIXED"),           // FIXED, VARIABLE, VAR_LOAD, VAR_LOAD_PIPE
      .ODELAY_VALUE(0),                // Output delay tap setting (0-31)
      .PIPE_SEL("FALSE"),              // Select pipelined mode, FALSE, TRUE
      .REFCLK_FREQUENCY(200.0),        // IDELAYCTRL clock input frequency in MHz (190.0-210.0, 290.0-310.0).
      .SIGNAL_PATTERN("DATA")          // DATA, CLOCK input signal
   )
   ODELAYE2_inst (
      .CNTVALUEOUT(CNTVALUEOUT), // 5-bit output: Counter value output
      .DATAOUT(DATAOUT),         // 1-bit output: Delayed data/clock output
      .C(C),                     // 1-bit input: Clock input
      .CE(CE),                   // 1-bit input: Active high enable increment/decrement input
      .CINVCTRL(CINVCTRL),       // 1-bit input: Dynamic clock inversion input
      .CLKIN(CLKIN),             // 1-bit input: Clock delay input
      .CNTVALUEIN(CNTVALUEIN),   // 5-bit input: Counter value input
      .INC(INC),                 // 1-bit input: Increment / Decrement tap delay input
      .LD(LD),                   // 1-bit input: Loads ODELAY_VALUE tap delay in VARIABLE mode, in VAR_LOAD or
                                 // VAR_LOAD_PIPE mode, loads the value of CNTVALUEIN

      .LDPIPEEN(LDPIPEEN),       // 1-bit input: Enables the pipeline register to load data
      .ODATAIN(ODATAIN),         // 1-bit input: Output delay data input
      .REGRST(REGRST)            // 1-bit input: Active-high reset tap-delay input
   );

   // End of ODELAYE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="I/O SERDES" treetype="folder">
					<Template label="Input SERial/DESerializer with Bitslip (ISERDESE2)" treetype="template">
//  ISERDESE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ISERDESE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ISERDESE2: Input SERial/DESerializer with Bitslip
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   ISERDESE2 #(
      .DATA_RATE("DDR"),           // DDR, SDR
      .DATA_WIDTH(4),              // Parallel data width (2-8,10,14)
      .DYN_CLKDIV_INV_EN("FALSE"), // Enable DYNCLKDIVINVSEL inversion (FALSE, TRUE)
      .DYN_CLK_INV_EN("FALSE"),    // Enable DYNCLKINVSEL inversion (FALSE, TRUE)
      // INIT_Q1 - INIT_Q4: Initial value on the Q outputs (0/1)
      .INIT_Q1(1'b0),
      .INIT_Q2(1'b0),
      .INIT_Q3(1'b0),
      .INIT_Q4(1'b0),
      .INTERFACE_TYPE("MEMORY"),   // MEMORY, MEMORY_DDR3, MEMORY_QDR, NETWORKING, OVERSAMPLE
      .IOBDELAY("NONE"),           // NONE, BOTH, IBUF, IFD
      .NUM_CE(2),                  // Number of clock enables (1,2)
      .OFB_USED("FALSE"),          // Select OFB path (FALSE, TRUE)
      .SERDES_MODE("MASTER"),      // MASTER, SLAVE
      // SRVAL_Q1 - SRVAL_Q4: Q output values when SR is used (0/1)
      .SRVAL_Q1(1'b0),
      .SRVAL_Q2(1'b0),
      .SRVAL_Q3(1'b0),
      .SRVAL_Q4(1'b0) 
   )
   ISERDESE2_inst (
      .O(O),                       // 1-bit output: Combinatorial output
      // Q1 - Q8: 1-bit (each) output: Registered data outputs
      .Q1(Q1),
      .Q2(Q2),
      .Q3(Q3),
      .Q4(Q4),
      .Q5(Q5),
      .Q6(Q6),
      .Q7(Q7),
      .Q8(Q8),
      // SHIFTOUT1, SHIFTOUT2: 1-bit (each) output: Data width expansion output ports
      .SHIFTOUT1(SHIFTOUT1),
      .SHIFTOUT2(SHIFTOUT2),
      .BITSLIP(BITSLIP),           // 1-bit input: The BITSLIP pin performs a Bitslip operation synchronous to
                                   // CLKDIV when asserted (active High). Subsequently, the data seen on the Q1
                                   // to Q8 output ports will shift, as in a barrel-shifter operation, one
                                   // position every time Bitslip is invoked (DDR operation is different from
                                   // SDR).

      // CE1, CE2: 1-bit (each) input: Data register clock enable inputs
      .CE1(CE1),
      .CE2(CE2),
      .CLKDIVP(CLKDIVP),           // 1-bit input: TBD
      // Clocks: 1-bit (each) input: ISERDESE2 clock input ports
      .CLK(CLK),                   // 1-bit input: High-speed clock
      .CLKB(CLKB),                 // 1-bit input: High-speed secondary clock
      .CLKDIV(CLKDIV),             // 1-bit input: Divided clock
      .OCLK(OCLK),                 // 1-bit input: High speed output clock used when INTERFACE_TYPE="MEMORY" 
      // Dynamic Clock Inversions: 1-bit (each) input: Dynamic clock inversion pins to switch clock polarity
      .DYNCLKDIVSEL(DYNCLKDIVSEL), // 1-bit input: Dynamic CLKDIV inversion
      .DYNCLKSEL(DYNCLKSEL),       // 1-bit input: Dynamic CLK/CLKB inversion
      // Input Data: 1-bit (each) input: ISERDESE2 data input ports
      .D(D),                       // 1-bit input: Data input
      .DDLY(DDLY),                 // 1-bit input: Serial data from IDELAYE2
      .OFB(OFB),                   // 1-bit input: Data feedback from OSERDESE2
      .OCLKB(OCLKB),               // 1-bit input: High speed negative edge output clock
      .RST(RST),                   // 1-bit input: Active high asynchronous reset
      // SHIFTIN1, SHIFTIN2: 1-bit (each) input: Data width expansion input ports
      .SHIFTIN1(SHIFTIN1),
      .SHIFTIN2(SHIFTIN2) 
   );

   // End of ISERDESE2_inst instantiation
					</Template>
					<Template label="Output SERial/DESerializer with bitslip (OSERDESE2)" treetype="template">
//  OSERDESE2  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (OSERDESE2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // OSERDESE2: Output SERial/DESerializer with bitslip
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   OSERDESE2 #(
      .DATA_RATE_OQ("DDR"),   // DDR, SDR
      .DATA_RATE_TQ("DDR"),   // DDR, BUF, SDR
      .DATA_WIDTH(4),         // Parallel data width (2-8,10,14)
      .INIT_OQ(1'b0),         // Initial value of OQ output (1'b0,1'b1)
      .INIT_TQ(1'b0),         // Initial value of TQ output (1'b0,1'b1)
      .SERDES_MODE("MASTER"), // MASTER, SLAVE
      .SRVAL_OQ(1'b0),        // OQ output value when SR is used (1'b0,1'b1)
      .SRVAL_TQ(1'b0),        // TQ output value when SR is used (1'b0,1'b1)
      .TBYTE_CTL("FALSE"),    // Enable tristate byte operation (FALSE, TRUE)
      .TBYTE_SRC("FALSE"),    // Tristate byte source (FALSE, TRUE)
      .TRISTATE_WIDTH(4)      // 3-state converter width (1,4)
   )
   OSERDESE2_inst (
      .OFB(OFB),             // 1-bit output: Feedback path for data
      .OQ(OQ),               // 1-bit output: Data path output
      // SHIFTOUT1 / SHIFTOUT2: 1-bit (each) output: Data output expansion (1-bit each)
      .SHIFTOUT1(SHIFTOUT1),
      .SHIFTOUT2(SHIFTOUT2),
      .TBYTEOUT(TBYTEOUT),   // 1-bit output: Byte group tristate
      .TFB(TFB),             // 1-bit output: 3-state control
      .TQ(TQ),               // 1-bit output: 3-state control
      .CLK(CLK),             // 1-bit input: High speed clock
      .CLKDIV(CLKDIV),       // 1-bit input: Divided clock
      // D1 - D8: 1-bit (each) input: Parallel data inputs (1-bit each)
      .D1(D1),
      .D2(D2),
      .D3(D3),
      .D4(D4),
      .D5(D5),
      .D6(D6),
      .D7(D7),
      .D8(D8),
      .OCE(OCE),             // 1-bit input: Output data clock enable
      .RST(RST),             // 1-bit input: Reset
      // SHIFTIN1 / SHIFTIN2: 1-bit (each) input: Data input expansion (1-bit each)
      .SHIFTIN1(SHIFTIN1),
      .SHIFTIN2(SHIFTIN2),
      // T1 - T4: 1-bit (each) input: Parallel 3-state inputs
      .T1(T1),
      .T2(T2),
      .T3(T3),
      .T4(T4),
      .TBYTEIN(TBYTEIN),     // 1-bit input: Byte group tristate
      .TCE(TCE)              // 1-bit input: 3-state clock enable
   );

   // End of OSERDESE2_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Output Buffers" treetype="folder">
					<Template label="Differential Buffer (OBUFDS)" treetype="template">

//     OBUFDS      : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFDS_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUFDS: Differential Output Buffer
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   OBUFDS #(
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW")           // Specify the output slew rate
   ) OBUFDS_inst (
      .O(O),     // Diff_p output (connect directly to top-level port)
      .OB(OB),   // Diff_n output (connect directly to top-level port)
      .I(I)      // Buffer input 
   );
  
   // End of OBUFDS_inst instantiation
					</Template>
					<Template label="Differential 3-state Buffer (OBUFTDS)" treetype="template">
//     OBUFTDS   : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (OBUFTDS_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUFTDS: Differential 3-state Output Buffer
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   OBUFTDS #(
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW")           // Specify the output slew rate
   ) OBUFTDS_inst (
      .O(O),     // Diff_p output (connect directly to top-level port)
      .OB(OB),   // Diff_n output (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input
   );
  
   // End of OBUFTDS_inst instantiation
					</Template>
					<Template label="Single-ended Buffer (OBUF)" treetype="template">
//      OBUF       : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUF_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUF: Single-ended Output Buffer
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   OBUF #(
      .DRIVE(12),   // Specify the output drive strength
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW") // Specify the output slew rate
   ) OBUF_inst (
      .O(O),     // Buffer output (connect directly to top-level port)
      .I(I)      // Buffer input 
   );
  
   // End of OBUF_inst instantiation
					</Template>
					<Template label="Single-ended 3-state Buffer (OBUFT)" treetype="template">
//      OBUFT      : In order to incorporate this function into the design,
//     Verilog     : the following instance declaration needs to be placed
//    instance     : in the body of the design code.  The instance name
//   declaration   : (OBUFT_inst) and/or the port declarations within the
//      code       : parenthesis may be changed to properly reference and
//                 : connect this function to the design.  Delete or comment
//                 : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // OBUFT: Single-ended 3-state Output Buffer
   //        All devices
   // Xilinx HDL Language Template, version 2016.4
   
   OBUFT #(
      .DRIVE(12),   // Specify the output drive strength
      .IOSTANDARD("DEFAULT"), // Specify the output I/O standard
      .SLEW("SLOW") // Specify the output slew rate
   ) OBUFT_inst (
      .O(O),     // Buffer output (connect directly to top-level port)
      .I(I),     // Buffer input
      .T(T)      // 3-state enable input 
   );
  
  // End of OBUFT_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Weak drivers" treetype="folder">
					<Template label="KEEPER" treetype="template">
//     KEEPER    : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (KEEPER_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.

//  &lt;-----Cut code below this line----&gt;

   // KEEPER: I/O Buffer Weak Keeper
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   KEEPER KEEPER_inst (
      .O(O)     // Keeper output (connect directly to top-level port)
   );
  
   // End of KEEPER_inst instantiation
					</Template>
					<Template label="PULLDOWN" treetype="template">
//    PULLDOWN   : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (PULLDOWN_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.

//  &lt;-----Cut code below this line----&gt;

   // PULLDOWN: I/O Buffer Weak Pull-down
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   PULLDOWN PULLDOWN_inst (
      .O(O)     // Pulldown output (connect directly to top-level port)
   );
  
   // End of PULLDOWN_inst instantiation
					</Template>
					<Template label="PULLUP" treetype="template">
//     PULLUP    : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (PULLUP_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.


//  &lt;-----Cut code below this line----&gt;

   // PULLUP: I/O Buffer Weak Pull-up
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   PULLUP PULLUP_inst (
      .O(O)     // Pullup output (connect directly to top-level port)
   );
  
   // End of PULLUP_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="RAM/ROM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<Template label="18Kb Block RAM Memory (RAMB18E1)" treetype="template">
//  RAMB18E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB18E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB18E1: 18K-bit Configurable Synchronous Block RAM
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAMB18E1 #(
      // Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      .RDADDR_COLLISION_HWCONFIG("DELAYED_WRITE"),
      // Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0 or 1)
      .DOA_REG(0),
      .DOB_REG(0),
      // INITP_00 to INITP_07: Initial contents of parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_3F: Initial contents of data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(18'h00000),
      .INIT_B(18'h00000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // RAM Mode: "SDP" or "TDP" 
      .RAM_MODE("TDP"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-72
      .READ_WIDTH_B(0),                                                                 // 0-18
      .WRITE_WIDTH_A(0),                                                                // 0-18
      .WRITE_WIDTH_B(0),                                                                // 0-72
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(18'h00000),
      .SRVAL_B(18'h00000),
      // Simulation Device: Must be set to "7SERIES" for simulation behavior
      .SIM_DEVICE("7SERIES"),
      // WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      .WRITE_MODE_A("WRITE_FIRST"),
      .WRITE_MODE_B("WRITE_FIRST") 
   )
   RAMB18E1_inst (
      // Port A Data: 16-bit (each) output: Port A data
      .DOADO(DOADO),                 // 16-bit output: A port data/LSB data
      .DOPADOP(DOPADOP),             // 2-bit output: A port parity/LSB parity
      // Port B Data: 16-bit (each) output: Port B data
      .DOBDO(DOBDO),                 // 16-bit output: B port data/MSB data
      .DOPBDOP(DOPBDOP),             // 2-bit output: B port parity/MSB parity
      // Port A Address/Control Signals: 14-bit (each) input: Port A address and control signals (read port
      // when RAM_MODE="SDP")
      .ADDRARDADDR(ADDRARDADDR),     // 14-bit input: A port address/Read address
      .CLKARDCLK(CLKARDCLK),         // 1-bit input: A port clock/Read clock
      .ENARDEN(ENARDEN),             // 1-bit input: A port enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),     // 1-bit input: A port register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM), // 1-bit input: A port set/reset
      .RSTREGARSTREG(RSTREGARSTREG), // 1-bit input: A port register set/reset
      .WEA(WEA),                     // 2-bit input: A port write enable
      // Port A Data: 16-bit (each) input: Port A data
      .DIADI(DIADI),                 // 16-bit input: A port data/LSB data
      .DIPADIP(DIPADIP),             // 2-bit input: A port parity/LSB parity
      // Port B Address/Control Signals: 14-bit (each) input: Port B address and control signals (write port
      // when RAM_MODE="SDP")
      .ADDRBWRADDR(ADDRBWRADDR),     // 14-bit input: B port address/Write address
      .CLKBWRCLK(CLKBWRCLK),         // 1-bit input: B port clock/Write clock
      .ENBWREN(ENBWREN),             // 1-bit input: B port enable/Write enable
      .REGCEB(REGCEB),               // 1-bit input: B port register enable
      .RSTRAMB(RSTRAMB),             // 1-bit input: B port set/reset
      .RSTREGB(RSTREGB),             // 1-bit input: B port register set/reset
      .WEBWE(WEBWE),                 // 4-bit input: B port write enable/Write enable
      // Port B Data: 16-bit (each) input: Port B data
      .DIBDI(DIBDI),                 // 16-bit input: B port data/MSB data
      .DIPBDIP(DIPBDIP)              // 2-bit input: B port parity/MSB parity
   );

   // End of RAMB18E1_inst instantiation
					</Template>
					<Template label="36Kb Block RAM Memory (RAMB36E1)" treetype="template">
//  RAMB36E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAMB36E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAMB36E1: 36K-bit Configurable Synchronous Block RAM
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAMB36E1 #(
      // Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE" 
      .RDADDR_COLLISION_HWCONFIG("DELAYED_WRITE"),
      // Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
      .SIM_COLLISION_CHECK("ALL"),
      // DOA_REG, DOB_REG: Optional output register (0 or 1)
      .DOA_REG(0),
      .DOB_REG(0),
      .EN_ECC_READ("FALSE"),                                                            // Enable ECC decoder,
                                                                                        // FALSE, TRUE
      .EN_ECC_WRITE("FALSE"),                                                           // Enable ECC encoder,
                                                                                        // FALSE, TRUE
      // INITP_00 to INITP_0F: Initial contents of the parity memory array
      .INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INITP_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_00 to INIT_7F: Initial contents of the data memory array
      .INIT_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_01(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_02(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_03(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_04(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_05(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_06(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_07(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_08(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_09(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_0F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_10(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_11(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_12(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_13(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_14(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_15(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_16(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_17(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_18(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_19(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_1F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_20(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_21(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_22(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_23(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_24(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_25(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_26(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_27(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_28(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_29(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_2F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_30(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_31(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_32(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_33(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_34(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_35(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_36(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_37(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_38(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_39(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_40(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_41(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_42(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_43(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_44(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_45(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_46(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_47(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_48(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_49(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_4F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_50(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_51(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_52(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_53(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_54(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_55(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_56(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_57(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_58(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_59(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_5F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_60(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_61(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_62(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_63(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_64(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_65(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_66(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_67(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_68(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_69(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_6F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_70(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_71(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_72(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_73(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_74(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_75(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_76(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_77(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_78(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_79(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7A(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7B(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7C(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7D(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7E(256'h0000000000000000000000000000000000000000000000000000000000000000),
      .INIT_7F(256'h0000000000000000000000000000000000000000000000000000000000000000),
      // INIT_A, INIT_B: Initial values on output ports
      .INIT_A(36'h000000000),
      .INIT_B(36'h000000000),
      // Initialization File: RAM initialization file
      .INIT_FILE("NONE"),
      // RAM Mode: "SDP" or "TDP" 
      .RAM_MODE("TDP"),
      // RAM_EXTENSION_A, RAM_EXTENSION_B: Selects cascade mode ("UPPER", "LOWER", or "NONE")
      .RAM_EXTENSION_A("NONE"),
      .RAM_EXTENSION_B("NONE"),
      // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
      .READ_WIDTH_A(0),                                                                 // 0-72
      .READ_WIDTH_B(0),                                                                 // 0-36
      .WRITE_WIDTH_A(0),                                                                // 0-36
      .WRITE_WIDTH_B(0),                                                                // 0-72
      // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
      .RSTREG_PRIORITY_A("RSTREG"),
      .RSTREG_PRIORITY_B("RSTREG"),
      // SRVAL_A, SRVAL_B: Set/reset value for output
      .SRVAL_A(36'h000000000),
      .SRVAL_B(36'h000000000),
      // Simulation Device: Must be set to "7SERIES" for simulation behavior
      .SIM_DEVICE("7SERIES"),
      // WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
      .WRITE_MODE_A("WRITE_FIRST"),
      .WRITE_MODE_B("WRITE_FIRST") 
   )
   RAMB36E1_inst (
      // Cascade Signals: 1-bit (each) output: BRAM cascade ports (to create 64kx1)
      .CASCADEOUTA(CASCADEOUTA),     // 1-bit output: A port cascade
      .CASCADEOUTB(CASCADEOUTB),     // 1-bit output: B port cascade
      // ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .RDADDRECC(RDADDRECC),         // 9-bit output: ECC read address
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Port A Data: 32-bit (each) output: Port A data
      .DOADO(DOADO),                 // 32-bit output: A port data/LSB data
      .DOPADOP(DOPADOP),             // 4-bit output: A port parity/LSB parity
      // Port B Data: 32-bit (each) output: Port B data
      .DOBDO(DOBDO),                 // 32-bit output: B port data/MSB data
      .DOPBDOP(DOPBDOP),             // 4-bit output: B port parity/MSB parity
      // Cascade Signals: 1-bit (each) input: BRAM cascade ports (to create 64kx1)
      .CASCADEINA(CASCADEINA),       // 1-bit input: A port cascade
      .CASCADEINB(CASCADEINB),       // 1-bit input: B port cascade
      // ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error
      .INJECTSBITERR(INJECTSBITERR), // 1-bit input: Inject a single bit error
      // Port A Address/Control Signals: 16-bit (each) input: Port A address and control signals (read port
      // when RAM_MODE="SDP")
      .ADDRARDADDR(ADDRARDADDR),     // 16-bit input: A port address/Read address
      .CLKARDCLK(CLKARDCLK),         // 1-bit input: A port clock/Read clock
      .ENARDEN(ENARDEN),             // 1-bit input: A port enable/Read enable
      .REGCEAREGCE(REGCEAREGCE),     // 1-bit input: A port register enable/Register enable
      .RSTRAMARSTRAM(RSTRAMARSTRAM), // 1-bit input: A port set/reset
      .RSTREGARSTREG(RSTREGARSTREG), // 1-bit input: A port register set/reset
      .WEA(WEA),                     // 4-bit input: A port write enable
      // Port A Data: 32-bit (each) input: Port A data
      .DIADI(DIADI),                 // 32-bit input: A port data/LSB data
      .DIPADIP(DIPADIP),             // 4-bit input: A port parity/LSB parity
      // Port B Address/Control Signals: 16-bit (each) input: Port B address and control signals (write port
      // when RAM_MODE="SDP")
      .ADDRBWRADDR(ADDRBWRADDR),     // 16-bit input: B port address/Write address
      .CLKBWRCLK(CLKBWRCLK),         // 1-bit input: B port clock/Write clock
      .ENBWREN(ENBWREN),             // 1-bit input: B port enable/Write enable
      .REGCEB(REGCEB),               // 1-bit input: B port register enable
      .RSTRAMB(RSTRAMB),             // 1-bit input: B port set/reset
      .RSTREGB(RSTREGB),             // 1-bit input: B port register set/reset
      .WEBWE(WEBWE),                 // 8-bit input: B port write enable/Write enable
      // Port B Data: 32-bit (each) input: Port B data
      .DIBDI(DIBDI),                 // 32-bit input: B port data/MSB data
      .DIPBDIP(DIPBDIP)              // 4-bit input: B port parity/MSB parity
   );

   // End of RAMB36E1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Distributed RAM" treetype="folder">
					<SubFolder label="Dual-Port" treetype="folder">
						<Template label="32 X 1 negedge write (RAM32X1D_1)" treetype="template">
//  RAM32X1D_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_1_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D_1: 32 x 1 negative edge write, asynchronous read dual-port
   //             distributed RAM (Mapped to a SliceM LUT6)
   //             Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D_1 #(
      .INIT(32'h00000000) // Initial contents of RAM
   ) RAM32X1D_1_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_1_inst instantiation
						</Template>
						<Template label="32 X 1 posedge write (RAM32X1D)" treetype="template">
//   RAM32X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM32X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1D: 32 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to a SliceM LUT6)
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1D #(
      .INIT(32'h00000000) // Initial contents of RAM
   ) RAM32X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM32X1D_inst instantiation
						</Template>
						<Template label="64 X 1 posedge write (RAM64X1D)" treetype="template">
//   RAM64X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM64X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1D: 64 x 1 positive edge write, asynchronous read dual-port
   //           distributed RAM (Mapped to a SliceM LUT6)
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1D #(
      .INIT(64'h0000000000000000) // Initial contents of RAM
   ) RAM64X1D_inst (
      .DPO(DPO),     // Read-only 1-bit data output
      .SPO(SPO),     // Rw/ 1-bit data output
      .A0(A0),       // Rw/ address[0] input bit
      .A1(A1),       // Rw/ address[1] input bit
      .A2(A2),       // Rw/ address[2] input bit
      .A3(A3),       // Rw/ address[3] input bit
      .A4(A4),       // Rw/ address[4] input bit
      .A5(A5),       // Rw/ address[5] input bit
      .D(D),         // Write 1-bit data input
      .DPRA0(DPRA0), // Read-only address[0] input bit
      .DPRA1(DPRA1), // Read-only address[1] input bit
      .DPRA2(DPRA2), // Read-only address[2] input bit
      .DPRA3(DPRA3), // Read-only address[3] input bit
      .DPRA4(DPRA4), // Read-only address[4] input bit
      .DPRA5(DPRA5), // Read-only address[5] input bit
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );

   // End of RAM64X1D_inst instantiation
						</Template>
						<Template label="128 X 1 posedge write (RAM128X1D)" treetype="template">
//  RAM128X1D  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//   instance  : in the body of the design code.  The instance name
// declaration : (RAM128X1D_inst) and/or the port declarations within the
//     code    : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1D: 128-deep by 1-wide positive edge write, asynchronous read  (Mapped to two SliceM LUT6s)
   //            dual-port distributed LUT RAM
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   RAM128X1D #(
      .INIT(128'h00000000000000000000000000000000)
   ) RAM128X1D_inst (
      .DPO(DPO),   // Read port 1-bit output
      .SPO(SPO),   // Read/write port 1-bit output
      .A(A),       // Read/write port 7-bit address input
      .D(D),       // RAM data input
      .DPRA(DPRA), // Read port 7-bit address input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM128X1D_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Multi-Port" treetype="folder">
						<Template label="32 X 8 (RAM32M)" treetype="template">
//   RAM32M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32M: 32-deep by 8-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4
      
   RAM32M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000)  // Initial contents of D Port
   ) RAM32M_inst (
      .DOA(DOA),     // Read port A 2-bit output
      .DOB(DOB),     // Read port B 2-bit output
      .DOC(DOC),     // Read port C 2-bit output
      .DOD(DOD),     // Read/write port D 2-bit output
      .ADDRA(ADDRA), // Read port A 5-bit address input
      .ADDRB(ADDRB), // Read port B 5-bit address input
      .ADDRC(ADDRC), // Read port C 5-bit address input
      .ADDRD(ADDRD), // Read/write port D 5-bit address input
      .DIA(DIA),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 2-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .WCLK(WCLK),   // Write clock input
      .WE(WE)        // Write enable input
   );
   
   // End of RAM32M_inst instantiation
						</Template>
						<Template label="64 X 4 (RAM64M)" treetype="template">
//   RAM64M    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64M_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64M: 64-deep by 4-wide Multi Port LUT RAM (Mapped to four SliceM LUT6s)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   RAM64M #(
      .INIT_A(64'h0000000000000000), // Initial contents of A Port
      .INIT_B(64'h0000000000000000), // Initial contents of B Port
      .INIT_C(64'h0000000000000000), // Initial contents of C Port
      .INIT_D(64'h0000000000000000)  // Initial contents of D Port
   ) RAM64M_inst (
      .DOA(DOA),     // Read port A 1-bit output
      .DOB(DOB),     // Read port B 1-bit output
      .DOC(DOC),     // Read port C 1-bit output
      .DOD(DOD),     // Read/write port D 1-bit output
      .DIA(DIA),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRA
      .DIB(DIB),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRB
      .DIC(DIC),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRC
      .DID(DID),     // RAM 1-bit data write input addressed by ADDRD, 
                     //   read addressed by ADDRD
      .ADDRA(ADDRA), // Read port A 6-bit address input
      .ADDRB(ADDRB), // Read port B 6-bit address input
      .ADDRC(ADDRC), // Read port C 6-bit address input
      .ADDRD(ADDRD), // Read/write port D 6-bit address input
      .WE(WE),       // Write enable input
      .WCLK(WCLK)    // Write clock input
   );

   // End of RAM64M_inst instantiation
						</Template>
					</SubFolder>
					<SubFolder label="Single-Port" treetype="folder">
						<SubFolder label="32 Deep (5-bit address)" treetype="folder">
							<Template label="32 x 1 negedge write (RAM32X1S_1)" treetype="template">
// RAM32X1S_1  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1S_1: 32 x 1 negedge write distributed (LUT) RAM (Mapped to a SliceM LUT6)
   //             Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1S_1 #(
      .INIT(32'h00000000)  // Initial contents of RAM
   )RAM32X1S_1_inst (
      .O(O),       // RAM output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D(D),       // RAM data input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X1S_1_inst instantiation
							</Template>
							<Template label="32 x 1 posedge write (RAM32X1S)" treetype="template">
//  RAM32X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM32X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X1S: 32 x 1 posedge write distributed (LUT) RAM (Mapped to a SliceM LUT6)
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X1S #(
      .INIT(32'h00000000)  // Initial contents of RAM
   ) RAM32X1S_inst (
      .O(O),       // RAM output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D(D),       // RAM data input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X1S_inst instantiation
							</Template>
							<Template label="32 x 2 posedge write (RAM32X2S)" treetype="template">
//  RAM32X2S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM16X2S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM32X2S: 32 x 2 posedge write distributed (LUT) RAM (Mapped to a SliceM LUT6)
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM32X2S #(
      .INIT_00(32'h00000000), // INIT for bit 0 of RAM
      .INIT_01(32'h00000000)  // INIT for bit 1 of RAM
   ) RAM32X2S_inst (
      .O0(O0),     // RAM data[0] output
      .O1(O1),     // RAM data[1] output
      .A0(A0),     // RAM address[0] input
      .A1(A1),     // RAM address[1] input
      .A2(A2),     // RAM address[2] input
      .A3(A3),     // RAM address[3] input
      .A4(A4),     // RAM address[4] input
      .D0(D0),     // RAM data[0] input
      .D1(D1),     // RAM data[1] input
      .WCLK(WCLK), // Write clock input
      .WE(WE)      // Write enable input
   );

   // End of RAM32X2S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="64 Deep (6-bit address)" treetype="folder">
							<Template label="64 X 1 negedge write (RAM64X1S_1)" treetype="template">
//  RAM64X1S_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1S_1: 64 x 1 negative edge write, asynchronous read single-port
   //             distributed RAM (Mapped to a SliceM LUT6)
   //             Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1S_1 #(
      .INIT(64'h0000000000000000) // Initial contents of RAM
   ) RAM64X1S_1_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM64X1S_1_inst instantiation
							</Template>
							<Template label="64 X 1 posedge write (RAM64X1S)" treetype="template">
//  RAM64X1S   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM64X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM64X1S: 64 x 1 positive edge write, asynchronous read single-port
   //           distributed RAM (Mapped to a SliceM LUT6)
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM64X1S #(
      .INIT(64'h0000000000000000) // Initial contents of RAM
   ) RAM64X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM64X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="128 Deep (7-bit address)" treetype="folder">
							<Template label="128 X 1 negedge write (RAM128X1S_1)" treetype="template">
// RAM128X1S_1 : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S_1: 128 x 1 negative edge write, asynchronous read single-port
   //              distributed RAM (Mapped to two SliceM LUT6s)
   //              Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S_1 #(
      .INIT(128'h00000000000000000000000000000000)  // Initial contents of RAM
   ) RAM128X1S_1_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_1_inst instantiation
							</Template>
							<Template label="128 X 1 posedge write (RAM128X1S)" treetype="template">
//  RAM128X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM128X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM128X1S: 128 x 1 positive edge write, asynchronous read single-port
   //            distributed RAM (Mapped to two SliceM LUT6s)
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   RAM128X1S #(
      .INIT(128'h00000000000000000000000000000000) // Initial contents of RAM
   ) RAM128X1S_inst (
      .O(O),        // 1-bit data output
      .A0(A0),      // Address[0] input bit
      .A1(A1),      // Address[1] input bit
      .A2(A2),      // Address[2] input bit
      .A3(A3),      // Address[3] input bit
      .A4(A4),      // Address[4] input bit
      .A5(A5),      // Address[5] input bit
      .A6(A6),      // Address[6] input bit
      .D(D),        // 1-bit data input
      .WCLK(WCLK),  // Write clock input
      .WE(WE)       // Write enable input
   );

   // End of RAM128X1S_inst instantiation
							</Template>
						</SubFolder>
						<SubFolder label="256 Deep (8-bit address)" treetype="folder">
							<Template label="256 X 1 posedge write (RAM256X1S)" treetype="template">
//  RAM256X1S  : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (RAM256X1S_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // RAM256X1S: 256-deep by 1-wide positive edge write, asynchronous read  (Mapped to four SliceM LUT6s)
   //            single-port distributed LUT RAM
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   RAM256X1S #( 
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000)
   ) RAM256X1S_inst (
      .O(O),       // Read/write port 1-bit output
      .A(A),       // Read/write port 8-bit address input
      .WE(WE),     // Write enable input
      .WCLK(WCLK), // Write clock input
      .D(D)        // RAM data input
   );

   // End of RAM256X1S_inst instantiation
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Distributed ROM" treetype="folder">
					<Template label="32 X 1 (ROM32X1)" treetype="template">
//   ROM32X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM32X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM32X1: 32 x 1 Asynchronous Distributed (LUT) ROM (Mapped to a SliceM LUT6)
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   ROM32X1 #(
      .INIT(32'h00000000) // Contents of ROM
   ) ROM32X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4)  // ROM address[4]
   );

   // End of ROM32X1_inst instantiation
					</Template>
					<Template label="64 X 1 (ROM64X1)" treetype="template">
//   ROM64X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM64X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM64X1: 64 x 1 Asynchronous Distributed (LUT) ROM (Mapped to a SliceM LUT6)
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   ROM64X1 #(
      .INIT(64'h0000000000000000) // Contents of ROM
   ) ROM64X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4), // ROM address[4]
      .A5(A5)  // ROM address[5]
   );

   // End of ROM64X1_inst instantiation
					</Template>
					<Template label="128 X 1 (ROM128X1)" treetype="template">
//   ROM128X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM128X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM128X1: 128 x 1 Asynchronous Distributed (LUT) ROM (Mapped to two SliceM LUT6s)
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   ROM128X1 #(
      .INIT(128'h00000000000000000000000000000000) // Contents of ROM
   ) ROM128X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4), // ROM address[4]
      .A5(A5), // ROM address[5]
      .A6(A6)  // ROM address[6]
   );

   // End of ROM128X1_inst instantiation
					</Template>
					<Template label="256 X 1 (ROM256X1)" treetype="template">
//   ROM256X1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (ROM256X1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // ROM256X1: 256 x 1 Asynchronous Distributed (LUT) ROM (Mapped to four SliceM LUT6s)
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   ROM256X1 #(
      .INIT(256'h0000000000000000000000000000000000000000000000000000000000000000) // Contents of ROM
   ) ROM256X1_inst (
      .O(O),   // ROM output
      .A0(A0), // ROM address[0]
      .A1(A1), // ROM address[1]
      .A2(A2), // ROM address[2]
      .A3(A3), // ROM address[3]
      .A4(A4), // ROM address[4]
      .A5(A5), // ROM address[5]
      .A6(A6), // ROM address[6]
      .A7(A7)  // ROM address[7]
   );

   // End of ROM256X1_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="FIFO" treetype="folder">
					<Template label="18Kb First-In-First-Out (FIFO) Buffer Memory (FIFO18E1)" treetype="template">
//  FIFO18E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO18E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO18E1: 18Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   FIFO18E1 #(
      .ALMOST_EMPTY_OFFSET(13'h0080),    // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(13'h0080),     // Sets almost full threshold
      .DATA_WIDTH(4),                    // Sets data width to 4-36
      .DO_REG(1),                        // Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      .EN_SYN("FALSE"),                  // Specifies FIFO as dual-clock (FALSE) or Synchronous (TRUE)
      .FIFO_MODE("FIFO18"),              // Sets mode to FIFO18 or FIFO18_36
      .FIRST_WORD_FALL_THROUGH("FALSE"), // Sets the FIFO FWFT to FALSE, TRUE
      .INIT(36'h000000000),              // Initial values on output port
      .SIM_DEVICE("7SERIES"),            // Must be set to "7SERIES" for simulation behavior
      .SRVAL(36'h000000000)              // Set/Reset value for output port
   )
   FIFO18E1_inst (
      // Read Data: 32-bit (each) output: Read output data
      .DO(DO),                   // 32-bit output: Data output
      .DOP(DOP),                 // 4-bit output: Parity data output
      // Status: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY), // 1-bit output: Almost empty flag
      .ALMOSTFULL(ALMOSTFULL),   // 1-bit output: Almost full flag
      .EMPTY(EMPTY),             // 1-bit output: Empty flag
      .FULL(FULL),               // 1-bit output: Full flag
      .RDCOUNT(RDCOUNT),         // 12-bit output: Read count
      .RDERR(RDERR),             // 1-bit output: Read error
      .WRCOUNT(WRCOUNT),         // 12-bit output: Write count
      .WRERR(WRERR),             // 1-bit output: Write error
      // Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      .RDCLK(RDCLK),             // 1-bit input: Read clock
      .RDEN(RDEN),               // 1-bit input: Read enable
      .REGCE(REGCE),             // 1-bit input: Clock enable
      .RST(RST),                 // 1-bit input: Asynchronous Reset
      .RSTREG(RSTREG),           // 1-bit input: Output register set/reset
      // Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      .WRCLK(WRCLK),             // 1-bit input: Write clock
      .WREN(WREN),               // 1-bit input: Write enable
      // Write Data: 32-bit (each) input: Write input data
      .DI(DI),                   // 32-bit input: Data input
      .DIP(DIP)                  // 4-bit input: Parity input
   );

   // End of FIFO18E1_inst instantiation
					</Template>
					<Template label="36Kb First-In-First-Out (FIFO) Buffer Memory (FIFO36E1)" treetype="template">
//  FIFO36E1   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (FIFO36E1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // FIFO36E1: 36Kb FIFO (First-In-First-Out) Block RAM Memory
   //           Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   FIFO36E1 #(
      .ALMOST_EMPTY_OFFSET(13'h0080),    // Sets the almost empty threshold
      .ALMOST_FULL_OFFSET(13'h0080),     // Sets almost full threshold
      .DATA_WIDTH(4),                    // Sets data width to 4-72
      .DO_REG(1),                        // Enable output register (1-0) Must be 1 if EN_SYN = FALSE
      .EN_ECC_READ("FALSE"),             // Enable ECC decoder, FALSE, TRUE
      .EN_ECC_WRITE("FALSE"),            // Enable ECC encoder, FALSE, TRUE
      .EN_SYN("FALSE"),                  // Specifies FIFO as Asynchronous (FALSE) or Synchronous (TRUE)
      .FIFO_MODE("FIFO36"),              // Sets mode to "FIFO36" or "FIFO36_72" 
      .FIRST_WORD_FALL_THROUGH("FALSE"), // Sets the FIFO FWFT to FALSE, TRUE
      .INIT(72'h000000000000000000),     // Initial values on output port
      .SIM_DEVICE("7SERIES"),            // Must be set to "7SERIES" for simulation behavior
      .SRVAL(72'h000000000000000000)     // Set/Reset value for output port
   )
   FIFO36E1_inst (
      // ECC Signals: 1-bit (each) output: Error Correction Circuitry ports
      .DBITERR(DBITERR),             // 1-bit output: Double bit error status
      .ECCPARITY(ECCPARITY),         // 8-bit output: Generated error correction parity
      .SBITERR(SBITERR),             // 1-bit output: Single bit error status
      // Read Data: 64-bit (each) output: Read output data
      .DO(DO),                       // 64-bit output: Data output
      .DOP(DOP),                     // 8-bit output: Parity data output
      // Status: 1-bit (each) output: Flags and other FIFO status outputs
      .ALMOSTEMPTY(ALMOSTEMPTY),     // 1-bit output: Almost empty flag
      .ALMOSTFULL(ALMOSTFULL),       // 1-bit output: Almost full flag
      .EMPTY(EMPTY),                 // 1-bit output: Empty flag
      .FULL(FULL),                   // 1-bit output: Full flag
      .RDCOUNT(RDCOUNT),             // 13-bit output: Read count
      .RDERR(RDERR),                 // 1-bit output: Read error
      .WRCOUNT(WRCOUNT),             // 13-bit output: Write count
      .WRERR(WRERR),                 // 1-bit output: Write error
      // ECC Signals: 1-bit (each) input: Error Correction Circuitry ports
      .INJECTDBITERR(INJECTDBITERR), // 1-bit input: Inject a double bit error input
      .INJECTSBITERR(INJECTSBITERR),
      // Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals
      .RDCLK(RDCLK),                 // 1-bit input: Read clock
      .RDEN(RDEN),                   // 1-bit input: Read enable
      .REGCE(REGCE),                 // 1-bit input: Clock enable
      .RST(RST),                     // 1-bit input: Reset
      .RSTREG(RSTREG),               // 1-bit input: Output register set/reset
      // Write Control Signals: 1-bit (each) input: Write clock and enable input signals
      .WRCLK(WRCLK),                 // 1-bit input: Rising edge write clock.
      .WREN(WREN),                   // 1-bit input: Write enable
      // Write Data: 64-bit (each) input: Write input data
      .DI(DI),                       // 64-bit input: Data input
      .DIP(DIP)                      // 8-bit input: Parity input
   );

   // End of FIFO36E1_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Registers &amp; Latches" treetype="folder">
				<SubFolder label="Double Data Rate" treetype="folder">
					<Template label="Dual-Clock, Input DDR Register (IDDR_2CLK)" treetype="template">
//    IDDR_2CLK  : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR_2CLK: Dual-Clock, Input Double Data Rate Input Register with 
   //            Set, Reset and Clock Enable.
   //            Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR_2CLK #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_2CLK_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit primary clock input
      .CB(CB), // 1-bit secondary clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_2CLK_inst instantiation
					</Template>
					<Template label="Input DDR Register (IDDR)" treetype="template">
//      IDDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (IDDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // IDDR: Input Double Data Rate Input Register with Set, Reset
   //       and Clock Enable.
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   IDDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE", "SAME_EDGE" 
                                      //    or "SAME_EDGE_PIPELINED" 
      .INIT_Q1(1'b0), // Initial value of Q1: 1'b0 or 1'b1
      .INIT_Q2(1'b0), // Initial value of Q2: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) IDDR_inst (
      .Q1(Q1), // 1-bit output for positive edge of clock 
      .Q2(Q2), // 1-bit output for negative edge of clock
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D(D),   // 1-bit DDR data input
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of IDDR_inst instantiation
					</Template>
					<Template label="Output DDR Register (ODDR)" treetype="template">
//      ODDR     : In order to incorporate this function into the design,
//     Verilog   : the following instance declaration needs to be placed
//    instance   : in the body of the design code.  The instance name
//   declaration : (ODDR_inst) and/or the port declarations within the
//      code     : parenthesis may be changed to properly reference and
//               : connect this function to the design.  Delete or comment
//               : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // ODDR: Output Double Data Rate Output Register with Set, Reset
   //       and Clock Enable.
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   ODDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE" or "SAME_EDGE" 
      .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) ODDR_inst (
      .Q(Q),   // 1-bit DDR output
      .C(C),   // 1-bit clock input
      .CE(CE), // 1-bit clock enable input
      .D1(D1), // 1-bit data input (positive edge)
      .D2(D2), // 1-bit data input (negative edge)
      .R(R),   // 1-bit reset
      .S(S)    // 1-bit set
   );

   // End of ODDR_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Single Data Rate" treetype="folder">
					<Template label="Posedge D-FF w/ Async Clear and CE (FDCE)" treetype="template">
//     FDCE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDCE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and
   //       Clock Enable (posedge clk).
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDCE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDCE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .CLR(CLR),  // 1-bit Asynchronous clear input
      .D(D)       // 1-bit Data input
   );

   // End of FDCE_inst instantiation
					</Template>
					<Template label="Posedge D-FF w/ Async Preset and CE (FDPE)" treetype="template">
//     FDPE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDPE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDPE: Single Data Rate D Flip-Flop with Asynchronous Preset and
   //       Clock Enable (posedge clk).
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDPE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDPE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .PRE(PRE),  // 1-bit Asynchronous preset input
      .D(D)       // 1-bit Data input
   );

   // End of FDPE_inst instantiation
					</Template>
					<Template label="Posedge D-FF w/ Sync Reset and CE (FDRE)" treetype="template">
//     FDRE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDRE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and
   //       Clock Enable (posedge clk).
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDRE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDRE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .R(R),      // 1-bit Synchronous reset input
      .D(D)       // 1-bit Data input
   );

   // End of FDRE_inst instantiation
					</Template>
					<Template label="Posedge D-FF w/ Sync Set and CE (FDSE)" treetype="template">
//     FDSE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (FDSE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // FDSE: Single Data Rate D Flip-Flop with Synchronous Set and
   //       Clock Enable (posedge clk).
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   FDSE #(
      .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
   ) FDSE_inst (
      .Q(Q),      // 1-bit Data output
      .C(C),      // 1-bit Clock input
      .CE(CE),    // 1-bit Clock enable input
      .S(S),      // 1-bit Synchronous set input
      .D(D)       // 1-bit Data input
   );

   // End of FDSE_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Transparent Latch" treetype="folder">
					<Template label="Latch with Async Reset and Gate Enable (LDCE)" treetype="template">
//     LDCE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (LDCE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // LDCE:  Transparent latch with Asynchronous Reset and Gate Enable.
   //        Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   LDCE #(
      .INIT(1'b0) // Initial value of latch (1'b0 or 1'b1)
   ) LDCE_inst (
      .Q(Q),      // Data output
      .CLR(CLR),  // Asynchronous clear/reset input
      .D(D),      // Data input
      .G(G),      // Gate input
      .GE(GE)     // Gate enable input
   );
  
   // End of LDCE_inst instantiation
					</Template>
					<Template label="Latch with Async Set and Gate Enable (LDPE)" treetype="template">
//     LDPE     : In order to incorporate this function into the design,
//    Verilog   : the following instance declaration needs to be placed
//   instance   : in the body of the design code.  The instance name
//  declaration : (LDPE_inst) and/or the port declarations within the
//     code     : parenthesis may be changed to properly reference and
//              : connect this function to the design.  Delete or comment
//              : out inputs/outs that are not necessary.

//  &lt;-----Cut code below this line----&gt;

   // LDPE:  Transparent latch with Asynchronous Preset and Gate Enable.
   //        Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   LDPE #(
      .INIT(1'b1) // Initial value of latch (1'b0 or 1'b1)
   ) LDPE_inst (
      .Q(Q),      // Data output
      .PRE(PRE),  // Asynchronous preset/set input
      .D(D),      // Data input
      .G(G),      // Gate input
      .GE(GE)     // Gate enable input
   );
  
   // End of LDPE_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Slice/CLB Primitives" treetype="folder">
				<Template label="Carry (CARRY4)" treetype="template">
//   CARRY4    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CARRY4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design. All inputs and
//             : and outputs of this primitive should be connected.

//  &lt;-----Cut code below this line----&gt;

   // CARRY4: Fast Carry Logic Component
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   CARRY4 CARRY4_inst (
      .CO(CO),         // 4-bit carry out
      .O(O),           // 4-bit carry chain XOR data out
      .CI(CI),         // 1-bit carry cascade input
      .CYINIT(CYINIT), // 1-bit carry initialization
      .DI(DI),         // 4-bit carry-MUX data in
      .S(S)            // 4-bit carry-MUX select input
   );

   // End of CARRY4_inst instantiation
				</Template>
				<SubFolder label="LUTs" treetype="folder">
					<SubFolder label="Info" treetype="folder">
						<Template label="Info (LUT INIT)" treetype="template">
// The INIT parameter for the FPGA LUT primitive is what gives the LUT its 
// logical value. By default this value is zero thus driving the output to a  
// zero regardless of the input values (acting as a ground) however in most 
// cases an new INIT value must be determined in order to specify the logic 
// function for the LUT primitive.  There are a few methods in which the LUT 
// value can be determined and two of those methods will be discussed here.
//
// The Truth Table Method
// ----------------------
//
//  A common method to determine the desired INIT value for a LUT is using a 
// truth table.  To do so, simply create a binary truth table of all possible 
// inputs, specify the desired logic value of the output and then create the 
// INIT string from those output values.  An example is shown below:
//
// Example of determining an XOR INIT equation for a LUT4:
//
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | 0 |\
//     |  0  0  0  1 | 1 | \ = 4'b0110 = 4'h6 ---------------+
//     |  0  0  1  0 | 1 | /                                 |
//     |  0  0  1  1 | 0 |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | 1 |\                                  |
//     |  0  1  0  1 | 0 | \ = 4'b1001 = 4'h9                |
//     |  0  1  1  0 | 0 | /                                 |
//     |  0  1  1  1 | 1 |/                                  |                     
//     |-------------|---|                     INIT = 16'h6996
//     |  1  0  0  0 | 1 |\                               |
//     |  1  0  0  1 | 0 | \ = 4'b0110 = 4'h9             |
//     |  1  0  1  0 | 0 | /                              |
//     |  1  0  1  1 | 1 |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | 0 |\                               |
//     |  1  1  0  1 | 1 | \ = 4'b1001 = 4'h6 ------------+
//     |  1  1  1  0 | 1 | /
//     |  1  1  1  1 | 0 |/
//     -------------------
//
// Example of determining a 3-input AND gate:
//
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | 0 |\
//     |  0  0  1 | 0 | \ = 4'b0000 = 4'h0 --------------+
//     |  0  1  0 | 0 | /                                |
//     |  0  1  1 | 0 |/                                 |
//     |----------|---|                       INIT = 8'h80 
//     |  1  0  0 | 0 |\                                |
//     |  1  0  1 | 0 | \ = 4'b1000 = 4'h8 -------------+
//     |  1  1  0 | 0 | / 
//     |  1  1  1 | 1 |/                      
//     ----------------
//
// The Equation Method
// -------------------
//
// Another method to determine the LUT value is to define parameters for each 
// input to the LUT that correspond to their listed truth value and use those to
// build the logic equation you are after.  This method is easier to understand 
// once you have grasped the concept and more self-documenting that the above 
// method however does require the code to first specify the appropriate 
// parameters.  See the example below.
//
// Example of specifying the equation (A and B) or (C and D) for a LUT4:
//
   // The following parameters are defined to allow for
   //   equation-based INIT specification.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;

   // LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT((I0&amp;I1)|(I2&amp;I3))  // Specify LUT Contents
   ) LUT4_inst (
      .O(O_LUT), // LUT general output
      .I0(A),    // LUT input
      .I1(B),    // LUT input
      .I2(C),    // LUT input
      .I3(D)     // LUT input
   );

   // End of LUT4_inst instantiation

// With the parameters specifying all possible cases for the truth table, a 
// Verilog equation can be written to determine the end INIT value.
						</Template>
						<SubFolder label="INIT Parameters" treetype="folder">
							<Template label="LUT1" treetype="template">
   // The following parameter is defined to allow for
   //   equation-based INIT specification for a LUT1.
   parameter I0 = 2'b10;
							</Template>
							<Template label="LUT2" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT2.
   parameter I0 = 4'ha;
   parameter I1 = 4'hc;
							</Template>
							<Template label="LUT3" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT3.
   parameter I0 = 8'haa;
   parameter I1 = 8'hcc;
   parameter I2 = 8'hf0;
							</Template>
							<Template label="LUT4" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT4.
   parameter I0 = 16'haaaa;
   parameter I1 = 16'hcccc;
   parameter I2 = 16'hf0f0;
   parameter I3 = 16'hff00;
							</Template>
							<Template label="LUT5" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT5.
   parameter I0 = 32'haaaaaaaa;
   parameter I1 = 32'hcccccccc;
   parameter I2 = 32'hf0f0f0f0;
   parameter I3 = 32'hff00ff00;
   parameter I4 = 32'hffff0000;
							</Template>
							<Template label="LUT6" treetype="template">
   // The following parameters are defined to allow for
   //   equation-based INIT specification for a LUT6.
   parameter I0 = 64'haaaaaaaaaaaaaaaa;
   parameter I1 = 64'hcccccccccccccccc;
   parameter I2 = 64'hf0f0f0f0f0f0f0f0;
   parameter I3 = 64'hff00ff00ff00ff00;
   parameter I4 = 64'hffff0000ffff0000;
   parameter I5 = 64'hffffffff00000000;
							</Template>
						</SubFolder>
						<SubFolder label="INIT Truth Tables" treetype="folder">
							<Template label="LUT1" treetype="template">
//  Truth Table to determine INIT value for a LUT1
//      ________
//     | I0 | O |
//     |--------|
//     |  0 | ? |\
//     |  1 | ? |/ = 2'b??
//     ----------
							</Template>
							<Template label="LUT2" treetype="template">
//  Truth Table to determine INIT value for a LUT2
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = INIT = 4'b???? = 4'h?
//     |  0  1  0 | ? | /
//     |  0  1  1 | ? |/ 
//      ---------- --- 
							</Template>
							<Template label="LUT3" treetype="template">
//  Truth Table to determine INIT value for a LUT3
//      ______________
//     | I2 I1 I0 | O |
//     |--------------|
//     |  0  0  0 | ? |\
//     |  0  0  1 | ? | \ = 4'b???? = 4'h? --------------+
//     |  0  1  0 | ? | /                                |
//     |  0  1  1 | ? |/                                 |
//     |----------|---|                       INIT = 8'h?? 
//     |  1  0  0 | ? |\                                |
//     |  1  0  1 | ? | \ = 4'b???? = 4'h? -------------+
//     |  1  1  0 | ? | / 
//     |  1  1  1 | ? |/                      
//     ----------------
							</Template>
							<Template label="LUT4" treetype="template">
//  Truth Table to determine INIT value for a LUT4
//      _________________
//     | I3 I2 I1 I0 | O |
//     |-----------------|
//     |  0  0  0  0 | ? |\
//     |  0  0  0  1 | ? | \ = 4'b???? = 4'h? ---------------+
//     |  0  0  1  0 | ? | /                                 |
//     |  0  0  1  1 | ? |/                                  |
//     |-------------|---|                                   |
//     |  0  1  0  0 | ? |\                                  |
//     |  0  1  0  1 | ? | \ = 4'b???? = 4'h?                |
//     |  0  1  1  0 | ? | /                                 |
//     |  0  1  1  1 | ? |/                                  |                     
//     |-------------|---|                     INIT = 16'h????
//     |  1  0  0  0 | ? |\                               |
//     |  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  0 | ? | /                              |
//     |  1  0  1  1 | ? |/                               |
//     |-------------|---|                                |
//     |  1  1  0  0 | ? |\                               |
//     |  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  0 | ? | /
//     |  1  1  1  1 | ? |/
//     -------------------
							</Template>
							<Template label="LUT5" treetype="template">
//  Truth Table to determine INIT value for a LUT5
//      ____________________
//     | I4 I3 I2 I1 I0 | O |
//     |--------------------|
//     |  0  0  0  0  0 | ? |\
//     |  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  0  1  0  0 | ? |\                                      |
//     |  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1 | ? |/                                      |                     
//     |----------------|---|                                       |
//     |  0  1  0  0  0 | ? |\                                      |
//     |  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  0 | ? | /                                     |
//     |  0  1  0  1  1 | ? |/                                      |
//     |----------------|---|                                       |
//     |  0  1  1  0  0 | ? |\                                      |
//     |  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1 | ? |/                                      |
//     ----------------------                     INIT = 32'h????????
//     |  1  0  0  0  0 | ? |\                               |
//     |  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  0  1  0 | ? | /                              |
//     |  1  0  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  0  1  0  0 | ? |\                               |
//     |  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  0  1  1  0 | ? | /                              |
//     |  1  0  1  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  0  0  0 | ? |\                               |
//     |  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?             |
//     |  1  1  0  1  0 | ? | /                              |
//     |  1  1  0  1  1 | ? |/                               |
//     |----------------|---|                                |
//     |  1  1  1  0  0 | ? |\                               |
//     |  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ------------+
//     |  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1 | ? |/
//     ----------------------
							</Template>
							<Template label="LUT6" treetype="template">
//  Truth Table to determine INIT value for a LUT6
//      _______________________
//     | I5 I4 I3 I2 I1 I0 | O |
//     |-----------------------|
//     |  0  0  0  0  0  0 | ? |\
//     |  0  0  0  0  0  1 | ? | \ = 4'b???? = 4'h? -------------------+
//     |  0  0  0  0  1  0 | ? | /                                     |
//     |  0  0  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  0  1  0  0 | ? |\                                      |
//     |  0  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  0  1  1  0 | ? | /                                     |
//     |  0  0  0  1  1  1 | ? |/                                      |                     
//     |-------------------|---|                                       |
//     |  0  0  1  0  0  0 | ? |\                                      |
//     |  0  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  0  1  0 | ? | /                                     |
//     |  0  0  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  0  1  1  0  0 | ? |\                                      |
//     |  0  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  0  1  1  1  0 | ? | /                                     |
//     |  0  0  1  1  1  1 | ? |/                                      |
//     -------------------------                                       |
//     |  0  1  0  0  0  0 | ? |\                                      |
//     |  0  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  0  1  0 | ? | /                                     |
//     |  0  1  0  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  0  1  0  0 | ? |\                                      |
//     |  0  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  0  1  1  0 | ? | /                                     |
//     |  0  1  0  1  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  0  0  0 | ? |\                                      |
//     |  0  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  0  1  0 | ? | /                                     |
//     |  0  1  1  0  1  1 | ? |/                                      |
//     |-------------------|---|                                       |
//     |  0  1  1  1  0  0 | ? |\                                      |
//     |  0  1  1  1  0  1 | ? | \ = 4'b???? = 4'h?                    |
//     |  0  1  1  1  1  0 | ? | /                                     |
//     |  0  1  1  1  1  1 | ? |/                                      |
//     ------------------------              INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
							<Template label="LUT6_2" treetype="template">
//  Truth Table to determine INIT value for a LUT6_2
//      _____________________________
//     | I5 I4 I3 I2 I1 I0 | O6 | O5 |
//     |-----------------------------|
//     |  0  0  0  0  0  0 |    ?    |\
//     |  0  0  0  0  0  1 |    ?    | \ = 4'b???? = 4'h? -------------+
//     |  0  0  0  0  1  0 |    ?    | /                               |
//     |  0  0  0  0  1  1 |	?    |/				       |
//     |-------------------|---------|                                 |
//     |  0  0  0  1  0  0 |	?    |\                                |
//     |  0  0  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  0  1  1  0 |	?    | /                               |
//     |  0  0  0  1  1  1 |	?    |/                                |                     
//     |-------------------|---------|                                 |
//     |  0  0  1  0  0  0 |	?    |\                                |
//     |  0  0  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  0  1  0 |	?    | /                               |
//     |  0  0  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  0  1  1  0  0 |	?    |\                                |
//     |  0  0  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  0  1  1  1  0 |	?    | /                               |
//     |  0  0  1  1  1  1 |	?    |/                                |
//     -------------------------------                                 |
//     |  0  1  0  0  0  0 |	?    |\                                |
//     |  0  1  0  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  0  1  0 |	?    | /                               |
//     |  0  1  0  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  0  1  0  0 |	?    |\                                |
//     |  0  1  0  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  0  1  1  0 |	?    | /                               |
//     |  0  1  0  1  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  0  0  0 |	?    |\                                |
//     |  0  1  1  0  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  0  1  0 |	?    | /                               |
//     |  0  1  1  0  1  1 |	?    |/                                |
//     |-------------------|---------|                                 |
//     |  0  1  1  1  0  0 |	?    |\                                |
//     |  0  1  1  1  0  1 |	?    | \ = 4'b???? = 4'h?              |
//     |  0  1  1  1  1  0 |	?    | /                               |
//     |  0  1  1  1  1  1 |	?    |/                                |
//     ------------------------------        INIT = 64'h????????????????
//     |  1  0  0  0  0  0 | ? |\                       |
//     |  1  0  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  0  1  0 | ? | /                      |
//     |  1  0  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  0  1  0  0 | ? |\                       |
//     |  1  0  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  0  1  1  0 | ? | /                      |
//     |  1  0  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  0  1  0  0  0 | ? |\                       |
//     |  1  0  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  0  1  0 | ? | /                      |
//     |  1  0  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  0  1  1  0  0 | ? |\                       |
//     |  1  0  1  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  0  1  1  1  0 | ? | /                      |
//     |  1  0  1  1  1  1 | ? |/                       |
//     -------------------------                        |
//     |  1  1  0  0  0  0 | ? |\                       |
//     |  1  1  0  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  0  1  0 | ? | /                      |
//     |  1  1  0  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  0  1  0  0 | ? |\                       |
//     |  1  1  0  1  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  0  1  1  0 | ? | /                      |
//     |  1  1  0  1  1  1 | ? |/                       |                     
//     |-------------------|---|                        |
//     |  1  1  1  0  0  0 | ? |\                       |
//     |  1  1  1  0  0  1 | ? | \ = 4'b???? = 4'h?     |
//     |  1  1  1  0  1  0 | ? | /                      |
//     |  1  1  1  0  1  1 | ? |/                       |
//     |-------------------|---|                        |
//     |  1  1  1  1  0  0 | ? |\                       |
//     |  1  1  1  1  0  1 | ? | \ = 4'b???? = 4'h? ----+
//     |  1  1  1  1  1  0 | ? | /
//     |  1  1  1  1  1  1 | ? |/
//     ------------------------
							</Template>
						</SubFolder>
					</SubFolder>
					<Template label="LUT1" treetype="template">
//     LUT1    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1: 1-input Look-Up Table with general output (Mapped to a LUT6)
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT1 #(
      .INIT(2'b00)  // Specify LUT Contents
   ) LUT1_inst (
      .O(O),   // LUT general output
      .I0(I0)  // LUT input
   );

   // End of LUT1_inst instantiation
					</Template>
					<Template label="LUT1_D" treetype="template">
//   LUT1_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1_D: 1-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT1_D #(
      .INIT(2'b00)  // Specify LUT Contents
   ) LUT1_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0)  // LUT input
   );

   // End of LUT1_D_inst instantiation
					</Template>
					<Template label="LUT1_L" treetype="template">
//   LUT1_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT1_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT1_L: 1-input Look-Up Table with local output (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT1_L #(
      .INIT(2'b00)  // Specify LUT Contents
   ) LUT1_L_inst (
      .LO(LO), // LUT local output
      .I0(I0)  // LUT input
   );

   // End of LUT1_L_inst instantiation
					</Template>
					<Template label="LUT2" treetype="template">
//     LUT2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2: 2-input Look-Up Table with general output (Mapped to a LUT6)
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT2 #(
      .INIT(4'h0)  // Specify LUT Contents
   ) LUT2_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1)  // LUT input
   );

   // End of LUT2_inst instantiation
					</Template>
					<Template label="LUT2_D" treetype="template">
//   LUT2_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2_D: 2-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT2_D #(
      .INIT(4'h0)  // Specify LUT Contents
   ) LUT2_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1)  // LUT input
   );

   // End of LUT2_L_inst instantiation
					</Template>
					<Template label="LUT2_L" treetype="template">
//   LUT2_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT2_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT2_L: 2-input Look-Up Table with local output (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT2_L #(
      .INIT(4'h0)  // Specify LUT Contents
   ) LUT2_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1)  // LUT input
   );

   // End of LUT2_L_inst instantiation
					</Template>
					<Template label="LUT3" treetype="template">
//     LUT3    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3: 3-input Look-Up Table with general output (Mapped to a LUT6)
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT3 #(
      .INIT(8'h00)  // Specify LUT Contents
   ) LUT3_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2)  // LUT input
   );

   // End of LUT3_inst instantiation
					</Template>
					<Template label="LUT3_D" treetype="template">
//   LUT3_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3_D: 3-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT3_D #(
      .INIT(8'h00)  // Specify LUT Contents
   ) LUT3_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0),   // LUT input
      .I1(I1),   // LUT input
      .I2(I2)    // LUT input
   );

   // End of LUT3_D_inst instantiation
					</Template>
					<Template label="LUT3_L" treetype="template">
//   LUT3_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT3_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT3_L: 3-input Look-Up Table with local output (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT3_L #(
      .INIT(8'h00)  // Specify LUT Contents
   ) LUT3_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2)  // LUT input
   );

   // End of LUT3_L_inst instantiation
					</Template>
					<Template label="LUT4" treetype="template">
//     LUT4    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4: 4-input Look-Up Table with general output (Mapped to a LUT6)
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4 #(
      .INIT(16'h0000)  // Specify LUT Contents
   ) LUT4_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3)  // LUT input
   );

   // End of LUT4_inst instantiation
					</Template>
					<Template label="LUT4_D" treetype="template">
//   LUT4_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4_D: 4-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4_D #(
      .INIT(16'h0000)  // Specify LUT Contents
   ) LUT4_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3)  // LUT input
   );

   // End of LUT4_D_inst instantiation
					</Template>
					<Template label="LUT4_L" treetype="template">
//   LUT4_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT4_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT4_L: 4-input Look-Up Table with local output (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT4_L #(
      .INIT(16'h0000)  // Specify LUT Contents
   ) LUT4_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3)  // LUT input
   );

   // End of LUT4_L_inst instantiation
					</Template>
					<Template label="LUT5" treetype="template">
//    LUT5     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5: 5-input Look-Up Table with general output (Mapped to a LUT6)
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT5 #(
      .INIT(32'h00000000)  // Specify LUT Contents
   ) LUT5_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4)  // LUT input
   );

   // End of LUT5_inst instantiation
					</Template>
					<Template label="LUT5_D" treetype="template">
//   LUT5_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5_D: 5-input Look-Up Table with general and local outputs (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT5_D #(
      .INIT(32'h0000000)  // Specify LUT Contents
   ) LUT5_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4)  // LUT input
   );

   // End of LUT5_D_inst instantiation
					</Template>
					<Template label="LUT5_L" treetype="template">
//   LUT5_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT5_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT5_L: 5-input Look-Up Table with local output (Mapped to a LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT5_L #(
      .INIT(32'h0000000)  // Specify LUT Contents
   ) LUT5_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4)  // LUT input
   );

   // End of LUT5_L_inst instantiation
					</Template>
					<Template label="LUT6" treetype="template">
//    LUT6     : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6: 6-input Look-Up Table with general output
   //       Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6 #(
      .INIT(64'h0000000000000000)  // Specify LUT Contents
   ) LUT6_inst (
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4), // LUT input
      .I5(I5)  // LUT input
   );

   // End of LUT6_inst instantiation
					</Template>
					<Template label="LUT6_D" treetype="template">
//   LUT6_D    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_D: 6-input Look-Up Table with general and local outputs
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6_D #(
      .INIT(64'h0000000000000000)  // Specify LUT Contents
   ) LUT6_D_inst (
      .LO(LO), // LUT local output
      .O(O),   // LUT general output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4), // LUT input
      .I5(I5)  // LUT input
   );

   // End of LUT6_D_inst instantiation
					</Template>
					<Template label="LUT6_L" treetype="template">
//   LUT6_L    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_L: 6-input Look-Up Table with local output
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6_L #(
      .INIT(64'h0000000000000000)  // Specify LUT Contents
   ) LUT6_L_inst (
      .LO(LO), // LUT local output
      .I0(I0), // LUT input
      .I1(I1), // LUT input
      .I2(I2), // LUT input
      .I3(I3), // LUT input
      .I4(I4), // LUT input
      .I5(I5)  // LUT input
   );

   // End of LUT6_L_inst instantiation
					</Template>
					<Template label="LUT6_2" treetype="template">
//   LUT6_2    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (LUT6_2_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // LUT6_2: 6-input, 2 output Look-Up Table
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   LUT6_2 #(
      .INIT(64'h0000000000000000) // Specify LUT Contents
   ) LUT6_2_inst (
      .O6(O6), // 1-bit LUT6 output
      .O5(O5), // 1-bit lower LUT5 output
      .I0(I0), // 1-bit LUT input
      .I1(I1), // 1-bit LUT input
      .I2(I2), // 1-bit LUT input
      .I3(I3), // 1-bit LUT input
      .I4(I4), // 1-bit LUT input
      .I5(I5)  // 1-bit LUT input (fast MUX select only available to O6 output)
   );

   // End of LUT6_2_inst instantiation
					</Template>
					<Template label="Reconfigurable LUT (CFGLUT5)" treetype="template">
//   CFGLUT5   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (CFGLUT5_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // CFGLUT5: Reconfigurable 5-input LUT  (Mapped to a SliceM LUT6)
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   CFGLUT5 #(
      .INIT(32'h00000000) // Specify initial LUT contents
   ) CFGLUT5_inst (
      .CDO(CDO), // Reconfiguration cascade output
      .O5(O5),   // 4-LUT output
      .O6(O6),   // 5-LUT output
      .CDI(CDI), // Reconfiguration data input
      .CE(CE),   // Reconfiguration enable input
      .CLK(CLK), // Clock input
      .I0(I0),   // Logic data input
      .I1(I1),   // Logic data input
      .I2(I2),   // Logic data input
      .I3(I3),   // Logic data input
      .I4(I4)    // Logic data input
   );

   // End of CFGLUT5_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="MUXFx" treetype="folder">
					<Template label="MUXF7" treetype="template">
//    MUXF7    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7: CLB MUX to tie two LUT6's together with general output
   //        Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF7 MUXF7_inst (
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to LUT6 O6 pin)
      .I1(I1),  // Input (tie to LUT6 O6 pin)
      .S(S)     // Input select to MUX
   );

   // End of MUXF7_inst instantiation
					</Template>
					<Template label="MUXF7_D" treetype="template">
//   MUXF7_D   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7_D: CLB MUX to tie two LUT6's together with general and local outputs
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF7_D MUXF7_D_inst (
      .LO(LO),  // Output of MUX to local routing
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to LUT6 O6 pin)
      .I1(I1),  // Input (tie to LUT6 O6 pin)
      .S(S)     // Input select to MUX
   );

   // End of MUXF7_D_inst instantiation
					</Template>
					<Template label="MUXF7_L" treetype="template">
//   MUXF7_L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF7_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF7_L: CLB MUX to tie two LUT6's together with local output
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF7_L MUXF7_L_inst (
      .LO(LO),  // Output of MUX to local routing
      .I0(I0),  // Input (tie to LUT6 O6 pin)
      .I1(I1),  // Input (tie to LUT6 O6 pin)
      .S(S)     // Input select to MUX
   );

   // End of MUXF7_L_inst instantiation
					</Template>
					<Template label="MUXF8" treetype="template">
//    MUXF8    : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8: CLB MUX to tie two MUXF7's together with general output
   //        Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF8 MUXF8_inst (
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to MUXF7 L/LO out)
      .I1(I1),  // Input (tie to MUXF7 L/LO out)
      .S(S)     // Input select to MUX
   );

   // End of MUXF8_inst instantiation
					</Template>
					<Template label="MUXF8_D" treetype="template">
//   MUXF8_D   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_D_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8_D: CLB MUX to tie two MUXF7's together with general and local outputs
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF8_D MUXF8_D_inst (
      .LO(LO),  // Output of MUX to local routing
      .O(O),    // Output of MUX to general routing
      .I0(I0),  // Input (tie to MUXF7 L/LO out)
      .I1(I1),  // Input (tie to MUXF7 L/LO out)
      .S(S)     // Input select to MUX
   );

   // End of MUXF8_D_inst instantiation
					</Template>
					<Template label="MUXF8_L" treetype="template">
//   MUXF8_L   : In order to incorporate this function into the design,
//   Verilog   : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (MUXF8_L_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // MUXF8_L: CLB MUX to tie two MUXF7's together with local output
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4

   MUXF8_L MUXF8_L_inst (
      .LO(LO),  // Output of MUX to local routing
      .I0(I0),  // Input (tie to MUXF7 L/LO out)
      .I1(I1),  // Input (tie to MUXF7 L/LO out)
      .S(S)     // Input select to MUX
   );

   // End of MUXF8_L_inst instantiation
					</Template>
				</SubFolder>
				<SubFolder label="Shift Register LUT" treetype="folder">
					<Template label="16-bit w/ CE posedge SR (SRL16E)" treetype="template">
//  SRL16E     : In order to incorporate this function into the design,
//  Verilog    : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL16E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRL16E: 16-bit shift register LUT with clock enable operating
   //         on posedge of clock (Mapped to a SliceM LUT6)
   //         Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   SRL16E #(
      .INIT(16'h0000) // Initial Value of Shift Register
   ) SRL16E_inst (
      .Q(Q),       // SRL data output
      .A0(A0),     // Select[0] input
      .A1(A1),     // Select[1] input
      .A2(A2),     // Select[2] input
      .A3(A3),     // Select[3] input
      .CE(CE),     // Clock enable input
      .CLK(CLK),   // Clock input
      .D(D)        // SRL data input
   );

   // End of SRL16E_inst instantiation
					</Template>
					<Template label="32-bit w/ CE posedge SR (SRLC32E)" treetype="template">
//  SRLC32E     : In order to incorporate this function into the design,
//  Verilog    : the following instance declaration needs to be placed
//  instance   : in the body of the design code.  The instance name
// declaration : (SRL32E_inst) and/or the port declarations within the
//    code     : parenthesis may be changed to properly reference and
//             : connect this function to the design.  All inputs
//             : and outputs must be connected.

//  &lt;-----Cut code below this line----&gt;

   // SRLC32E: 32-bit variable length cascadable shift register LUT  (Mapped to a SliceM LUT6)
   //          with clock enable
   //          Virtex-7
   // Xilinx HDL Language Template, version 2016.4
   
   SRLC32E #(
      .INIT(32'h00000000) // Initial Value of Shift Register
   ) SRLC32E_inst (
      .Q(Q),     // SRL data output
      .Q31(Q31), // SRL cascade output pin
      .A(A),     // 5-bit shift depth select input
      .CE(CE),   // Clock enable input
      .CLK(CLK), // Clock input
      .D(D)      // SRL data input
   );

   // End of SRLC32E_inst instantiation
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
	</Folder>
	<Folder label="IP Integrator HDL" treetype="folder">
		<SubFolder label="Advanced Interfaces" treetype="folder">
			<Template label="10-Gigabit Ethernet Media Independent Interface" treetype="template">
// xgmii - 10-Gigabit Ethernet Media Independent Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; TXD" *)
  input [&lt;left_bound&gt;:0] &lt;s_txd&gt;, // Ethernet Transmit Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; TXC" *)
  input [&lt;left_bound&gt;:0] &lt;s_txc&gt;, // Ethernet Transmit Control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; RXD" *)
  output [&lt;left_bound&gt;:0] &lt;s_rxd&gt;, // Ethernet Receive Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; RXC" *)
  output [&lt;left_bound&gt;:0] &lt;s_rxc&gt;, // Ethernet Receive Control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; TX_CLK" *)
  input &lt;s_tx_clk&gt;, // Ethernet Transmit Clock (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:xgmii:1.0 &lt;interface_name&gt; RX_CLK" *)
  output &lt;s_rx_clk&gt;, // Ethernet Receive Clock (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<SubFolder label="acc" treetype="folder">
				<Template label="Accelerator Handshake Interface" treetype="template">
// acc_handshake - Accelerator Handshake Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; start" *)
  input &lt;s_start&gt;, // Accelerator Start (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; ready" *)
  output &lt;s_ready&gt;, // Accelerator Ready (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; done" *)
  output &lt;s_done&gt;, // Accelerator Done (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; continue" *)
  input &lt;s_continue&gt;, // Accelerator Continue (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_handshake:1.0 &lt;interface_name&gt; idle" *)
  output &lt;s_idle&gt;, // Accelerator Idle (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Acc_fifo_read" treetype="template">
// acc_fifo_read -  (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_fifo_read:1.0 &lt;interface_name&gt; RD_DATA" *)
  output [&lt;left_bound&gt;:0] &lt;s_rd_data&gt;, // FIFO Read Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_fifo_read:1.0 &lt;interface_name&gt; RD_EN" *)
  input &lt;s_rd_en&gt;, // FIFO Read Enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_fifo_read:1.0 &lt;interface_name&gt; EMPTY_N" *)
  output &lt;s_empty_n&gt;, // FIFO Empty flag (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Acc_fifo_write" treetype="template">
// acc_fifo_write -  (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_fifo_write:1.0 &lt;interface_name&gt; WR_DATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_wr_data&gt;, // FIFO Write Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_fifo_write:1.0 &lt;interface_name&gt; WR_EN" *)
  input &lt;s_wr_en&gt;, // FIFO Write Enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acc_fifo_write:1.0 &lt;interface_name&gt; FULL_N" *)
  output &lt;s_full_n&gt;, // FIFO Full flag (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<Template label="AMBA ACE Interface" treetype="template">
// acemm - AMBA ACE Interface (slave directions)
// 
// Allowed parameters:
//  MAX_BURST_LENGTH          - Max Burst Length          (long) 
//  NUM_WRITE_OUTSTANDING     - Num Write Outstanding     (long) 
//  NUM_READ_OUTSTANDING      - Num Read Outstanding      (long) 
//  SUPPORTS_NARROW_BURST     - Supports Narrow Burst     (long) 
//  READ_WRITE_MODE           - Read Write Mode           (string default: READ_WRITE) 
//  BUSER_WIDTH               - Buser Width               (long) 
//  RUSER_WIDTH               - Ruser Width               (long) 
//  WUSER_WIDTH               - Wuser Width               (long) 
//  ARUSER_WIDTH              - Aruser Width              (long) 
//  AWUSER_WIDTH              - Awuser Width              (long) 
//  ADDR_WIDTH                - Addr Width                (long) 
//  ID_WIDTH                  - Id Width                  (long) 
//  FREQ_HZ                   - Frequency                 (float default: 100000000) 
//  PROTOCOL                  - Protocol                  (string default: &lt;blank&gt;) 
//  DATA_WIDTH                - Data Width                (long) 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWID" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "MAX_BURST_LENGTH &lt;value&gt;,NUM_WRITE_OUTSTANDING &lt;value&gt;,NUM_READ_OUTSTANDING &lt;value&gt;,SUPPORTS_NARROW_BURST &lt;value&gt;,READ_WRITE_MODE &lt;value&gt;,BUSER_WIDTH &lt;value&gt;,RUSER_WIDTH &lt;value&gt;,WUSER_WIDTH &lt;value&gt;,ARUSER_WIDTH &lt;value&gt;,AWUSER_WIDTH &lt;value&gt;,ADDR_WIDTH &lt;value&gt;,ID_WIDTH &lt;value&gt;,FREQ_HZ &lt;value&gt;,PROTOCOL &lt;value&gt;,DATA_WIDTH &lt;value&gt;" *)
  input [&lt;left_bound&gt;:0] &lt;s_awid&gt;, // Write address ID (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWADDR" *)
  input [&lt;left_bound&gt;:0] &lt;s_awaddr&gt;, // Write address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWLEN" *)
  input [&lt;left_bound&gt;:0] &lt;s_awlen&gt;, // Burst length (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWSIZE" *)
  input [2:0] &lt;s_awsize&gt;, // Burst size (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWBURST" *)
  input [1:0] &lt;s_awburst&gt;, // Burst type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWLOCK" *)
  input [&lt;left_bound&gt;:0] &lt;s_awlock&gt;, // Lock type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWCACHE" *)
  input [3:0] &lt;s_awcache&gt;, // Cache type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWPROT" *)
  input [2:0] &lt;s_awprot&gt;, // Protection type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWREGION" *)
  input [3:0] &lt;s_awregion&gt;, // Write address slave region (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWQOS" *)
  input [3:0] &lt;s_awqos&gt;, // Transaction Quality of Service token (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWUSER" *)
  input [&lt;left_bound&gt;:0] &lt;s_awuser&gt;, // Write address user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWVALID" *)
  input &lt;s_awvalid&gt;, // Write address valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWREADY" *)
  output &lt;s_awready&gt;, // Write address ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWDOMAIN" *)
  input [1:0] &lt;s_awdomain&gt;, // Write address domain (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWSNOOP" *)
  input [2:0] &lt;s_awsnoop&gt;, // Write address snoop (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; AWBAR" *)
  input [1:0] &lt;s_awbar&gt;, // Write address barrier (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WID" *)
  input [&lt;left_bound&gt;:0] &lt;s_wid&gt;, // Write ID tag (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WDATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_wdata&gt;, // Write data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WSTRB" *)
  input [&lt;left_bound&gt;:0] &lt;s_wstrb&gt;, // Write strobes (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WLAST" *)
  input &lt;s_wlast&gt;, // Write last beat (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WUSER" *)
  input [&lt;left_bound&gt;:0] &lt;s_wuser&gt;, // Write data user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WVALID" *)
  input &lt;s_wvalid&gt;, // Write valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WREADY" *)
  output &lt;s_wready&gt;, // Write ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BID" *)
  output [&lt;left_bound&gt;:0] &lt;s_bid&gt;, // Response ID (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BRESP" *)
  output [1:0] &lt;s_bresp&gt;, // Write response (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BUSER" *)
  output [&lt;left_bound&gt;:0] &lt;s_buser&gt;, // Write response user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BVALID" *)
  output &lt;s_bvalid&gt;, // Write response valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; BREADY" *)
  input &lt;s_bready&gt;, // Write response ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; WACK" *)
  input &lt;s_wack&gt;, // Write response acknowledge (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARID" *)
  input [&lt;left_bound&gt;:0] &lt;s_arid&gt;, // Read address ID (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARADDR" *)
  input [&lt;left_bound&gt;:0] &lt;s_araddr&gt;, // Read address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARLEN" *)
  input [&lt;left_bound&gt;:0] &lt;s_arlen&gt;, // Burst length (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARSIZE" *)
  input [2:0] &lt;s_arsize&gt;, // Burst size (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARBURST" *)
  input [1:0] &lt;s_arburst&gt;, // Burst type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARLOCK" *)
  input [&lt;left_bound&gt;:0] &lt;s_arlock&gt;, // Lock type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARCACHE" *)
  input [3:0] &lt;s_arcache&gt;, // Cache type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARPROT" *)
  input [2:0] &lt;s_arprot&gt;, // Protection type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARREGION" *)
  input [3:0] &lt;s_arregion&gt;, // Read address slave region (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARQOS" *)
  input [3:0] &lt;s_arqos&gt;, // Quality of service token (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARUSER" *)
  input [&lt;left_bound&gt;:0] &lt;s_aruser&gt;, // Read address user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARVALID" *)
  input &lt;s_arvalid&gt;, // Read address valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARREADY" *)
  output &lt;s_arready&gt;, // Read address ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARDOMAIN" *)
  input [1:0] &lt;s_ardomain&gt;, // Read address domain (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARSNOOP" *)
  input [3:0] &lt;s_arsnoop&gt;, // Read address snoop (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ARBAR" *)
  input [1:0] &lt;s_arbar&gt;, // Read address barrier (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RID" *)
  output [&lt;left_bound&gt;:0] &lt;s_rid&gt;, // Read ID tag (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RDATA" *)
  output [&lt;left_bound&gt;:0] &lt;s_rdata&gt;, // Read data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RRESP" *)
  output [3:0] &lt;s_rresp&gt;, // Read response (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RLAST" *)
  output &lt;s_rlast&gt;, // Read last beat (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RUSER" *)
  output [&lt;left_bound&gt;:0] &lt;s_ruser&gt;, // Read data user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RVALID" *)
  output &lt;s_rvalid&gt;, // Read valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RREADY" *)
  input &lt;s_rready&gt;, // Read ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; RACK" *)
  input &lt;s_rack&gt;, // Read response acknowledge (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACVALID" *)
  output &lt;s_acvalid&gt;, // Snoop address valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACADDR" *)
  output [&lt;left_bound&gt;:0] &lt;s_acaddr&gt;, // Snoop address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACSNOOP" *)
  output [3:0] &lt;s_acsnoop&gt;, // Snoop address snoop (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACPROT" *)
  output [2:0] &lt;s_acprot&gt;, // Snoop address protection type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; ACREADY" *)
  input &lt;s_acready&gt;, // Snoop address ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CRREADY" *)
  output &lt;s_crready&gt;, // Snoop response ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CRVALID" *)
  input &lt;s_crvalid&gt;, // Snoop response valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CRRESP" *)
  input [4:0] &lt;s_crresp&gt;, // Snoop response (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CDVALID" *)
  input &lt;s_cdvalid&gt;, // Snoop data valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CDREADY" *)
  output &lt;s_cdready&gt;, // Snoop data ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CDDATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_cddata&gt;, // Snoop data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:acemm:1.0 &lt;interface_name&gt; CDLAST" *)
  input &lt;s_cdlast&gt;, // Snoop data last beat (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="AMBA AHB Lite interface" treetype="template">
// ahblite - AMBA AHB Lite interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; SEL" *)
  input &lt;s_sel&gt;, // Slave select (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HADDR" *)
  input [31:0] &lt;s_haddr&gt;, // Address bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HPROT" *)
  input [3:0] &lt;s_hprot&gt;, // Protenction type (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HTRANS" *)
  input [1:0] &lt;s_htrans&gt;, // Transfer type (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HSIZE" *)
  input [2:0] &lt;s_hsize&gt;, // Transfer size (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HWRITE" *)
  input &lt;s_hwrite&gt;, // Write / Read transfer (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HBURST" *)
  input [2:0] &lt;s_hburst&gt;, // Burst type (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HWDATA" *)
  input [31:0] &lt;s_hwdata&gt;, // Write data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HRDATA" *)
  output [31:0] &lt;s_hrdata&gt;, // Read data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HRESP" *)
  output &lt;s_hresp&gt;, // Status of the transfer (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HMASTLOCK" *)
  input &lt;s_hmastlock&gt;, // This signal indicates that the current transfer is part of a locked sequence (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:1.0 &lt;interface_name&gt; HREADY" *)
  output &lt;s_hready&gt;, // This signal indicates that the previous transfer is complete. (required)
//  additional ports here
);

//  user logic here

endmodule
// ahblite - AMBA AHB Lite interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; SEL" *)
  input &lt;s_sel&gt;, // Slave select (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HADDR" *)
  input [31:0] &lt;s_haddr&gt;, // Address bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HPROT" *)
  input [3:0] &lt;s_hprot&gt;, // Protection type (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HTRANS" *)
  input [1:0] &lt;s_htrans&gt;, // Transfer type (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HSIZE" *)
  input [2:0] &lt;s_hsize&gt;, // Transfer size (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HWRITE" *)
  input &lt;s_hwrite&gt;, // Write / Read transfer (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HBURST" *)
  input [2:0] &lt;s_hburst&gt;, // Burst type (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HWDATA" *)
  input [31:0] &lt;s_hwdata&gt;, // Write data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HRDATA" *)
  output [31:0] &lt;s_hrdata&gt;, // Read data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HRESP" *)
  output &lt;s_hresp&gt;, // Status of the transfer (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HMASTLOCK" *)
  input &lt;s_hmastlock&gt;, // This signal indicates that the current transfer is part of a locked sequence (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HREADY_IN" *)
  input &lt;s_hready_in&gt;, // This signal indicates that the previous transfer is complete. (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ahblite:2.0 &lt;interface_name&gt; HREADY_OUT" *)
  output &lt;s_hready_out&gt;, // This signal indicates that the transfer is complete. (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Apb" treetype="template">
// apb -  (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PADDR" *)
  input [31:0] &lt;s_paddr&gt;, // Address (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PPROT" *)
  input [2:0] &lt;s_pprot&gt;, // Protection (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PSEL" *)
  input &lt;s_psel&gt;, // Slave Select (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PENABLE" *)
  input &lt;s_penable&gt;, // Enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PWRITE" *)
  input &lt;s_pwrite&gt;, // Write Control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PWDATA" *)
  input [31:0] &lt;s_pwdata&gt;, // Write Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PSTRB" *)
  input [3:0] &lt;s_pstrb&gt;, // Write data strobe (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PREADY" *)
  output &lt;s_pready&gt;, // Slave Ready (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PRDATA" *)
  output [31:0] &lt;s_prdata&gt;, // Read Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:apb:1.0 &lt;interface_name&gt; PSLVERR" *)
  output &lt;s_pslverr&gt;, // Slave Error Response (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Avalon" treetype="template">
// avalon - Avalon interface (slave directions)
//

module my_module (

  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; ADDRESS" *)
  input [&lt;left_bound&gt;:0] &lt;s_address&gt;, // Read Write Address (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; READDATA" *)
  output [&lt;left_bound&gt;:0] &lt;s_readdata&gt;, // Read Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; READDATAVALID" *)
  output &lt;s_readdatavalid&gt;, // Read Datavalid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; WAITREQUEST" *)
  output &lt;s_waitrequest&gt;, // Wait Request (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; BYTEENABLE" *)
  input [&lt;left_bound&gt;:0] &lt;s_byteenable&gt;, // Byte Enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; READ" *)
  input &lt;s_read&gt;, // Read transfer (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; RESPONSE" *)
  output [1:0] &lt;s_response&gt;, // Read Write Response (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; WRITE" *)
  input &lt;s_write&gt;, // Write Transfer (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; WRITEDATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_writedata&gt;, // Write Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; LOCK" *)
  input &lt;s_lock&gt;, // Lock (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; WRITERESPONSEVALID" *)
  output &lt;s_writeresponsevalid&gt;, // Write Response Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; BURSTCOUNT" *)
  input [&lt;left_bound&gt;:0]   &lt;s_burstcount&gt;, // Burst Count (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:avalon:1.0 &lt;interface_name&gt; BEGINBURSTTRANSFER" *)
  input &lt;s_beginbursttransfer&gt;, // Begin Burst Transfer (optional)
  //  additional ports here
  );

// user logic here

endmodule
			</Template>
			<Template label="AXI SmartConnect Interface" treetype="template">
// sc - AXI SmartConnect Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; RECV" *)
  output [&lt;left_bound&gt;:0] &lt;s_recv&gt;, // Response Handshake (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; SEND" *)
  input [&lt;left_bound&gt;:0] &lt;s_send&gt;, // Forward Handshake (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; REQ" *)
  input [&lt;left_bound&gt;:0] &lt;s_req&gt;, // Arbitration Request (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; SEL" *)
  output [&lt;left_bound&gt;:0] &lt;s_sel&gt;, // Arbitration Response (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; PAYLD" *)
  input [&lt;left_bound&gt;:0] &lt;s_payld&gt;, // Transfer Payload (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sc:1.0 &lt;interface_name&gt; INFO" *)
  input [&lt;left_bound&gt;:0] &lt;s_info&gt;, // Additional Transfer Attributes (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Block RAM interface" treetype="template">
// bram - Xilinx Block RAM interface (slave directions)
// 
// Allowed parameters:
//  MASTER_TYPE               - Master Type               (string default: &lt;blank&gt;) 
//  MEM_ECC                   - Mem Ecc                   (string default: &lt;blank&gt;) 
//  MEM_WIDTH                 - Mem Width                 (long) 
//  MEM_SIZE                  - Mem Size                  (long) 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; EN" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "MASTER_TYPE &lt;value&gt;,MEM_ECC &lt;value&gt;,MEM_WIDTH &lt;value&gt;,MEM_SIZE &lt;value&gt;" *)
  input &lt;s_en&gt;, // Chip Enable Signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; DOUT" *)
  output [&lt;left_bound&gt;:0] &lt;s_dout&gt;, // Data Out Bus (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; DIN" *)
  input [&lt;left_bound&gt;:0] &lt;s_din&gt;, // Data In Bus (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; WE" *)
  input [&lt;left_bound&gt;:0] &lt;s_we&gt;, // Byte Enables (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; ADDR" *)
  input [&lt;left_bound&gt;:0] &lt;s_addr&gt;, // Address Signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; CLK" *)
  input &lt;s_clk&gt;, // Clock Signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bram:1.0 &lt;interface_name&gt; RST" *)
  input &lt;s_rst&gt;, // Reset Signal (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Boundary Scan (BSCAN) Bus Definition" treetype="template">
// bscan - Boundary Scan (BSCAN) Bus Definition (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; DRCK" *)
  input &lt;s_drck&gt;, // Data register clock (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; RESET" *)
  input &lt;s_reset&gt;, // Reset (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; SEL" *)
  input &lt;s_sel&gt;, // Select (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; CAPTURE" *)
  input &lt;s_capture&gt;, // Capture (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; SHIFT" *)
  input &lt;s_shift&gt;, // Shift (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; UPDATE" *)
  input &lt;s_update&gt;, // Update (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; TDI" *)
  input &lt;s_tdi&gt;, // Test data in (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:bscan:1.0 &lt;interface_name&gt; TDO" *)
  output &lt;s_tdo&gt;, // Test data out (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="bus definition for DDR4" treetype="template">
// ddr4 - bus definition for DDR4 (master directions)
// 
// Allowed parameters:
//  TIMEPERIOD_PS             - Timeperiod Ps             (string default: &lt;blank&gt;) 
//  MEMORY_TYPE               - Memory Type               (string default: Components) {Components,UDIMMs,SODIMMs,RDIMMs}
//  MEMORY_PART               - Memory Part               (string default: &lt;blank&gt;) 
//  CUSTOM_PARTS              - Custom Parts              (string default: &lt;blank&gt;) 
//  DATA_WIDTH                - Data Width                (string default: &lt;blank&gt;) 
//  SLOT                      - Slot                      (string default: Single) {Single,Dual}
//  CS_ENABLED                - Enable Chip Select Pin    (bool default: true) 
//  DATA_MASK_ENABLED         - Data Mask                 (string default: NONE) 
//  MEM_ADDR_MAP              - Memory Address Map        (string default: ROW_BANK_COLUMN) {ROW_BANK_COLUMN,BANK_ROW_COLUMN,ROW_COLUMN_BANK,ROW_COLUMN_BANK_INTLV}
//  BURST_LENGTH              - Burst Length              (long default: 8) 
//  AXI_ARBITRATION_SCHEME    - Arbitration Scheme        (string default: TDM) {TDM,ROUND_ROBIN,RD_PRI_REG,RD_PRI_REG_STARVE_LIMIT,WRITE_PRIORITY_REG,WRITE_PRIORITY}
//  CAS_LATENCY               - Cas Latency               (long default: 13) 
//  CAS_WRITE_LATENCY         - Cas Write Latency         (long default: 9) 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; DQ" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "TIMEPERIOD_PS &lt;value&gt;,MEMORY_TYPE &lt;value&gt;,MEMORY_PART &lt;value&gt;,CUSTOM_PARTS &lt;value&gt;,DATA_WIDTH &lt;value&gt;,SLOT &lt;value&gt;,CS_ENABLED &lt;value&gt;,DATA_MASK_ENABLED &lt;value&gt;,MEM_ADDR_MAP &lt;value&gt;,BURST_LENGTH &lt;value&gt;,AXI_ARBITRATION_SCHEME &lt;value&gt;,CAS_LATENCY &lt;value&gt;,CAS_WRITE_LATENCY &lt;value&gt;" *)
  inoutput [63:0] &lt;m_dq&gt;, // Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; DQS_T" *)
  inoutput [7:0] &lt;m_dqs_t&gt;, // Data Strobe (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; DQS_C" *)
  inoutput [7:0] &lt;m_dqs_c&gt;, // Data Strobe (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; ADR" *)
  output [12:0] &lt;m_adr&gt;, // Address (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; BA" *)
  output [2:0] &lt;m_ba&gt;, // Bank Address (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; BG" *)
  output &lt;m_bg&gt;, // Bank Group Bits (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; ACT_N" *)
  output &lt;m_act_n&gt;, // write enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; RESET_N" *)
  output &lt;m_reset_n&gt;, // reset to memory device (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; CK_T" *)
  output &lt;m_ck_t&gt;, // clock to memory device (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; CK_C" *)
  output &lt;m_ck_c&gt;, // clock to memory device (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; CKE" *)
  output &lt;m_cke&gt;, // clock enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; CS_N" *)
  output &lt;m_cs_n&gt;, // chip select (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; DM_N" *)
  inoutput [7:0] &lt;m_dm_n&gt;, // data mask (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; ODT" *)
  output &lt;m_odt&gt;, // on die termination (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddr4:1.0 &lt;interface_name&gt; PAR" *)
  output &lt;m_par&gt;, // parity bit (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Can" treetype="template">
// can -  (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:can:1.0 &lt;interface_name&gt; CLK" *)
  input &lt;m_clk&gt;, // CAN Clock (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:can:1.0 &lt;interface_name&gt; TX" *)
  output &lt;m_tx&gt;, // Trasnmit Line (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:can:1.0 &lt;interface_name&gt; RX" *)
  input &lt;m_rx&gt;, // Receive Line (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Configuration Access Port arbitration interface" treetype="template">
// cap - Configuration Access Port arbitration interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:cap:1.0 &lt;interface_name&gt; REQ" *)
  input &lt;s_req&gt;, // Request output signal. Used by the IP to Request access to the configuration engine (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cap:1.0 &lt;interface_name&gt; GNT" *)
  output &lt;s_gnt&gt;, // Grant input signal. Default drive_value 1. Used by an arbiter to Grant access of the configuration engine to an IP or endpoint (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cap:1.0 &lt;interface_name&gt; REL" *)
  output &lt;s_rel&gt;, // Request for Release input signal. Default_drive_value 0. Used by an arbiter to Request that an IP or endpoint give up control of the configuration engine (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<SubFolder label="cpri" treetype="folder">
				<Template label="Cpri_hdlc" treetype="template">
// cpri_hdlc - High Level Data Link Control Interface for CPRI (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_hdlc:1.0 &lt;interface_name&gt; TX_DATA" *)
  output &lt;s_tx_data&gt;, // HDLC Transmit Serial Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_hdlc:1.0 &lt;interface_name&gt; RX_DATA" *)
  input &lt;s_rx_data&gt;, // HDLC Receive Serial Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_hdlc:1.0 &lt;interface_name&gt; TX_ENABLE" *)
  input &lt;s_tx_enable&gt;, // HDLC Enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_hdlc:1.0 &lt;interface_name&gt; RX_DATA_VALID" *)
  input &lt;s_rx_data_valid&gt;, // HDLC Data Valid (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Cpri_iq" treetype="template">
// cpri_iq - CPRI I/Q Interface for sending and receiving sample data and synchronization information (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; DATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_data&gt;, // I/Q Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; ENABLE" *)
  output &lt;s_enable&gt;, // I/Q Enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; BFFW" *)
  input &lt;s_bffw&gt;, // I/Q Basic Frame First Word (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; STROBE" *)
  input &lt;s_strobe&gt;, // Frame Strobe (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_iq:1.0 &lt;interface_name&gt; STROBE_BFN" *)
  input [11:0] &lt;s_strobe_bfn&gt;, // Node B Frame Number (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="CPRI Vendor Specific Interface" treetype="template">
// cpri_vendor - CPRI Vendor Specific Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; DATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_data&gt;, // Vendor Specific Word (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; TX_XS" *)
  output [1:0] &lt;s_tx_xs&gt;, // Transmit Control Word Index (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; TX_NS" *)
  output [5:0] &lt;s_tx_ns&gt;, // Transmit Subchannel Index (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; RX_XS" *)
  input [1:0] &lt;s_rx_xs&gt;, // Receive Control Word Index (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:cpri_vendor:1.0 &lt;interface_name&gt; RX_NS" *)
  input [5:0] &lt;s_rx_ns&gt;, // Receive Subchannel Index (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<Template label="Ddrx" treetype="template">
// ddrx - Common bus definition for DDR2/DDR3/LPDDR etc (master directions)
// 
// Allowed parameters:
//  TIMEPERIOD_PS             - Timeperiod Ps             (string default: &lt;blank&gt;) 
//  CUSTOM_PARTS              - Custom Parts              (string default: &lt;blank&gt;) 
//  MEMORY_TYPE               - Memory Type               (string default: Components) {Components,UDIMMs,SODIMMs,RDIMMs}
//  MEMORY_PART               - Memory Part               (string default: &lt;blank&gt;) 
//  DATA_WIDTH                - Data Width                (string default: &lt;blank&gt;) 
//  SLOT                      - Slot                      (string default: Single) {Single,Dual}
//  CS_ENABLED                - Enable Chip Select Pin    (bool default: true) 
//  DATA_MASK_ENABLED         - Data Mask                 (bool default: true) 
//  MEM_ADDR_MAP              - Memory Address Map        (string default: ROW_BANK_COLUMN) {ROW_BANK_COLUMN,BANK_ROW_COLUMN,ROW_COLUMN_BANK,ROW_COLUMN_BANK_INTLV}
//  BURST_LENGTH              - Burst Length              (long default: 8) 
//  AXI_ARBITRATION_SCHEME    - Arbitration Scheme        (string default: TDM) {TDM,ROUND_ROBIN,RD_PRI_REG,RD_PRI_REG_STARVE_LIMIT,WRITE_PRIORITY_REG,WRITE_PRIORITY}
//  CAS_LATENCY               - Cas Latency               (long default: 13) 
//  CAS_WRITE_LATENCY         - Cas Write Latency         (long default: 9) 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; DQ" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "TIMEPERIOD_PS &lt;value&gt;,CUSTOM_PARTS &lt;value&gt;,MEMORY_TYPE &lt;value&gt;,MEMORY_PART &lt;value&gt;,DATA_WIDTH &lt;value&gt;,SLOT &lt;value&gt;,CS_ENABLED &lt;value&gt;,DATA_MASK_ENABLED &lt;value&gt;,MEM_ADDR_MAP &lt;value&gt;,BURST_LENGTH &lt;value&gt;,AXI_ARBITRATION_SCHEME &lt;value&gt;,CAS_LATENCY &lt;value&gt;,CAS_WRITE_LATENCY &lt;value&gt;" *)
  inoutput [63:0] &lt;m_dq&gt;, // Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; DQS_P" *)
  inoutput [7:0] &lt;m_dqs_p&gt;, // Data Strobe (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; DQS_N" *)
  inoutput [7:0] &lt;m_dqs_n&gt;, // Data Strobe (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; ADDR" *)
  output [12:0] &lt;m_addr&gt;, // Address (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; BA" *)
  output [2:0] &lt;m_ba&gt;, // Bank Address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; RAS_N" *)
  output &lt;m_ras_n&gt;, // row address strobe (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CAS_N" *)
  output &lt;m_cas_n&gt;, // column address strobe (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; WE_N" *)
  output &lt;m_we_n&gt;, // write enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; RESET_N" *)
  output &lt;m_reset_n&gt;, // reset to memory device (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CK_P" *)
  output &lt;m_ck_p&gt;, // clock to memory device (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CK_N" *)
  output &lt;m_ck_n&gt;, // clock to memory device (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CKE" *)
  output &lt;m_cke&gt;, // clock enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; CS_N" *)
  output &lt;m_cs_n&gt;, // chip select (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; DM" *)
  output [7:0] &lt;m_dm&gt;, // data mask (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; ODT" *)
  output &lt;m_odt&gt;, // on die termination (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ddrx:1.0 &lt;interface_name&gt; PARITY" *)
  output &lt;m_parity&gt;, // parity bit (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<SubFolder label="diff" treetype="folder">
				<Template label="Diff_analog_io" treetype="template">
// diff_analog_io - Differential Analog IO interface for VP/VN and VAUXP[15:0]/VAUXN[15:0] (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:diff_analog_io:1.0 &lt;interface_name&gt; V_P" *)
  input &lt;s_v_p&gt;, // Analog Volt P (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:diff_analog_io:1.0 &lt;interface_name&gt; V_N" *)
  input &lt;s_v_n&gt;, // Analog Volt N (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Differential Clock Interface" treetype="template">
// diff_clock - Differential Clock Interface (slave directions)
// 
// Allowed parameters:
//  FREQ_HZ                   - Frequency                 (float default: 100000000) 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:diff_clock:1.0 &lt;interface_name&gt; CLK_P" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "FREQ_HZ &lt;value&gt;" *)
  input &lt;s_clk_p&gt;, // ClockP (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:diff_clock:1.0 &lt;interface_name&gt; CLK_N" *)
  input &lt;s_clk_n&gt;, // ClockN (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<SubFolder label="dp" treetype="folder">
				<Template label="Dp_aux" treetype="template">
// dp_aux - Auxiliary interface is to access video register data (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_aux:1.0 &lt;interface_name&gt; AUX_TX_CHANNEL_OUT_P" *)
  input &lt;s_aux_tx_channel_out_p&gt;, // Aux. Channel out differential p (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_aux:1.0 &lt;interface_name&gt; AUX_TX_CHANNEL_OUT_N" *)
  input &lt;s_aux_tx_channel_out_n&gt;, // Aux. Channel out differential n (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_aux:1.0 &lt;interface_name&gt; AUX_TX_CHANNEL_IN_P" *)
  output &lt;s_aux_tx_channel_in_p&gt;, // Aux. Channel in differential p (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_aux:1.0 &lt;interface_name&gt; AUX_TX_CHANNEL_IN_N" *)
  output &lt;s_aux_tx_channel_in_n&gt;, // Aux. Channel in differential n (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Dp_main_lnk" treetype="template">
// dp_main_lnk - To move video stream through these high speed I/O from source to sink core (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_CLK_P" *)
  input &lt;m_lnk_clk_p&gt;, // Differential clock input(Positive) (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_CLK_N" *)
  input &lt;m_lnk_clk_n&gt;, // Differential clock input(Negative) (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_CLK" *)
  output &lt;m_lnk_clk&gt;, // Reference clock for FPGA fabric (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_TX_LANE_P" *)
  output [3:0] &lt;m_lnk_tx_lane_p&gt;, // High-speed lane serial data(Positive) (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_TX_LANE_N" *)
  output [3:0] &lt;m_lnk_tx_lane_n&gt;, // High-speed lane serial data(Negative) (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_M_VID" *)
  output [23:0] &lt;m_lnk_m_vid&gt;, // M-value for clock generation (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_main_lnk:1.0 &lt;interface_name&gt; LNK_N_VID" *)
  output [23:0] &lt;m_lnk_n_vid&gt;, // N-value for clock generation (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Dp_vid" treetype="template">
// dp_vid - Video interface is to access pixel data (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_CLK" *)
  input &lt;s_tx_vid_clk&gt;, // Video clock (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_RST" *)
  input &lt;s_tx_vid_rst&gt;, // Video reset (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_VSYNC" *)
  input &lt;s_tx_vid_vsync&gt;, // Vertical sync (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_HSYNC" *)
  input &lt;s_tx_vid_hsync&gt;, // Horizontal sync (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_ODDEVEN" *)
  input &lt;s_tx_vid_oddeven&gt;, // Video odd/even pixel (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_ENABLE" *)
  input &lt;s_tx_vid_enable&gt;, // Video enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_PIXEL0" *)
  input &lt;s_tx_vid_pixel0&gt;, // Video pixel 0 (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_PIXEL1" *)
  input &lt;s_tx_vid_pixel1&gt;, // Video pixel 1 (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_PIXEL2" *)
  input &lt;s_tx_vid_pixel2&gt;, // Vdeo pixel 2 (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dp_vid:1.0 &lt;interface_name&gt; TX_VID_PIXEL3" *)
  input &lt;s_tx_vid_pixel3&gt;, // Video pixel 3 (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<Template label="Dvi" treetype="template">
// dvi - DVI interface used for AXI TFT controller (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; CLK_P" *)
  output &lt;m_clk_p&gt;, // DVI Clock positive signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; CLK_N" *)
  output &lt;m_clk_n&gt;, // DVI Clock negative signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; DATA" *)
  output [11:0] &lt;m_data&gt;, // DVI Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; HSYNC" *)
  output &lt;m_hsync&gt;, // Horizantal sync signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; VSYNC" *)
  output &lt;m_vsync&gt;, // Vertical sync signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; DE" *)
  output &lt;m_de&gt;, // Display enable signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:dvi:1.0 &lt;interface_name&gt; DPS" *)
  output &lt;m_dps&gt;, // Display scan signal (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Dynamic Reconfiguration Port (DRP)" treetype="template">
// drp - Dynamic Reconfiguration Port (DRP) (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DEN" *)
  input &lt;s_den&gt;, // Enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DADDR" *)
  input [&lt;left_bound&gt;:0] &lt;s_daddr&gt;, // Address (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DI" *)
  input &lt;s_di&gt;, // Data In (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DO" *)
  output [&lt;left_bound&gt;:0] &lt;s_do&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DRDY" *)
  output &lt;s_drdy&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:drp:1.0 &lt;interface_name&gt; DWE" *)
  input &lt;s_dwe&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Emc" treetype="template">
// emc - external memory controller interface definition, used to define interfaces like EMC and memories. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_I" *)
  input [&lt;left_bound&gt;:0] &lt;s_dq_i&gt;, // Data signal from external memory (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_O" *)
  output [&lt;left_bound&gt;:0] &lt;s_dq_o&gt;, // Data signal from external memory (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_T" *)
  output [&lt;left_bound&gt;:0] &lt;s_dq_t&gt;, // Data signal from external memory (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_PARITY_I" *)
  input [&lt;left_bound&gt;:0] &lt;s_dq_parity_i&gt;, // Data parity input from memory (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_PARITY_O" *)
  output [&lt;left_bound&gt;:0] &lt;s_dq_parity_o&gt;, // Data parity output to memory (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; DQ_PARITY_T" *)
  output [&lt;left_bound&gt;:0] &lt;s_dq_parity_t&gt;, // Data parity enable signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; ADDR" *)
  input [&lt;left_bound&gt;:0] &lt;s_addr&gt;, // external memory address signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; CE" *)
  input [&lt;left_bound&gt;:0] &lt;s_ce&gt;, // Active high chip enable signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; CE_N" *)
  input [&lt;left_bound&gt;:0] &lt;s_ce_n&gt;, // Active low chip enable signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; OEN" *)
  input [&lt;left_bound&gt;:0] &lt;s_oen&gt;, // Outut enable signals (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; WEN" *)
  input [&lt;left_bound&gt;:0] &lt;s_wen&gt;, // Write enable signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; BEN" *)
  input [&lt;left_bound&gt;:0] &lt;s_ben&gt;, // byte enable signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; QWEN" *)
  input [&lt;left_bound&gt;:0] &lt;s_qwen&gt;, // Quad word enable signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; RPN" *)
  input &lt;s_rpn&gt;, // Reset or power down signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; ADV_LDN" *)
  input &lt;s_adv_ldn&gt;, // Active low address valid signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; LBON" *)
  input &lt;s_lbon&gt;, // interleaved burst ordering (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; CLKEN" *)
  input &lt;s_clken&gt;, // clock enable signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; RNW" *)
  input &lt;s_rnw&gt;, // Read or write signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; CRE" *)
  input &lt;s_cre&gt;, // command sequence configuration of RSRAM (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; WAIT" *)
  output [&lt;left_bound&gt;:0] &lt;s_wait&gt;, // wait signal from memory (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:emc:1.0 &lt;interface_name&gt; RD_CLK" *)
  input &lt;s_rd_clk&gt;, // Read Clock Signal (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Evntbus" treetype="template">
// evntbus - The event bus in ARM processors provide a low-latency and direct mechanism to transfer status and implement a wake mechanism for the Application processing unit (APU) (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:evntbus:1.0 &lt;interface_name&gt; EVENTO" *)
  input &lt;s_evento&gt;, // Toggle Output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:evntbus:1.0 &lt;interface_name&gt; EVENTI" *)
  output &lt;s_eventi&gt;, // Toggle Input (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:evntbus:1.0 &lt;interface_name&gt; STANDBYWFE" *)
  input [1:0] &lt;s_standbywfe&gt;, // Indicates CPU State Following the Execution of the WFE (wait for event) Instruction (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:evntbus:1.0 &lt;interface_name&gt; STANDBYWFI" *)
  input [1:0] &lt;s_standbywfi&gt;, // Indicates CPU State Following the Execution of the WFI (wait for interrupt) Instruction (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="external peripheral controller interface definition" treetype="template">
// epc - external peripheral controller interface definition (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; CS_N" *)
  input &lt;s_cs_n&gt;, // Chip Enable Signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; ADDR" *)
  input [&lt;left_bound&gt;:0] &lt;s_addr&gt;, // Address signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; ADS" *)
  input &lt;s_ads&gt;, // Address Strobe Signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; BE" *)
  input [&lt;left_bound&gt;:0] &lt;s_be&gt;, // Byte enables (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; RNW" *)
  input &lt;s_rnw&gt;, // Active high read and active low write signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; RD_N" *)
  input &lt;s_rd_n&gt;, // Active low read signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; WR_N" *)
  input &lt;s_wr_n&gt;, // Active low write signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; BURST" *)
  input &lt;s_burst&gt;, // Burst operation  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; RDY" *)
  output &lt;s_rdy&gt;, // Ready signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; DATA_I" *)
  input [&lt;left_bound&gt;:0] &lt;s_data_i&gt;, // Input signal from the tristate data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; DATA_O" *)
  output [&lt;left_bound&gt;:0] &lt;s_data_o&gt;, // output signal from the tristate data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; DATA_T" *)
  output [&lt;left_bound&gt;:0] &lt;s_data_t&gt;, // Output enable signal from the tristate data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; CLK" *)
  input &lt;s_clk&gt;, // Peripheral clock signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:epc:1.0 &lt;interface_name&gt; RST" *)
  input &lt;s_rst&gt;, // Peripheral Reset (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<SubFolder label="fifo" treetype="folder">
				<Template label="FIFO read interface" treetype="template">
// fifo_read - FIFO read interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:fifo_read:1.0 &lt;interface_name&gt; RD_DATA" *)
  output [&lt;left_bound&gt;:0] &lt;s_rd_data&gt;, // FIFO Read Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:fifo_read:1.0 &lt;interface_name&gt; RD_EN" *)
  input &lt;s_rd_en&gt;, // FIFO Read Enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:fifo_read:1.0 &lt;interface_name&gt; EMPTY" *)
  output &lt;s_empty&gt;, // FIFO Empty flag (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:fifo_read:1.0 &lt;interface_name&gt; ALMOST_EMPTY" *)
  output &lt;s_almost_empty&gt;, // FIFO Almost Empty flag (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Fifo_write" treetype="template">
// fifo_write -  (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:fifo_write:1.0 &lt;interface_name&gt; WR_DATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_wr_data&gt;, // FIFO Write Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:fifo_write:1.0 &lt;interface_name&gt; WR_EN" *)
  input &lt;s_wr_en&gt;, // FIFO Write Enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:fifo_write:1.0 &lt;interface_name&gt; FULL" *)
  output &lt;s_full&gt;, // FIFO Full flag (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:fifo_write:1.0 &lt;interface_name&gt; ALMOST_FULL" *)
  output &lt;s_almost_full&gt;, // FIFO Almost full flag (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<Template label="General purpose input output interface" treetype="template">
// gpio - General purpose input output interface (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:gpio:1.0 &lt;interface_name&gt; TRI_T" *)
  output [&lt;left_bound&gt;:0] &lt;m_tri_t&gt;, // Tristate output enable signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gpio:1.0 &lt;interface_name&gt; TRI_O" *)
  output [&lt;left_bound&gt;:0] &lt;m_tri_o&gt;, // Tristate output signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gpio:1.0 &lt;interface_name&gt; TRI_I" *)
  input [&lt;left_bound&gt;:0] &lt;m_tri_i&gt;, // Tristate input signal (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Gigabit Media Independent Interface" treetype="template">
// gmii - Gigabit Media Independent Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; TXD" *)
  input [7:0] &lt;s_txd&gt;, // Ethernet transmit data. (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; TX_EN" *)
  input &lt;s_tx_en&gt;, // Ethernet transmit enable. (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; TX_ER" *)
  input &lt;s_tx_er&gt;, // Ethernet transmit error. (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; RXD" *)
  output [7:0] &lt;s_rxd&gt;, // Ethernet receive data.  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; RX_DV" *)
  output &lt;s_rx_dv&gt;, // Ethernet receive data valid. (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; RX_ER" *)
  output &lt;s_rx_er&gt;, // Ethernet receive error. (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; CRS" *)
  output &lt;s_crs&gt;, // Ethernet carrier sense. (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; COL" *)
  output &lt;s_col&gt;, // Ethernet collision. (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; TX_CLK" *)
  output &lt;s_tx_clk&gt;, // Ethernet transmit clock for 10/100Mb/s Ethernet speeds (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; GTX_CLK" *)
  input &lt;s_gtx_clk&gt;, // Ethernet transmit clock for 1Gb/s Ethernet (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gmii:1.0 &lt;interface_name&gt; RX_CLK" *)
  output &lt;s_rx_clk&gt;, // Ethernet receive clock (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="GT interface" treetype="template">
// gt - GT interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:gt:1.0 &lt;interface_name&gt; GTX_P" *)
  input &lt;s_gtx_p&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:gt:1.0 &lt;interface_name&gt; GTX_N" *)
  input &lt;s_gtx_n&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="HDMI Interface" treetype="template">
// hdmi - HDMI Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:hdmi:1.0 &lt;interface_name&gt; DATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_data&gt;, // HDMI Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:hdmi:1.0 &lt;interface_name&gt; HSYNC" *)
  input &lt;s_hsync&gt;, // HDMI Horizontal sync (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:hdmi:1.0 &lt;interface_name&gt; VSYNC" *)
  input &lt;s_vsync&gt;, // HDMI Vertical sync (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:hdmi:1.0 &lt;interface_name&gt; DE" *)
  input &lt;s_de&gt;, // HDMI Active Video (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Hsic" treetype="template">
// hsic - HSIC interface for USB HSIC capable PHY's (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:hsic:1.0 &lt;interface_name&gt; DATA" *)
  inoutput &lt;m_data&gt;, // HSIC Data line (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:hsic:1.0 &lt;interface_name&gt; STROBE" *)
  inoutput &lt;m_strobe&gt;, // HSIC Strobe line (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="ICAP interface" treetype="template">
// icap - ICAP interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; csib" *)
  input &lt;s_csib&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; rdwrb" *)
  input &lt;s_rdwrb&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; i" *)
  input [31:0] &lt;s_i&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; o" *)
  output [31:0] &lt;s_o&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; clk" *)
  input &lt;s_clk&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; avail" *)
  output &lt;s_avail&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; prdone" *)
  output &lt;s_prdone&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:icap:1.0 &lt;interface_name&gt; prerror" *)
  output &lt;s_prerror&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="IIC Interface" treetype="template">
// iic - IIC Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SCL_I" *)
  output &lt;s_scl_i&gt;, // IIC Serial Clock Input from 3-state buffer (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SCL_O" *)
  input &lt;s_scl_o&gt;, // IIC Serial Clock Output to 3-state buffer (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SCL_T" *)
  input &lt;s_scl_t&gt;, // IIC Serial Clock Output Enable to 3-state buffer (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SDA_I" *)
  output &lt;s_sda_i&gt;, // IIC Serial Data Input from 3-state buffer (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SDA_O" *)
  input &lt;s_sda_o&gt;, // IIC Serial Data Output to 3-state buffer (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:iic:1.0 &lt;interface_name&gt; SDA_T" *)
  input &lt;s_sda_t&gt;, // IIC Serial Data Output Enable to 3-state buffer (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="_Info" treetype="template">
// 
// Verilog attributes are used to declare interfaces and set parameters on them.
// Due to the language, the attributes need to be placed before a port which is part of the interface.
// When adding one or more parameters for an interface, a single attribute with multiple
// key value pairs should be added to before of the ports that is mapped into the interface.
// Generally, the form of the attributes are:
//   (* X_INTERFACE_INFO = "&lt;interface vlnv&gt; &lt;interface_name&gt; &lt;logical_port_name&gt;" *)
//   (* X_INTERFACE_PARAMETER = "&lt;parameter_name1&gt; &lt;parameter_value1&gt;, &lt;parameter_name2&gt; &lt;parameter_value2&gt;" *) 
//   input &lt;portname&gt;; 
			</Template>
			<Template label="Jtag" treetype="template">
// jtag - Provides debug access via a standard JTAG debug interface (slave directions)
// 
// Allowed parameters:
//  BUFFER_TYPE               - Buffer Type               (string default: NONE) {AUTO,NONE}
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TCK" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "BUFFER_TYPE &lt;value&gt;" *)
  input &lt;s_tck&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TMS" *)
  input &lt;s_tms&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TD_I" *)
  input &lt;s_td_i&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TD_O" *)
  output &lt;s_td_o&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:jtag:1.0 &lt;interface_name&gt; TD_T" *)
  output &lt;s_td_t&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
// jtag - Provides debug access via a standard JTAG debug interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:jtag:2.0 &lt;interface_name&gt; TCK" *)
  input &lt;s_tck&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:jtag:2.0 &lt;interface_name&gt; TMS" *)
  input &lt;s_tms&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:jtag:2.0 &lt;interface_name&gt; TDI" *)
  input &lt;s_tdi&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:jtag:2.0 &lt;interface_name&gt; TDO" *)
  output &lt;s_tdo&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Local Memory Bus (LMB) Definition" treetype="template">
// lmb - Local Memory Bus (LMB) Definition (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; RST" *)
  input &lt;s_rst&gt;, // Reset (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; ABUS" *)
  input [31:0] &lt;s_abus&gt;, // Address bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; READSTROBE" *)
  input &lt;s_readstrobe&gt;, // Read strobe (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; WRITESTROBE" *)
  input &lt;s_writestrobe&gt;, // Write strobe (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; ADDRSTROBE" *)
  input &lt;s_addrstrobe&gt;, // Address strobe (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; WRITEDBUS" *)
  input [31:0] &lt;s_writedbus&gt;, // Write data bus (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; BE" *)
  input [3:0] &lt;s_be&gt;, // Byte enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; READY" *)
  output &lt;s_ready&gt;, // Ready (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; WAIT" *)
  output &lt;s_wait&gt;, // Wait (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; CE" *)
  output &lt;s_ce&gt;, // Correctable error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; UE" *)
  output &lt;s_ue&gt;, // Uncorrectable error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:lmb:1.0 &lt;interface_name&gt; READDBUS" *)
  output [31:0] &lt;s_readdbus&gt;, // Read data bus (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Management Data IO interface" treetype="template">
// mdio - Management Data IO interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDC" *)
  input &lt;s_mdc&gt;, // Ethernet to PHY MII Management clock (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; IO" *)
  inoutput &lt;s_io&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
// mdio - Management Data IO interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDIO_I" *)
  input &lt;s_mdio_i&gt;, // PHY MDIO data input from 3-state buffer (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDIO_O" *)
  output &lt;s_mdio_o&gt;, // PHY MDIO data output to 3-state buffer (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDIO_T" *)
  output &lt;s_mdio_t&gt;, // PHY MDIO data output enable to 3-state buffer (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mdio:1.0 &lt;interface_name&gt; MDC" *)
  input &lt;s_mdc&gt;, // Ethernet to PHY MII Management clock (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="MicroBlaze Debug Bus Interface" treetype="template">
// mbdebug - MicroBlaze Debug Bus Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; CLK" *)
  input &lt;s_clk&gt;, // Debug clock (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TDI" *)
  input &lt;s_tdi&gt;, // Debug test data in (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TDO" *)
  output &lt;s_tdo&gt;, // Debug test data out (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; REG_EN" *)
  input [7:0] &lt;s_reg_en&gt;, // Debug register enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; SHIFT" *)
  input &lt;s_shift&gt;, // Debug shift (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; CAPTURE" *)
  input &lt;s_capture&gt;, // Debug capture (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; UPDATE" *)
  input &lt;s_update&gt;, // Debug update (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; RST" *)
  input &lt;s_rst&gt;, // Debug reset (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRIG_IN" *)
  output [7:0] &lt;s_trig_in&gt;, // Trigger input (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRIG_ACK_IN" *)
  input [7:0] &lt;s_trig_ack_in&gt;, // Trigger Acknowledge input (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRIG_OUT" *)
  input [7:0] &lt;s_trig_out&gt;, // Trigger output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRIG_ACK_OUT" *)
  output [7:0] &lt;s_trig_ack_out&gt;, // Trigger Acknowledge output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRCLK" *)
  input &lt;s_trclk&gt;, // Trace Clock (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRDATA" *)
  output [35:0] &lt;s_trdata&gt;, // Trace Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRREADY" *)
  input &lt;s_trready&gt;, // Trace Ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbdebug:3.0 &lt;interface_name&gt; TRVALID" *)
  output &lt;s_trvalid&gt;, // Trace Valid (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="MicroBlaze Interrupt Bus Interface" treetype="template">
// mbinterrupt - MicroBlaze Interrupt Bus Interface (slave directions)
// 
// Allowed parameters:
//  LOW_LATENCY               - Low Latency               (string default: &lt;blank&gt;) 
//  SENSITIVITY               - Sensitivity               (string default: LEVEL_HIGH) {LEVEL_HIGH,LEVEL_LOW,EDGE_RISING,EDGE_FALLING}
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbinterrupt:1.0 &lt;interface_name&gt; INTERRUPT" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "LOW_LATENCY &lt;value&gt;,SENSITIVITY &lt;value&gt;" *)
  input &lt;s_interrupt&gt;, // Interrupt (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbinterrupt:1.0 &lt;interface_name&gt; ADDRESS" *)
  input [31:0] &lt;s_address&gt;, // Interrupt address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbinterrupt:1.0 &lt;interface_name&gt; ACK" *)
  output [1:0] &lt;s_ack&gt;, // Interrupt acknowledge (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="MicroBlaze MCS I/O Bus Definition" treetype="template">
// mcsio_bus - MicroBlaze MCS I/O Bus Definition (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; ADDR_STROBE" *)
  input &lt;s_addr_strobe&gt;, // I/O address strobe (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; READ_STROBE" *)
  input &lt;s_read_strobe&gt;, // I/O read strobe (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; WRITE_STROBE" *)
  input &lt;s_write_strobe&gt;, // I/O write strobe (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; ADDRESS" *)
  input [&lt;left_bound&gt;:0] &lt;s_address&gt;, // I/O address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; BYTE_ENABLE" *)
  input [3:0] &lt;s_byte_enable&gt;, // I/O byte enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; WRITE_DATA" *)
  input [31:0] &lt;s_write_data&gt;, // I/O write data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; READ_DATA" *)
  output [31:0] &lt;s_read_data&gt;, // I/O read data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mcsio_bus:1.0 &lt;interface_name&gt; READY" *)
  output &lt;s_ready&gt;, // I/O ready (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="MicroBlaze Trace Bus Definition" treetype="template">
// mbtrace - MicroBlaze Trace Bus Definition (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; INSTRUCTION" *)
  input [31:0] &lt;s_instruction&gt;, // Trace instruction (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; VALID_INSTR" *)
  input &lt;s_valid_instr&gt;, // Trace valid instruction (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; PC" *)
  input [31:0] &lt;s_pc&gt;, // Trace program counter (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; REG_WRITE" *)
  input &lt;s_reg_write&gt;, // Trace register write (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; REG_ADDR" *)
  input [4:0] &lt;s_reg_addr&gt;, // Trace register address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; MSR_REG" *)
  input [14:0] &lt;s_msr_reg&gt;, // Trace machine status register (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; PID_REG" *)
  input [7:0] &lt;s_pid_reg&gt;, // Trace process id register (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; NEW_REG_VALUE" *)
  input [31:0] &lt;s_new_reg_value&gt;, // Trace new register value (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; EXCEPTION_TAKEN" *)
  input &lt;s_exception_taken&gt;, // Trace exception taken (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; EXCEPTION_KIND" *)
  input [4:0] &lt;s_exception_kind&gt;, // Trace exception kind (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; JUMP_TAKEN" *)
  input &lt;s_jump_taken&gt;, // Trace jump taken (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DELAY_SLOT" *)
  input &lt;s_delay_slot&gt;, // Trace delay slot (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_ADDRESS" *)
  input [31:0] &lt;s_data_address&gt;, // Trace data address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_ACCESS" *)
  input &lt;s_data_access&gt;, // Trace data access (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_READ" *)
  input &lt;s_data_read&gt;, // Trace  data read (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_WRITE" *)
  input &lt;s_data_write&gt;, // Trace data write (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_WRITE_VALUE" *)
  input [31:0] &lt;s_data_write_value&gt;, // Trace data write value (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DATA_BYTE_ENABLE" *)
  input [3:0] &lt;s_data_byte_enable&gt;, // Trace data byte enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DCACHE_REQ" *)
  input &lt;s_dcache_req&gt;, // Trace data cache request (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DCACHE_HIT" *)
  input &lt;s_dcache_hit&gt;, // Trace data cache hit (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DCACHE_RDY" *)
  input &lt;s_dcache_rdy&gt;, // Trace data cache ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; DCACHE_READ" *)
  input &lt;s_dcache_read&gt;, // Trace data cache read (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; ICACHE_REQ" *)
  input &lt;s_icache_req&gt;, // Trace instruction cache request (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; ICACHE_HIT" *)
  input &lt;s_icache_hit&gt;, // Trace instruction cache hit (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; ICACHE_RDY" *)
  input &lt;s_icache_rdy&gt;, // Trace instruction cache ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; OF_PIPERUN" *)
  input &lt;s_of_piperun&gt;, // Trace OF pipe run (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; EX_PIPERUN" *)
  input &lt;s_ex_piperun&gt;, // Trace EX pipe run (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; MEM_PIPERUN" *)
  input &lt;s_mem_piperun&gt;, // Trace MEM pipe run (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; MB_HALTED" *)
  input &lt;s_mb_halted&gt;, // Trace MicroBlaze halted (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mbtrace:2.0 &lt;interface_name&gt; JUMP_HIT" *)
  input &lt;s_jump_hit&gt;, // Trace jump hit (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Mii" treetype="template">
// mii -  (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; TXD" *)
  input [3:0] &lt;s_txd&gt;, // Ethernet transmit data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; TX_EN" *)
  input &lt;s_tx_en&gt;, // Ethernet transmit enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; TX_ER" *)
  input &lt;s_tx_er&gt;, // Ethernet transmit error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RXD" *)
  output [3:0] &lt;s_rxd&gt;, // Ethernet receive data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RX_DV" *)
  output &lt;s_rx_dv&gt;, // Ethernet receive data valid (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RX_ER" *)
  output &lt;s_rx_er&gt;, // Ethernet receive error (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; CRS" *)
  output &lt;s_crs&gt;, // Ethernet carrier sense (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; COL" *)
  output &lt;s_col&gt;, // Ethernet collision (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; TX_CLK" *)
  output &lt;s_tx_clk&gt;, // Ethernet transmit clock (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RX_CLK" *)
  output &lt;s_rx_clk&gt;, // Ethernet receive clock (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:mii:1.0 &lt;interface_name&gt; RST_N" *)
  input &lt;s_rst_n&gt;, // PHY reset, active low (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<SubFolder label="onsg" treetype="folder">
				<Template label="FEC Interface for Framer blocks" treetype="template">
// onsg_fec - FEC Interface for Framer blocks (slave directions)
// 
// Allowed parameters:
//  OTN_RATE                  - OTN_RATE                  (string default: OTU1) {OTU1,OTU2,OTU3,OTU4}
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FEN_Valid" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "OTN_RATE &lt;value&gt;" *)
  input &lt;s_fen_valid&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FEN_FS" *)
  input &lt;s_fen_fs&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FEN_Data" *)
  input &lt;s_fen_data&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FDE_Valid" *)
  input &lt;s_fde_valid&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FDE_FS" *)
  input &lt;s_fde_fs&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_fec:1.0 &lt;interface_name&gt; FDE_Data" *)
  input &lt;s_fde_data&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Onsg_proc" treetype="template">
// onsg_proc - Processor interface for OTN IP Blocks (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_CS" *)
  input &lt;s_proc_cs&gt;, // Chip select (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_WE" *)
  input &lt;s_proc_we&gt;, // Write Enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_Addr" *)
  input [31:0] &lt;s_proc_addr&gt;, // Access Address (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_D_In" *)
  input [31:0] &lt;s_proc_d_in&gt;, // Access Write Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_D_Out" *)
  output [31:0] &lt;s_proc_d_out&gt;, // Access Read Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:onsg_proc:1.0 &lt;interface_name&gt; Proc_Ack" *)
  output &lt;s_proc_ack&gt;, // Processor cycle acknowledge (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<SubFolder label="pcie" treetype="folder">
				<Template label="Pcie_cfg_fc" treetype="template">
// pcie_cfg_fc - Configuration Flow Control for PCIE Gen2/3 Core. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; PH" *)
  input [7:0] &lt;s_ph&gt;, // Posted Header Flow Control Credit (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; PD" *)
  input [11:0] &lt;s_pd&gt;, // Posted Data Flow Control Credit (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; NPH" *)
  input [7:0] &lt;s_nph&gt;, // Non-Posted Header Flow Control Credit (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; NPD" *)
  input [11:0] &lt;s_npd&gt;, // Non-Posted Data Flow Control Credit (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; CPLH" *)
  input [7:0] &lt;s_cplh&gt;, // Completion Header Flow Control Credit (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; CPLD" *)
  input [11:0] &lt;s_cpld&gt;, // Completion Data Flow Control Credit (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_fc:1.0 &lt;interface_name&gt; SEL" *)
  output [2:0] &lt;s_sel&gt;, // Flow Control Information Select (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie_cfg_mgmt" treetype="template">
// pcie_cfg_mgmt - Configuration Management register for PCIE Gen2/3 is used to read and write to the Configuration Space registers (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; ADDR" *)
  input [18:0] &lt;s_addr&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; WRITE_EN" *)
  input &lt;s_write_en&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; WRITE_DATA" *)
  input [31:0] &lt;s_write_data&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; BYTE_EN" *)
  input [3:0] &lt;s_byte_en&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; READ_EN" *)
  input &lt;s_read_en&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; READ_DATA" *)
  output [31:0] &lt;s_read_data&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; READ_WRITE_DONE" *)
  output &lt;s_read_write_done&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; TYPE1_CFG_REG_ACCESS" *)
  input &lt;s_type1_cfg_reg_access&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_cfg_mgmt:1.0 &lt;interface_name&gt; READONLY" *)
  input &lt;s_readonly&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie_pipe_debug" treetype="template">
// pcie_pipe_debug - Transceiver Debug Interfaces for PCIE Gen2/3 Core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; txprbssel" *)
  input [2:0] &lt;s_txprbssel&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rxprbssel" *)
  input [2:0] &lt;s_rxprbssel&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; txprbsforceerr" *)
  input &lt;s_txprbsforceerr&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rxprbscntreset" *)
  input &lt;s_rxprbscntreset&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; loopback" *)
  input [2:0] &lt;s_loopback&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rxprbserr" *)
  output [&lt;left_bound&gt;:0] &lt;s_rxprbserr&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rst_fsm" *)
  output [4:0] &lt;s_rst_fsm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; qrst_fsm" *)
  output [11:0] &lt;s_qrst_fsm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rate_fsm" *)
  output [&lt;left_bound&gt;:0] &lt;s_rate_fsm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; sync_fsm_tx" *)
  output [&lt;left_bound&gt;:0] &lt;s_sync_fsm_tx&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; sync_fsm_rx" *)
  output [&lt;left_bound&gt;:0] &lt;s_sync_fsm_rx&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; drp_fsm" *)
  output [&lt;left_bound&gt;:0] &lt;s_drp_fsm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rst_idle" *)
  output &lt;s_rst_idle&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; qrst_idle" *)
  output &lt;s_qrst_idle&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; rate_idle" *)
  output &lt;s_rate_idle&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; gt_ch_drp_rdy" *)
  output [&lt;left_bound&gt;:0] &lt;s_gt_ch_drp_rdy&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_0" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_0&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_1" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_1&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_2" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_2&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_3" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_3&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_4" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_4&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_5" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_5&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_6" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_6&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_7" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_7&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_8" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_8&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug_9" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_9&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_pipe_debug:1.0 &lt;interface_name&gt; debug" *)
  output [31:0] &lt;s_debug&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie_qpll_drp" treetype="template">
// pcie_qpll_drp - External GT Common Ports for Sharing for PCIE Gen2/3 Core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; crscode" *)
  input [11:0] &lt;s_crscode&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; fsm" *)
  input [17:0] &lt;s_fsm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; done" *)
  input [1:0] &lt;s_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; reset" *)
  input [1:0] &lt;s_reset&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qplllock" *)
  input [1:0] &lt;s_qplllock&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qplloutclk" *)
  input [1:0] &lt;s_qplloutclk&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qplloutrefclk" *)
  input [1:0] &lt;s_qplloutrefclk&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qplld" *)
  output &lt;s_qplld&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; qpllreset" *)
  output [1:0] &lt;s_qpllreset&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; clk" *)
  output &lt;s_clk&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; rst_n" *)
  output &lt;s_rst_n&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; ovrd" *)
  output &lt;s_ovrd&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; gen3" *)
  output &lt;s_gen3&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_qpll_drp:1.0 &lt;interface_name&gt; start" *)
  output &lt;s_start&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="PCIe Serial Link Interface" treetype="template">
// pcie_7x_mgt - PCIe Serial Link Interface (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_mgt:1.0 &lt;interface_name&gt; txn" *)
  output [&lt;left_bound&gt;:0] &lt;m_txn&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_mgt:1.0 &lt;interface_name&gt; rxn" *)
  input [&lt;left_bound&gt;:0] &lt;m_rxn&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_mgt:1.0 &lt;interface_name&gt; txp" *)
  output [&lt;left_bound&gt;:0] &lt;m_txp&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_mgt:1.0 &lt;interface_name&gt; rxp" *)
  input [&lt;left_bound&gt;:0] &lt;m_rxp&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie_sharedlogic_int_clk" treetype="template">
// pcie_sharedlogic_int_clk - Shared Logic Internal Clock for PCIE Gen2/3 Core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; pclk_slave" *)
  input &lt;s_pclk_slave&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; pipe_rxusrclk" *)
  input &lt;s_pipe_rxusrclk&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; rxoutclk" *)
  input [&lt;left_bound&gt;:0] &lt;s_rxoutclk&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; dclk" *)
  input &lt;s_dclk&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; usrclk1" *)
  input &lt;s_usrclk1&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; usrclk2" *)
  input &lt;s_usrclk2&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; oobclk" *)
  input &lt;s_oobclk&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; qplllock" *)
  input [1:0] &lt;s_qplllock&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; qplloutclk" *)
  input [1:0] &lt;s_qplloutclk&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; qplloutrefclk" *)
  input [1:0] &lt;s_qplloutrefclk&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; pclk_sel_slave" *)
  output [&lt;left_bound&gt;:0] &lt;s_pclk_sel_slave&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_sharedlogic_int_clk:1.0 &lt;interface_name&gt; mmcm_lock" *)
  input &lt;s_mmcm_lock&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="PCIE Side band signals" treetype="template">
// pcie_7x_sideband - PCIE Side band signals (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_cpld" *)
  output [11:0] &lt;s_fc_cpld&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_cplh" *)
  output [7:0] &lt;s_fc_cplh&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_npd" *)
  output [11:0] &lt;s_fc_npd&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_nph" *)
  output [7:0] &lt;s_fc_nph&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_pd" *)
  output [11:0] &lt;s_fc_pd&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_ph" *)
  output [7:0] &lt;s_fc_ph&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; fc_sel" *)
  input [2:0] &lt;s_fc_sel&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_do" *)
  output [31:0] &lt;s_cfg_mgmt_do&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_rd_wr_done" *)
  output &lt;s_cfg_mgmt_rd_wr_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_status" *)
  output [15:0] &lt;s_cfg_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_command" *)
  output [15:0] &lt;s_cfg_command&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_dstatus" *)
  output [15:0] &lt;s_cfg_dstatus&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_dcommand" *)
  output [15:0] &lt;s_cfg_dcommand&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_lstatus" *)
  output [15:0] &lt;s_cfg_lstatus&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_lcommand" *)
  output [15:0] &lt;s_cfg_lcommand&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_dcommand2" *)
  output [15:0] &lt;s_cfg_dcommand2&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pcie_link_state" *)
  output [2:0] &lt;s_cfg_pcie_link_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pmcsr_pme_en" *)
  output &lt;s_cfg_pmcsr_pme_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pmcsr_powerstate" *)
  output [1:0] &lt;s_cfg_pmcsr_powerstate&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pmcsr_pme_status" *)
  output &lt;s_cfg_pmcsr_pme_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_received_func_lvl_rst" *)
  output &lt;s_cfg_received_func_lvl_rst&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_di" *)
  input [31:0] &lt;s_cfg_mgmt_di&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_byte_en" *)
  input [3:0] &lt;s_cfg_mgmt_byte_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_dwaddr" *)
  input [9:0] &lt;s_cfg_mgmt_dwaddr&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_wr_en" *)
  input &lt;s_cfg_mgmt_wr_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_rd_en" *)
  input &lt;s_cfg_mgmt_rd_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_wr_readonly" *)
  input &lt;s_cfg_mgmt_wr_readonly&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_ecrc" *)
  input &lt;s_cfg_err_ecrc&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_ur" *)
  input &lt;s_cfg_err_ur&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cpl_timeout" *)
  input &lt;s_cfg_err_cpl_timeout&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cpl_unexpect" *)
  input &lt;s_cfg_err_cpl_unexpect&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cpl_abort" *)
  input &lt;s_cfg_err_cpl_abort&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_posted" *)
  input &lt;s_cfg_err_posted&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cor" *)
  input &lt;s_cfg_err_cor&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_atomic_egress_blocked" *)
  input &lt;s_cfg_err_atomic_egress_blocked&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_internal_cor" *)
  input &lt;s_cfg_err_internal_cor&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_malformed" *)
  input &lt;s_cfg_err_malformed&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_mc_blocked" *)
  input &lt;s_cfg_err_mc_blocked&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_poisoned" *)
  input &lt;s_cfg_err_poisoned&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_norecovery" *)
  input &lt;s_cfg_err_norecovery&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_tlp_cpl_header" *)
  input [47:0] &lt;s_cfg_err_tlp_cpl_header&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cpl_rdy" *)
  output &lt;s_cfg_err_cpl_rdy&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_locked" *)
  input &lt;s_cfg_err_locked&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_acs" *)
  input &lt;s_cfg_err_acs&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_internal_uncor" *)
  input &lt;s_cfg_err_internal_uncor&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_trn_pending" *)
  input &lt;s_cfg_trn_pending&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_halt_aspm_l0s" *)
  input &lt;s_cfg_pm_halt_aspm_l0s&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_halt_aspm_l1" *)
  input &lt;s_cfg_pm_halt_aspm_l1&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_force_state_en" *)
  input &lt;s_cfg_pm_force_state_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_force_state" *)
  input [1:0] &lt;s_cfg_pm_force_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_dsn" *)
  input [63:0] &lt;s_cfg_dsn&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received" *)
  output &lt;s_cfg_msg_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_data" *)
  output [15:0] &lt;s_cfg_msg_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt" *)
  input &lt;s_cfg_interrupt&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_rdy" *)
  output &lt;s_cfg_interrupt_rdy&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_assert" *)
  input &lt;s_cfg_interrupt_assert&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_di" *)
  input [7:0] &lt;s_cfg_interrupt_di&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_do" *)
  output [7:0] &lt;s_cfg_interrupt_do&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_mmenable" *)
  output [2:0] &lt;s_cfg_interrupt_mmenable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msienable" *)
  output &lt;s_cfg_interrupt_msienable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msixenable" *)
  output &lt;s_cfg_interrupt_msixenable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msixfm" *)
  output &lt;s_cfg_interrupt_msixfm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_stat" *)
  input &lt;s_cfg_interrupt_stat&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pciecap_interrupt_msgnum" *)
  input [4:0] &lt;s_cfg_pciecap_interrupt_msgnum&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_to_turnoff" *)
  output &lt;s_cfg_to_turnoff&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_turnoff_ok" *)
  input &lt;s_cfg_turnoff_ok&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_bus_number" *)
  output [7:0] &lt;s_cfg_bus_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_device_number" *)
  output [4:0] &lt;s_cfg_device_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_function_number" *)
  output [2:0] &lt;s_cfg_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_wake" *)
  input &lt;s_cfg_pm_wake&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_pm_as_nak" *)
  output &lt;s_cfg_msg_received_pm_as_nak&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_setslotpowerlimit" *)
  output &lt;s_cfg_msg_received_setslotpowerlimit&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_pm_send_pme_to" *)
  input &lt;s_cfg_pm_send_pme_to&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_bus_number" *)
  input [7:0] &lt;s_cfg_ds_bus_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_device_number" *)
  input [4:0] &lt;s_cfg_ds_device_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_function_number" *)
  input [2:0] &lt;s_cfg_ds_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_wr_rw1c_as_rw" *)
  input &lt;s_cfg_mgmt_wr_rw1c_as_rw&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_bridge_serr_en" *)
  output &lt;s_cfg_bridge_serr_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_slot_control_electromech_il_ctl_pulse" *)
  output &lt;s_cfg_slot_control_electromech_il_ctl_pulse&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_root_control_syserr_corr_err_en" *)
  output &lt;s_cfg_root_control_syserr_corr_err_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_root_control_syserr_non_fatal_err_en" *)
  output &lt;s_cfg_root_control_syserr_non_fatal_err_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_root_control_syserr_fatal_err_en" *)
  output &lt;s_cfg_root_control_syserr_fatal_err_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_root_control_pme_int_en" *)
  output &lt;s_cfg_root_control_pme_int_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_corr_err_reporting_en" *)
  output &lt;s_cfg_aer_rooterr_corr_err_reporting_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_non_fatal_err_reporting_en" *)
  output &lt;s_cfg_aer_rooterr_non_fatal_err_reporting_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_fatal_err_reporting_en" *)
  output &lt;s_cfg_aer_rooterr_fatal_err_reporting_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_corr_err_received" *)
  output &lt;s_cfg_aer_rooterr_corr_err_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_non_fatal_err_received" *)
  output &lt;s_cfg_aer_rooterr_non_fatal_err_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_rooterr_fatal_err_received" *)
  output &lt;s_cfg_aer_rooterr_fatal_err_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_err_cor" *)
  output &lt;s_cfg_msg_received_err_cor&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_err_non_fatal" *)
  output &lt;s_cfg_msg_received_err_non_fatal&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_err_fatal" *)
  output &lt;s_cfg_msg_received_err_fatal&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_pm_pme" *)
  output &lt;s_cfg_msg_received_pm_pme&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_pme_to_ack" *)
  output &lt;s_cfg_msg_received_pme_to_ack&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_assert_int_a" *)
  output &lt;s_cfg_msg_received_assert_int_a&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_assert_int_b" *)
  output &lt;s_cfg_msg_received_assert_int_b&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_assert_int_c" *)
  output &lt;s_cfg_msg_received_assert_int_c&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_assert_int_d" *)
  output &lt;s_cfg_msg_received_assert_int_d&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_deassert_int_a" *)
  output &lt;s_cfg_msg_received_deassert_int_a&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_deassert_int_b" *)
  output &lt;s_cfg_msg_received_deassert_int_b&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_deassert_int_c" *)
  output &lt;s_cfg_msg_received_deassert_int_c&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_deassert_int_d" *)
  output &lt;s_cfg_msg_received_deassert_int_d&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_aer_headerlog" *)
  input [127:0] &lt;s_cfg_err_aer_headerlog&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_interrupt_msgnum" *)
  input [4:0] &lt;s_cfg_aer_interrupt_msgnum&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_aer_headerlog_set" *)
  output &lt;s_cfg_err_aer_headerlog_set&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_ecrc_check_en" *)
  output &lt;s_cfg_aer_ecrc_check_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_aer_ecrc_gen_en" *)
  output &lt;s_cfg_aer_ecrc_gen_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; cfg_vc_tcvc_map" *)
  output [6:0] &lt;s_cfg_vc_tcvc_map&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; tx_buf_av" *)
  output [5:0] &lt;s_tx_buf_av&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; tx_err_drop" *)
  output &lt;s_tx_err_drop&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; tx_cfg_req" *)
  output &lt;s_tx_cfg_req&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; rx_np_ok" *)
  input &lt;s_rx_np_ok&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; rx_np_req" *)
  input &lt;s_rx_np_req&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; tx_cfg_gnt" *)
  input &lt;s_tx_cfg_gnt&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_link_change" *)
  input [1:0] &lt;s_pl_directed_link_change&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_link_width" *)
  input [1:0] &lt;s_pl_directed_link_width&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_link_speed" *)
  input &lt;s_pl_directed_link_speed&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_link_auton" *)
  input &lt;s_pl_directed_link_auton&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_upstream_prefer_deemph" *)
  input &lt;s_pl_upstream_prefer_deemph&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_sel_lnk_rate" *)
  output &lt;s_pl_sel_lnk_rate&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_sel_lnk_width" *)
  output [1:0] &lt;s_pl_sel_lnk_width&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_ltssm_state" *)
  output [5:0] &lt;s_pl_ltssm_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_lane_reversal_mode" *)
  output [1:0] &lt;s_pl_lane_reversal_mode&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_phy_lnk_up" *)
  output &lt;s_pl_phy_lnk_up&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_tx_pm_state" *)
  output [2:0] &lt;s_pl_tx_pm_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_rx_pm_state" *)
  output [1:0] &lt;s_pl_rx_pm_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_link_upcfg_cap" *)
  output &lt;s_pl_link_upcfg_cap&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_link_gen2_cap" *)
  output &lt;s_pl_link_gen2_cap&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_link_partner_gen2_supported" *)
  output &lt;s_pl_link_partner_gen2_supported&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_initial_link_width" *)
  output [2:0] &lt;s_pl_initial_link_width&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_directed_change_done" *)
  output &lt;s_pl_directed_change_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_received_hot_rst" *)
  output &lt;s_pl_received_hot_rst&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_transmit_hot_rst" *)
  input &lt;s_pl_transmit_hot_rst&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie_7x_sideband:1.0 &lt;interface_name&gt; pl_downstream_deemph_source" *)
  input &lt;s_pl_downstream_deemph_source&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<SubFolder label="pcie2" treetype="folder">
				<Template label="Pcie2_cfg_control" treetype="template">
// pcie2_cfg_control - Configuration Control Interface for PCIE Gen2 Core allows a broad range of information exchange between the user application and the core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; tx_cfg_gnt" *)
  input &lt;s_tx_cfg_gnt&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; rx_np_ok" *)
  input &lt;s_rx_np_ok&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; rx_np_req" *)
  input &lt;s_rx_np_req&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; trn_pending" *)
  input &lt;s_trn_pending&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_halt_aspm_l0s" *)
  input &lt;s_pm_halt_aspm_l0s&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_halt_aspm_l1" *)
  input &lt;s_pm_halt_aspm_l1&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_force_state_en" *)
  input &lt;s_pm_force_state_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_force_state" *)
  input [1:0] &lt;s_pm_force_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; dsn" *)
  input [63:0] &lt;s_dsn&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; turnoff_ok" *)
  input &lt;s_turnoff_ok&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_wake" *)
  input &lt;s_pm_wake&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; pm_send_pme_to" *)
  input &lt;s_pm_send_pme_to&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; ds_bus_number" *)
  input [7:0] &lt;s_ds_bus_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; ds_device_number" *)
  input [4:0] &lt;s_ds_device_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_control:1.0 &lt;interface_name&gt; ds_function_number" *)
  input [2:0] &lt;s_ds_function_number&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie2_cfg_err" treetype="template">
// pcie2_cfg_err - It is a user application error reporting interface for PCIE Gen2 Core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; ecrc" *)
  input &lt;s_ecrc&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; ur" *)
  input &lt;s_ur&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cpl_timeout" *)
  input &lt;s_cpl_timeout&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cpl_unexpect" *)
  input &lt;s_cpl_unexpect&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cpl_abort" *)
  input &lt;s_cpl_abort&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; posted" *)
  input &lt;s_posted&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cor" *)
  input &lt;s_cor&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; atomic_egress_blocked" *)
  input &lt;s_atomic_egress_blocked&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; internal_cor" *)
  input &lt;s_internal_cor&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; mc_blocked" *)
  input &lt;s_mc_blocked&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; poisoned" *)
  input &lt;s_poisoned&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; norecovery" *)
  input &lt;s_norecovery&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; tlp_cpl_header" *)
  input [47:0] &lt;s_tlp_cpl_header&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; cpl_rdy" *)
  output &lt;s_cpl_rdy&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; locked" *)
  input &lt;s_locked&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; acs" *)
  input &lt;s_acs&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; internal_uncor" *)
  input &lt;s_internal_uncor&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; err_aer_headerlog" *)
  input [127:0] &lt;s_err_aer_headerlog&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; aer_interrupt_msgnum" *)
  input [4:0] &lt;s_aer_interrupt_msgnum&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; err_aer_headerlog_set" *)
  output &lt;s_err_aer_headerlog_set&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; aer_ecrc_check_en" *)
  output &lt;s_aer_ecrc_check_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; aer_ecrc_gen_en" *)
  output &lt;s_aer_ecrc_gen_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_err:1.0 &lt;interface_name&gt; malformed" *)
  input &lt;s_malformed&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie2_cfg_interrupt" treetype="template">
// pcie2_cfg_interrupt - It defines the Interrupt Interface signals for PCIE Gen2 Core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; interrupt" *)
  input &lt;s_interrupt&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; rdy" *)
  output &lt;s_rdy&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; assert" *)
  input &lt;s_assert&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; write_data" *)
  input [7:0] &lt;s_write_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; read_data" *)
  output [7:0] &lt;s_read_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; mmenable" *)
  output [2:0] &lt;s_mmenable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; msienable" *)
  output &lt;s_msienable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; msixenable" *)
  output &lt;s_msixenable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; msixfm" *)
  output &lt;s_msixfm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; stat" *)
  input &lt;s_stat&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_interrupt:1.0 &lt;interface_name&gt; pciecap_interrupt_msgnum" *)
  input [4:0] &lt;s_pciecap_interrupt_msgnum&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie2_cfg_msg_rcvd" treetype="template">
// pcie2_cfg_msg_rcvd - Configuration Message Received Interface for PCIE Gen2 Core indicates to th elogic that a decodable message from the link, parameters associated with th edata and type of message received (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; received" *)
  input &lt;s_received&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; data" *)
  input [15:0] &lt;s_data&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; err_cor" *)
  input &lt;s_err_cor&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; err_non_fatal" *)
  input &lt;s_err_non_fatal&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; err_fatal" *)
  input &lt;s_err_fatal&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; pm_pme" *)
  input &lt;s_pm_pme&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; pme_to_ack" *)
  input &lt;s_pme_to_ack&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; assert_int_a" *)
  input &lt;s_assert_int_a&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; assert_int_b" *)
  input &lt;s_assert_int_b&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; assert_int_c" *)
  input &lt;s_assert_int_c&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; assert_int_d" *)
  input &lt;s_assert_int_d&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; deassert_int_a" *)
  input &lt;s_deassert_int_a&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; deassert_int_b" *)
  input &lt;s_deassert_int_b&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; deassert_int_c" *)
  input &lt;s_deassert_int_c&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; deassert_int_d" *)
  input &lt;s_deassert_int_d&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; received_pm_as_nak" *)
  input &lt;s_received_pm_as_nak&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_msg_rcvd:1.0 &lt;interface_name&gt; received_setslotpowerlimit" *)
  input &lt;s_received_setslotpowerlimit&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie2_cfg_status" treetype="template">
// pcie2_cfg_status - Configuration Status Interface provides information on how the PCIE Gen2 core is configured (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; status" *)
  input [15:0] &lt;s_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; command" *)
  input [15:0] &lt;s_command&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; dstatus" *)
  input [15:0] &lt;s_dstatus&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; dcommand" *)
  input [15:0] &lt;s_dcommand&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; lstatus" *)
  input [15:0] &lt;s_lstatus&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; lcommand" *)
  input [15:0] &lt;s_lcommand&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; dcommand2" *)
  input [15:0] &lt;s_dcommand2&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; pcie_link_state" *)
  input [2:0] &lt;s_pcie_link_state&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; pmcsr_pme_en" *)
  input &lt;s_pmcsr_pme_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; pmcsr_powerstate" *)
  input [1:0] &lt;s_pmcsr_powerstate&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; pmcsr_pme_status" *)
  input &lt;s_pmcsr_pme_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; received_func_lvl_rst" *)
  input &lt;s_received_func_lvl_rst&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; turnoff" *)
  input &lt;s_turnoff&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; bus_number" *)
  input [7:0] &lt;s_bus_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; device_number" *)
  input [4:0] &lt;s_device_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; function_number" *)
  input [2:0] &lt;s_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; bridge_serr_en" *)
  input &lt;s_bridge_serr_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; slot_control_electromech_il_ctl_pulse" *)
  input &lt;s_slot_control_electromech_il_ctl_pulse&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; root_control_syserr_corr_err_en" *)
  input &lt;s_root_control_syserr_corr_err_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; root_control_syserr_non_fatal_err_en" *)
  input &lt;s_root_control_syserr_non_fatal_err_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; root_control_syserr_fatal_err_en" *)
  input &lt;s_root_control_syserr_fatal_err_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; root_control_pme_int_en" *)
  input &lt;s_root_control_pme_int_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_corr_err_reporting_en" *)
  input &lt;s_aer_rooterr_corr_err_reporting_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_non_fatal_err_reporting_en" *)
  input &lt;s_aer_rooterr_non_fatal_err_reporting_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_fatal_err_reporting_en" *)
  input &lt;s_aer_rooterr_fatal_err_reporting_en&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_corr_err_received" *)
  input &lt;s_aer_rooterr_corr_err_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_non_fatal_err_received" *)
  input &lt;s_aer_rooterr_non_fatal_err_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; aer_rooterr_fatal_err_received" *)
  input &lt;s_aer_rooterr_fatal_err_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; vc_tcvc_map" *)
  input [6:0] &lt;s_vc_tcvc_map&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; tx_buf_av" *)
  input [5:0] &lt;s_tx_buf_av&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; tx_err_drop" *)
  input &lt;s_tx_err_drop&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_cfg_status:1.0 &lt;interface_name&gt; tx_cfg_req" *)
  input &lt;s_tx_cfg_req&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie2_pl" treetype="template">
// pcie2_pl - Physical Layer Interface for PCIE Gen2 Core enables the user design to inspect the status of the link and link partner and control the link state (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_link_change" *)
  input [1:0] &lt;s_directed_link_change&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_link_width" *)
  input [1:0] &lt;s_directed_link_width&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_link_speed" *)
  input &lt;s_directed_link_speed&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_link_auton" *)
  input &lt;s_directed_link_auton&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; upstream_prefer_deemph" *)
  input &lt;s_upstream_prefer_deemph&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; sel_lnk_rate" *)
  output &lt;s_sel_lnk_rate&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; sel_lnk_width" *)
  output [1:0] &lt;s_sel_lnk_width&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; ltssm_state" *)
  output [5:0] &lt;s_ltssm_state&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; lane_reversal_mode" *)
  output [1:0] &lt;s_lane_reversal_mode&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; phy_lnk_up" *)
  output &lt;s_phy_lnk_up&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; tx_pm_state" *)
  output [2:0] &lt;s_tx_pm_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; rx_pm_state" *)
  output [1:0] &lt;s_rx_pm_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; link_upcfg_cap" *)
  output &lt;s_link_upcfg_cap&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; link_gen2_cap" *)
  output &lt;s_link_gen2_cap&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; link_partner_gen2_supported" *)
  output &lt;s_link_partner_gen2_supported&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; initial_link_width" *)
  output [2:0] &lt;s_initial_link_width&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; directed_change_done" *)
  output &lt;s_directed_change_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; received_hot_rst" *)
  output &lt;s_received_hot_rst&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; transmit_hot_rst" *)
  input &lt;s_transmit_hot_rst&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie2_pl:1.0 &lt;interface_name&gt; downstream_deemph_source" *)
  input &lt;s_downstream_deemph_source&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<SubFolder label="pcie3" treetype="folder">
				<Template label="PCIE Gen3 Sideband signal interface" treetype="template">
// pcie3_7x_sideband - PCIE Gen3 Sideband signal interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_phy_link_down" *)
  output &lt;s_cfg_phy_link_down&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_phy_link_status" *)
  output [1:0] &lt;s_cfg_phy_link_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_negotiated_width" *)
  output [3:0] &lt;s_cfg_negotiated_width&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_current_speed" *)
  output [2:0] &lt;s_cfg_current_speed&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_max_payload" *)
  output [2:0] &lt;s_cfg_max_payload&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_max_read_req" *)
  output [2:0] &lt;s_cfg_max_read_req&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_function_status" *)
  output [7:0] &lt;s_cfg_function_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_function_power_state" *)
  output [5:0] &lt;s_cfg_function_power_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_status" *)
  output [11:0] &lt;s_cfg_vf_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_power_state" *)
  output [17:0] &lt;s_cfg_vf_power_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_link_power_state" *)
  output [1:0] &lt;s_cfg_link_power_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_addr" *)
  input [18:0] &lt;s_cfg_mgmt_addr&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_write" *)
  input &lt;s_cfg_mgmt_write&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_write_data" *)
  input [31:0] &lt;s_cfg_mgmt_write_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_byte_enable" *)
  input [3:0] &lt;s_cfg_mgmt_byte_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_read" *)
  input &lt;s_cfg_mgmt_read&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_read_data" *)
  output [31:0] &lt;s_cfg_mgmt_read_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_read_write_done" *)
  output &lt;s_cfg_mgmt_read_write_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_mgmt_type1_cfg_reg_access" *)
  input &lt;s_cfg_mgmt_type1_cfg_reg_access&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cor_out" *)
  output &lt;s_cfg_err_cor_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_nonfatal_out" *)
  output &lt;s_cfg_err_nonfatal_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_fatal_out" *)
  output &lt;s_cfg_err_fatal_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ltr_enable" *)
  output &lt;s_cfg_ltr_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ltssm_state" *)
  output [5:0] &lt;s_cfg_ltssm_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_rcb_status" *)
  output [1:0] &lt;s_cfg_rcb_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_dpa_substate_change" *)
  output [1:0] &lt;s_cfg_dpa_substate_change&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_obff_enable" *)
  output [1:0] &lt;s_cfg_obff_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_pl_status_change" *)
  output &lt;s_cfg_pl_status_change&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_tph_requester_enable" *)
  output [1:0] &lt;s_cfg_tph_requester_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_tph_st_mode" *)
  output [5:0] &lt;s_cfg_tph_st_mode&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_tph_requester_enable" *)
  output [5:0] &lt;s_cfg_vf_tph_requester_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_tph_st_mode" *)
  output [17:0] &lt;s_cfg_vf_tph_st_mode&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received" *)
  output &lt;s_cfg_msg_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_data" *)
  output [7:0] &lt;s_cfg_msg_received_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_received_type" *)
  output [4:0] &lt;s_cfg_msg_received_type&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_transmit" *)
  input &lt;s_cfg_msg_transmit&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_transmit_type" *)
  input [2:0] &lt;s_cfg_msg_transmit_type&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_transmit_data" *)
  input [31:0] &lt;s_cfg_msg_transmit_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_msg_transmit_done" *)
  output &lt;s_cfg_msg_transmit_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_ph" *)
  output [7:0] &lt;s_cfg_fc_ph&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_pd" *)
  output [11:0] &lt;s_cfg_fc_pd&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_nph" *)
  output [7:0] &lt;s_cfg_fc_nph&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_npd" *)
  output [11:0] &lt;s_cfg_fc_npd&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_cplh" *)
  output [7:0] &lt;s_cfg_fc_cplh&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_cpld" *)
  output [11:0] &lt;s_cfg_fc_cpld&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_fc_sel" *)
  input [2:0] &lt;s_cfg_fc_sel&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_func_status_control" *)
  input [2:0] &lt;s_cfg_per_func_status_control&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_func_status_data" *)
  output [15:0] &lt;s_cfg_per_func_status_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_function_number" *)
  input [2:0] &lt;s_cfg_per_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_function_output_request" *)
  input &lt;s_cfg_per_function_output_request&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_per_function_update_done" *)
  output &lt;s_cfg_per_function_update_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_dsn" *)
  input [63:0] &lt;s_cfg_dsn&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_power_state_change_ack" *)
  input &lt;s_cfg_power_state_change_ack&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_power_state_change_interrupt" *)
  output &lt;s_cfg_power_state_change_interrupt&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_cor_in" *)
  input &lt;s_cfg_err_cor_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_err_uncor_in" *)
  input &lt;s_cfg_err_uncor_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_flr_in_process" *)
  output [1:0] &lt;s_cfg_flr_in_process&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_flr_done" *)
  input [1:0] &lt;s_cfg_flr_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_flr_in_process" *)
  output [5:0] &lt;s_cfg_vf_flr_in_process&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_vf_flr_done" *)
  input [5:0] &lt;s_cfg_vf_flr_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_link_training_enable" *)
  input &lt;s_cfg_link_training_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_read_received" *)
  output &lt;s_cfg_ext_read_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_write_received" *)
  output &lt;s_cfg_ext_write_received&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_register_number" *)
  output [9:0] &lt;s_cfg_ext_register_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_function_number" *)
  output [7:0] &lt;s_cfg_ext_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_write_data" *)
  output [31:0] &lt;s_cfg_ext_write_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_write_byte_enable" *)
  output [3:0] &lt;s_cfg_ext_write_byte_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_read_data" *)
  input [31:0] &lt;s_cfg_ext_read_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ext_read_data_valid" *)
  input &lt;s_cfg_ext_read_data_valid&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_port_number" *)
  input [7:0] &lt;s_cfg_ds_port_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_int" *)
  input [3:0] &lt;s_cfg_interrupt_int&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_pending" *)
  input [1:0] &lt;s_cfg_interrupt_pending&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_sent" *)
  output &lt;s_cfg_interrupt_sent&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_enable" *)
  output [1:0] &lt;s_cfg_interrupt_msi_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_vf_enable" *)
  output [5:0] &lt;s_cfg_interrupt_msi_vf_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_mmenable" *)
  output [5:0] &lt;s_cfg_interrupt_msi_mmenable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_mask_update" *)
  output &lt;s_cfg_interrupt_msi_mask_update&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_data" *)
  output [31:0] &lt;s_cfg_interrupt_msi_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_select" *)
  input [3:0] &lt;s_cfg_interrupt_msi_select&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_int" *)
  input [31:0] &lt;s_cfg_interrupt_msi_int&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_pending_status" *)
  input [63:0] &lt;s_cfg_interrupt_msi_pending_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_sent" *)
  output &lt;s_cfg_interrupt_msi_sent&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_fail" *)
  output &lt;s_cfg_interrupt_msi_fail&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_enable" *)
  output [1:0] &lt;s_cfg_interrupt_msix_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_mask" *)
  output [1:0] &lt;s_cfg_interrupt_msix_mask&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_vf_enable" *)
  output [5:0] &lt;s_cfg_interrupt_msix_vf_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_vf_mask" *)
  output [5:0] &lt;s_cfg_interrupt_msix_vf_mask&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_data" *)
  input [31:0] &lt;s_cfg_interrupt_msix_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_address" *)
  input [63:0] &lt;s_cfg_interrupt_msix_address&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_int" *)
  input &lt;s_cfg_interrupt_msix_int&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_sent" *)
  output &lt;s_cfg_interrupt_msix_sent&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msix_fail" *)
  output &lt;s_cfg_interrupt_msix_fail&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_attr" *)
  input [2:0] &lt;s_cfg_interrupt_msi_attr&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_tph_present" *)
  input &lt;s_cfg_interrupt_msi_tph_present&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_tph_type" *)
  input [1:0] &lt;s_cfg_interrupt_msi_tph_type&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_tph_st_tag" *)
  input [8:0] &lt;s_cfg_interrupt_msi_tph_st_tag&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_interrupt_msi_function_number" *)
  input [2:0] &lt;s_cfg_interrupt_msi_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_hot_reset_out" *)
  output &lt;s_cfg_hot_reset_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_config_space_enable" *)
  input &lt;s_cfg_config_space_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_req_pm_transition_l23_ready" *)
  input &lt;s_cfg_req_pm_transition_l23_ready&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_hot_reset_in" *)
  input &lt;s_cfg_hot_reset_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_bus_number" *)
  input [7:0] &lt;s_cfg_ds_bus_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_device_number" *)
  input [4:0] &lt;s_cfg_ds_device_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; cfg_ds_function_number" *)
  input [2:0] &lt;s_cfg_ds_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_rq_seq_num" *)
  output [3:0] &lt;s_pcie_rq_seq_num&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_rq_seq_num_vld" *)
  output &lt;s_pcie_rq_seq_num_vld&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_rq_tag" *)
  output [5:0] &lt;s_pcie_rq_tag&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_rq_tag_vld" *)
  output &lt;s_pcie_rq_tag_vld&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_tfc_nph_av" *)
  output [1:0] &lt;s_pcie_tfc_nph_av&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_tfc_npd_av" *)
  output [1:0] &lt;s_pcie_tfc_npd_av&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_cq_np_req" *)
  input &lt;s_pcie_cq_np_req&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; pcie_cq_np_req_count" *)
  output [5:0] &lt;s_pcie_cq_np_req_count&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_stt_address" *)
  input [4:0] &lt;s_user_tph_stt_address&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_function_num" *)
  input [2:0] &lt;s_user_tph_function_num&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_stt_read_data" *)
  output [31:0] &lt;s_user_tph_stt_read_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_stt_read_data_valid" *)
  output &lt;s_user_tph_stt_read_data_valid&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_7x_sideband:1.0 &lt;interface_name&gt; user_tph_stt_read_enable" *)
  input &lt;s_user_tph_stt_read_enable&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_cfg_control" treetype="template">
// pcie3_cfg_control - Configuration Control Interface for PCIE Gen3 core allows a broad range of information exchange between the user application and the core. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; hot_reset_in" *)
  input &lt;s_hot_reset_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; hot_reset_out" *)
  output &lt;s_hot_reset_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; config_space_enable" *)
  input &lt;s_config_space_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; per_function_update_done" *)
  output &lt;s_per_function_update_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; per_function_number" *)
  input [2:0] &lt;s_per_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; per_function_output_request" *)
  input &lt;s_per_function_output_request&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; dsn" *)
  input [63:0] &lt;s_dsn&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; power_state_change_ack" *)
  input &lt;s_power_state_change_ack&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; power_state_change_interrupt" *)
  output &lt;s_power_state_change_interrupt&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; err_cor_in" *)
  input &lt;s_err_cor_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; err_uncor_in" *)
  input &lt;s_err_uncor_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; flr_in_process" *)
  output [&lt;left_bound&gt;:0] &lt;s_flr_in_process&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; flr_done" *)
  input [&lt;left_bound&gt;:0] &lt;s_flr_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; vf_flr_in_process" *)
  output [&lt;left_bound&gt;:0] &lt;s_vf_flr_in_process&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; vf_flr_done" *)
  input [5:0] &lt;s_vf_flr_done&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; link_training_enable" *)
  input &lt;s_link_training_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; req_pm_transition_l23_ready" *)
  input &lt;s_req_pm_transition_l23_ready&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; ds_port_number" *)
  input [7:0] &lt;s_ds_port_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; ds_bus_number" *)
  input [7:0] &lt;s_ds_bus_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; ds_device_number" *)
  input [4:0] &lt;s_ds_device_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; ds_function_number" *)
  input [2:0] &lt;s_ds_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; subsys_vend_id" *)
  input [15:0] &lt;s_subsys_vend_id&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; local_error" *)
  output &lt;s_local_error&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; vend_id" *)
  input [15:0] &lt;s_vend_id&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; dev_id" *)
  input [15:0] &lt;s_dev_id&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; rev_id" *)
  input [7:0] &lt;s_rev_id&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_control:1.0 &lt;interface_name&gt; subsys_id" *)
  input [15:0] &lt;s_subsys_id&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_cfg_ext" treetype="template">
// pcie3_cfg_ext - The Configuration Extend interface allows the PCIE Gen3 core to transfer configuration information with the user application when externally implemented configuration registers are implemented. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; read_received" *)
  input &lt;s_read_received&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; write_received" *)
  input &lt;s_write_received&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; register_number" *)
  input [9:0] &lt;s_register_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; function_number" *)
  input [7:0] &lt;s_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; write_data" *)
  input [31:0] &lt;s_write_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; write_byte_enable" *)
  input [3:0] &lt;s_write_byte_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; read_data" *)
  output [31:0] &lt;s_read_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_ext:1.0 &lt;interface_name&gt; read_data_valid" *)
  output &lt;s_read_data_valid&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_cfg_interrupt" treetype="template">
// pcie3_cfg_interrupt - Configuration Interrupt Control Interface fpr PCIE Gen3 Core allows the user application to set Legacy PCIE INterrupts (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_interrupt:1.0 &lt;interface_name&gt; INTx_VECTOR" *)
  input [3:0] &lt;s_intx_vector&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_interrupt:1.0 &lt;interface_name&gt; SENT" *)
  output &lt;s_sent&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_interrupt:1.0 &lt;interface_name&gt; PENDING" *)
  input [&lt;left_bound&gt;:0] &lt;s_pending&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_cfg_mesg_tx" treetype="template">
// pcie3_cfg_mesg_tx - The Configuration Transmit Message Interface is used by the user application to transmit messages to the PCIE Gen3 Core. The user application supplies the transmit message type and data information to the core, which responds with the DONE signal (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_mesg_tx:1.0 &lt;interface_name&gt; TRANSMIT" *)
  output &lt;s_transmit&gt;, // Transmit Encoded message (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_mesg_tx:1.0 &lt;interface_name&gt; TRANSMIT_TYPE" *)
  output [2:0] &lt;s_transmit_type&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_mesg_tx:1.0 &lt;interface_name&gt; TRANSMIT_DATA" *)
  output [31:0] &lt;s_transmit_data&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_mesg_tx:1.0 &lt;interface_name&gt; TRANSMIT_DONE" *)
  input &lt;s_transmit_done&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_cfg_msg_received" treetype="template">
// pcie3_cfg_msg_received - Configuration Received message Interface for PCIE Gen3 core indicates the logic that a decodable message from the link, the parameters associated with the data and type of message have been received (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msg_received:1.0 &lt;interface_name&gt; recd" *)
  input &lt;s_recd&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msg_received:1.0 &lt;interface_name&gt; recd_data" *)
  input [7:0] &lt;s_recd_data&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msg_received:1.0 &lt;interface_name&gt; recd_type" *)
  input [4:0] &lt;s_recd_type&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_cfg_msi" treetype="template">
// pcie3_cfg_msi - Configuration MSI interface allows the user application to set MSI interrupts for the PCIE Gen3 Core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; enable" *)
  output [&lt;left_bound&gt;:0] &lt;s_enable&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; vf_enable" *)
  output [&lt;left_bound&gt;:0] &lt;s_vf_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; mmenable" *)
  output [&lt;left_bound&gt;:0] &lt;s_mmenable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; mask_update" *)
  output &lt;s_mask_update&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; data" *)
  output [31:0] &lt;s_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; select" *)
  input [3:0] &lt;s_select&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; int_vector" *)
  input [31:0] &lt;s_int_vector&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; pending_status" *)
  input [&lt;left_bound&gt;:0] &lt;s_pending_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; sent" *)
  output &lt;s_sent&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; fail" *)
  output &lt;s_fail&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; attr" *)
  input [2:0] &lt;s_attr&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; tph_present" *)
  input &lt;s_tph_present&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; tph_type" *)
  input [1:0] &lt;s_tph_type&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; tph_st_tag" *)
  input [8:0] &lt;s_tph_st_tag&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; function_number" *)
  input [&lt;left_bound&gt;:0] &lt;s_function_number&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; pending_status_data_enable" *)
  input &lt;s_pending_status_data_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msi:1.0 &lt;interface_name&gt; pending_status_function_num" *)
  input [3:0] &lt;s_pending_status_function_num&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_cfg_msix" treetype="template">
// pcie3_cfg_msix - Configuration MSIx interface allows the user application to set MSIx interrupts for the PCIE Gen3 Core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; enable" *)
  output [&lt;left_bound&gt;:0] &lt;s_enable&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; mask" *)
  output [&lt;left_bound&gt;:0] &lt;s_mask&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; vf_enable" *)
  output [&lt;left_bound&gt;:0] &lt;s_vf_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; vf_mask" *)
  output [&lt;left_bound&gt;:0] &lt;s_vf_mask&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; data" *)
  input [31:0] &lt;s_data&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; address" *)
  input [63:0] &lt;s_address&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; int_vector" *)
  input &lt;s_int_vector&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; sent" *)
  output &lt;s_sent&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_msix:1.0 &lt;interface_name&gt; fail" *)
  output &lt;s_fail&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_cfg_status" treetype="template">
// pcie3_cfg_status - Configuration Status Interface for PCIE Gen3 Core provides information on how the core is configured. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; phy_link_down" *)
  input &lt;s_phy_link_down&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; phy_link_status" *)
  input [1:0] &lt;s_phy_link_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; negotiated_width" *)
  input [3:0] &lt;s_negotiated_width&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; current_speed" *)
  input [2:0] &lt;s_current_speed&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; max_payload" *)
  input [2:0] &lt;s_max_payload&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; max_read_req" *)
  input [2:0] &lt;s_max_read_req&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; function_status" *)
  input [&lt;left_bound&gt;:0] &lt;s_function_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; function_power_state" *)
  input [5:0] &lt;s_function_power_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; vf_status" *)
  input [&lt;left_bound&gt;:0] &lt;s_vf_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; vf_power_state" *)
  input [17:0] &lt;s_vf_power_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; link_power_state" *)
  input [1:0] &lt;s_link_power_state&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; err_cor_out" *)
  input &lt;s_err_cor_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; err_nonfatal_out" *)
  input &lt;s_err_nonfatal_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; err_fatal_out" *)
  input &lt;s_err_fatal_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; ltr_enable" *)
  input &lt;s_ltr_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; ltssm_state" *)
  input [5:0] &lt;s_ltssm_state&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rcb_status" *)
  input [&lt;left_bound&gt;:0] &lt;s_rcb_status&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; dpa_substate_change" *)
  input [&lt;left_bound&gt;:0] &lt;s_dpa_substate_change&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; obff_enable" *)
  input [1:0] &lt;s_obff_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; pl_status_change" *)
  input &lt;s_pl_status_change&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; tph_requester_enable" *)
  input [&lt;left_bound&gt;:0] &lt;s_tph_requester_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; tph_st_mode" *)
  input [5:0] &lt;s_tph_st_mode&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; vf_tph_requester_enable" *)
  input [5:0] &lt;s_vf_tph_requester_enable&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; vf_tph_st_mode" *)
  input [17:0] &lt;s_vf_tph_st_mode&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_seq_num" *)
  input [3:0] &lt;s_rq_seq_num&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_seq_num_vld" *)
  input &lt;s_rq_seq_num_vld&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_tag" *)
  input [5:0] &lt;s_rq_tag&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_tag_vld" *)
  input &lt;s_rq_tag_vld&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; tfc_nph_av" *)
  input [1:0] &lt;s_tfc_nph_av&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; tfc_npd_av" *)
  input [1:0] &lt;s_tfc_npd_av&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; cq_np_req" *)
  output &lt;s_cq_np_req&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; cq_np_req_count" *)
  input [5:0] &lt;s_cq_np_req_count&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_cfg_status:1.0 &lt;interface_name&gt; rq_tag_av" *)
  input [1:0] &lt;s_rq_tag_av&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_per_func_status" treetype="template">
// pcie3_per_func_status - Per Function Status Interface for PCIE Gen3 Core provides status data as requested by the user application through the selected function (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_per_func_status:1.0 &lt;interface_name&gt; STATUS_CONTROL" *)
  output [2:0] &lt;s_status_control&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_per_func_status:1.0 &lt;interface_name&gt; STATUS_DATA" *)
  input [15:0] &lt;s_status_data&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_pipe_debug" treetype="template">
// pcie3_pipe_debug - Transceiver Pipe Debug Interface for the PCIE Gen3 Core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; txprbssel" *)
  input [2:0] &lt;s_txprbssel&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rxprbssel" *)
  input [2:0] &lt;s_rxprbssel&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; txprbsforceerr" *)
  input &lt;s_txprbsforceerr&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rxprbscntreset" *)
  input &lt;s_rxprbscntreset&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; loopback" *)
  input [2:0] &lt;s_loopback&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rxprbserr" *)
  output [&lt;left_bound&gt;:0] &lt;s_rxprbserr&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rst_fsm" *)
  output [4:0] &lt;s_rst_fsm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; qrst_fsm" *)
  output [11:0] &lt;s_qrst_fsm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rate_fsm" *)
  output [&lt;left_bound&gt;:0] &lt;s_rate_fsm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; sync_fsm_tx" *)
  output [&lt;left_bound&gt;:0] &lt;s_sync_fsm_tx&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; sync_fsm_rx" *)
  output [&lt;left_bound&gt;:0] &lt;s_sync_fsm_rx&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; drp_fsm" *)
  output [&lt;left_bound&gt;:0] &lt;s_drp_fsm&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rst_idle" *)
  output &lt;s_rst_idle&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; qrst_idle" *)
  output &lt;s_qrst_idle&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; rate_idle" *)
  output &lt;s_rate_idle&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; gt_ch_drp_rdy" *)
  output [&lt;left_bound&gt;:0] &lt;s_gt_ch_drp_rdy&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_0" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_0&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_1" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_1&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_2" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_2&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_3" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_3&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_4" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_4&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_5" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_5&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_6" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_6&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_7" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_7&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_8" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_8&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug_9" *)
  output [&lt;left_bound&gt;:0] &lt;s_debug_9&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_pipe_debug:1.0 &lt;interface_name&gt; debug" *)
  output [31:0] &lt;s_debug&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_transmit_fc" treetype="template">
// pcie3_transmit_fc - Transmit Flow Control Interface for PCIE Gen3 Core is used by the user application to request which flow Control information the core provides. This interface provides the Posted/Non-Posted Header Flow Control Credits, Posted/Non-Posted Data Flow Control Credits, the Completion Header Flow Control Credits and Completion Data Flow Control Credits to User application based upon the setting flow control select input to the core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_transmit_fc:1.0 &lt;interface_name&gt; nph_av" *)
  input [1:0] &lt;s_nph_av&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_transmit_fc:1.0 &lt;interface_name&gt; npd_av" *)
  input [1:0] &lt;s_npd_av&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
				<Template label="Pcie3_user_tph" treetype="template">
// pcie3_user_tph - Transaction Processing Hint (TPH) Interface for PCIE Gen3 Core (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; stt_address" *)
  output [4:0] &lt;s_stt_address&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; function_num" *)
  output [&lt;left_bound&gt;:0] &lt;s_function_num&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; stt_read_data" *)
  input [31:0] &lt;s_stt_read_data&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; stt_read_data_valid" *)
  input &lt;s_stt_read_data_valid&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pcie3_user_tph:1.0 &lt;interface_name&gt; stt_read_enable" *)
  output &lt;s_stt_read_enable&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<Template label="Pipe Clock Interface" treetype="template">
// pipe_clock - Pipe Clock Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; pclk_in" *)
  input &lt;s_pclk_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; rxusrclk_in" *)
  input &lt;s_rxusrclk_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; rxoutclk_in" *)
  input [&lt;left_bound&gt;:0] &lt;s_rxoutclk_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; dclk_in" *)
  input &lt;s_dclk_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; userclk1_in" *)
  input &lt;s_userclk1_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; userclk2_in" *)
  input &lt;s_userclk2_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; oobclk_in" *)
  input &lt;s_oobclk_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; mmcm_lock_in" *)
  input &lt;s_mmcm_lock_in&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; txoutclk_out" *)
  output &lt;s_txoutclk_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; rxoutclk_out" *)
  output [&lt;left_bound&gt;:0] &lt;s_rxoutclk_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; pclk_sel_out" *)
  output [&lt;left_bound&gt;:0] &lt;s_pclk_sel_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; gen3_out" *)
  output &lt;s_gen3_out&gt;, //  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:pipe_clock:1.0 &lt;interface_name&gt; mmcm_rst_n" *)
  input &lt;s_mmcm_rst_n&gt;, //  (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Ptp" treetype="template">
// ptp - The PTP interface connected to the Ethernet controller provide the capability to handle IEEE-1588 precision time protocol (PTP) signaling (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; SOF_TX" *)
  input &lt;s_sof_tx&gt;, //  Tx Start-of-Frame (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; SOF_RX" *)
  input &lt;s_sof_rx&gt;, //  Rx Start-of-Frame (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; DELAY_REQ_TX" *)
  input &lt;s_delay_req_tx&gt;, // Tx PTP  delay req frame detected (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; PDELAY_REQ_TX" *)
  input &lt;s_pdelay_req_tx&gt;, // Tx PTP  peer delay frame detected (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; PDELAY_RESP_TX" *)
  input &lt;s_pdelay_resp_tx&gt;, // Tx PTP peer delay response frame detected (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; SYNC_FRAME_TX" *)
  input &lt;s_sync_frame_tx&gt;, // Tx PTP sync frame detected (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; DELAY_REQ_RX" *)
  input &lt;s_delay_req_rx&gt;, // Rx PTP  delay req frame detected (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; PDELAY_REQ_RX" *)
  input &lt;s_pdelay_req_rx&gt;, // Rx PTP  peer delay frame detected (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; PDELAY_RESP_RX" *)
  input &lt;s_pdelay_resp_rx&gt;, // Rx PTP peer delay response frame detected (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ptp:1.0 &lt;interface_name&gt; SYNC_FRAME_RX" *)
  input &lt;s_sync_frame_rx&gt;, // Rx PTP sync frame detected (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Raw_switchable" treetype="template">
// raw_switchable - Raw data format for connecting as 4x80 or 10x32 bit data bus (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_ALT_DATA0" *)
  input [15:0] &lt;s_tx_alt_data0&gt;, // Top 16 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_ALT_DATA1" *)
  input [15:0] &lt;s_tx_alt_data1&gt;, // Top 16 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_ALT_DATA2" *)
  input [15:0] &lt;s_tx_alt_data2&gt;, // Top 16 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_ALT_DATA3" *)
  input [15:0] &lt;s_tx_alt_data3&gt;, // Top 16 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA0" *)
  input [63:0] &lt;s_tx_data0&gt;, // Bottom 64 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA1" *)
  input [63:0] &lt;s_tx_data1&gt;, // Bottom 64 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA2" *)
  input [63:0] &lt;s_tx_data2&gt;, // Bottom 64 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA3" *)
  input [63:0] &lt;s_tx_data3&gt;, // Bottom 64 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA4" *)
  input [31:0] &lt;s_tx_data4&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA5" *)
  input [31:0] &lt;s_tx_data5&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA6" *)
  input [31:0] &lt;s_tx_data6&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA7" *)
  input [31:0] &lt;s_tx_data7&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA8" *)
  input [31:0] &lt;s_tx_data8&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; TX_DATA9" *)
  input [31:0] &lt;s_tx_data9&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_ALT_DATA0" *)
  output [15:0] &lt;s_rx_alt_data0&gt;, // Top 16 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_ALT_DATA1" *)
  output [15:0] &lt;s_rx_alt_data1&gt;, // Top 16 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_ALT_DATA2" *)
  output [15:0] &lt;s_rx_alt_data2&gt;, // Top 16 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_ALT_DATA3" *)
  output [15:0] &lt;s_rx_alt_data3&gt;, // Top 16 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA0" *)
  output [63:0] &lt;s_rx_data0&gt;, // Bottom 64 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA1" *)
  output [63:0] &lt;s_rx_data1&gt;, // Bottom 64 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA2" *)
  output [63:0] &lt;s_rx_data2&gt;, // Bottom 64 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA3" *)
  output [63:0] &lt;s_rx_data3&gt;, // Bottom 64 bits of 80-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA4" *)
  output [31:0] &lt;s_rx_data4&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA5" *)
  output [31:0] &lt;s_rx_data5&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA6" *)
  output [31:0] &lt;s_rx_data6&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA7" *)
  output [31:0] &lt;s_rx_data7&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA8" *)
  output [31:0] &lt;s_rx_data8&gt;, // 32-bit data bus (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:raw_switchable:1.0 &lt;interface_name&gt; RX_DATA9" *)
  output [31:0] &lt;s_rx_data9&gt;, // 32-bit data bus (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Rgmii" treetype="template">
// rgmii - DDR bus I/F between a 10/100/1000Mbps Ethernet MAC and a PHY (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; TD" *)
  output [3:0] &lt;m_td&gt;, // Ethernet transmit data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; TX_CTL" *)
  output &lt;m_tx_ctl&gt;, // Ethernet transmit control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; TXC" *)
  output &lt;m_txc&gt;, // Ethernet transmit clock (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; RD" *)
  input [3:0] &lt;m_rd&gt;, // Ethernet receive data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; RX_CTL" *)
  input &lt;m_rx_ctl&gt;, // Ethernet receive control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rgmii:1.0 &lt;interface_name&gt; RXC" *)
  input &lt;m_rxc&gt;, // Ethernet receive clock (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Rmii" treetype="template">
// rmii - Reduced Media Independent Interface (RMII) is an interface used in ethernet designs to insulate Media Access (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; CRS_DV" *)
  output &lt;s_crs_dv&gt;, // Carrier sence, Receive data valid (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; RXD" *)
  output [1:0] &lt;s_rxd&gt;, // Receive data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; TX_EN" *)
  input &lt;s_tx_en&gt;, // Transmit enable (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; TXD" *)
  input [1:0] &lt;s_txd&gt;, // Transmit data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rmii:1.0 &lt;interface_name&gt; RX_ER" *)
  output &lt;s_rx_er&gt;, // Receive error (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Rx_mipi_ppi_if" treetype="template">
// rx_mipi_ppi_if - MIPI PPI interface for rx clock lane and one (or) more rx data lane(s). This on-chip interface is used to connect to MIPI CSI IP from MIPI D-PHY IP in FPGA fabric. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_ENABLE" *)
  output &lt;s_cl_enable&gt;, // Enable Clock Lane Module (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_STOPSTATE" *)
  input &lt;s_cl_stopstate&gt;, // Clock Lane is in Stop state (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_RXCLKACTIVEHS" *)
  input &lt;s_cl_rxclkactivehs&gt;, // Receiver Clock Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_ULPSACTIVENOT" *)
  input &lt;s_cl_ulpsactivenot&gt;, // Clock Lane ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_RXULPSCLKNOT" *)
  input &lt;s_cl_rxulpsclknot&gt;, // Receive Ultra-Low Power State on Clock Lane (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_STOPSTATE" *)
  input &lt;s_dl0_stopstate&gt;, // Data Lane 0 is in Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ENABLE" *)
  output &lt;s_dl0_enable&gt;, // Enable Data Lane 0 Module (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXACTIVEHS" *)
  input &lt;s_dl0_rxactivehs&gt;, // Data Lane 0 High-Speed Reception Active (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXSYNCHS" *)
  input &lt;s_dl0_rxsynchs&gt;, // Data Lane 0 Receiver Synchronization Observed (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXVALIDHS" *)
  input &lt;s_dl0_rxvalidhs&gt;, // Data Lane 0 High-Speed Receive Data Valid (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXDATAHS" *)
  input [7:0] &lt;s_dl0_rxdatahs&gt;, // Data Lane 0 High-Speed Receive Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_FORCERXMODE" *)
  output &lt;s_dl0_forcerxmode&gt;, // Force Data Lane 0 to Wait for Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXCLKESC" *)
  input &lt;s_dl0_rxclkesc&gt;, // Data Lane 0 Escape Mode Receive Clock (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXLPDTESC" *)
  input &lt;s_dl0_rxlpdtesc&gt;, // Data Lane 0 Escape Low-Power Data Receive mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXULPSESC" *)
  input &lt;s_dl0_rxulpsesc&gt;, // Data Lane 0 Escape Ultra-Low Power (Receive) mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXDATAESC" *)
  input [7:0] &lt;s_dl0_rxdataesc&gt;, // Data Lane 0 Escape mode Receive Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXTRIGGERESC" *)
  input [3:0] &lt;s_dl0_rxtriggeresc&gt;, // Data Lane 0 Escape Mode Receive Trigger 0-3 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_RXVALIDESC" *)
  input &lt;s_dl0_rxvalidesc&gt;, // Data Lane 0 Escape Mode Receive Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ULPSACTIVENOT" *)
  input &lt;s_dl0_ulpsactivenot&gt;, // Data Lane 0 ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRSOTHS" *)
  input &lt;s_dl0_errsoths&gt;, // Data Lane 0 Start-of-Transmission (SoT) Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRSOTSYNCHS" *)
  input &lt;s_dl0_errsotsynchs&gt;, // Data Lane 0 Start-of-Transmission Synchronization Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRESC" *)
  input &lt;s_dl0_erresc&gt;, // Data Lane 0 Escape Entry Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRSYNCESC" *)
  input &lt;s_dl0_errsyncesc&gt;, // Data Lane 0 Low-Power Data Transmission Synchronization Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ERRCONTROL" *)
  input &lt;s_dl0_errcontrol&gt;, // Data Lane 0 Control Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_STOPSTATE" *)
  input &lt;s_dl1_stopstate&gt;, // Data Lane 1 is in Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ENABLE" *)
  output &lt;s_dl1_enable&gt;, // Enable Data Lane 1 Module (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXACTIVEHS" *)
  input &lt;s_dl1_rxactivehs&gt;, // Data Lane 1 High-Speed Reception Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXSYNCHS" *)
  input &lt;s_dl1_rxsynchs&gt;, // Data Lane 1 Receiver Synchronization Observed (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXVALIDHS" *)
  input &lt;s_dl1_rxvalidhs&gt;, // Data Lane 1 High-Speed Receive Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXDATAHS" *)
  input [7:0] &lt;s_dl1_rxdatahs&gt;, // Data Lane 1 High-Speed Receive Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_FORCERXMODE" *)
  output &lt;s_dl1_forcerxmode&gt;, // Force Data Lane 1 to Wait for Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXCLKESC" *)
  input &lt;s_dl1_rxclkesc&gt;, // Data Lane 1 Escape Mode Receive Clock (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXLPDTESC" *)
  input &lt;s_dl1_rxlpdtesc&gt;, // Data Lane 1 Escape Low-Power Data Receive mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXULPSESC" *)
  input &lt;s_dl1_rxulpsesc&gt;, // Data Lane 1 Escape Ultra-Low Power (Receive) mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXDATAESC" *)
  input [7:0] &lt;s_dl1_rxdataesc&gt;, // Data Lane 1 Escape mode Receive Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXTRIGGERESC" *)
  input [3:0] &lt;s_dl1_rxtriggeresc&gt;, // Data Lane 1 Escape Mode Receive Trigger 0-3 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_RXVALIDESC" *)
  input &lt;s_dl1_rxvalidesc&gt;, // Data Lane 1 Escape Mode Receive Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ULPSACTIVENOT" *)
  input &lt;s_dl1_ulpsactivenot&gt;, // Data Lane 1 ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRSOTHS" *)
  input &lt;s_dl1_errsoths&gt;, // Data Lane 1 Start-of-Transmission (SoT) Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRSOTSYNCHS" *)
  input &lt;s_dl1_errsotsynchs&gt;, // Data Lane 1 Start-of-Transmission Synchronization Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRESC" *)
  input &lt;s_dl1_erresc&gt;, // Data Lane 1 Escape Entry Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRSYNCESC" *)
  input &lt;s_dl1_errsyncesc&gt;, // Data Lane 1 Low-Power Data Transmission Synchronization Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ERRCONTROL" *)
  input &lt;s_dl1_errcontrol&gt;, // Data Lane 1 Control Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_STOPSTATE" *)
  input &lt;s_dl2_stopstate&gt;, // Data Lane 2 is in Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ENABLE" *)
  output &lt;s_dl2_enable&gt;, // Enable Data Lane 2 Module (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXACTIVEHS" *)
  input &lt;s_dl2_rxactivehs&gt;, // Data Lane 2 High-Speed Reception Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXSYNCHS" *)
  input &lt;s_dl2_rxsynchs&gt;, // Data Lane 2 Receiver Synchronization Observed (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXVALIDHS" *)
  input &lt;s_dl2_rxvalidhs&gt;, // Data Lane 2 High-Speed Receive Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXDATAHS" *)
  input [7:0] &lt;s_dl2_rxdatahs&gt;, // Data Lane 2 High-Speed Receive Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_FORCERXMODE" *)
  output &lt;s_dl2_forcerxmode&gt;, // Force Data Lane 2 to Wait for Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXCLKESC" *)
  input &lt;s_dl2_rxclkesc&gt;, // Data Lane 2 Escape Mode Receive Clock (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXLPDTESC" *)
  input &lt;s_dl2_rxlpdtesc&gt;, // Data Lane 2 Escape Low-Power Data Receive mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXULPSESC" *)
  input &lt;s_dl2_rxulpsesc&gt;, // Data Lane 2 Escape Ultra-Low Power (Receive) mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXDATAESC" *)
  input [7:0] &lt;s_dl2_rxdataesc&gt;, // Data Lane 2 Escape mode Receive Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXTRIGGERESC" *)
  input [3:0] &lt;s_dl2_rxtriggeresc&gt;, // Data Lane 2 Escape Mode Receive Trigger 0-3 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_RXVALIDESC" *)
  input &lt;s_dl2_rxvalidesc&gt;, // Data Lane 2 Escape Mode Receive Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ULPSACTIVENOT" *)
  input &lt;s_dl2_ulpsactivenot&gt;, // Data Lane 2 ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRSOTHS" *)
  input &lt;s_dl2_errsoths&gt;, // Data Lane 2 Start-of-Transmission (SoT) Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRSOTSYNCHS" *)
  input &lt;s_dl2_errsotsynchs&gt;, // Data Lane 2 Start-of-Transmission Synchronization Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRESC" *)
  input &lt;s_dl2_erresc&gt;, // Data Lane 2 Escape Entry Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRSYNCESC" *)
  input &lt;s_dl2_errsyncesc&gt;, // Data Lane 2 Low-Power Data Transmission Synchronization Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ERRCONTROL" *)
  input &lt;s_dl2_errcontrol&gt;, // Data Lane 2 Control Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_STOPSTATE" *)
  input &lt;s_dl3_stopstate&gt;, // Data Lane 3 is in Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ENABLE" *)
  output &lt;s_dl3_enable&gt;, // Enable Data Lane 3 Module (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXACTIVEHS" *)
  input &lt;s_dl3_rxactivehs&gt;, // Data Lane 3 High-Speed Reception Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXSYNCHS" *)
  input &lt;s_dl3_rxsynchs&gt;, // Data Lane 3 Receiver Synchronization Observed (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXVALIDHS" *)
  input &lt;s_dl3_rxvalidhs&gt;, // Data Lane 3 High-Speed Receive Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXDATAHS" *)
  input [7:0] &lt;s_dl3_rxdatahs&gt;, // Data Lane 3 High-Speed Receive Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_FORCERXMODE" *)
  output &lt;s_dl3_forcerxmode&gt;, // Force Data Lane 3 to Wait for Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXCLKESC" *)
  input &lt;s_dl3_rxclkesc&gt;, // Data Lane 3 Escape Mode Receive Clock (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXLPDTESC" *)
  input &lt;s_dl3_rxlpdtesc&gt;, // Data Lane 3 Escape Low-Power Data Receive mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXULPSESC" *)
  input &lt;s_dl3_rxulpsesc&gt;, // Data Lane 3 Escape Ultra-Low Power (Receive) mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXDATAESC" *)
  input [7:0] &lt;s_dl3_rxdataesc&gt;, // Data Lane 3 Escape mode Receive Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXTRIGGERESC" *)
  input [3:0] &lt;s_dl3_rxtriggeresc&gt;, // Data Lane 3 Escape Mode Receive Trigger 0-3 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_RXVALIDESC" *)
  input &lt;s_dl3_rxvalidesc&gt;, // Data Lane 3 Escape Mode Receive Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ULPSACTIVENOT" *)
  input &lt;s_dl3_ulpsactivenot&gt;, // Data Lane 3 ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRSOTHS" *)
  input &lt;s_dl3_errsoths&gt;, // Data Lane 3 Start-of-Transmission (SoT) Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRSOTSYNCHS" *)
  input &lt;s_dl3_errsotsynchs&gt;, // Data Lane 3 Start-of-Transmission Synchronization Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRESC" *)
  input &lt;s_dl3_erresc&gt;, // Data Lane 3 Escape Entry Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRSYNCESC" *)
  input &lt;s_dl3_errsyncesc&gt;, // Data Lane 3 Low-Power Data Transmission Synchronization Error (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:rx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ERRCONTROL" *)
  input &lt;s_dl3_errcontrol&gt;, // Data Lane 3 Control Error (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<SubFolder label="sdi" treetype="folder">
				<Template label="Sdi_native" treetype="template">
// sdi_native - bus definition for SDI that used between SDI with video block or Aux block (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; DS1A" *)
  input [9:0] &lt;s_ds1a&gt;, // data stream 1A or A_Y_IN (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; DS2A" *)
  input [9:0] &lt;s_ds2a&gt;, // data stream 2A or A_C_IN (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; DS1B" *)
  input [9:0] &lt;s_ds1b&gt;, // data stream 1B or B_Y_IN (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; DS2B" *)
  input [9:0] &lt;s_ds2b&gt;, // data stream 2B or B_C_IN (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; LVL_B_3G" *)
  input &lt;s_lvl_b_3g&gt;, // used in 3g mode to determine module is configure for lvlA or lvl B (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; D_RDY_3G" *)
  input &lt;s_d_rdy_3g&gt;, // data ready signal used in 3G mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; LINE_A" *)
  input [10:0] &lt;s_line_a&gt;, // capture current line number (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; LINE_B" *)
  input [10:0] &lt;s_line_b&gt;, // capture current line number in 3G mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_EAV" *)
  input &lt;s_rx_eav&gt;, // high when XYZ word of an EAV is present in the data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_SAV" *)
  input &lt;s_rx_sav&gt;, // high when XYZ word of an SAV is present in the data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_TRS" *)
  input &lt;s_rx_trs&gt;, // high for 4 consec sample times of all 4 words of an EAV and SAV (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; CE" *)
  input [&lt;left_bound&gt;:0] &lt;s_ce&gt;, // clock enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; SDI_MODE" *)
  input [1:0] &lt;s_sdi_mode&gt;, // indicate current sdi mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_MODE_HD" *)
  input &lt;s_rx_mode_hd&gt;, // indicator for matched SDI mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_MODE_SD" *)
  input &lt;s_rx_mode_sd&gt;, // indicator for matched SDI mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_MODE_3G" *)
  input &lt;s_rx_mode_3g&gt;, // indicator for matched SDI mode (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_MODE_LOCKED" *)
  input &lt;s_rx_mode_locked&gt;, // indicate sdi mode has been locked (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_T_LOCKED" *)
  input &lt;s_rx_t_locked&gt;, // indicate transpoprt format has been locked (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_T_FAMILY" *)
  input [3:0] &lt;s_rx_t_family&gt;, // indicate family of video signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_T_RATE" *)
  input [3:0] &lt;s_rx_t_rate&gt;, // indicate frame rate of transport (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_T_SCAN" *)
  input &lt;s_rx_t_scan&gt;, // indicate prog or interlaced (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_A_VPID" *)
  input [31:0] &lt;s_rx_a_vpid&gt;, // all four user data bytes of the ST 352 packet from data stream 1 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_A_VPID_VALID" *)
  input &lt;s_rx_a_vpid_valid&gt;, // indicate validity of vpid from a_vpid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_B_VPID" *)
  input [31:0] &lt;s_rx_b_vpid&gt;, // all four user data bytes of the ST 352 packet from data stream 2 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_B_VPID_VALID" *)
  input &lt;s_rx_b_vpid_valid&gt;, // indicate validity of vpid from b_vpid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; RX_BIT_RATE" *)
  input &lt;s_rx_bit_rate&gt;, // indicate bit rate in HD-SDI and 3G-SDI modes (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdi_native:1.0 &lt;interface_name&gt; TX_BIT_RATE" *)
  input &lt;s_tx_bit_rate&gt;, // selection control between 148.5 amd 148.35 ref clk (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<Template label="Sdio" treetype="template">
// sdio - SDIO peripheral controller interface controls communication with SDIO devices, SD memory, and MMC cards (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CLK" *)
  input &lt;s_clk&gt;, // Clock (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CLK_FB" *)
  output &lt;s_clk_fb&gt;, // Clock Feedback (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CMD_I" *)
  output &lt;s_cmd_i&gt;, // Command (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CMD_O" *)
  input &lt;s_cmd_o&gt;, // Command (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CMD_T" *)
  input &lt;s_cmd_t&gt;, // Command (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; DATA_I" *)
  output [&lt;left_bound&gt;:0] &lt;s_data_i&gt;, // Data Bus (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; DATA_O" *)
  input [&lt;left_bound&gt;:0] &lt;s_data_o&gt;, // Data Bus (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; DATA_T" *)
  input [&lt;left_bound&gt;:0] &lt;s_data_t&gt;, // Data Bus (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; CDN" *)
  output &lt;s_cdn&gt;, // Card Detect (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; WP" *)
  output &lt;s_wp&gt;, // Write Protect (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; LED" *)
  input &lt;s_led&gt;, // LED Control (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; BUSPOW" *)
  input &lt;s_buspow&gt;, // Power Control (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sdio:1.0 &lt;interface_name&gt; BUSVOLT" *)
  input &lt;s_busvolt&gt;, // Bus Voltage (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Serial Peripheral Interface" treetype="template">
// spi - Serial Peripheral Interface (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SPISEL" *)
  input &lt;m_spisel&gt;, // SPISEL input to the core (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS_I" *)
  input &lt;m_ss_i&gt;, // Slave Select Input (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS_O" *)
  output &lt;m_ss_o&gt;, // Slave Select Output (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS_T" *)
  output &lt;m_ss_t&gt;, // Slave Select Tri-State Control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SCK_I" *)
  input &lt;m_sck_i&gt;, // SPI Clock Input (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SCK_O" *)
  output &lt;m_sck_o&gt;, // SPI Clock Output (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SCK_T" *)
  output &lt;m_sck_t&gt;, // SPI Clock Tri-State Control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO0_I" *)
  input &lt;m_io0_i&gt;, // IO0 Input Port (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO0_O" *)
  output &lt;m_io0_o&gt;, // IO0 Output Port (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO0_T" *)
  output &lt;m_io0_t&gt;, // IO0 Tri-State Control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO1_I" *)
  input &lt;m_io1_i&gt;, // IO1 Input Port (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO1_O" *)
  output &lt;m_io1_o&gt;, // IO1 Output Port (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO1_T" *)
  output &lt;m_io1_t&gt;, // IO1 Tri-State Control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO2_I" *)
  input &lt;m_io2_i&gt;, // IO2 Input Port (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO2_O" *)
  output &lt;m_io2_o&gt;, // IO2 Output Port (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO2_T" *)
  output &lt;m_io2_t&gt;, // IO2 Tri-State Control (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO3_I" *)
  input &lt;m_io3_i&gt;, // IO3 Input Port (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO3_O" *)
  output &lt;m_io3_o&gt;, // IO3 Output Port (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; IO3_T" *)
  output &lt;m_io3_t&gt;, // IO3 Tri-State Control (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS1_O" *)
  output &lt;m_ss1_o&gt;, // Slave Select 1 Output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spi:1.0 &lt;interface_name&gt; SS2_O" *)
  output &lt;m_ss2_o&gt;, // Slave Select 2 Output (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Sfp" treetype="template">
// sfp - Bus interface between a GT and a connected SFP (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; TXN" *)
  input &lt;s_txn&gt;, // Transmit Data N of differential pair (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; RXN" *)
  output &lt;s_rxn&gt;, // Receive Data N of differential pair (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; TXP" *)
  input &lt;s_txp&gt;, // Transmit Data P of differential pair (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; RXP" *)
  output &lt;s_rxp&gt;, // Receive Data P of differential pair (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; RX_LOS" *)
  output &lt;s_rx_los&gt;, // Receiver Loss of Signal Indication (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; MOD_ABS" *)
  output &lt;s_mod_abs&gt;, // Module Absent (SFP+ MOD_ABS =SFP MOD-DEF0) (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; SCL" *)
  input &lt;s_scl&gt;, // Serial Interface Clock (SFP+SCL = SFP MOD-DEF1) (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; SDA" *)
  inoutput &lt;s_sda&gt;, // Serial Interface Data Line (SFP+ SDA = SFP MOD-DEF2) (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; TX_DISABLE" *)
  input &lt;s_tx_disable&gt;, // Transmitter Disable; Turns off transmitter laser output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sfp:1.0 &lt;interface_name&gt; TX_FAULT" *)
  output &lt;s_tx_fault&gt;, // Module Transmitter Fault (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Sgmii" treetype="template">
// sgmii - Bus interface between a GT and a connected PHY (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:sgmii:1.0 &lt;interface_name&gt; TXN" *)
  input &lt;s_txn&gt;, // Transmit Data N of differential pair (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sgmii:1.0 &lt;interface_name&gt; RXN" *)
  output &lt;s_rxn&gt;, // Receive Data N of differential pair (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sgmii:1.0 &lt;interface_name&gt; TXP" *)
  input &lt;s_txp&gt;, // Transmit Data P of differential pair (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:sgmii:1.0 &lt;interface_name&gt; RXP" *)
  output &lt;s_rxp&gt;, // Receive Data P of differential pair (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="SPDIF Bus Definition" treetype="template">
// spdif - SPDIF Bus Definition (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:spdif:2.0 &lt;interface_name&gt; SPDIF" *)
  input &lt;s_spdif&gt;, // Bi-Phase mark coded serial audio data (optional)
//  additional ports here
);

//  user logic here

endmodule
// spdif - SPDIF Bus Definition (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:spdif:1.0 &lt;interface_name&gt; SPDIF_O" *)
  output &lt;s_spdif_o&gt;, // Bi-Phase mark coded serial audio data out (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:spdif:1.0 &lt;interface_name&gt; SPDIF_I" *)
  input &lt;s_spdif_i&gt;, // Bi-Phase mark coded serial audio data in (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Startup Primitive Interface" treetype="template">
// startup - Startup Primitive Interface (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; cfgclk" *)
  output &lt;s_cfgclk&gt;, // Configuration main clock output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; cfgmclk" *)
  output &lt;s_cfgmclk&gt;, // Configuration internal oscillator clock output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; eos" *)
  output &lt;s_eos&gt;, // End Of Startup (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; preq" *)
  output &lt;s_preq&gt;, // PROGRAM request to fabric output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; clk" *)
  input &lt;s_clk&gt;, // User start-up clock  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; gsr" *)
  input &lt;s_gsr&gt;, // Global Set/Reset (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; gts" *)
  input &lt;s_gts&gt;, // Global 3-state input (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; keyclearb" *)
  input &lt;s_keyclearb&gt;, // Clear AES Decrypter Key (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; pack" *)
  input &lt;s_pack&gt;, // PROGRAM acknowledge (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; usrcclko" *)
  input &lt;s_usrcclko&gt;, // User CCLK (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; usrclkts" *)
  input &lt;s_usrclkts&gt;, // User CCLK 3-state enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; userdoneo" *)
  input &lt;s_userdoneo&gt;, // User DONE pin  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; usrdonets" *)
  input &lt;s_usrdonets&gt;, // User DONE 3-state enable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; di" *)
  output [3:0] &lt;s_di&gt;, // Pin inputs from STARTUP to FPGA (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; do" *)
  input [3:0] &lt;s_do&gt;, // FPGA logic signal routed to STARTUP (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; dts" *)
  input [3:0] &lt;s_dts&gt;, // 3-state control (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; fcsbo" *)
  input &lt;s_fcsbo&gt;, // User control of FCS_B pin for flash access (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:startup:1.0 &lt;interface_name&gt; fcsbts" *)
  input &lt;s_fcsbts&gt;, // 3-state control of external FCS_B pin (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Trigger" treetype="template">
// trigger - This comprises of two ports TRIG (required) and TRIG_ACK (required) ports. When the interface is configured as a Master, external processor or ILA generates a trigger through TRIG port to mark a debugger event or hardware event. When configured as a Slave, external processor or ILA receives trigger from an external master to capture processor/hardware event. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:trigger:1.0 &lt;interface_name&gt; TRIG" *)
  input &lt;s_trig&gt;, // Trigger (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:trigger:1.0 &lt;interface_name&gt; ACK" *)
  output &lt;s_ack&gt;, // Trigger acknowledgement (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Tx_mipi_ppi_if" treetype="template">
// tx_mipi_ppi_if - MIPI PPI interface for tx clock lane and one (or) more tx data lane(s). This on-chip interface is used to connect with MIPI DSI IP to MIPI D-PHY IP in FPGA fabric. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_TXREQUESTHS" *)
  output &lt;s_cl_txrequesths&gt;, // Clock Lane High-Speed Transmit Request and Data Valid (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_STOPSTATE" *)
  input &lt;s_cl_stopstate&gt;, // Clock Lane is in Stop state (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_ENABLE" *)
  output &lt;s_cl_enable&gt;, // Enable Clock Lane Module (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_TXULPSCLK" *)
  output &lt;s_cl_txulpsclk&gt;, // Transmit Ultra-Low Power State on Clock Lane (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_TXULPSEXIT" *)
  output &lt;s_cl_txulpsexit&gt;, // Clock Lane Transmit ULP Exit Sequence (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; CL_ULPSACTIVENOT" *)
  input &lt;s_cl_ulpsactivenot&gt;, // Clock Lane ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_STOPSTATE" *)
  input &lt;s_dl0_stopstate&gt;, // Data Lane 0 is in Stop state (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ENABLE" *)
  output &lt;s_dl0_enable&gt;, // Enable Data Lane 0 Module (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXREQUESTHS" *)
  output &lt;s_dl0_txrequesths&gt;, // Data Lane 0 High-Speed Transmit Request and Data Valid (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXDATAHS" *)
  output [7:0] &lt;s_dl0_txdatahs&gt;, // Data Lane 0 High-Speed Transmit Data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXREADYHS" *)
  input &lt;s_dl0_txreadyhs&gt;, // Data Lane 0 High-Speed Transmit Ready (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_FORCETXSTOPMODE" *)
  output &lt;s_dl0_forcetxstopmode&gt;, // Force Data Lane 0 to Generate Stop state  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXREQUESTESC" *)
  output &lt;s_dl0_txrequestesc&gt;, // Data Lane 0 Escape Mode Transmit Request (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXULPSEXIT" *)
  output &lt;s_dl0_txulpsexit&gt;, // Data Lane 0 Transmit ULP Exit Sequence (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_ULPSACTIVENOT" *)
  input &lt;s_dl0_ulpsactivenot&gt;, // Data Lane 0 ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXULPSESC" *)
  output &lt;s_dl0_txulpsesc&gt;, // Data Lane 0 Escape Mode Transmit Ultra-Low Power State (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXLPDTESC" *)
  output &lt;s_dl0_txlpdtesc&gt;, // Data Lane 0 Escape Mode Transmit Low-Power Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXDATAESC" *)
  output [7:0] &lt;s_dl0_txdataesc&gt;, // Data Lane 0 Escape Mode Transmit Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXTRIGGERESC" *)
  output [3:0] &lt;s_dl0_txtriggeresc&gt;, // Data Lane 0 Escape Mode Transmit Trigger 0-3 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXVALIDESC" *)
  output &lt;s_dl0_txvalidesc&gt;, // Data Lane 0 Escape Mode Transmit Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL0_TXREADYESC" *)
  input &lt;s_dl0_txreadyesc&gt;, // Data Lane 0 Escape Mode Transmit Ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_STOPSTATE" *)
  input &lt;s_dl1_stopstate&gt;, // Data Lane 1 is in Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ENABLE" *)
  output &lt;s_dl1_enable&gt;, // Enable Data Lane 1 Module (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXREQUESTHS" *)
  output &lt;s_dl1_txrequesths&gt;, // Data Lane 1 High-Speed Transmit Request and Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXDATAHS" *)
  output [7:0] &lt;s_dl1_txdatahs&gt;, // Data Lane 1 High-Speed Transmit Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXREADYHS" *)
  input &lt;s_dl1_txreadyhs&gt;, // Data Lane 1 High-Speed Transmit Ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_FORCETXSTOPMODE" *)
  output &lt;s_dl1_forcetxstopmode&gt;, // Force Data Lane 1 to Generate Stop state  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXREQUESTESC" *)
  output &lt;s_dl1_txrequestesc&gt;, // Data Lane 1 Escape Mode Transmit Request (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXULPSEXIT" *)
  output &lt;s_dl1_txulpsexit&gt;, // Data Lane 1 Transmit ULP Exit Sequence (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_ULPSACTIVENOT" *)
  input &lt;s_dl1_ulpsactivenot&gt;, // Data Lane 1 ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXULPSESC" *)
  output &lt;s_dl1_txulpsesc&gt;, // Data Lane 1 Escape Mode Transmit Ultra-Low Power State (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXLPDTESC" *)
  output &lt;s_dl1_txlpdtesc&gt;, // Data Lane 1 Escape Mode Transmit Low-Power Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXDATAESC" *)
  output [7:0] &lt;s_dl1_txdataesc&gt;, // Data Lane 1 Escape Mode Transmit Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXTRIGGERESC" *)
  output [3:0] &lt;s_dl1_txtriggeresc&gt;, // Data Lane 1 Escape Mode Transmit Trigger 0-3 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXVALIDESC" *)
  output &lt;s_dl1_txvalidesc&gt;, // Data Lane 1 Escape Mode Transmit Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL1_TXREADYESC" *)
  input &lt;s_dl1_txreadyesc&gt;, // Data Lane 1 Escape Mode Transmit Ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_STOPSTATE" *)
  input &lt;s_dl2_stopstate&gt;, // Data Lane 2 is in Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ENABLE" *)
  output &lt;s_dl2_enable&gt;, // Enable Data Lane 2 Module (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXREQUESTHS" *)
  output &lt;s_dl2_txrequesths&gt;, // Data Lane 2 High-Speed Transmit Request and Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXDATAHS" *)
  output [7:0] &lt;s_dl2_txdatahs&gt;, // Data Lane 2 High-Speed Transmit Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXREADYHS" *)
  input &lt;s_dl2_txreadyhs&gt;, // Data Lane 2 High-Speed Transmit Ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_FORCETXSTOPMODE" *)
  output &lt;s_dl2_forcetxstopmode&gt;, // Force Data Lane 2 to Generate Stop state  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXREQUESTESC" *)
  output &lt;s_dl2_txrequestesc&gt;, // Data Lane 2 Escape Mode Transmit Request (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXULPSEXIT" *)
  output &lt;s_dl2_txulpsexit&gt;, // Data Lane 2 Transmit ULP Exit Sequence (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_ULPSACTIVENOT" *)
  input &lt;s_dl2_ulpsactivenot&gt;, // Data Lane 2 ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXULPSESC" *)
  output &lt;s_dl2_txulpsesc&gt;, // Data Lane 2 Escape Mode Transmit Ultra-Low Power State (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXLPDTESC" *)
  output &lt;s_dl2_txlpdtesc&gt;, // Data Lane 2 Escape Mode Transmit Low-Power Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXDATAESC" *)
  output [7:0] &lt;s_dl2_txdataesc&gt;, // Data Lane 2 Escape Mode Transmit Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXTRIGGERESC" *)
  output [3:0] &lt;s_dl2_txtriggeresc&gt;, // Data Lane 2 Escape Mode Transmit Trigger 0-3 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXVALIDESC" *)
  output &lt;s_dl2_txvalidesc&gt;, // Data Lane 2 Escape Mode Transmit Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL2_TXREADYESC" *)
  input &lt;s_dl2_txreadyesc&gt;, // Data Lane 2 Escape Mode Transmit Ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_STOPSTATE" *)
  input &lt;s_dl3_stopstate&gt;, // Data Lane 3 is in Stop state (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ENABLE" *)
  output &lt;s_dl3_enable&gt;, // Enable Data Lane 3 Module (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXREQUESTHS" *)
  output &lt;s_dl3_txrequesths&gt;, // Data Lane 3 High-Speed Transmit Request and Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXDATAHS" *)
  output [7:0] &lt;s_dl3_txdatahs&gt;, // Data Lane 3 High-Speed Transmit Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXREADYHS" *)
  input &lt;s_dl3_txreadyhs&gt;, // Data Lane 3 High-Speed Transmit Ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_FORCETXSTOPMODE" *)
  output &lt;s_dl3_forcetxstopmode&gt;, // Force Data Lane 3 to Generate Stop state  (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXREQUESTESC" *)
  output &lt;s_dl3_txrequestesc&gt;, // Data Lane 3 Escape Mode Transmit Request (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXULPSEXIT" *)
  output &lt;s_dl3_txulpsexit&gt;, // Data Lane 3 Transmit ULP Exit Sequence (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_ULPSACTIVENOT" *)
  input &lt;s_dl3_ulpsactivenot&gt;, // Data Lane 3 ULP State (not) Active (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXULPSESC" *)
  output &lt;s_dl3_txulpsesc&gt;, // Data Lane 3 Escape Mode Transmit Ultra-Low Power State (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXLPDTESC" *)
  output &lt;s_dl3_txlpdtesc&gt;, // Data Lane 3 Escape Mode Transmit Low-Power Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXDATAESC" *)
  output [7:0] &lt;s_dl3_txdataesc&gt;, // Data Lane 3 Escape Mode Transmit Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXTRIGGERESC" *)
  output [3:0] &lt;s_dl3_txtriggeresc&gt;, // Data Lane 3 Escape Mode Transmit Trigger 0-3 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXVALIDESC" *)
  output &lt;s_dl3_txvalidesc&gt;, // Data Lane 3 Escape Mode Transmit Data Valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:tx_mipi_ppi_if:1.0 &lt;interface_name&gt; DL3_TXREADYESC" *)
  input &lt;s_dl3_txreadyesc&gt;, // Data Lane 3 Escape Mode Transmit Ready (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Uart" treetype="template">
// uart -  (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RxD" *)
  input &lt;m_rxd&gt;, // Serial Input (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; TxD" *)
  output &lt;m_txd&gt;, // Serial Output (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RTSn" *)
  output &lt;m_rtsn&gt;, // Request to Send (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; CTSn" *)
  input &lt;m_ctsn&gt;, // Clear to Send (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; DTRn" *)
  output &lt;m_dtrn&gt;, // Data Terminal Ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; DSRn" *)
  input &lt;m_dsrn&gt;, // Data Set Ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; BAUDOUTn" *)
  output &lt;m_baudoutn&gt;, // Baud Out (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RCLK" *)
  input &lt;m_rclk&gt;, // Receiver Clock (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; XIN" *)
  input &lt;m_xin&gt;, // External Crystal Input (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; XOUT" *)
  output &lt;m_xout&gt;, // External Crystal Output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; DCDn" *)
  input &lt;m_dcdn&gt;, // Data Carrier Detect (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; DDIS" *)
  output &lt;m_ddis&gt;, // Driver Disable (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; OUT1n" *)
  output &lt;m_out1n&gt;, // User Controlled Output1 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; OUT2n" *)
  output &lt;m_out2n&gt;, // User Controlled Output2 (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; TXRDYn" *)
  output &lt;m_txrdyn&gt;, // Transmitter DMA Control Signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RXRDYn" *)
  output &lt;m_rxrdyn&gt;, // Receiver DMA Control Signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:uart:1.0 &lt;interface_name&gt; RI" *)
  input &lt;m_ri&gt;, // Ring Indicator (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Ulpi" treetype="template">
// ulpi - UTMI Low Pin Interface definition, used to define interfaces in IP's like USB (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; CLK" *)
  input &lt;s_clk&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; RST" *)
  output &lt;s_rst&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; DIR" *)
  input &lt;s_dir&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; NEXT" *)
  input &lt;s_next&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; STOP" *)
  output &lt;s_stop&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; DATA_I" *)
  input [7:0] &lt;s_data_i&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; DATA_O" *)
  output [7:0] &lt;s_data_o&gt;, //  (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:ulpi:1.0 &lt;interface_name&gt; DATA_T" *)
  output &lt;s_data_t&gt;, //  (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Vga" treetype="template">
// vga - VGA interface definition, used in TFT controller (master directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; CLK" *)
  output &lt;m_clk&gt;, // VGA Clock signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; RED" *)
  output [&lt;left_bound&gt;:0] &lt;m_red&gt;, // Red pixel data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; GREEN" *)
  output [&lt;left_bound&gt;:0] &lt;m_green&gt;, // Green data of the pixel (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; BLUE" *)
  output [&lt;left_bound&gt;:0] &lt;m_blue&gt;, // BLUE data of the pixel (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; HSYNC" *)
  output &lt;m_hsync&gt;, // Horizantal sync signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; VSYNC" *)
  output &lt;m_vsync&gt;, // Vertical sync signal (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; DPS" *)
  output &lt;m_dps&gt;, // Display scan signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vga:1.0 &lt;interface_name&gt; DE" *)
  output &lt;m_de&gt;, // Display enable signal (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<SubFolder label="vid" treetype="folder">
				<Template label="Vid_io" treetype="template">
// vid_io - Video interface bus which includes data, syncs, and blanks. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; DATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_data&gt;, // Parallel video data (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; ACTIVE_VIDEO" *)
  input &lt;s_active_video&gt;, // Active video Flag (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; HBLANK" *)
  input &lt;s_hblank&gt;, // Horizontal blanking signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; VBLANK" *)
  input &lt;s_vblank&gt;, // Vertical blanking signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; HSYNC" *)
  input &lt;s_hsync&gt;, // Horizontal sync signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; VSYNC" *)
  input &lt;s_vsync&gt;, // Veritcal sync signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:vid_io:1.0 &lt;interface_name&gt; FIELD" *)
  input &lt;s_field&gt;, // Field ID (optional)
//  additional ports here
);

//  user logic here

endmodule
				</Template>
			</SubFolder>
			<Template label="Video synchronization and timing signals" treetype="template">
// video_timing - Video synchronization and timing signals. (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; ACTIVE_VIDEO" *)
  input &lt;s_active_video&gt;, // Active video flag (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; HBLANK" *)
  input &lt;s_hblank&gt;, // Horizontal blanking signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; VBLANK" *)
  input &lt;s_vblank&gt;, // Veritcal blanking signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; HSYNC" *)
  input &lt;s_hsync&gt;, // Horizontal sync signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; VSYNC" *)
  input &lt;s_vsync&gt;, // Vertical sync signal (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:video_timing:2.0 &lt;interface_name&gt; FIELD" *)
  input &lt;s_field&gt;, // Field ID (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Zynq_trace" treetype="template">
// zynq_trace - TPIU (Trace Port Interface Unit) uses this interface to output trace data (slave directions)
// 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:zynq_trace:1.0 &lt;interface_name&gt; CLK_I" *)
  output &lt;s_clk_i&gt;, // Trace clock input (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:zynq_trace:1.0 &lt;interface_name&gt; CLK_O" *)
  input &lt;s_clk_o&gt;, // Trace clock output (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:zynq_trace:1.0 &lt;interface_name&gt; CTL" *)
  input &lt;s_ctl&gt;, // Trace control (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:zynq_trace:1.0 &lt;interface_name&gt; DATA" *)
  input [31:0] &lt;s_data&gt;, // Trace data (required)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
		</SubFolder>
		<SubFolder label="AXI Interfaces" treetype="folder">
			<Template label="Axi Memory Mapped" treetype="template">
// Normally AXI is automatically inferred.  However, if the names of your ports do not match, you can force the
// the creation of an interface and map the physical ports to the logical ports by using the X_INTERFACE_INFO
// attribute before each physical port
// Typical parameters the user might specify: PROTOCOL {AXI4, AXI4LITE, AXI3}, SUPPORTS_NARROW_BURST {0, 1}, NUM_READ_OUTSTANDING, NUM_WRITE_OUTSTANDING, MAX_BURST_LENGTH
// The PROTOCOL can be typically be inferred from the set of signals.
// aximm - AMBA AXI Interface (slave directions)
// 
// Allowed parameters:
//  CLK_DOMAIN                - Clk Domain                (string default: &lt;blank&gt;) 
//  PHASE                     - Phase                     (float) 
//  MAX_BURST_LENGTH          - Max Burst Length          (long default: 256) [1, 256]
//  NUM_WRITE_OUTSTANDING     - Num Write Outstanding     (long default: 1) [0, 32]
//  NUM_READ_OUTSTANDING      - Num Read Outstanding      (long default: 1) [0, 32]
//  SUPPORTS_NARROW_BURST     - Supports Narrow Burst     (long default: 1) [0, 1]
//  READ_WRITE_MODE           - Read Write Mode           (string default: READ_WRITE) {READ_WRITE,READ_ONLY,WRITE_ONLY}
//  BUSER_WIDTH               - Buser Width               (long) 
//  RUSER_WIDTH               - Ruser Width               (long) 
//  WUSER_WIDTH               - Wuser Width               (long) 
//  ARUSER_WIDTH              - Aruser Width              (long) 
//  AWUSER_WIDTH              - Awuser Width              (long) 
//  ADDR_WIDTH                - Addr Width                (long default: 32) [1, 64]
//  ID_WIDTH                  - Id Width                  (long) 
//  FREQ_HZ                   - Frequency                 (float default: 100000000) 
//  PROTOCOL                  - Protocol                  (string default: AXI4) {AXI4,AXI4LITE,AXI3}
//  DATA_WIDTH                - Data Width                (long default: 32) {32,64,128,256,512,1024}
//  HAS_BURST                 - Has BURST                 (long default: 1) {0,1}
//  HAS_CACHE                 - Has CACHE                 (long default: 1) {0,1}
//  HAS_LOCK                  - Has LOCK                  (long default: 1) {0,1}
//  HAS_PROT                  - Has PROT                  (long default: 1) {0,1}
//  HAS_QOS                   - Has QOS                   (long default: 1) {0,1}
//  HAS_REGION                - Has REGION                (long default: 1) {0,1}
//  HAS_WSTRB                 - Has WSTRB                 (long default: 1) {0,1}
//  HAS_BRESP                 - Has BRESP                 (long default: 1) {0,1}
//  HAS_RRESP                 - Has RRESP                 (long default: 1) {0,1}
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWID" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "CLK_DOMAIN &lt;value&gt;,PHASE &lt;value&gt;,MAX_BURST_LENGTH &lt;value&gt;,NUM_WRITE_OUTSTANDING &lt;value&gt;,NUM_READ_OUTSTANDING &lt;value&gt;,SUPPORTS_NARROW_BURST &lt;value&gt;,READ_WRITE_MODE &lt;value&gt;,BUSER_WIDTH &lt;value&gt;,RUSER_WIDTH &lt;value&gt;,WUSER_WIDTH &lt;value&gt;,ARUSER_WIDTH &lt;value&gt;,AWUSER_WIDTH &lt;value&gt;,ADDR_WIDTH &lt;value&gt;,ID_WIDTH &lt;value&gt;,FREQ_HZ &lt;value&gt;,PROTOCOL &lt;value&gt;,DATA_WIDTH &lt;value&gt;,HAS_BURST &lt;value&gt;,HAS_CACHE &lt;value&gt;,HAS_LOCK &lt;value&gt;,HAS_PROT &lt;value&gt;,HAS_QOS &lt;value&gt;,HAS_REGION &lt;value&gt;,HAS_WSTRB &lt;value&gt;,HAS_BRESP &lt;value&gt;,HAS_RRESP &lt;value&gt;" *)
  input [&lt;left_bound&gt;:0] &lt;s_awid&gt;, // Write address ID (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWADDR" *)
  input [&lt;left_bound&gt;:0] &lt;s_awaddr&gt;, // Write address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWLEN" *)
  input [&lt;left_bound&gt;:0] &lt;s_awlen&gt;, // Burst length (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWSIZE" *)
  input [2:0] &lt;s_awsize&gt;, // Burst size (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWBURST" *)
  input [1:0] &lt;s_awburst&gt;, // Burst type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWLOCK" *)
  input [&lt;left_bound&gt;:0] &lt;s_awlock&gt;, // Lock type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWCACHE" *)
  input [3:0] &lt;s_awcache&gt;, // Cache type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWPROT" *)
  input [2:0] &lt;s_awprot&gt;, // Protection type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWREGION" *)
  input [3:0] &lt;s_awregion&gt;, // Write address slave region (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWQOS" *)
  input [3:0] &lt;s_awqos&gt;, // Transaction Quality of Service token (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWUSER" *)
  input [&lt;left_bound&gt;:0] &lt;s_awuser&gt;, // Write address user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWVALID" *)
  input &lt;s_awvalid&gt;, // Write address valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; AWREADY" *)
  output &lt;s_awready&gt;, // Write address ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WID" *)
  input [&lt;left_bound&gt;:0] &lt;s_wid&gt;, // Write ID tag (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WDATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_wdata&gt;, // Write data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WSTRB" *)
  input [&lt;left_bound&gt;:0] &lt;s_wstrb&gt;, // Write strobes (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WLAST" *)
  input &lt;s_wlast&gt;, // Write last beat (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WUSER" *)
  input [&lt;left_bound&gt;:0] &lt;s_wuser&gt;, // Write data user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WVALID" *)
  input &lt;s_wvalid&gt;, // Write valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; WREADY" *)
  output &lt;s_wready&gt;, // Write ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BID" *)
  output [&lt;left_bound&gt;:0] &lt;s_bid&gt;, // Response ID (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BRESP" *)
  output [1:0] &lt;s_bresp&gt;, // Write response (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BUSER" *)
  output [&lt;left_bound&gt;:0] &lt;s_buser&gt;, // Write response user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BVALID" *)
  output &lt;s_bvalid&gt;, // Write response valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; BREADY" *)
  input &lt;s_bready&gt;, // Write response ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARID" *)
  input [&lt;left_bound&gt;:0] &lt;s_arid&gt;, // Read address ID (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARADDR" *)
  input [&lt;left_bound&gt;:0] &lt;s_araddr&gt;, // Read address (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARLEN" *)
  input [&lt;left_bound&gt;:0] &lt;s_arlen&gt;, // Burst length (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARSIZE" *)
  input [2:0] &lt;s_arsize&gt;, // Burst size (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARBURST" *)
  input [1:0] &lt;s_arburst&gt;, // Burst type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARLOCK" *)
  input [&lt;left_bound&gt;:0] &lt;s_arlock&gt;, // Lock type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARCACHE" *)
  input [3:0] &lt;s_arcache&gt;, // Cache type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARPROT" *)
  input [2:0] &lt;s_arprot&gt;, // Protection type (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARREGION" *)
  input [3:0] &lt;s_arregion&gt;, // Read address slave region (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARQOS" *)
  input [3:0] &lt;s_arqos&gt;, // Quality of service token (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARUSER" *)
  input [&lt;left_bound&gt;:0] &lt;s_aruser&gt;, // Read address user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARVALID" *)
  input &lt;s_arvalid&gt;, // Read address valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; ARREADY" *)
  output &lt;s_arready&gt;, // Read address ready (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RID" *)
  output [&lt;left_bound&gt;:0] &lt;s_rid&gt;, // Read ID tag (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RDATA" *)
  output [&lt;left_bound&gt;:0] &lt;s_rdata&gt;, // Read data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RRESP" *)
  output [1:0] &lt;s_rresp&gt;, // Read response (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RLAST" *)
  output &lt;s_rlast&gt;, // Read last beat (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RUSER" *)
  output [&lt;left_bound&gt;:0] &lt;s_ruser&gt;, // Read user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RVALID" *)
  output &lt;s_rvalid&gt;, // Read valid (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 &lt;interface_name&gt; RREADY" *)
  input &lt;s_rready&gt;, // Read ready (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="Axi Stream" treetype="template">
// Normally AXI is automatically inferred.  However, if the names of your ports do not match, you can force the
// the creation of an interface and map the physical ports to the logical ports by using the X_INTERFACE_INFO
// attribute before each physical port
// Parameters are typically computed by the Block Diagram and annotated onto the cell (no need to specify these)
// axis - AMBA AXI4-Stream Interface (slave directions)
// 
// Allowed parameters:
//  CLK_DOMAIN                - Clk Domain                (string default: &lt;blank&gt;) 
//  PHASE                     - Phase                     (float) 
//  FREQ_HZ                   - Frequency                 (float default: 100000000) 
//  LAYERED_METADATA          - Layered Metadata          (string default: &lt;blank&gt;) 
//  HAS_TLAST                 - Has Tlast                 (long) {false - 0, true - 1}
//  HAS_TKEEP                 - Has Tkeep                 (long) {false - 0, true - 1}
//  HAS_TSTRB                 - Has Tstrb                 (long) {false - 0, true - 1}
//  HAS_TREADY                - Has Tready                (long) {false - 0, true - 1}
//  TUSER_WIDTH               - Tuser Width               (long) 
//  TID_WIDTH                 - Tid Width                 (long) 
//  TDEST_WIDTH               - Tdest Width               (long) 
//  TDATA_NUM_BYTES           - Tdata Num Bytes           (long) 
module my_module (
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TID" *)
  // Uncomment the following to set interface specific parameter on the bus interface.
  //  (* X_INTERFACE_PARAMETER = "CLK_DOMAIN &lt;value&gt;,PHASE &lt;value&gt;,FREQ_HZ &lt;value&gt;,LAYERED_METADATA &lt;value&gt;,HAS_TLAST &lt;value&gt;,HAS_TKEEP &lt;value&gt;,HAS_TSTRB &lt;value&gt;,HAS_TREADY &lt;value&gt;,TUSER_WIDTH &lt;value&gt;,TID_WIDTH &lt;value&gt;,TDEST_WIDTH &lt;value&gt;,TDATA_NUM_BYTES &lt;value&gt;" *)
  input [&lt;left_bound&gt;:0] &lt;s_tid&gt;, // Transfer ID tag (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TDEST" *)
  input [&lt;left_bound&gt;:0] &lt;s_tdest&gt;, // Transfer Destination (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TDATA" *)
  input [&lt;left_bound&gt;:0] &lt;s_tdata&gt;, // Transfer Data (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TSTRB" *)
  input [&lt;left_bound&gt;:0] &lt;s_tstrb&gt;, // Transfer Data Byte Strobes (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TKEEP" *)
  input [&lt;left_bound&gt;:0] &lt;s_tkeep&gt;, // Transfer Null Byte Indicators (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TLAST" *)
  input &lt;s_tlast&gt;, // Packet Boundary Indicator (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TUSER" *)
  input [&lt;left_bound&gt;:0] &lt;s_tuser&gt;, // Transfer user sideband (optional)
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TVALID" *)
  input &lt;s_tvalid&gt;, // Transfer valid (required)
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 &lt;interface_name&gt; TREADY" *)
  output &lt;s_tready&gt;, // Transfer ready (optional)
//  additional ports here
);

//  user logic here

endmodule
			</Template>
			<Template label="_Info" treetype="template">
// 
// Verilog attributes are used to declare interfaces and set parameters on them.
// Due to the language, the attributes need to be placed before a port which is part of the interface.
// When adding one or more parameters for an interface, a single attribute with multiple
// key value pairs should be added to before of the ports that is mapped into the interface.
// Generally, the form of the attributes are:
//   (* X_INTERFACE_INFO = "&lt;interface vlnv&gt; &lt;interface_name&gt; &lt;logical_port_name&gt;" *)
//   (* X_INTERFACE_PARAMETER = "&lt;parameter_name1&gt; &lt;parameter_value1&gt;, &lt;parameter_name2&gt; &lt;parameter_value2&gt;" *) 
//   input &lt;portname&gt;; 
			</Template>
		</SubFolder>
		<SubFolder label="Signal Interfaces" treetype="folder">
			<Template label="clock" treetype="template">
// Declare the attributes above the port declaration
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 &lt;clock_port_name&gt; CLK" *)
// Supported parameters: ASSOCIATED_CLKEN, ASSOCIATED_RESET, ASSOCIATED_ASYNC_RESET, ASSOCIATED_BUSIF, CLK_DOMAIN, PHASE, FREQ_HZ
// Most of these parameters are optional.  However, when using AXI, at least one clock must be associated to the AXI interface.
// Use the axi interface name for ASSOCIATED_BUSIF, if there are multiple interfaces, separate each name by ':'
// Use the port name for ASSOCIATED_RESET.
// Output clocks will require FREQ_HZ to be set (note the value is in HZ and an integer is expected).
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF &lt;AXI_interface_name&gt;, ASSOCIATED_RESET &lt;reset_port_name&gt;, FREQ_HZ 100000000" *)
input &lt;clock&gt;, //  (required)
			</Template>
			<Template label="clockenable" treetype="template">
// Declare the attributes above the port declaration
(* X_INTERFACE_INFO = "xilinx.com:signal:clockenable:1.0 &lt;clockenable_port_name&gt; CE" *)
// Supported parameter: POLARITY {ACTIVE_LOW, ACTIVE_HIGH}
// Normally active low is assumed.  Use this parameter to force the level
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_HIGH" *)
input &lt;clockenable&gt;, //  (required)
			</Template>
			<Template label="_Info" treetype="template">
// 
// Verilog attributes are used to declare signal interfaces and set parameters on them.
// Due to the language, the attributes need to be placed before a port which is part of the interface.
// When adding one or more parameters for an interface, a single attribute with multiple
// key value pairs should be added to before of the ports that is mapped into the interface.
// Generally, the form of the attributes are:
//   (* X_INTERFACE_INFO = "&lt;interface vlnv&gt; &lt;interface_name&gt; &lt;logical_port_name&gt;" *)
//   (* X_INTERFACE_PARAMETER = "&lt;parameter_name1&gt; &lt;parameter_value1&gt;, &lt;parameter_name2&gt; &lt;parameter_value2&gt;" *) 
//   input &lt;portname&gt;; 
			</Template>
			<Template label="interrupt" treetype="template">
// Declare the attributes above the port declaration
(* X_INTERFACE_INFO = "xilinx.com:signal:interrupt:1.0 &lt;interrput_port_name&gt; INTR" *)
// Supported parameter: SENSITIVITY { LEVEL_HIGH, LEVEL_LOW, EDGE_RISING, EDGE_FALLING }
// Normally LEVEL_HIGH is assumed.  Use this parameter to force the level
(* X_INTERFACE_PARAMETER = "SENSITIVITY EDGE_RISING" *)
input &lt;interrupt&gt;, //  (required)
			</Template>
			<Template label="reset" treetype="template">
// Declare the attributes above the port declaration
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 &lt;reset_port_name&gt; RST" *)
// Supported parameter: POLARITY {ACTIVE_LOW, ACTIVE_HIGH}
// Normally active low is assumed.  Use this parameter to force the level
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_HIGH" *)
input &lt;reset&gt;, //  (required)
			</Template>
		</SubFolder>
	</Folder>
	<Folder label="Simulation Constructs" treetype="folder">
		<SubFolder label="Clock Stimulus" treetype="folder">
			<SubFolder label="50% Duty Cycle" treetype="folder">
				<Template label="Using Always" treetype="template">
   // Note: CLK must be defined as a reg when using this method

   parameter PERIOD = &lt;value&gt;;

   always begin
      CLK = 1'b0;
      #(PERIOD/2) CLK = 1'b1;
      #(PERIOD/2);
   end
				</Template>
				<Template label="Using forever" treetype="template">
   // Note: CLK must be defined as a wire when using this method

   parameter PERIOD = &lt;value&gt;;

   initial begin
      CLK = 1'b0;
      #(PERIOD/2);
      forever
         #(PERIOD/2) CLK = ~CLK;
   end
				</Template>
			</SubFolder>
			<SubFolder label="Differential, Non-50% Duty Cycle" treetype="folder">
				<Template label="Using Always" treetype="template">
   // Note: CLK_P and CLK_N must be defined as a reg when using this method

   parameter PERIOD = &lt;value&gt;;
   parameter DUTY_CYCLE = &lt;value_0.01_to_0.99&gt;;

   always begin
      CLK_P = 1'b0;
      CLK_N = 1'b1;
      #(PERIOD-(PERIOD*DUTY_CYCLE)) CLK_P = 1'b1;
      CLK_N = 1'b0;
      #(PERIOD*DUTY_CYCLE);
   end
				</Template>
				<Template label="Using forever" treetype="template">
   // Note: CLK_P and CLK_N must be defined as a wire when using this method

   parameter PERIOD = &lt;value&gt;;
   parameter DUTY_CYCLE = &lt;value_0.01_to_0.99&gt;;

   initial
      forever begin
         CLK_P = 1'b0;
         CLK_N = 1'b1;
         #(PERIOD-(PERIOD*DUTY_CYCLE)) CLK_P = 1'b1;
         CLK_N = 1'b0;
         #(PERIOD*DUTY_CYCLE);
      end
				</Template>
			</SubFolder>
			<SubFolder label="Differential, 50% Duty Cycle" treetype="folder">
				<Template label="Using Always" treetype="template">
   // Note: CLK_P and CLK_N must be defined as a reg when using this method

   parameter PERIOD = &lt;value&gt;;

   always begin
      CLK_P = 1'b0;
      CLK_N = 1'b1;
      #(PERIOD/2) CLK_P = 1'b1;
      CLK_N = 1'b0;
      #(PERIOD/2);
   end
				</Template>
				<Template label="Using forever" treetype="template">
   // Note: CLK_P and CLK_N must be defined as a wire when using this method

   parameter PERIOD = &lt;value&gt;;

   initial begin
      CLK_P = 1'b0;
      CLK_N = 1'b1;
      #(PERIOD/2);
      forever
         #(PERIOD/2) {CLK_P, CLK_N} = ~{CLK_P, CLK_N};
   end
				</Template>
			</SubFolder>
			<SubFolder label="Non-50% Duty Cycle" treetype="folder">
				<Template label="Using Always" treetype="template">
   // Note: CLK must be defined as a reg when using this method

   parameter PERIOD = &lt;value&gt;;
   parameter DUTY_CYCLE = &lt;value_0.01_to_0.99&gt;;

   always begin
      CLK = 1'b0;
      #(PERIOD-(PERIOD*DUTY_CYCLE)) CLK = 1'b1;
      #(PERIOD*DUTY_CYCLE);
   end
				</Template>
				<Template label="Using forever" treetype="template">
   // Note: CLK must be defined as a wire when using this method

   parameter PERIOD = &lt;value&gt;;
   parameter DUTY_CYCLE = &lt;value_0.01_to_0.99&gt;;

   initial
      forever begin
         CLK = 1'b0;
         #(PERIOD-(PERIOD*DUTY_CYCLE)) CLK = 1'b1;
         #(PERIOD*DUTY_CYCLE);
      end
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Configuration" treetype="folder">
			<Template label="Cell Library Clause" treetype="template">
// The following will specify which library to bind to a sub-module (cell) within the design
config &lt;config_name&gt;;
   design &lt;lib_name&gt;.&lt;design_name&gt;
   default liblist &lt;new_library_1&gt; &lt;library_2&gt;;
   cell &lt;sub-module_name&gt; use &lt;new_library&gt;.&lt;new_module_name&gt;;
endconfig;
			</Template>
			<Template label="Default Library Clause" treetype="template">
// The following overrides the default library search order
config &lt;config_name&gt;;
   design &lt;lib_name&gt;.&lt;design_name&gt;
   default liblist &lt;library_1&gt; &lt;library_2&gt;;
endconfig;
			</Template>
			<Template label="Info (Configuration)" treetype="template">
// The Verilog-2001 Configuration Statement
// ========================================
//
// Verilog-2001 adds a new construct, the configuration or config statement,
// to the Verilog language to allow the modification of library binding rules.
// In general, it is still suggested to use the simulator to specify the library
// binding however at times more specific control is needed and this construct
// allows very specific binding rules for libraries.  This is generally used
// for simulation where different models (i.e. behavioral, rtl or gate-level) can
// be used and inter-changed during simulation.
//
// Example: The following will change the default library binding rules for
//          a design named ethernet_top located in the work library so that
//          the library named gate_lib is used first and if not found there,
//          rtl_lib is used. The configuration is name mixed_gate_sim

config mixed_gate_sim;
   design work.ethernet_top
   default liblist gate_lib rtl_lib;
endconfig;

// Example: The following will change the default library binding rules for
//          any instantiation of a module named sram512 in the module named
//          ethernet_top located in the work library so that the library named
//          sim_lib is used for that model

config mixed_gate_sim;
   design work.ethernet_top
   default liblist gate_lib rtl_lib;
   cell sram512 use sim_lib.sram512;
endconfig;

// Example: The following will change the default library binding rules for
//          the instance named sdram_ctrl_inst in the module named
//          custom_cpu located in the work library so that the library named
//          dave_lib is used for that model

config mixed_gate_sim;
   design work.custom_cpu
   default liblist gate_lib rtl_lib;
   instance custom_cpu_top.sdram_ctrl_inst liblist dave_lib;
endconfig;
			</Template>
			<Template label="Instance Library Clause" treetype="template">
// The following will specify which library to bind to an instance within the design
config &lt;config_name&gt;;
   design &lt;lib_name&gt;.&lt;design_name&gt;
   default liblist &lt;new_library_1&gt; &lt;library_2&gt;;
   instance &lt;instance_name&gt; liblist &lt;new_library&gt;;
endconfig;
			</Template>
		</SubFolder>
		<SubFolder label="Delays" treetype="folder">
			<Template label="Finite Delay" treetype="template">
   #&lt;delay_value&gt;;
			</Template>
			<Template label="Wait for Any Signal Transition" treetype="template">
   @(&lt;signal&gt;);
			</Template>
			<Template label="Wait for Negative Signal Transition" treetype="template">
   @(negedge &lt;signal&gt;);
			</Template>
			<Template label="Wait for Positive Signal Transition" treetype="template">
   @(posedge &lt;signal&gt;);
			</Template>
			<Template label="Wait for Signal Condition" treetype="template">
   wait (&lt;signal&gt;==&lt;value&gt;);
			</Template>
		</SubFolder>
		<SubFolder label="Loops" treetype="folder">
			<Template label="Decrementing for Loop" treetype="template">
   integer &lt;var&gt;;

   for (&lt;var&gt; = &lt;initial_value&gt;; &lt;var&gt; &gt;= &lt;final_value&gt;; &lt;var&gt;=&lt;var&gt;-1) begin
      &lt;statement&gt;;
   end
			</Template>
			<Template label="Disable Loop" treetype="template">
   disable &lt;loop_identifier&gt;;
			</Template>
			<Template label="forever Loop" treetype="template">
   forever begin
      &lt;statement&gt;;
   end
			</Template>
			<Template label="Incrementing for Loop" treetype="template">
   integer &lt;var&gt;;

   for (&lt;var&gt; = &lt;initial_value&gt;; &lt;var&gt; &lt;= &lt;final_value&gt;; &lt;var&gt;=&lt;var&gt;+1) begin
      &lt;statement&gt;;
   end
			</Template>
			<Template label=" (Loops)" treetype="template">
// information for Verilog Looping Statements (i.e. while, repeat, forever, for, etc.)
// ===================================================================================
//
// There are several ways to create a looping statement within a verilog
// testbench.  Each of these constructs must appear within an initial or
// always block and can be disabled if the block is labeled.
//
// Repeat - A repeat loop is generally the easiest construct if it is desired
//          to perform an action a known, finite number of times and the loop
//          variable is not needed for the function.
//
//          Example: The following example will apply random data to the
//                   DATA_IN signal 30 times at each clock signal.

initial begin
   repeat (30) begin
      @(posedge CLK);
      #1 DATA_IN = $random;
   end
end

// While - The while loop is a good way to create a conditional loop that will
//         execute as long as a condition is met.
//
//         Example: The following example will read from a FIFO as long as the
//                  EMPTY flag is true.

initial begin
   while (EMPTY==1'b0) begin
      @(posedge CLK);
      #1 read_fifo = 1'b1;
   end

// for - The for loop is generally used when a finite loop is desired and it
//       is necessary to key off the loop variable.  Depending on how the for
//       condition is created, an incrementing or decrementing loop can be created.
//
//       Example: The following will assign a 1'b0 to each bit in the 32 bit
//                DATA signal at time zero. An incrementing for loop will be used.

parameter WIDTH=32;
reg [WIDTH-1:0] DATA;
integer i;

initial
   for (i=0; i&lt;WIDTH; i=i+1)
      DATA[i] = 1'b0;

// forever - The forever loop is a construct generally used to create an infinite
//           loop for simulation.
//
//           Example: The following will create a clock using a forever loop with
//                    a period of 10 ns and a 50% duty cycle.

`timescale 1ns/1ps

initial
   forever begin
      CLK = 1'b0;
      #5 CLK = 1'b1;
      #5;
   end

// Disable - Any loop can be disabled by using the disable construct.  In order
//           to disable a loop, a loop identifier or label must be used on the
//           loop to be disabled.
//
//           Example: The following will stop a clock created in a forever loop
//                    if a signal called stop_clock is 1'b1.

`timescale 1ns/1ps

initial
   forever begin : clock_10ns
      CLK = 1'b0;
      #5 CLK = 1'b1;
      #5;
   end

always @(posedge stop_clock)
   if (stop_clock)
      disable clock_10ns;
			</Template>
			<Template label="Repeat Loop" treetype="template">
   repeat (&lt;value&gt;) begin
      &lt;statements&gt;;
   end
			</Template>
			<Template label="While Loop" treetype="template">
   while (&lt;condition&gt;) begin
      &lt;statement&gt;;
   end
			</Template>
		</SubFolder>
		<SubFolder label="Mnemonics" treetype="folder">
			<Template label="Info (Mnemonics)" treetype="template">
// Mnemonics
//
// Most simulators have the ability to display ASCII text in the waveform and
// other debug windows as a means to allow for easier visual reference and
// understanding of a circuit operation.  A useful debugging methodology is to
// assign text values to certain circuit values from within the testbench so
// that when added to the waveform and displayed as ASCII, would give more
// useful information about that current state of the circuit.  Such methods are
// particularly useful in state-machine designs where each state value could be
// represented as a more easily identified text string.  Other examples could
// include mapping OPMODEs, detecting certain data (i.e. packet starts, training
// sequences, etc.) or mapping address values/ranges.  Below is an example of
// defining a mnemonic in a testbench to decode a simple state-machine states to
// something more intelligible.
//

  // A reg must be declared with enough bits (8 times number of characters)
  //  to store the desired string.  Add this vector to the waveform and set the
  //  radix to ASCII

  reg [(8*12)-1:0] state_string = "??UNKNOWN??";

  // There is a 4-bit register called "state" in the uart_inst sub-instance in
  //  the design file.  This always statement looks at it to generate the
  //  mnemonics for the state-machine to the desired state_string reg.

  always @(uut.uart_inst.state)
    case (uut.uart_inst.state)
      4'b0001 : begin
        $display("%t: STATE is now: START", $realtime);
        state_string = "START";
      end
      4'b0010 : begin
        $display("%t: STATE is now: FIRST_MATCH", $realtime);
        state_string = "FIRST_MATCH";
      end
      4'b0100 : begin
        $display("%t: STATE is now: SECOND_MATCH", $realtime);
        state_string = "SECOND_MATCH";
      end
      4'b1000 : begin
        $display("%t: STATE is now: SUCCESS", $realtime);
        state_string = "SUCCESS";
      end
      default : begin
        $display("%t: ERROR: STATE is now: UNKNOWN !!!!", $realtime);
        state_string = "??UNKNOWN??";
      end
    endcase
			</Template>
		</SubFolder>
		<SubFolder label="Procedural Blocks" treetype="folder">
			<Template label="Conditional Repeated Execution (Always specification)" treetype="template">
   always @(&lt;signals&gt;) begin
      &lt;statements&gt;;
   end
			</Template>
			<Template label="Execute Once (Initial Specification)" treetype="template">
   initial begin
      //  Wait for Global Reset to Complete
      #100;
      &lt;statements&gt;;
   end
			</Template>
			<Template label="Repeated Execution (Always specification)" treetype="template">
   always begin
      &lt;statements&gt;;
   end
			</Template>
		</SubFolder>
		<SubFolder label="Signal Assignment" treetype="folder">
			<Template label="Assign a value (assign)" treetype="template">
   assign &lt;reg&gt; = &lt;value&gt;;
			</Template>
			<Template label="Deassign a value (deassign)" treetype="template">
   deassign &lt;reg&gt;;
			</Template>
			<Template label="force a value (force)" treetype="template">
   force &lt;wire_or_reg&gt; = &lt;value&gt;;
			</Template>
			<SubFolder label="Initialize Values" treetype="folder">
				<SubFolder label="Using initial" treetype="folder">
					<Template label="1-bit Register" treetype="template">
   initial begin
      &lt;reg&gt; = 1'b0;
   end
					</Template>
					<Template label="2-bit Register" treetype="template">
   initial begin
      &lt;reg&gt; = 2'b00;
   end
					</Template>
					<Template label="3-bit Register" treetype="template">
   initial begin
      &lt;reg&gt; = 3'b000;
   end
					</Template>
					<Template label="4-bit Register" treetype="template">
   initial begin
      &lt;reg&gt; = 4'h0;
   end
					</Template>
					<Template label="8-bit Register" treetype="template">
   initial begin
      &lt;reg&gt; = 8'h00;
   end
					</Template>
					<Template label="16-bit Register" treetype="template">
   initial begin
      &lt;reg&gt; = 16'h0000;
   end
					</Template>
					<Template label="32-bit Register" treetype="template">
   initial begin
      &lt;reg&gt; = 32'h00000000;
   end
					</Template>
					<Template label="64-bit Register" treetype="template">
   initial begin
      &lt;reg&gt; = 64'h0000000000000000;
   end
					</Template>
				</SubFolder>
				<SubFolder label="Using reg declaration" treetype="folder">
					<Template label="1-bit Register" treetype="template">
   reg &lt;name&gt; = 1'b0;
					</Template>
					<Template label="2-bit Register" treetype="template">
   reg [1:0] &lt;name&gt; = 2'b00;
					</Template>
					<Template label="3-bit Register" treetype="template">
   reg [2:0] &lt;name&gt; = 3'b000;
					</Template>
					<Template label="4-bit Register" treetype="template">
   reg [3:0] &lt;name&gt; = 4'h0;
					</Template>
					<Template label="8-bit Register" treetype="template">
   reg [7:0] &lt;name&gt; = 8'h00;
					</Template>
					<Template label="16-bit Register" treetype="template">
   reg [15:0] &lt;name&gt; = 16'h0000;
					</Template>
					<Template label="32-bit Register" treetype="template">
   reg [31:0] &lt;name&gt; = 32'h00000000;
   reg [63:0] &lt;name&gt; = 64'h0000000000000000;
					</Template>
				</SubFolder>
			</SubFolder>
			<Template label="Release a forced value (release)" treetype="template">
   release &lt;wire_or_reg&gt;;
   release &lt;wire_or_reg&gt;;
			</Template>
			<SubFolder label="Vcc/Gnd" treetype="folder">
				<Template label="Ground Rail" treetype="template">
   supply0 &lt;name&gt;;
				</Template>
				<Template label="Vcc Rail" treetype="template">
   supply1 &lt;name&gt;;
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Signal, Constant &amp; Variable Declarations" treetype="folder">
			<Template label="32-bit Integer" treetype="template">
   integer &lt;name&gt;;
			</Template>
			<Template label="64-bit floating point (real)" treetype="template">
   real &lt;name&gt;;
			</Template>
			<Template label="64-bit floating point (time)" treetype="template">
   time &lt;name&gt;;
			</Template>
			<SubFolder label="Parameter" treetype="folder">
				<Template label="Info (Parameter)" treetype="template">
// information on the Verilog Parameter, Local Parameter,
//           Defparam and Named Parameter Value Assignment
// =======================================================
//
// Parameters are a method within Verilog in order to define constants
// within the code.  They are very useful in order to define bus widths,
// memory depths, state-machine assignments, clock periods and other useful
// constants used throughout the design and testbench.  Parameters can bring
// more meaning and documentation to the code or can be used to make the
// code more parameterizable and thus help enable re-use or help adjust to
// late changes in the design.  There are two main types of parameters, the
// parameter and local parameter.  A local parameter acts the same as a
// parameter however its contents cannot be modified via a defparam or a
// named parameter value assignment in the instantiation.  A defparam allows
// the reassignment to the value of a parameter from a different level of
// hierarchy in the testbench or design.  A named parameter value assignment
// allows a respecification of the parameter value within the instance
// declaration of the instantiation of the component.  Both local parameters
// and parameters can be sized to a specified number of bits and/or can be typed
// to be either a signed value, an integer, a real number, a time (64-bit
// precision) or a realtime (double-precision floating point) value.

// Example declaring a parameter and local parameter

// Define pi as a local real number parameter since I do not want to ever change this

localparam real pi = 3.14;

// Define BUS_WIDTH as a parameter with a default value of 8

parameter BUS_WIDTH = 8;

// Use this parameter to define the width of a declared register

reg [BUS_WIDTH-1:0] my_reg;

// Use a defparam from my testbench to change BUS_WIDTH to 16 for the instantiated
//    design instance UUT

defparam UUT.BUS_WIDTH = 16;

//  Alternatively to the defparam, I could have done this using the named parameter value assignment when I instantiate UUT

my_design #(
   .BUS_WIDTH(16)
) UUT (
   .A(A),
   .B(B),
   .C(C)
);
				</Template>
				<SubFolder label="Local Parameter" treetype="folder">
					<Template label="Integer local parameter" treetype="template">
   localparam integer &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Real local parameter" treetype="template">
   localparam real &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Realtime local parameter" treetype="template">
   localparam realtime &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Signed, ranged local parameter" treetype="template">
   localparam signed [upper:lower] &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Signed, unranged local parameter" treetype="template">
   localparam signed &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Time local parameter" treetype="template">
   localparam time &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Un-typed, ranged local parameter" treetype="template">
   localparam [upper:lower] &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Un-typed, unranged local parameter" treetype="template">
   localparam &lt;name&gt; = &lt;value&gt;;
					</Template>
				</SubFolder>
				<SubFolder label="Parameter" treetype="folder">
					<Template label="Integer parameter" treetype="template">
   parameter integer &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Real parameter" treetype="template">
   parameter real &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Realtime parameter" treetype="template">
   parameter realtime &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Signed, ranged parameter" treetype="template">
   parameter signed [upper:lower] &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Signed, unranged parameter" treetype="template">
   parameter signed &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Time parameter" treetype="template">
   parameter time &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Un-typed, ranged parameter" treetype="template">
   parameter [upper:lower] &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Un-typed, unranged parameter" treetype="template">
   parameter &lt;name&gt; = &lt;value&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="reg" treetype="folder">
				<Template label="2-dimensional 1k x 18" treetype="template">
   reg [17:0] &lt;name&gt; [1023:0];
				</Template>
				<Template label="2-dimensional 2k x 9" treetype="template">
   reg [8:0] &lt;name&gt; [2047:0];
				</Template>
				<Template label="2-dimensional 4k x 4" treetype="template">
   reg [3:0] &lt;name&gt; [4095:0];
				</Template>
				<Template label="2-dimensional 8k x 2" treetype="template">
   reg [1:0] &lt;name&gt; [8191:0];
				</Template>
				<Template label="2-dimensional 16k x 1" treetype="template">
   reg &lt;name&gt; [16383:0];
				</Template>
				<Template label="2-dimensional 16 x 1" treetype="template">
   reg &lt;name&gt; [15:0];
				</Template>
				<Template label="2-dimensional 32 x 1" treetype="template">
   reg &lt;name&gt; [31:0];
				</Template>
				<Template label="2-dimensional 64 x 1" treetype="template">
   reg &lt;name&gt; [63:0];
				</Template>
				<Template label="2-dimensional 512 x 36" treetype="template">
   reg [35:0] &lt;name&gt; [511:0];
				</Template>
				<SubFolder label="Initialized" treetype="folder">
					<SubFolder label="Keeper Reg" treetype="folder">
						<Template label="1-bit" treetype="template">
   // Stores last value when 3-stated
   trireg &lt;name&gt; = 1'b0;
						</Template>
						<Template label="2-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [1:0] &lt;name&gt; = 2'b00;
						</Template>
						<Template label="3-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [2:0] &lt;name&gt; = 3'b000;
						</Template>
						<Template label="4-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [3:0] &lt;name&gt; = 4'h0;
						</Template>
						<Template label="8-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [7:0] &lt;name&gt; = 8'h00;
						</Template>
						<Template label="16-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [15:0] &lt;name&gt; = 16'h0000;
						</Template>
						<Template label="32-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [31:0] &lt;name&gt; = 32'h00000000;
						</Template>
						<Template label="64-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [63:0] &lt;name&gt; = 64'h0000000000000000;
						</Template>
					</SubFolder>
				</SubFolder>
				<Template label="Initialized Signed 8-bit" treetype="template">
   reg signed [7:0] &lt;name&gt; = 8'sh00;
				</Template>
				<Template label="Initialized Signed 9-bit" treetype="template">
   reg signed [8:0] &lt;name&gt; = 9'sh000;
				</Template>
				<Template label="Initialized Signed 16-bit" treetype="template">
   reg signed [15:0] &lt;name&gt; = 16'sh0000;
				</Template>
				<Template label="Initialized Signed 18-bit" treetype="template">
   reg signed [17:0] &lt;name&gt; = 18'sh00000;
				</Template>
				<Template label="Initialized Signed 32-bit" treetype="template">
   reg signed [31:0] &lt;name&gt; = 32'sh00000000;
				</Template>
				<Template label="Initialized Signed 64-bit" treetype="template">
   reg signed [63:0] &lt;name&gt; = 64'sh0000000000000000;
				</Template>
				<Template label="Initialized 1-bit" treetype="template">
   reg &lt;name&gt; = 1'b0;
				</Template>
				<Template label="Initialized 2-bit" treetype="template">
   reg [1:0] &lt;name&gt; = 2'b00;
				</Template>
				<Template label="Initialized 3-bit" treetype="template">
   reg [2:0] &lt;name&gt; = 3'b000;
				</Template>
				<Template label="Initialized 4-bit" treetype="template">
   reg [3:0] &lt;name&gt; = 4'h0;
				</Template>
				<Template label="Initialized 8-bit" treetype="template">
   reg [7:0] &lt;name&gt; = 8'h00;
				</Template>
				<Template label="Initialized 16-bit" treetype="template">
   reg [15:0] &lt;name&gt; = 16'h0000;
				</Template>
				<Template label="Initialized 32-bit" treetype="template">
   reg [31:0] &lt;name&gt; = 32'h00000000;
				</Template>
				<Template label="Initialized 64-bit" treetype="template">
   reg [63:0] &lt;name&gt; = 64'h0000000000000000;
				</Template>
				<SubFolder label="Uninitialized" treetype="folder">
					<SubFolder label="Keeper Reg" treetype="folder">
						<Template label="1-bit" treetype="template">
   // Stores last value when 3-stated
   trireg &lt;name&gt;;
						</Template>
						<Template label="2-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [1:0] &lt;name&gt;;
						</Template>
						<Template label="3-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [2:0] &lt;name&gt;;
						</Template>
						<Template label="4-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [3:0] &lt;name&gt;;
						</Template>
						<Template label="8-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [7:0] &lt;name&gt;;
						</Template>
						<Template label="16-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [15:0] &lt;name&gt;;
						</Template>
						<Template label="32-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [31:0] &lt;name&gt;;
						</Template>
						<Template label="64-bit" treetype="template">
   // Stores last value when 3-stated
   trireg [63:0] &lt;name&gt;;
						</Template>
					</SubFolder>
				</SubFolder>
				<Template label="Uninitialized Signed 8-bit" treetype="template">
   reg signed [7:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized Signed 9-bit" treetype="template">
   reg signed [8:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized Signed 16-bit" treetype="template">
   reg signed [15:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized Signed 18-bit" treetype="template">
   reg signed [17:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized Signed 32-bit" treetype="template">
   reg signed [31:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized Signed 64-bit" treetype="template">
   reg signed [63:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized 1-bit" treetype="template">
   reg &lt;name&gt;;
				</Template>
				<Template label="Uninitialized 2-bit" treetype="template">
   reg [1:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized 3-bit" treetype="template">
   reg [2:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized 4-bit" treetype="template">
   reg [3:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized 8-bit" treetype="template">
   reg [7:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized 16-bit" treetype="template">
   reg [15:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized 32-bit" treetype="template">
   reg [31:0] &lt;name&gt;;
				</Template>
				<Template label="Uninitialized 64-bit" treetype="template">
   reg [63:0] &lt;name&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="wire" treetype="folder">
				<Template label="1-bit" treetype="template">
   wire &lt;name&gt;;
				</Template>
				<Template label="2-bit" treetype="template">
   wire [1:0] &lt;name&gt;;
				</Template>
				<Template label="3-bit" treetype="template">
   wire [2:0] &lt;name&gt;;
				</Template>
				<Template label="4-bit" treetype="template">
   wire [3:0] &lt;name&gt;;
				</Template>
				<Template label="8-bit" treetype="template">
   wire [7:0] &lt;name&gt;;
				</Template>
				<Template label="16-bit" treetype="template">
   wire [15:0] &lt;name&gt;;
				</Template>
				<Template label="32-bit" treetype="template">
   wire [31:0] &lt;name&gt;;
				</Template>
				<Template label="64-bit" treetype="template">
   wire [63:0] &lt;name&gt;;
				</Template>
				<Template label="Signed 8-bit" treetype="template">
   wire signed [7:0] &lt;name&gt;;
				</Template>
				<Template label="Signed 9-bit" treetype="template">
   wire signed [8:0] &lt;name&gt;;
				</Template>
				<Template label="Signed 16-bit" treetype="template">
   wire signed [15:0] &lt;name&gt;;
				</Template>
				<Template label="Signed 18-bit" treetype="template">
   wire signed [17:0] &lt;name&gt;;
				</Template>
				<Template label="Signed 32-bit" treetype="template">
   wire signed [31:0] &lt;name&gt;;
				</Template>
				<Template label="Signed 64-bit" treetype="template">
   wire signed [63:0] &lt;name&gt;;
				</Template>
				<SubFolder label="Wire w/ Pullup" treetype="folder">
					<Template label="1-bit" treetype="template">
   tri1 &lt;name&gt;;
					</Template>
					<Template label="2-bit" treetype="template">
   tri1 [1:0] &lt;name&gt;;
					</Template>
					<Template label="3-bit" treetype="template">
   tri1 [2:0] &lt;name&gt;;
					</Template>
					<Template label="4-bit" treetype="template">
   tri1 [3:0] &lt;name&gt;;
					</Template>
					<Template label="8-bit" treetype="template">
   tri1 [7:0] &lt;name&gt;;
					</Template>
					<Template label="16-bit" treetype="template">
   tri1 [15:0] &lt;name&gt;;
					</Template>
					<Template label="32-bit" treetype="template">
   tri1 [31:0] &lt;name&gt;;
					</Template>
					<Template label="64-bit" treetype="template">
   tri1 [63:0] &lt;name&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="System Tasks &amp; Functions" treetype="folder">
			<SubFolder label="File I/O" treetype="folder">
				<SubFolder label="Read Memory File" treetype="folder">
					<Template label="Binary Data ($readmemb)" treetype="template">
   reg [&lt;memory_width&gt;] &lt;reg_name&gt; [&lt;memory_depth&gt;];

   initial
      $readmemb ("&lt;file_name&gt;", &lt;reg_name&gt;, &lt;start_address&gt;, &lt;end_address&gt;);
					</Template>
					<Template label="Hex Data ($readmemh)" treetype="template">
   reg [&lt;memory_width&gt;] &lt;reg_name&gt; [&lt;memory_depth&gt;];

   initial
      $readmemh ("&lt;file_name&gt;", &lt;reg_name&gt;, &lt;start_address&gt;, &lt;end_address&gt;);
					</Template>
					<Template label="Info ($readmemb/h)" treetype="template">
// information on the $readmemb and $readmemh system functions
// ===========================================================
//
// $readmemb is a system function which will read binary data from a
// specified file and place it in an array. The syntax is the following:
// $readmemb ("&lt;file_name&gt;", &lt;reg_name&gt;, &lt;start_address&gt;, &lt;end_address&gt;);
// where the &lt;file_name&gt; is the name and location of the file containing
// the binary data, the &lt;reg_name&gt; is a 2-D register array in which the
// memory data is stored, and the last two optional comma separated  numbers
// specify the beginning and ending address of the data.  The data file
// may only contain binary data, white spaces and comments.  This function
// must be executed within an initial block.
//
// $readmemh is the same as $readmemb with the exception that it
// inputs hex data as the read values.
//
// In the past, these functions could only be used for simulation
// purposes however synthesis tools now has the ability to initialize RAM
// and ROM arrays using this construct.
//
// Example of reading binary data from a file:

   reg  [31:0] rom_data[1023:0];

   initial
     $readmemb("../data/mem_file.dat", rom_data, 0, 7);

// The initialization file may only contain white spaces, address
// labels (denoted by @&lt;address&gt;), comments and the actual binary
// or hexadecimal data.
// The following is a small example of a binary memory file data:

// This is a comment

1111000011110000     // This specifies these 16-bits to the first address
1010_0101_1010_0101  // This is for the second address with underscores
                     // to make this more readable
&lt;more entries like above to fill up the array&gt;

// Optionally, we can change addresses
@025 // Now at address 025
11111111_00000000

// Addresses can also be specified in-line
@035 00000000_11111111

// It is highly suggested to fill all memory contents with a known value
//  when initializing memories.
					</Template>
				</SubFolder>
				<SubFolder label="Readw/rite to a File" treetype="folder">
					<SubFolder label="Functions" treetype="folder">
						<Template label="Change the File Position ($fseek)" treetype="template">
   &lt;integer&gt; = $fseek(&lt;file_desc&gt;, &lt;offset_value&gt;, &lt;operation_number&gt;);
						</Template>
						<Template label="Close a File ($fclose)" treetype="template">
   $fclose(&lt;file_desc&gt;);
						</Template>
						<Template label="Display Text to a File ($fdisplay)" treetype="template">
   $fdisplay(&lt;file_desc&gt;, "&lt;string&gt;", variables);
						</Template>
						<Template label="Find the File Position ($ftell)" treetype="template">
   &lt;reg&gt; = $ftell(&lt;file_desc&gt;);
						</Template>
						<Template label="Flush Buffer ($fflush)" treetype="template">
   $fflush(&lt;file_desc&gt;);
						</Template>
						<Template label="Open a File ($fopen)" treetype="template">
   integer &lt;file_desc&gt;;
   &lt;file_desc&gt; = $fopen("&lt;file_name&gt;", "&lt;file_mode&gt;");
						</Template>
						<Template label="Read a character from a file ($fgetc)" treetype="template">
   reg [7:0] &lt;8-bit_reg&gt;;
   &lt;8-bit_reg&gt; = $fgetc(&lt;file_desc&gt;);
						</Template>
						<Template label="Read a formatted line from a file ($fscanf)" treetype="template">
   integer &lt;integer&gt;;
   &lt;integer&gt; = $fscanf(&lt;file_desc&gt;, "&lt;format&gt;", &lt;destination_regs&gt;);
						</Template>
						<Template label="Read a line from a file ($fgets)" treetype="template">
   integer &lt;integer&gt;;
   reg [8*&lt;#_of_chars&gt;:0] &lt;string_reg&gt;;
   &lt;integer&gt; = $fgets(&lt;string_reg&gt;, &lt;file_desc&gt;);
						</Template>
						<Template label="Strobe Text to a File ($fstrobe)" treetype="template">
   $fstrobe(&lt;file_desc&gt;, "&lt;string&gt;", variables);
						</Template>
						<Template label="Test Error ($ferror)" treetype="template">
   &lt;640-bit_reg&gt; = $ferror(&lt;file_desc&gt;);
						</Template>
						<Template label="Write Monitored Text to a File ($fmonitor)" treetype="template">
   $fmonitor(&lt;file_desc&gt;, "&lt;string&gt;", variables);
						</Template>
						<Template label="Write Text to a File ($fwrite)" treetype="template">
   $fwrite(&lt;file_desc&gt;, "&lt;string&gt;", variables);
						</Template>
					</SubFolder>
					<Template label="Info (File I/O)" treetype="template">
// information on the $fopen, $fdisplay, $fstrobe, $fwrite, $ftell,
// $feof, $ferror, $fgetc, $fgets, and $fclose system functions
// ================================================================
//
// Opening Command
// ---------------
// $fopen is used to open a file for reading, writing and/or appending.
// This operation must precede any of the reading or writing commands
// specified in this document. When using the $fopen, you must specify
// the file name and file mode (read, write, etc.). The syntax looks like
// the following: $fopen("&lt;file_name&gt;", "&lt;file_mode&gt;")
// Upon opening the file a handle number is issued for the file and must
// be used to reference the file in subsequent commands. Generally, this
// number should be assigned to a declared integer.
//
// The file mode can be one of the following:
//
//    "r" ...... Open ASCII file for reading
//    "rb" ..... Open Binary file for reading
//    "w" ...... Open ASCII file for writing (delete if exists)
//    "wb" ..... Open Binary file for writing (delete if exists)
//    "a" ...... Open ASCII file for writing (append to end of file)
//    "ab" ..... Open Binary file for writing (append to end of file)
//    "r+" ..... Open ASCII file for reading and writing
//
//
// Writing Commands
// ----------------
// $fdisplay will write formatted text to a specified file. Specific text,
// system functions/tasks and signal values can be output using this
// function.  The file handle assigned by the $fopen function must be
// specified to indicate the destination file for the text.  The syntax looks
// as follows:  $fdisplay(&lt;file_desc&gt;, "&lt;string&gt;", variables);
//
// $fwrite acts very similar to $fdisplay in that it can write a specified
// string to a file however it does not specify a carriage return after
// performing this operation.
//
// $fstrobe is also similar to $fdisplay only waits for all simulation events
// in the queue to be executed before writing the message.
//
// $fmonitor will write a string to the specified file whenever a change
// in value is detected for one of the variables being written.  After
// the string is written, a carriage return is issued.
//
// When using these write commands ($fdisplay, $fwrite, $fstrobe, $fmonitor),
// variables can be specified to the output in a variety of formats.  Also,
// special escape characters can be used to specify special characters or
// formatting.  These formats are listed below.
//
//    Variables
//    ---------
//    %b .... Binary Value
//    %h .... Hexadecimal Value
//    %d .... Decimal Value
//    %t .... Time
//    %s .... String
//    %c .... ASCII
//    %f .... Real Value
//    %e .... Exponential Value
//    %o .... Octal Value
//    %m .... Module Hierarchical Name
//    %v .... Strength
//
//    Escape Characters
//    -----------------
//    \t ........ Tab
//    \n ........ Newline
//    \\ ........ Backslash
//    %% ........ Percent
//    \" ........ Quote
//    \&lt;octal&gt; .. ASCII representation
//
//
// Reading Commands
// ----------------
// $fgets will read an entire line of text from a file and store it as a
// string. The format for $fgets is: $fgets(&lt;string_reg&gt;, &lt;file_desc&gt;);
// $fgets returns an integer value either indicating the number of characters
// read or a zero indication an error during the read attempt.  The &lt;string_reg&gt;
// should be defined a width equal to the number of characters on the longest
// line multiplied by 8.
//
// $fgetc will read a character from a file and return it as an 8-bit string.
// If EOF is encountered, a value of -1 is written.
//
// $fscanf will read a line from a file and store it in a specified form. The
// format for the $fsacnf is: $fscanf(&lt;file_desc&gt;, &lt;format&gt;, &lt;destination_regs&gt;)
// where the format is specified similar to how it is specified in the read
// command above and the &lt;destination_regs&gt; is where the read data is stored.
// $fscanf will return an integer value indicating the number of matched
// formatted data read. If an error occurs during the read, this number will
// be zero.
//
//
// Special Functions
// -----------------
// $ferror tests and reports last error encountered during a file open, read
// or write.  The written string can be up to 80 characters (640 bits) wide.
//
// $fseek will reposition the pointer within the file to the specified position.
// The format for the $fseek command is:
// $fseek(&lt;file_desc&gt;, &lt;offset_value&gt;, &lt;operation_number&gt;) where the operation
// number is one of three values:
// 0 - set position using the beginning of file as the reference point
// 1 - set position using the current location of the pointer as reference
// 2 - set position using the EOF as reference
// $fseek will return a zero if the command was successful and a -1 if not.
//
// $ftell specifies the position of the pointer within the file by outputting an
// integer value indicating the number of offset bytes from the beginning of the
// file.
//
// $fflush writes any buffered output to the specified file.
//
//
// Close File
// ----------
// $fclose closes a previous opened file.  The format is $fclose(&lt;file_desc&gt;);
//
// In general, you may wish to limit the amount and occurrences of reading and
// writing to a file during simulation as it may have a negative impact on
// overall simulation runtime. File access can be a slow process and if done
// often can weigh down simulation quite a bit.
//
//
// Example of writing monitored signals:
// -------------------------------------

   // Define file handle integer
   integer outfile;

   initial begin
      // Open file output.dat for writing
      outfile = $fopen("output.dat", "w");

      // Check if file was properly opened and if not, produce error and exit
      if (outfile == 0) begin
         $display("Error: File, output.dat could not be opened.\nExiting Simulation.");
         $finish;
      end

      // Write monitor data to a file
      $fmonitor (outfile, "Time: %t\t Data_out = %h", $realtime, Data_out);

      // Wait for 1 ms and end monitoring
      #1000000;

      // Close file to end monitoring
      $fclose(outfile);
   end

// Example of reading a file using $fscanf:
// ----------------------------------------

   real number;

   // Define integers for file handling
   integer number_file;
   integer i=1;

   initial begin
      // Open file numbers.txt for reading
      number_file = $fopen("numbers.txt", "r");
      // Produce error and exit if file could not be opened
      if (number_file == 0) begin
         $display("Error: Failed to open file, numbers.txt\nExiting Simulation.");
         $finish;
      end
      // Loop while data is being read from file
      //    (i will be -1 when end of file or 0 for blank line)
      while (i&gt;0) begin
         $display("i = %d", i);
         i=$fscanf(number_file, "%f", number);
         $display("Number read from file is %f", number);
         @(posedge CLK);
      end
      // Close out file when finished reading
      $fclose(number_file);
      #100;
      $display("Simulation ended normally");
      $stop;
   end
					</Template>
				</SubFolder>
			</SubFolder>
			<Template label="Random Number Generation" treetype="template">
   &lt;reg&gt; = $random(&lt;seed&gt;);
			</Template>
			<SubFolder label="Screen Output" treetype="folder">
				<Template label="Display text ($display)" treetype="template">
   $display("&lt;string_and/or_variables&gt;", &lt;functions_or_signals&gt;);
				</Template>
				<Template label="Info (Screen Output)" treetype="template">
// information of $display, $monitor, $write, and $strobe System Functions
// =======================================================================
//
// $display will display a string to the standard output (screen/console)
// of the simulator.  Variables may be added to the string to indicate
// current time (as well as other system functions) and states of signals
// in the design.  After the string is displayed, a carriage return is
// issued.
//
// $monitor will display a string to the standard output whenever a change
// in value is detected for one of the variables being displayed.  After
// the string is displayed, a carriage return is issued.
//
// $write acts very similar to $display in that it can output a specified
// string to the standard out however it does not return a carriage return
// after performing this operation.
//
// $strobe is also similar to $display only waits for all simulation events
// in the queue to be executed before generating the message.
//
// When using these standard output commands, variables can be specified to
// the output in a variety of formats.  Also, special escape characters can
// be used to specify special characters or formatting.  These formats are
// listed below.
//
//    Variables
//    ---------
//    %b .... Binary Value
//    %h .... Hexadecimal Value
//    %d .... Decimal Value
//    %t .... Time
//    %s .... String
//    %c .... ASCII
//    %f .... Real Value
//    %e .... Exponential Value
//    %o .... Octal Value
//    %m .... Module Hierarchical Name
//    %v .... Strength
//
//    Escape Characters
//    -----------------
//    \t ........ Tab
//    \n ........ Newline
//    \\ ........ Backslash
//    %% ........ Percent
//    \" ........ Quote
//    \&lt;octal&gt; .. ASCII representation
//
// $display and $strobe are general used within a conditional statement
// (i.e. if (error) $display) specified from an initial or always construct
// while the $monitor is generally specified from an initial statement without
// any other qualification.  Display functions are for simulation purposes only
// and while very useful, should be used sparingly in order to increase the
// overall speed of simulation.  It is very useful to use these constructs to
// indicate problems in the simulation however every time an output is written
// to the screen, a penalty of a longer simulation runtime is seen.
//
// Example of $display:

   initial begin
      #100000;
      $display("Simulation Ended Normally at Time: %t", $realtime");
      $stop;
   end

// Example of $monitor:

   initial
      $monitor("time %t: out1=%d(decimal), out2=%h(hex), out3=%b(binary),
                         state=%s(string)", $realtime, out1, out2, out3, state);

// Example of $write:

   always @(posedge check)
      $write(".");

// Example of $strobe:

   always @(out1)
      if (out1 != correct_out1)
         $strobe("Error at time %t: out1 is %h and should be %h",
	            $realtime, out1, correct_out1);

// Example of using a $monitor to display the state of a state-machine to the screen:

   reg[8*22:0] ascii_state;

   initial
     $monitor("Current State is: %s", ascii_state);

   always @(UUT.top.state_reg)
      case (UUT.top.state_reg)
         2'b00  : ascii_state = "Reset";
         2'b01  : ascii_state = "Send";
         2'b10  : ascii_state = "Poll";
         2'b11  : ascii_state = "Receive";
         default: ascii_state = "ERROR: Undefined State";
      endcase
				</Template>
				<Template label="Monitor Signals ($monitor)" treetype="template">
   $monitor("&lt;string_and/or_variables&gt;", &lt;functions or signals&gt;);
				</Template>
				<Template label="Strobe text w/ delayed output ($strobe)" treetype="template">
   $strobe ("&lt;string_and/or_variables&gt;", &lt;functions_or_signals&gt;);
				</Template>
				<Template label="Write text w/o CRs ($write)" treetype="template">
   $write ("&lt;string_and/or_variables&gt;", &lt;functions_or_signals&gt;);
				</Template>
			</SubFolder>
			<SubFolder label="Signed / Unsigned" treetype="folder">
				<Template label=" Convert to an Unsigned Value" treetype="template">
   $unsigned(&lt;signal&gt;);
				</Template>
				<Template label=" Convert to a Signed Value" treetype="template">
   $signed(&lt;signal&gt;);
				</Template>
			</SubFolder>
			<SubFolder label="Simulation Time" treetype="folder">
				<SubFolder label="format // ($timeformat)" treetype="folder">
					<Template label="Micro-second Specification" treetype="template">
   initial
      $timeformat (-6, 6, " us", 10);
					</Template>
					<Template label="Mili-second Specification" treetype="template">
   initial
      $timeformat (-3, 0, " ms", 8);
					</Template>
					<Template label="Nano-second Specification" treetype="template">
   initial
      $timeformat (-9, 3, " ns", 13);
					</Template>
					<Template label="Pico-second Specification" treetype="template">
   initial
      $timeformat (-12, 1, " ps", 13);
					</Template>
					<Template label="Second Specification" treetype="template">
   initial
      $timeformat (0, 0, " sec", 6);
					</Template>
				</SubFolder>
				<Template label="Info (Simulation Time)" treetype="template">
// information on the system tasks $time, $stime, $realtime, and $timeformat
// =========================================================================
//
// $time is a system function in which returns the current simulation time
// as a 64-bit integer.
//
// $stime is a system function in which returns the lower 32-bits of the
// current simulation time.
//
// $realtime is a system function that returns the current simulation time
// as a real number.
//
// Generally, these system time functions are using within screen
// ($monitor and $display) and file output ($fwrite and $fmonitor) commands
// to specify within the message the simulation time at which the message is
// displayed or written.
//
//
// $timeformat is a system call which specifies the format in which the $time,
// $stime and $realtime should be displayed when used with the %t format
// variable in a display or write call.  It is recommended to specify this
// within the testbench when using the %t variable to make the time value more
// readable.  The $timeformat must be specified within an initial declaration.
// The format of $timeformat is the following:

initial
   $timeformat (&lt;unit&gt;, &lt;precision&gt;, &lt;suffix_string&gt;, &lt;min_field_width&gt;);

//
// Example:
//
// This specifies the output to be displayed in nano-seconds, a precision
//    down to pico seconds, to append the string " ns" after the time and
//    to allow for 13 numbers to be displayed to show this value.
initial
   $timeformat (-9, 3, " ns", 13);

// This will display the system time in the format specified above after
//   the string "Time=" as well as display the value of DATA_OUT every
//   time DATA_OUT changes value.
initial
   $monitor("Time=%t : DATA_OUT=%b", $realtime, DATA_OUT);

				</Template>
			</SubFolder>
			<SubFolder label="Stop Simulation" treetype="folder">
				<Template label="Pause Simulation ($stop)" treetype="template">
   $stop;
				</Template>
				<Template label="Quit Simulation ($finish)" treetype="template">
   $finish;
				</Template>
			</SubFolder>
		</SubFolder>
	</Folder>
	<Folder label="Synthesis Constructs" treetype="folder">
		<SubFolder label="Always" treetype="folder">
			<SubFolder label="Negedge Clocked" treetype="folder">
				<Template label="w/ Sync High Reset" treetype="template">
   always @(negedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;signal&gt; &lt;= 0;
      end else begin
         &lt;signal&gt; &lt;= &lt;clocked_value&gt;;
      end
				</Template>
				<Template label="w/ Sync Low Reset" treetype="template">
   always @(negedge &lt;clock&gt;)
      if (!&lt;reset&gt;) begin
         &lt;signal&gt; &lt;= 0;
      end else begin
         &lt;signal&gt; &lt;= &lt;clocked_value&gt;;
      end
				</Template>
			</SubFolder>
			<SubFolder label="Posedge Clocked" treetype="folder">
				<Template label="Simple Flop" treetype="template">
   always @(posedge &lt;clock&gt;) begin
      &lt;signal&gt; &lt;= &lt;clocked_value&gt;;
   end
				</Template>
				<Template label="w/ Sync High Reset" treetype="template">
   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;signal&gt; &lt;= 0;
      end else begin
         &lt;signal&gt; &lt;= &lt;clocked_value&gt;;
      end
				</Template>
				<Template label="w/ Sync Low Reset" treetype="template">
   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;) begin
         &lt;signal&gt; &lt;= 0;
      end else begin
         &lt;signal&gt; &lt;= &lt;clocked_value&gt;;
      end
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Attributes" treetype="folder">
			<SubFolder label="Clock" treetype="folder">
				<SubFolder label="Buffer Type" treetype="folder">
					<Template label="BUFR (CLOCK_BUFFER_TYPE)" treetype="template">
   (* clock_buffer_type="BUFR" *)
					</Template>
					<Template label="NONE (CLOCK_BUFFER_TYPE)" treetype="template">
   (* clock_buffer_type="NONE" *)
					</Template>
				</SubFolder>
			</SubFolder>
			<Template label="Info (Synthesis Attributes)" treetype="template">
// information on Synthesis Attributes
// ===================================
//
// The following templates for synthesis attributes use the Verilog-2001 attribute
// syntax for passing these constraints to the synthesis and back-end Xilinx tools.
// Since these are synthesis attributes, they are ignored for the purpose of
// simulation and thus generally should be used for passing attributes that do not
// effect design or component functionality such as placement or hierarchy
// constraints.  These can also be used to guide synthesis implementation such as in
// the case of the state-machine extraction algorithms and parallel and full case
// specifications.  To properly specify these constraints, they must be placed
// in-line with the declaring function or signal. Multiple attributes can be
// specified by comma separating them in the parenthesis-star brackets.

// Example of placing a LOC attribute on an input port declaration:

   (* LOC="K1" *) input A;

// Example of placing an ASYNC_REG constraint on an inferred register:

   (* ASYNC_REG="true" *) reg empty_reg;

// Example of placing a KEEP_HIERARCHY constraint on an instantiated module:

    // Instantiation of the DECODER module
    (* keep_hierarchy="yes" *) DECODER DECODER_inst (
      .DATA_IN(DATA_IN),
      .CLK(CLK),
      .RST(RST),
      .DATA_OUT(DATA_OUT)
    );
    // End of DECODER_inst instantiation

// Example of PARALLEL_CASE / FULL_CASE:

   always @(A, B, C, current_state) begin (* parallel_case, full_case *)
      case (current_state)
         RESET: begin
                   ...
			</Template>
			<SubFolder label="I/O" treetype="folder">
				<SubFolder label="Buffer Type" treetype="folder">
					<Template label="IBUF (IO_BUFFER_TYPE)" treetype="template">
   (* io_buffer_type="ibuf" *)
					</Template>
					<Template label="NONE (IO_BUFFER_TYPE)" treetype="template">
   (* io_buffer_type="none" *)
					</Template>
				</SubFolder>
				<Template label="Don't Place Register into IOB (IOB)" treetype="template">
   (* IOB="false" *)
				</Template>
				<Template label="I/O Standard (IOSTANDARD)" treetype="template">
   (* IOSTANDARD="&lt;standard&gt;" *)
				</Template>
				<Template label="Place Register into IOB (IOB)" treetype="template">
   (* IOB="true" *)
				</Template>
			</SubFolder>
			<SubFolder label="Location / Packing" treetype="folder">
				<Template label="Absolute Location Constraint (LOC)" treetype="template">
   (* LOC="&lt;value&gt;" *)
				</Template>
				<Template label="Hierarchical LUT Packing Constraint (HLUTNM)" treetype="template">
   // Specifies LUT packing of two LUT5s into the same LUT6 for uniquified by hierarchy
   (* HLUTNM="&lt;value&gt;" *)
				</Template>
				<Template label="LUT Packing Constraint (LUTNM)" treetype="template">
   // Specifies LUT packing of two LUT5s into the same LUT6
   (* LUTNM="&lt;value&gt;" *)
				</Template>
				<Template label="Relative Location Constraint (RLOC)" treetype="template">
   (* RLOC="&lt;value&gt;" *)
				</Template>
			</SubFolder>
			<SubFolder label="Misc" treetype="folder">
				<Template label="Asynchronous Register Specification (ASYNC_REG)" treetype="template">
   (* ASYNC_REG="true" *)
				</Template>
				<Template label="Mark Signal for Debug (MARK_DEBUG)" treetype="template">
   (* MARK_DEBUG="true" *)
				</Template>
			</SubFolder>
			<SubFolder label="Synthesis" treetype="folder">
				<Template label="Black Box(BLACK_BOX)" treetype="template">
   (* black_box="true" *)
// Apply before module declaration which needs to be black boxed
				</Template>
				<SubFolder label="Buffer Type" treetype="folder">
					<Template label="IBUF (BUFFER_TYPE)" treetype="template">
   (* buffer_type="ibuf" *)
					</Template>
					<Template label="NONE (BUFFER_TYPE)" treetype="template">
   (* buffer_type="none" *)
					</Template>
				</SubFolder>
				<SubFolder label="Case Statement" treetype="folder">
					<Template label="Full Case, Parallel Case Statement" treetype="template">
   (* full_case, parallel_case *)
					</Template>
					<Template label="Full Case Statement" treetype="template">
   (* full_case *)
					</Template>
					<Template label="Parallel Case Statement" treetype="template">
   (* parallel_case *)
					</Template>
				</SubFolder>
				<Template label="Do Not Optimize (DONT_TOUCH)" treetype="template">
   (* dont_touch="true" *)
				</Template>
				<Template label="Keep Hierarchy (KEEP_HIERARCHY)" treetype="template">
   (* keep_hierarchy="yes" *)
				</Template>
				<Template label="Keep/Preserve a Signal (KEEP)" treetype="template">
   (* keep="true" *)
				</Template>
				<Template label="Maximum Fanout (MAX_FANOUT)" treetype="template">
   (* max_fanout=&lt;number&gt; *)
				</Template>
				<SubFolder label="RAM Inference Styles" treetype="folder">
					<Template label="BlockRAM Implementation (RAM_STYLE=block)" treetype="template">
   (* ram_style="block" *)
					</Template>
					<Template label="Distributed RAM Implementation (RAM_STYLE=distributed)" treetype="template">
   (* ram_style="distributed" *)
					</Template>
					<Template label="Register Implementation (RAM_STYLE=register)" treetype="template">
   (* ram_style="register" *)
					</Template>
				</SubFolder>
				<Template label="Use DSP48 (USE_DSP48)" treetype="template">
   (* use_dsp48="yes" *)
				</Template>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Coding Examples" treetype="folder">
			<SubFolder label="Accumulators" treetype="folder">
				<Template label="Async Reset &amp; CE" treetype="template">
// Usage of asynchronous resets may negatively impact FPGA resources
// and timing. In general faster and smaller FPGA designs will
// result from not using asynchronous resets.

   parameter ACC_SIZE=&lt;accumulator_width&gt;;
   reg [ACC_SIZE-1:0] &lt;accumulate_out&gt;;

   always @ (posedge &lt;clock&gt; or posedge &lt;reset&gt;)
      if (&lt;reset&gt;)
         &lt;accumulate_out&gt; &lt;= 0;
      else if (&lt;clock_enable&gt;)
         &lt;accumulate_out&gt; &lt;= &lt;accumulate_out&gt; + &lt;accumulate_in&gt;;
				</Template>
				<Template label="Sync Reset &amp; CE" treetype="template">
   parameter ACC_SIZE=&lt;accumulator_width&gt;;
   reg [ACC_SIZE-1:0] &lt;accumulate_out&gt;;

   always @ (posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;accumulate_out&gt; &lt;= 0;
      else if (&lt;clock_enable&gt;)
         &lt;accumulate_out&gt; &lt;= &lt;accumulate_out&gt; + &lt;accumulate_in&gt;;
				</Template>
				<Template label="Sync Reset, CE, &amp; Sync Load" treetype="template">
   parameter ACC_SIZE=&lt;accumulator_width&gt;;
   reg [ACC_SIZE-1:0] &lt;accumulate_out&gt;;

   always @ (posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;accumulate_out&gt; &lt;= 0;
      else if (&lt;clock_enable&gt;)
         if (&lt;load&gt;)
            &lt;accumulate_out&gt; &lt;= &lt;load_value&gt;;
         else
            &lt;accumulate_out&gt; &lt;= &lt;accumulate_out&gt; + &lt;accumulate_in&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="Arithmetic" treetype="folder">
				<SubFolder label="Adder" treetype="folder">
					<SubFolder label="Combinatorial" treetype="folder">
						<Template label="Simple Signed Adder" treetype="template">
   parameter ADDER_WIDTH = &lt;adder_bit_width&gt;;

   wire signed [ADDER_WIDTH-1:0] &lt;a_input&gt;;
   wire signed [ADDER_WIDTH-1:0] &lt;b_input&gt;;
   wire signed [ADDER_WIDTH-1:0] &lt;sum&gt;;

   assign &lt;sum&gt; = &lt;a_input&gt; + &lt;b_input&gt;;
						</Template>
						<Template label="Simple Unsigned Adder" treetype="template">
   parameter ADDER_WIDTH = &lt;adder_bit_width&gt;;

   wire [ADDER_WIDTH-1:0] &lt;a_input&gt;;
   wire [ADDER_WIDTH-1:0] &lt;b_input&gt;;
   wire [ADDER_WIDTH-1:0] &lt;sum&gt;;

   assign &lt;sum&gt; = &lt;a_input&gt; + &lt;b_input&gt;;
						</Template>
						<Template label="Unsigned Adder w/ Carry-out" treetype="template">
   parameter ADDER_WIDTH = &lt;adder_bit_width&gt;;

   wire [ADDER_WIDTH-1:0] &lt;a_input&gt;;
   wire [ADDER_WIDTH-1:0] &lt;b_input&gt;;
   wire                   &lt;carry_out&gt;;
   wire [ADDER_WIDTH-1:0] &lt;sum&gt;;

   assign {&lt;carry_out&gt;, &lt;sum&gt;} = &lt;a_input&gt; + &lt;b_input&gt;;
						</Template>
					</SubFolder>
					<SubFolder label="Sequential" treetype="folder">
						<Template label="Simple Signed Adder" treetype="template">
   parameter ADDER_WIDTH = &lt;adder_bit_width&gt;;

   reg signed [ADDER_WIDTH-1:0] &lt;sum&gt; = {ADDER_WIDTH{1'b0}};

   always @(posedge &lt;CLK&gt;)
      &lt;sum&gt; &lt;= &lt;a_input&gt; + &lt;b_input&gt;;
						</Template>
						<Template label="Simple Unsigned Adder" treetype="template">
   parameter ADDER_WIDTH = &lt;adder_bit_width&gt;;

   reg [ADDER_WIDTH-1:0] &lt;sum&gt; = {ADDER_WIDTH{1'b0}};

   always @(posedge &lt;CLK&gt;)
      &lt;sum&gt; &lt;= &lt;a_input&gt; + &lt;b_input&gt;;
						</Template>
						<Template label="Unsigned Adder w/ Carry-out" treetype="template">
   parameter ADDER_WIDTH = &lt;adder_bit_width&gt;;

   reg [ADDER_WIDTH-1:0] &lt;sum&gt; = {ADDER_WIDTH{1'b0}};
   reg                   &lt;carry_out&gt; = 1'b0;

   always @(posedge &lt;CLK&gt;)
      {&lt;carry_out&gt;, &lt;sum&gt;} &lt;= &lt;a_input&gt; + &lt;b_input&gt;;
						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Divider" treetype="folder">
					<Template label="Divide by 2" treetype="template">
   parameter DIV_WIDTH = &lt;div_bit_width&gt;;

   wire [DIV_WIDTH-1:0] &lt;div_input&gt;;
   wire [DIV_WIDTH-1:0] &lt;dividend&gt;;

   assign &lt;dividend&gt; = &lt;div_input&gt; / 2;
					</Template>
					<Template label="Divide by 4" treetype="template">
   parameter DIV_WIDTH = &lt;div_bit_width&gt;;

   wire [DIV_WIDTH-1:0] &lt;div_input&gt;;
   wire [DIV_WIDTH-1:0] &lt;dividend&gt;;

   assign &lt;dividend&gt; = &lt;div_input&gt; / 4;
					</Template>
					<Template label="Divide by 8" treetype="template">
   parameter DIV_WIDTH = &lt;div_bit_width&gt;;

   wire [DIV_WIDTH-1:0] &lt;div_input&gt;;
   wire [DIV_WIDTH-1:0] &lt;dividend&gt;;

   assign &lt;dividend&gt; = &lt;div_input&gt; / 8;
					</Template>
					<Template label="Divide by 16" treetype="template">
   parameter DIV_WIDTH = &lt;div_bit_width&gt;;

   wire [DIV_WIDTH-1:0] &lt;div_input&gt;;
   wire [DIV_WIDTH-1:0] &lt;dividend&gt;;

   assign &lt;dividend&gt; = &lt;div_input&gt; / 16;
					</Template>
				</SubFolder>
				<SubFolder label="Multiplier" treetype="folder">
					<Template label="18x18 Synchronous Multiplier" treetype="template">
   wire [17:0] &lt;a_input&gt;;
   wire [17:0] &lt;b_input&gt;;
   reg  [35:0] &lt;product&gt; = {36{1'b0}};

   always @(posedge &lt;clock&gt;)
      &lt;product&gt; &lt;= &lt;a_input&gt; * &lt;b_input&gt;;
					</Template>
					<Template label="Combinatorial Multiplier" treetype="template">
   // Note: Performance of un-registered multiplier may be lacking.
   // Suggested to use pipeline registers when possible for best performance characteristics.

   parameter MULT_INPUT_WIDTH = &lt;mult_input_bit_width&gt;;

   wire [MULT_INPUT_WIDTH-1:0] &lt;a_input&gt;;
   wire [MULT_INPUT_WIDTH-1:0] &lt;b_input&gt;;
   wire [MULT_INPUT_WIDTH*2-1:0] &lt;product&gt;;

   assign &lt;product&gt; = &lt;a_input&gt; * &lt;b_input&gt;;
					</Template>
				</SubFolder>
				<SubFolder label="Subtractor" treetype="folder">
					<Template label="Simple Subtractor" treetype="template">
   parameter SUB_WIDTH = &lt;sub_bit_width&gt;;

   wire [SUB_WIDTH-1:0] &lt;a_input&gt;;
   wire [SUB_WIDTH-1:0] &lt;b_input&gt;;
   wire [SUB_WIDTH-1:0] &lt;difference&gt;;

   assign &lt;difference&gt; = &lt;a_input&gt; - &lt;b_input&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Basic Gates" treetype="folder">
				<SubFolder label="AND" treetype="folder">
					<Template label="2-Input AND Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; &amp; &lt;signal2&gt;;
					</Template>
					<Template label="3-Input AND Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; &amp; &lt;signal2&gt; &amp; &lt;signal3&gt;;
					</Template>
					<Template label="4-Input AND Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; &amp; &lt;signal2&gt; &amp; &lt;signal3&gt; &amp; &lt;signal4&gt;;
					</Template>
				</SubFolder>
				<Template label="Inverter" treetype="template">
   &lt;1-bit_wire&gt; = ~&lt;signal&gt;;
				</Template>
				<SubFolder label="NAND" treetype="folder">
					<Template label="2-Input NAND Gate" treetype="template">
   &lt;1-bit_wire&gt; = ~(&lt;signal1&gt; &amp; &lt;signal2&gt;);
					</Template>
					<Template label="3-Input NAND Gate" treetype="template">
   &lt;1-bit_wire&gt; = ~(&lt;signal1&gt; &amp; &lt;signal2&gt; &amp; &lt;signal3&gt;);
					</Template>
					<Template label="4-Input NAND Gate" treetype="template">
   &lt;1-bit_wire&gt; = ~(&lt;signal1&gt; &amp; &lt;signal2&gt; &amp; &lt;signal3&gt; &amp; &lt;signal4&gt;);
					</Template>
				</SubFolder>
				<SubFolder label="NOR" treetype="folder">
					<Template label="2-Input NOR Gate" treetype="template">
   &lt;1-bit_wire&gt; = ~(&lt;signal1&gt; | &lt;signal2&gt;);
					</Template>
					<Template label="3-Input NOR Gate" treetype="template">
   &lt;1-bit_wire&gt; = ~(&lt;signal1&gt; | &lt;signal2&gt; | &lt;signal3&gt;);
					</Template>
					<Template label="4-Input NOR Gate" treetype="template">
   &lt;1-bit_wire&gt; = ~(&lt;signal1&gt; | &lt;signal2&gt; | &lt;signal3&gt; | &lt;signal4&gt;);
					</Template>
				</SubFolder>
				<SubFolder label="OR" treetype="folder">
					<Template label="2-Input OR Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; | &lt;signal2&gt;;
					</Template>
					<Template label="3-Input OR Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; | &lt;signal2&gt; | &lt;signal3&gt;;
					</Template>
					<Template label="4-Input OR Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; | &lt;signal2&gt; | &lt;signal3&gt; | &lt;signal4&gt;;
					</Template>
				</SubFolder>
				<SubFolder label="XNOR" treetype="folder">
					<Template label="2-Input XNOR Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; ~^ &lt;signal2&gt;;
					</Template>
					<Template label="3-Input XNOR Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; ~^ &lt;signal2&gt; ~^ &lt;signal3&gt;;
					</Template>
					<Template label="4-Input XNOR Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; ~^ &lt;signal2&gt; ~^ &lt;signal3&gt; ~^ &lt;signal4&gt;;
					</Template>
				</SubFolder>
				<SubFolder label="XOR" treetype="folder">
					<Template label="2-Input XOR Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; ^ &lt;signal2&gt;;
					</Template>
					<Template label="3-Input XOR Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; ^ &lt;signal2&gt; ^ &lt;signal3&gt;;
					</Template>
					<Template label="4-Input XOR Gate" treetype="template">
   &lt;1-bit_wire&gt; = &lt;signal1&gt; ^ &lt;signal2&gt; ^ &lt;signal3&gt; ^ &lt;signal4&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Bi-directional I/O" treetype="folder">
				<Template label="Info" treetype="template">

//  The following represents the connectivity of the registered
//    bi-directional I/O example
//
//                                       ______
//                                      |     |
//                           |----------|D    |
//                           |          |    Q|-----in_reg
//                           |  clock___|\    |
//    ________________       |          |/    |
//   / top_level_port \______|          |_____|
//   \________________/      |
//                           |
//                           |     /|
//                           |____/ |________________________
//                                \ |              _____     |
//                      _____     |\|             |     |    |
//                     |     |    |       out_sig-|D   Q|----|
//          out_en-----|D   Q|____|               |     |
//                     |     |            clock___|\    |
//               clock_|\    |                    |/    |
//                     |/    |                    |_____|
//                     |_____|
//
//
//
//  The following represents the connectivity of the unregistered
//    bi-directional I/O example
//
//                           |----------input_signal
//                           |
//                           |
//    ________________       |
//   / top_level_port \______|
//   \________________/      |
//                           |
//                           |     /|
//                           |____/ |______output_signal
//                                \ |
//                                |\|
//                                |
//                                |---output_enable_signal
//
				</Template>
				<SubFolder label="Registered Input only" treetype="folder">
					<Template label="1-bit" treetype="template">
   inout &lt;top_level_port&gt;;

   wire &lt;output_enable_signal&gt;, &lt;output_signal&gt;;
   reg  &lt;input_reg&gt; = 1'b0;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;input_reg&gt;  &lt;= 1'b0;
      else
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
					</Template>
					<Template label="2-bit" treetype="template">
   inout [1:0] &lt;top_level_port&gt;;

   wire [1:0] &lt;output_signal&gt;;
   wire       &lt;output_enable_signal&gt;;
   reg  [1:0] &lt;input_reg&gt; = 2'b00;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 2'bzz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;input_reg&gt;  &lt;= 2'b00;
      else
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
					</Template>
					<Template label="4-bit" treetype="template">
   inout [3:0] &lt;top_level_port&gt;;

   wire [3:0] &lt;output_signal&gt;;
   wire       &lt;output_enable_signal&gt;;
   reg  [3:0] &lt;input_reg&gt; = 4'h0;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 4'hz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;input_reg&gt;  &lt;= 4'h0;
      else
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
					</Template>
					<Template label="8-bit" treetype="template">
   inout [7:0] &lt;top_level_port&gt;;

   wire [7:0] &lt;output_signal&gt;;
   wire       &lt;output_enable_signal&gt;;
   reg  [7:0] &lt;input_reg&gt; = 8'h00;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 8'hzz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;input_reg&gt;  &lt;= 8'h00;
      else
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
					</Template>
					<Template label="16-bit" treetype="template">
   inout [15:0] &lt;top_level_port&gt;;

   wire [15:0] &lt;output_signal&gt;;
   wire        &lt;output_enable_signal&gt;;
   reg  [15:0] &lt;input_reg&gt; = 16'h0000;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 16'hzzzz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;input_reg&gt;  &lt;= 16'h0000;
      else
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
					</Template>
					<Template label="32-bit" treetype="template">
   inout [31:0] &lt;top_level_port&gt;;

   wire [31:0] &lt;output_signal&gt;;
   wire        &lt;output_enable_signal&gt;;
   reg  [31:0] &lt;input_reg&gt; = 32'h00000000;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 32'hzzzzzzzz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;input_reg&gt;  &lt;= 32'h00000000;
      else
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
					</Template>
				</SubFolder>
				<SubFolder label="Registered Input, Output and OE" treetype="folder">
					<Template label="1-bit Registered" treetype="template">
   inout &lt;top_level_port&gt;;

   reg &lt;input_reg&gt; = 1'b0, &lt;output_reg&gt; = 1'b0, &lt;output_enable_reg&gt; = 1'b0;

   assign &lt;top_level_port&gt; = &lt;output_enable_reg&gt; ? &lt;output_reg&gt; : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;input_reg&gt;  &lt;= 1'b0;
         &lt;output_reg&gt; &lt;= 1'b0;
         &lt;output_enable_reg&gt; &lt;= 1'b0;
      end else begin
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
         &lt;output_reg&gt; &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= &lt;output_enable_signal&gt;;
      end
					</Template>
					<Template label="2-bit" treetype="template">
   inout [1:0] &lt;top_level_port&gt;;

   reg [1:0] &lt;input_reg&gt; = 2'b00, &lt;output_reg&gt; = 2'b00, &lt;output_enable_reg&gt; = 2'b00;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;input_reg&gt;  &lt;= 2'b00;
         &lt;output_reg&gt; &lt;= 2'b00;
         &lt;output_enable_reg&gt; &lt;= 2'b00;
      end else begin
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
         &lt;output_reg&gt; &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {2{&lt;output_enable_signal&gt;}};
      end
					</Template>
					<Template label="4-bit" treetype="template">
   inout [3:0] &lt;top_level_port&gt;;

   reg [3:0] &lt;input_reg&gt; = 4'h0, &lt;output_reg&gt; = 4'h0, &lt;output_enable_reg&gt; = 4'h0;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;
   assign &lt;top_level_port&gt;[2] = &lt;output_enable_reg&gt;[2] ? &lt;output_reg&gt;[2] : 1'bz;
   assign &lt;top_level_port&gt;[3] = &lt;output_enable_reg&gt;[3] ? &lt;output_reg&gt;[3] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;input_reg&gt;  &lt;= 4'h0;
         &lt;output_reg&gt; &lt;= 4'h0;
         &lt;output_enable_reg&gt; &lt;= 4'h0;
      end else begin
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
         &lt;output_reg&gt; &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {4{&lt;output_enable_signal&gt;}};
      end
					</Template>
					<Template label="8-bit" treetype="template">
   inout [7:0] &lt;top_level_port&gt;;

   reg [7:0] &lt;input_reg&gt; = 8'h00, &lt;output_reg&gt; = 8'h00, &lt;output_enable_reg&gt; = 8'h00;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;
   assign &lt;top_level_port&gt;[2] = &lt;output_enable_reg&gt;[2] ? &lt;output_reg&gt;[2] : 1'bz;
   assign &lt;top_level_port&gt;[3] = &lt;output_enable_reg&gt;[3] ? &lt;output_reg&gt;[3] : 1'bz;
   assign &lt;top_level_port&gt;[4] = &lt;output_enable_reg&gt;[4] ? &lt;output_reg&gt;[4] : 1'bz;
   assign &lt;top_level_port&gt;[5] = &lt;output_enable_reg&gt;[5] ? &lt;output_reg&gt;[5] : 1'bz;
   assign &lt;top_level_port&gt;[6] = &lt;output_enable_reg&gt;[6] ? &lt;output_reg&gt;[6] : 1'bz;
   assign &lt;top_level_port&gt;[7] = &lt;output_enable_reg&gt;[7] ? &lt;output_reg&gt;[7] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;input_reg&gt;  &lt;= 8'h00;
         &lt;output_reg&gt; &lt;= 8'h00;
         &lt;output_enable_reg&gt; &lt;= 8'h00;
      end else begin
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
         &lt;output_reg&gt; &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {8{&lt;output_enable_signal&gt;}};
      end
					</Template>
					<Template label="16-bit" treetype="template">
   inout [15:0] &lt;top_level_port&gt;;

   reg [15:0] &lt;input_reg&gt; = 16'h0000, &lt;output_reg&gt; = 16'h0000, &lt;output_enable_reg&gt; = 16'h0000;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;
   assign &lt;top_level_port&gt;[2] = &lt;output_enable_reg&gt;[2] ? &lt;output_reg&gt;[2] : 1'bz;
   assign &lt;top_level_port&gt;[3] = &lt;output_enable_reg&gt;[3] ? &lt;output_reg&gt;[3] : 1'bz;
   assign &lt;top_level_port&gt;[4] = &lt;output_enable_reg&gt;[4] ? &lt;output_reg&gt;[4] : 1'bz;
   assign &lt;top_level_port&gt;[5] = &lt;output_enable_reg&gt;[5] ? &lt;output_reg&gt;[5] : 1'bz;
   assign &lt;top_level_port&gt;[6] = &lt;output_enable_reg&gt;[6] ? &lt;output_reg&gt;[6] : 1'bz;
   assign &lt;top_level_port&gt;[7] = &lt;output_enable_reg&gt;[7] ? &lt;output_reg&gt;[7] : 1'bz;
   assign &lt;top_level_port&gt;[8] = &lt;output_enable_reg&gt;[8] ? &lt;output_reg&gt;[8] : 1'bz;
   assign &lt;top_level_port&gt;[9] = &lt;output_enable_reg&gt;[9] ? &lt;output_reg&gt;[9] : 1'bz;
   assign &lt;top_level_port&gt;[10] = &lt;output_enable_reg&gt;[10] ? &lt;output_reg&gt;[10] : 1'bz;
   assign &lt;top_level_port&gt;[11] = &lt;output_enable_reg&gt;[11] ? &lt;output_reg&gt;[11] : 1'bz;
   assign &lt;top_level_port&gt;[12] = &lt;output_enable_reg&gt;[12] ? &lt;output_reg&gt;[12] : 1'bz;
   assign &lt;top_level_port&gt;[13] = &lt;output_enable_reg&gt;[13] ? &lt;output_reg&gt;[13] : 1'bz;
   assign &lt;top_level_port&gt;[14] = &lt;output_enable_reg&gt;[14] ? &lt;output_reg&gt;[14] : 1'bz;
   assign &lt;top_level_port&gt;[15] = &lt;output_enable_reg&gt;[15] ? &lt;output_reg&gt;[15] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;input_reg&gt;  &lt;= 16'h0000;
         &lt;output_reg&gt; &lt;= 16'h0000;
         &lt;output_enable_reg&gt; &lt;= 16'h0000;
      end else begin
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
         &lt;output_reg&gt; &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {16{&lt;output_enable_signal&gt;}};
      end
					</Template>
					<Template label="32-bit" treetype="template">
   inout [31:0] &lt;top_level_port&gt;;

   reg [31:0] &lt;input_reg&gt; = 32'h00000000, &lt;output_reg&gt; = 32'h00000000, &lt;output_enable_reg&gt; = 32'h00000000;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;
   assign &lt;top_level_port&gt;[2] = &lt;output_enable_reg&gt;[2] ? &lt;output_reg&gt;[2] : 1'bz;
   assign &lt;top_level_port&gt;[3] = &lt;output_enable_reg&gt;[3] ? &lt;output_reg&gt;[3] : 1'bz;
   assign &lt;top_level_port&gt;[4] = &lt;output_enable_reg&gt;[4] ? &lt;output_reg&gt;[4] : 1'bz;
   assign &lt;top_level_port&gt;[5] = &lt;output_enable_reg&gt;[5] ? &lt;output_reg&gt;[5] : 1'bz;
   assign &lt;top_level_port&gt;[6] = &lt;output_enable_reg&gt;[6] ? &lt;output_reg&gt;[6] : 1'bz;
   assign &lt;top_level_port&gt;[7] = &lt;output_enable_reg&gt;[7] ? &lt;output_reg&gt;[7] : 1'bz;
   assign &lt;top_level_port&gt;[8] = &lt;output_enable_reg&gt;[8] ? &lt;output_reg&gt;[8] : 1'bz;
   assign &lt;top_level_port&gt;[9] = &lt;output_enable_reg&gt;[9] ? &lt;output_reg&gt;[9] : 1'bz;
   assign &lt;top_level_port&gt;[10] = &lt;output_enable_reg&gt;[10] ? &lt;output_reg&gt;[10] : 1'bz;
   assign &lt;top_level_port&gt;[11] = &lt;output_enable_reg&gt;[11] ? &lt;output_reg&gt;[11] : 1'bz;
   assign &lt;top_level_port&gt;[12] = &lt;output_enable_reg&gt;[12] ? &lt;output_reg&gt;[12] : 1'bz;
   assign &lt;top_level_port&gt;[13] = &lt;output_enable_reg&gt;[13] ? &lt;output_reg&gt;[13] : 1'bz;
   assign &lt;top_level_port&gt;[14] = &lt;output_enable_reg&gt;[14] ? &lt;output_reg&gt;[14] : 1'bz;
   assign &lt;top_level_port&gt;[15] = &lt;output_enable_reg&gt;[15] ? &lt;output_reg&gt;[15] : 1'bz;
   assign &lt;top_level_port&gt;[16] = &lt;output_enable_reg&gt;[16] ? &lt;output_reg&gt;[16] : 1'bz;
   assign &lt;top_level_port&gt;[17] = &lt;output_enable_reg&gt;[17] ? &lt;output_reg&gt;[17] : 1'bz;
   assign &lt;top_level_port&gt;[18] = &lt;output_enable_reg&gt;[18] ? &lt;output_reg&gt;[18] : 1'bz;
   assign &lt;top_level_port&gt;[19] = &lt;output_enable_reg&gt;[19] ? &lt;output_reg&gt;[19] : 1'bz;
   assign &lt;top_level_port&gt;[20] = &lt;output_enable_reg&gt;[20] ? &lt;output_reg&gt;[20] : 1'bz;
   assign &lt;top_level_port&gt;[21] = &lt;output_enable_reg&gt;[21] ? &lt;output_reg&gt;[21] : 1'bz;
   assign &lt;top_level_port&gt;[22] = &lt;output_enable_reg&gt;[22] ? &lt;output_reg&gt;[22] : 1'bz;
   assign &lt;top_level_port&gt;[23] = &lt;output_enable_reg&gt;[23] ? &lt;output_reg&gt;[23] : 1'bz;
   assign &lt;top_level_port&gt;[24] = &lt;output_enable_reg&gt;[24] ? &lt;output_reg&gt;[24] : 1'bz;
   assign &lt;top_level_port&gt;[25] = &lt;output_enable_reg&gt;[25] ? &lt;output_reg&gt;[25] : 1'bz;
   assign &lt;top_level_port&gt;[26] = &lt;output_enable_reg&gt;[26] ? &lt;output_reg&gt;[26] : 1'bz;
   assign &lt;top_level_port&gt;[27] = &lt;output_enable_reg&gt;[27] ? &lt;output_reg&gt;[27] : 1'bz;
   assign &lt;top_level_port&gt;[28] = &lt;output_enable_reg&gt;[28] ? &lt;output_reg&gt;[28] : 1'bz;
   assign &lt;top_level_port&gt;[29] = &lt;output_enable_reg&gt;[29] ? &lt;output_reg&gt;[29] : 1'bz;
   assign &lt;top_level_port&gt;[30] = &lt;output_enable_reg&gt;[30] ? &lt;output_reg&gt;[30] : 1'bz;
   assign &lt;top_level_port&gt;[31] = &lt;output_enable_reg&gt;[31] ? &lt;output_reg&gt;[31] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;input_reg&gt;  &lt;= 32'h00000000;
         &lt;output_reg&gt; &lt;= 32'h00000000;
         &lt;output_enable_reg&gt; &lt;= 32'h00000000;
      end else begin
         &lt;input_reg&gt;  &lt;= &lt;top_level_port&gt;;
         &lt;output_reg&gt; &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {32{&lt;output_enable_signal&gt;}};
      end
					</Template>
				</SubFolder>
				<SubFolder label="Registered Output and Output Enable only" treetype="folder">
					<Template label="1-bit" treetype="template">
   inout &lt;top_level_port&gt;;

   reg  &lt;output_reg&gt; = 1'b0, &lt;output_enable_reg&gt; = 1'b0;
   wire &lt;input_signal&gt;, &lt;output_enable_wire&gt;, &lt;output_signal&gt;;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;

   assign &lt;top_level_port&gt; = &lt;output_enable_reg&gt; ? &lt;output_reg&gt; : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;output_reg&gt;  &lt;= 1'b0;
         &lt;output_enable_reg&gt; &lt;= 1'b0;
      end
      else begin
         &lt;output_reg&gt;  &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= &lt;output_enable_signal&gt;;
      end
					</Template>
					<Template label="2-bit" treetype="template">
   inout [1:0] &lt;top_level_port&gt;;

   reg  [1:0] &lt;output_reg&gt; = 2'b00, &lt;output_enable_reg&gt; = 2'b00;
   wire [1:0] &lt;input_signal&gt;, &lt;output_signal&gt;;
   wire       &lt;output_enable_wire&gt;;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;output_reg&gt;  &lt;= 2'b00;
         &lt;output_enable_reg&gt; &lt;= 2'b00;
      end
      else begin
         &lt;output_reg&gt;  &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {2{&lt;output_enable_signal&gt;}};
      end
					</Template>
					<Template label="4-bit" treetype="template">
   inout [3:0] &lt;top_level_port&gt;;

   reg  [3:0] &lt;output_reg&gt; = 4'h0, &lt;output_enable_reg&gt; = 4'h0;
   wire [3:0] &lt;input_signal&gt;, &lt;output_signal&gt;;
   wire       &lt;output_enable_wire&gt;;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;
   assign &lt;top_level_port&gt;[2] = &lt;output_enable_reg&gt;[2] ? &lt;output_reg&gt;[2] : 1'bz;
   assign &lt;top_level_port&gt;[3] = &lt;output_enable_reg&gt;[3] ? &lt;output_reg&gt;[3] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;output_reg&gt;  &lt;= 4'h0;
         &lt;output_enable_reg&gt; &lt;= 4'h0;
      end
      else begin
         &lt;output_reg&gt;  &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {4{&lt;output_enable_signal&gt;}};
      end
					</Template>
					<Template label="8-bit" treetype="template">
   inout [7:0] &lt;top_level_port&gt;;

   reg  [7:0] &lt;output_reg&gt; = 8'h00, &lt;output_enable_reg&gt; = 8'h00;
   wire [7:0] &lt;input_signal&gt;, &lt;output_signal&gt;;
   wire       &lt;output_enable_wire&gt;;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;
   assign &lt;top_level_port&gt;[2] = &lt;output_enable_reg&gt;[2] ? &lt;output_reg&gt;[2] : 1'bz;
   assign &lt;top_level_port&gt;[3] = &lt;output_enable_reg&gt;[3] ? &lt;output_reg&gt;[3] : 1'bz;
   assign &lt;top_level_port&gt;[4] = &lt;output_enable_reg&gt;[4] ? &lt;output_reg&gt;[4] : 1'bz;
   assign &lt;top_level_port&gt;[5] = &lt;output_enable_reg&gt;[5] ? &lt;output_reg&gt;[5] : 1'bz;
   assign &lt;top_level_port&gt;[6] = &lt;output_enable_reg&gt;[6] ? &lt;output_reg&gt;[6] : 1'bz;
   assign &lt;top_level_port&gt;[7] = &lt;output_enable_reg&gt;[7] ? &lt;output_reg&gt;[7] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;output_reg&gt;  &lt;= 8'h00;
         &lt;output_enable_reg&gt; &lt;= 8'h00;
      end
      else begin
         &lt;output_reg&gt;  &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {8{&lt;output_enable_signal&gt;}};
      end
					</Template>
					<Template label="16-bit" treetype="template">
   inout [15:0] &lt;top_level_port&gt;;

   reg  [15:0] &lt;output_reg&gt; = 16'h0000, &lt;output_enable_reg&gt; = 16'h0000;
   wire [15:0] &lt;input_signal&gt;, &lt;output_signal&gt;;
   wire       &lt;output_enable_wire&gt;;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;
   assign &lt;top_level_port&gt;[2] = &lt;output_enable_reg&gt;[2] ? &lt;output_reg&gt;[2] : 1'bz;
   assign &lt;top_level_port&gt;[3] = &lt;output_enable_reg&gt;[3] ? &lt;output_reg&gt;[3] : 1'bz;
   assign &lt;top_level_port&gt;[4] = &lt;output_enable_reg&gt;[4] ? &lt;output_reg&gt;[4] : 1'bz;
   assign &lt;top_level_port&gt;[5] = &lt;output_enable_reg&gt;[5] ? &lt;output_reg&gt;[5] : 1'bz;
   assign &lt;top_level_port&gt;[6] = &lt;output_enable_reg&gt;[6] ? &lt;output_reg&gt;[6] : 1'bz;
   assign &lt;top_level_port&gt;[7] = &lt;output_enable_reg&gt;[7] ? &lt;output_reg&gt;[7] : 1'bz;
   assign &lt;top_level_port&gt;[8] = &lt;output_enable_reg&gt;[8] ? &lt;output_reg&gt;[8] : 1'bz;
   assign &lt;top_level_port&gt;[9] = &lt;output_enable_reg&gt;[9] ? &lt;output_reg&gt;[9] : 1'bz;
   assign &lt;top_level_port&gt;[10] = &lt;output_enable_reg&gt;[10] ? &lt;output_reg&gt;[10] : 1'bz;
   assign &lt;top_level_port&gt;[11] = &lt;output_enable_reg&gt;[11] ? &lt;output_reg&gt;[11] : 1'bz;
   assign &lt;top_level_port&gt;[12] = &lt;output_enable_reg&gt;[12] ? &lt;output_reg&gt;[12] : 1'bz;
   assign &lt;top_level_port&gt;[13] = &lt;output_enable_reg&gt;[13] ? &lt;output_reg&gt;[13] : 1'bz;
   assign &lt;top_level_port&gt;[14] = &lt;output_enable_reg&gt;[14] ? &lt;output_reg&gt;[14] : 1'bz;
   assign &lt;top_level_port&gt;[15] = &lt;output_enable_reg&gt;[15] ? &lt;output_reg&gt;[15] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;output_reg&gt;  &lt;= 16'h0000;
         &lt;output_enable_reg&gt; &lt;= 16'h0000;
      end
      else begin
         &lt;output_reg&gt;  &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {16{&lt;output_enable_signal&gt;}};
      end
					</Template>
					<Template label="32-bit" treetype="template">
   inout [31:0] &lt;top_level_port&gt;;

   reg  [31:0] &lt;output_reg&gt; = 32'h00000000, &lt;output_enable_reg&gt; = 32'h00000000;
   wire [31:0] &lt;input_signal&gt;, &lt;output_signal&gt;;
   wire       &lt;output_enable_wire&gt;;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;

   assign &lt;top_level_port&gt;[0] = &lt;output_enable_reg&gt;[0] ? &lt;output_reg&gt;[0] : 1'bz;
   assign &lt;top_level_port&gt;[1] = &lt;output_enable_reg&gt;[1] ? &lt;output_reg&gt;[1] : 1'bz;
   assign &lt;top_level_port&gt;[2] = &lt;output_enable_reg&gt;[2] ? &lt;output_reg&gt;[2] : 1'bz;
   assign &lt;top_level_port&gt;[3] = &lt;output_enable_reg&gt;[3] ? &lt;output_reg&gt;[3] : 1'bz;
   assign &lt;top_level_port&gt;[4] = &lt;output_enable_reg&gt;[4] ? &lt;output_reg&gt;[4] : 1'bz;
   assign &lt;top_level_port&gt;[5] = &lt;output_enable_reg&gt;[5] ? &lt;output_reg&gt;[5] : 1'bz;
   assign &lt;top_level_port&gt;[6] = &lt;output_enable_reg&gt;[6] ? &lt;output_reg&gt;[6] : 1'bz;
   assign &lt;top_level_port&gt;[7] = &lt;output_enable_reg&gt;[7] ? &lt;output_reg&gt;[7] : 1'bz;
   assign &lt;top_level_port&gt;[8] = &lt;output_enable_reg&gt;[8] ? &lt;output_reg&gt;[8] : 1'bz;
   assign &lt;top_level_port&gt;[9] = &lt;output_enable_reg&gt;[9] ? &lt;output_reg&gt;[9] : 1'bz;
   assign &lt;top_level_port&gt;[10] = &lt;output_enable_reg&gt;[10] ? &lt;output_reg&gt;[10] : 1'bz;
   assign &lt;top_level_port&gt;[11] = &lt;output_enable_reg&gt;[11] ? &lt;output_reg&gt;[11] : 1'bz;
   assign &lt;top_level_port&gt;[12] = &lt;output_enable_reg&gt;[12] ? &lt;output_reg&gt;[12] : 1'bz;
   assign &lt;top_level_port&gt;[13] = &lt;output_enable_reg&gt;[13] ? &lt;output_reg&gt;[13] : 1'bz;
   assign &lt;top_level_port&gt;[14] = &lt;output_enable_reg&gt;[14] ? &lt;output_reg&gt;[14] : 1'bz;
   assign &lt;top_level_port&gt;[15] = &lt;output_enable_reg&gt;[15] ? &lt;output_reg&gt;[15] : 1'bz;
   assign &lt;top_level_port&gt;[16] = &lt;output_enable_reg&gt;[16] ? &lt;output_reg&gt;[16] : 1'bz;
   assign &lt;top_level_port&gt;[17] = &lt;output_enable_reg&gt;[17] ? &lt;output_reg&gt;[17] : 1'bz;
   assign &lt;top_level_port&gt;[18] = &lt;output_enable_reg&gt;[18] ? &lt;output_reg&gt;[18] : 1'bz;
   assign &lt;top_level_port&gt;[19] = &lt;output_enable_reg&gt;[19] ? &lt;output_reg&gt;[19] : 1'bz;
   assign &lt;top_level_port&gt;[20] = &lt;output_enable_reg&gt;[20] ? &lt;output_reg&gt;[20] : 1'bz;
   assign &lt;top_level_port&gt;[21] = &lt;output_enable_reg&gt;[21] ? &lt;output_reg&gt;[21] : 1'bz;
   assign &lt;top_level_port&gt;[22] = &lt;output_enable_reg&gt;[22] ? &lt;output_reg&gt;[22] : 1'bz;
   assign &lt;top_level_port&gt;[23] = &lt;output_enable_reg&gt;[23] ? &lt;output_reg&gt;[23] : 1'bz;
   assign &lt;top_level_port&gt;[24] = &lt;output_enable_reg&gt;[24] ? &lt;output_reg&gt;[24] : 1'bz;
   assign &lt;top_level_port&gt;[25] = &lt;output_enable_reg&gt;[25] ? &lt;output_reg&gt;[25] : 1'bz;
   assign &lt;top_level_port&gt;[26] = &lt;output_enable_reg&gt;[26] ? &lt;output_reg&gt;[26] : 1'bz;
   assign &lt;top_level_port&gt;[27] = &lt;output_enable_reg&gt;[27] ? &lt;output_reg&gt;[27] : 1'bz;
   assign &lt;top_level_port&gt;[28] = &lt;output_enable_reg&gt;[28] ? &lt;output_reg&gt;[28] : 1'bz;
   assign &lt;top_level_port&gt;[29] = &lt;output_enable_reg&gt;[29] ? &lt;output_reg&gt;[29] : 1'bz;
   assign &lt;top_level_port&gt;[30] = &lt;output_enable_reg&gt;[30] ? &lt;output_reg&gt;[30] : 1'bz;
   assign &lt;top_level_port&gt;[31] = &lt;output_enable_reg&gt;[31] ? &lt;output_reg&gt;[31] : 1'bz;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;output_reg&gt;  &lt;= 32'h00000000;
         &lt;output_enable_reg&gt; &lt;= 32'h00000000;
      end
      else begin
         &lt;output_reg&gt;  &lt;= &lt;output_signal&gt;;
         &lt;output_enable_reg&gt; &lt;= {32{&lt;output_enable_signal&gt;}};
      end
					</Template>
				</SubFolder>
				<SubFolder label="Unregistered" treetype="folder">
					<Template label="1-bit" treetype="template">
   inout &lt;top_level_port&gt;;

   wire &lt;output_enable_signal&gt;, &lt;output_signal&gt;, &lt;input_signal&gt;;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 1'bz;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;
					</Template>
					<Template label="2-bit" treetype="template">
   inout [1:0] &lt;top_level_port&gt;;

   wire [1:0] &lt;output_signal&gt;, &lt;input_signal&gt;;
   wire       &lt;output_enable_signal&gt;;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 2'bzz;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;
					</Template>
					<Template label="4-bit" treetype="template">
   inout [3:0] &lt;top_level_port&gt;;

   wire [3:0] &lt;output_signal&gt;, &lt;input_signal&gt;;
   wire       &lt;output_enable_signal&gt;;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 4'hz;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;
					</Template>
					<Template label="8-bit" treetype="template">
   inout [7:0] &lt;top_level_port&gt;;

   wire [7:0] &lt;output_signal&gt;, &lt;input_signal&gt;;
   wire       &lt;output_enable_signal&gt;;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 8'hzz;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;
					</Template>
					<Template label="16-bit" treetype="template">
   inout [15:0] &lt;top_level_port&gt;;

   wire [15:0] &lt;output_signal&gt;, &lt;input_signal&gt;;
   wire        &lt;output_enable_signal&gt;;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 16'hzzzz;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;
					</Template>
					<Template label="32-bit" treetype="template">
   inout [31:0] &lt;top_level_port&gt;;

   wire [31:0] &lt;output_signal&gt;, &lt;input_signal&gt;;
   wire        &lt;output_enable_signal&gt;;

   assign &lt;top_level_port&gt; = &lt;output_enable_signal&gt; ? &lt;output_signal&gt; : 32'hzzzzzzzz;

   assign &lt;input_signal&gt; = &lt;top_level_port&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Comparators" treetype="folder">
				<Template label="Equal" treetype="template">
   reg &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (&lt;input1&gt; == &lt;input2&gt;)
         &lt;output&gt; &lt;= 1'b1;
      else
         &lt;output&gt; &lt;= 1'b0;
				</Template>
				<Template label="Greater-than" treetype="template">
   reg &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (&lt;input1&gt; &gt; &lt;input2&gt;)
         &lt;output&gt; &lt;= 1'b1;
      else
         &lt;output&gt; &lt;= 1'b0;
				</Template>
				<Template label="Greater-than or Equal" treetype="template">
   reg &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (&lt;input1&gt; &gt;= &lt;input2&gt;)
         &lt;output&gt; &lt;= 1'b1;
      else
         &lt;output&gt; &lt;= 1'b0;
				</Template>
				<Template label="Less-than" treetype="template">
   reg &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (&lt;input1&gt; &lt; &lt;input2&gt;)
         &lt;output&gt; &lt;= 1'b1;
      else
         &lt;output&gt; &lt;= 1'b0;
				</Template>
				<Template label="Less-than or equal" treetype="template">
   reg &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (&lt;input1&gt; &lt;= &lt;input2&gt;)
         &lt;output&gt; &lt;= 1'b1;
      else
         &lt;output&gt; &lt;= 1'b0;
				</Template>
				<Template label="Not Equal" treetype="template">
   reg &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (&lt;input1&gt; != &lt;input2&gt;)
         &lt;output&gt; &lt;= 1'b1;
      else
         &lt;output&gt; &lt;= 1'b0;
				</Template>
			</SubFolder>
			<SubFolder label="Counters" treetype="folder">
				<SubFolder label="Binary" treetype="folder">
					<SubFolder label="Down Counters" treetype="folder">
						<Template label="Simple Counter" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ CE" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;clock_enable&gt;)
         &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ CE and Sync Active High Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ CE and Sync Active Low Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ Load, CE and Sync Active High Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         if (&lt;load_enable&gt;)
            &lt;reg_name&gt; &lt;= &lt;load_signal_or_value&gt;;
         else
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ Load, CE and Sync Active Low Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         if (&lt;load_enable&gt;)
            &lt;reg_name&gt; &lt;= &lt;load_signal_or_value&gt;;
         else
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
					</SubFolder>
					<SubFolder label="Up Counters" treetype="folder">
						<Template label="Simple Counter" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
						</Template>
						<Template label="w/ CE" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;clock_enable&gt;)
         &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
						</Template>
						<Template label="w/ CE and Sync Active High Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
						</Template>
						<Template label="w/ CE and Sync Active Low Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
						</Template>
						<Template label="w/ Load, CE and Sync Active High Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         if (&lt;load_enable&gt;)
            &lt;reg_name&gt; &lt;= &lt;load_signal_or_value&gt;;
         else
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
						</Template>
						<Template label="w/ Load, CE and Sync Active Low Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         if (&lt;load_enable&gt;)
            &lt;reg_name&gt; &lt;= &lt;load_signal_or_value&gt;;
         else
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
						</Template>
					</SubFolder>
					<SubFolder label="Up/Down Counters" treetype="folder">
						<Template label="Simple Counter" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;up_down&gt;)
         &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
      else
         &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ CE" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;clock_enable&gt;)
         if (&lt;up_down&gt;)
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
         else
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ CE and Sync Active High Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         if (&lt;up_down&gt;)
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
         else
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ CE and Sync Active Low Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         if (&lt;up_down&gt;)
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
         else
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ Load, CE and Sync Active High Reset" treetype="template">
   parameter COUNTER_WIDTH = &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         if (&lt;load_enable&gt;)
            &lt;reg_name&gt; &lt;= &lt;load_signal_or_value&gt;;
         else if (&lt;up_down&gt;)
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
         else
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
						<Template label="w/ Load, CE and Sync Active Low Reset" treetype="template">
   parameter COUNTER_WIDTH  &lt;width&gt;;

   reg [COUNTER_WIDTH-1:0] &lt;reg_name&gt; = {COUNTER_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= {COUNTER_WIDTH{1'b0}};
      else if (&lt;clock_enable&gt;)
         if (&lt;load_enable&gt;)
            &lt;reg_name&gt; &lt;= &lt;load_signal_or_value&gt;;
         else if (&lt;up_down&gt;)
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; + 1'b1;
         else
            &lt;reg_name&gt; &lt;= &lt;reg_name&gt; - 1'b1;
						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Gray Code" treetype="folder">
					<Template label="w/ CE and Sync Active High Reset" treetype="template">
   parameter gray_width = &lt;gray_value_width&gt;;

   reg  [gray_width-1:0] &lt;binary_value&gt; = {{gray_width{1'b0}}, 1'b1};
   reg  [gray_width-1:0] &lt;gray_value&gt; = {gray_width{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;binary_value&gt; &lt;= {{gray_width{1'b0}}, 1'b1};
         &lt;gray_value&gt; &lt;= {gray_width{1'b0}};
      end
      else if (&lt;clock_enable&gt;) begin
         &lt;binary_value&gt; &lt;= &lt;binary_value&gt; + 1;
         &lt;gray_value&gt; &lt;= (&lt;binary_value&gt; &gt;&gt; 1) ^ &lt;binary_value&gt;;
      end
					</Template>
				</SubFolder>
				<SubFolder label="LFSR" treetype="folder">
					<Template label="4-bit w/ CE and Sync Active High Reset" treetype="template">
   reg [3:0] &lt;reg_name&gt; = 4'h0;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= 4'h0;
      else if (&lt;clock_enable&gt;) begin
         &lt;reg_name&gt;[3:1] &lt;= &lt;reg_name&gt;[2:0];
         &lt;reg_name&gt;[0] &lt;= ~^&lt;reg_name&gt;[3:2];
      end
					</Template>
					<Template label="8-bit w/ CE and Sync Active High Reset" treetype="template">
   reg [7:0] &lt;reg_name&gt; = 8'h00;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= 8'h00;
      else if (&lt;clock_enable&gt;) begin
         &lt;reg_name&gt;[7:1] &lt;= &lt;reg_name&gt;[6:0];
         &lt;reg_name&gt;[0] &lt;= ~^{&lt;reg_name&gt;[7], &lt;reg_name&gt;[5:3]};
      end
					</Template>
					<Template label="16-bit w/ CE and Sync Active High Reset" treetype="template">
   reg [15:0] &lt;reg_name&gt; = 16'h0000;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= 16'h0000;
      else if (&lt;clock_enable&gt;) begin
         &lt;reg_name&gt;[15:1] &lt;= &lt;reg_name&gt;[14:0];
         &lt;reg_name&gt;[0] &lt;= ~^{&lt;reg_name&gt;[15:14], &lt;reg_name&gt;[12], &lt;reg_name&gt;[3]};
      end
					</Template>
					<Template label="32-bit w/ CE and Sync Active High Reset" treetype="template">
   reg [31:0] &lt;reg_name&gt; = 32'h00000000;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= 32'h00000000;
      else if (&lt;clock_enable&gt;) begin
         &lt;reg_name&gt;[31:1] &lt;= &lt;reg_name&gt;[30:0];
         &lt;reg_name&gt;[0] &lt;= ~^{&lt;reg_name&gt;[31], &lt;reg_name&gt;[21], &lt;reg_name&gt;[1:0]};
      end
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Decoders" treetype="folder">
				<Template label="4-bit Registered Output" treetype="template">
   reg [3:0] &lt;output&gt; = 4'h0;

   &lt;reg_or_wire&gt; [1:0] &lt;input&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;output&gt; &lt;= 4'h0;
      else
         case (&lt;input&gt;)
            2'b00   : &lt;output&gt; &lt;= 4'b0001;
            2'b01   : &lt;output&gt; &lt;= 4'b0010;
            2'b10   : &lt;output&gt; &lt;= 4'b0100;
            2'b11   : &lt;output&gt; &lt;= 4'b1000;
            default : &lt;output&gt; &lt;= 4'b0000;
         endcase
				</Template>
				<Template label="8-bit Registered Output" treetype="template">
   reg [7:0] &lt;output&gt; = 8'h00;

   &lt;reg_or_wire&gt; [2:0] &lt;input&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;output&gt; &lt;= 8'h00;
      else
         case (&lt;input&gt;)
            3'b000  : &lt;output&gt; &lt;= 8'b00000001;
            3'b001  : &lt;output&gt; &lt;= 8'b00000010;
            3'b010  : &lt;output&gt; &lt;= 8'b00000100;
            3'b011  : &lt;output&gt; &lt;= 8'b00001000;
            3'b100  : &lt;output&gt; &lt;= 8'b00010000;
            3'b101  : &lt;output&gt; &lt;= 8'b00100000;
            3'b110  : &lt;output&gt; &lt;= 8'b01000000;
            3'b111  : &lt;output&gt; &lt;= 8'b10000000;
            default : &lt;output&gt; &lt;= 8'b00000000;
         endcase
				</Template>
			</SubFolder>
			<SubFolder label="DSP" treetype="folder">
				<Template label="Complex Multiplier" treetype="template">

//  Complex Multilier
//  The following code implements a parameterizable complex multiplier
//  The style described uses 3 DSP's to implement the complex multiplier
//  taking advantage of the pre-adder, so widths chosen should be less than what the architecture supports or else extra-logic/extra DSPs will be inferred
parameter AWIDTH = &lt;awidth&gt;;  // size of 1st input of multiplier
parameter BWIDTH = &lt;bwidth&gt;;  // size of 2nd input of multiplier
wire_reg &lt;clk&gt;;               // Clock
wire_reg signed [AWIDTH-1:0] 	    &lt;ar&gt;, &lt;ai&gt;; // 1st inputs real and imaginary parts
wire_reg signed [BWIDTH-1:0] 	    &lt;br&gt;, &lt;bi&gt;; // 2nd inputs real and imaginary parts
wire_reg signed [AWIDTH+BWIDTH:0] &lt;pr&gt;, &lt;pi&gt;; // output signal


reg signed [AWIDTH-1:0]	&lt;ai_d&gt;, &lt;ai_dd&gt;, &lt;ai_ddd&gt;, &lt;ai_dddd&gt;;
reg signed [AWIDTH-1:0]	&lt;ar_d&gt;, &lt;ar_dd&gt;, &lt;ar_ddd&gt;, &lt;ar_dddd&gt;;
reg signed [BWIDTH-1:0]	&lt;bi_d&gt;, &lt;bi_dd&gt;, &lt;bi_ddd&gt;, &lt;br_d&gt;, &lt;br_dd&gt;, &lt;br_ddd&gt;;
reg signed [AWIDTH:0]		&lt;addcommon&gt;;
reg signed [BWIDTH:0]		&lt;addr&gt;, &lt;addi&gt;;
reg signed [AWIDTH+BWIDTH:0]	&lt;mult0&gt;, &lt;multr&gt;, &lt;multi&gt;, &lt;pr_int&gt;, &lt;pi_int&gt;;
reg signed [AWIDTH+BWIDTH:0]	&lt;common&gt;, &lt;commonr1&gt;, &lt;commonr2&gt;;

always @(posedge &lt;clk&gt;)
  begin
    &lt;ar_d&gt;   &lt;= &lt;ar&gt;;
    &lt;ar_dd&gt;  &lt;= &lt;ar_d&gt;;
    &lt;ai_d&gt;   &lt;= &lt;ai&gt;;
    &lt;ai_dd&gt;  &lt;= &lt;ai_d&gt;;
    &lt;br_d&gt;   &lt;= &lt;br&gt;;
    &lt;br_dd&gt;  &lt;= &lt;br_d&gt;;
    &lt;br_ddd&gt; &lt;= &lt;br_dd&gt;;
    &lt;bi_d&gt;   &lt;= &lt;bi&gt;;
    &lt;bi_dd&gt;  &lt;= &lt;bi_d&gt;;
    &lt;bi_ddd&gt; &lt;= &lt;bi_dd&gt;;
  end

   // Common factor (ar ai) x bi, shared for the calculations of the real and imaginary final products
   //
always @(posedge &lt;clk&gt;)
 begin
	&lt;addcommon&gt; &lt;= &lt;ar_d&gt; - &lt;ai_d&gt;;
	&lt;mult0&gt;     &lt;= &lt;addcommon&gt; * &lt;bi_dd&gt;;
	&lt;common&gt;    &lt;= &lt;mult0&gt;;
 end

   // Real product
   //
always @(posedge &lt;clk&gt;)
 begin
	&lt;ar_ddd&gt;   &lt;= &lt;ar_dd&gt;;
	&lt;ar_dddd&gt;  &lt;= &lt;ar_ddd&gt;;
	&lt;addr&gt;     &lt;= &lt;br_ddd&gt; - &lt;bi_ddd&gt;;
	&lt;multr&gt;    &lt;= &lt;addr&gt; * &lt;ar_dddd&gt;;
	&lt;commonr1&gt; &lt;= &lt;common&gt;;
	&lt;pr_int&gt;   &lt;= &lt;multr&gt; + &lt;commonr1&gt;;
 end

   // Imaginary product
   //
always @(posedge &lt;clk&gt;)
 begin
	&lt;ai_ddd&gt;   &lt;= &lt;ai_dd&gt;;
	&lt;ai_dddd&gt;  &lt;= &lt;ai_ddd&gt;;
	&lt;addi&gt;     &lt;= &lt;br_ddd&gt; + &lt;bi_ddd&gt;;
	&lt;multi&gt;    &lt;= &lt;addi&gt; * &lt;ai_dddd&gt;;
	&lt;commonr2&gt; &lt;= &lt;common&gt;;
	&lt;pi_int&gt;   &lt;= &lt;multi&gt; + &lt;commonr2&gt;;
 end

assign &lt;pr&gt; = &lt;pr_int&gt;;
assign &lt;pi&gt; = &lt;pi_int&gt;;

				</Template>
				<Template label="Complex Multiply Accumulate" treetype="template">
// This module describes a Complex Multiplier with accumulation (pr+i.pi) = (ar+i.ai)*(br+i.bi)
// This can be packed into 3 DSP blocks (Ultrascale architecture)
// Make sure the widths are less than what is supported by the architecture
parameter AWIDTH = 16;  // width of 1st input
parameter BWIDTH = 18;  // width of 2nd input 
parameter SIZEOUT = 40; // output width
&lt;wire_or_reg&gt; clk;        // clock input 
&lt;wire_or_reg&gt; sload;      // synchronous load
&lt;wire_or_reg&gt; signed [AWIDTH-1:0] ar;  // 1st input of multiplier - real part
&lt;wire_or_reg&gt; signed [AWIDTH-1:0] ai;  // 1st input of multiplier - imaginary part
&lt;wire_or_reg&gt; signed [BWIDTH-1:0]   br; // 2nd input of multiplier - real part
&lt;wire_or_reg&gt; signed [BWIDTH-1:0]   bi; // 2nd input of multiplier - imaginary part
wire signed [SIZEOUT-1:0] pr; // output  - Real part
wire signed [SIZEOUT-1:0] pi; // output - Imaginary part
                
reg signed [AWIDTH-1:0] 	&lt;ai_d&gt;, &lt;ai_dd&gt;, &lt;ai_ddd&gt;, &lt;ai_dddd&gt;;
reg signed [AWIDTH-1:0]	&lt;ar_d&gt;, &lt;ar_dd&gt;, &lt;ar_ddd&gt;, &lt;ar_dddd&gt;;
reg signed [BWIDTH-1:0]	&lt;bi_d&gt;, &lt;bi_dd&gt;, &lt;bi_ddd&gt;, &lt;br_d&gt;, &lt;br_dd&gt;, &lt;br_ddd&gt;;
reg signed [AWIDTH:0]	&lt;addcommon&gt;;
reg signed [BWIDTH:0]	&lt;addr&gt;, &lt;addi&gt;;
reg signed [AWIDTH+BWIDTH:0]	&lt;mult0&gt;, &lt;multr&gt;, &lt;multi&gt;;	 
reg signed [SIZEOUT-1:0]	&lt;pr_int&gt;, &lt;pi_int&gt;, &lt;old_result_real&gt;, &lt;old_result_im&gt;;
reg signed [AWIDTH+BWIDTH:0]	&lt;common&gt;, &lt;commonr1&gt;, &lt;commonr2&gt;;

reg &lt;sload_reg&gt;;   
 
always @(posedge &lt;clk&gt;)
begin
  &lt;ar_d&gt;      &lt;= &lt;ar&gt;;
  &lt;ar_dd&gt;     &lt;= &lt;ar_d&gt;;
  &lt;ai_d&gt;      &lt;= &lt;ai&gt;;
  &lt;ai_dd&gt;     &lt;= &lt;ai_d&gt;;
  &lt;br_d&gt;      &lt;= &lt;br&gt;;
  &lt;br_dd&gt;     &lt;= &lt;br_d&gt;;
  &lt;br_ddd&gt;    &lt;= &lt;br_dd&gt;;
  &lt;bi_d&gt;      &lt;= &lt;bi&gt;;
  &lt;bi_dd&gt;     &lt;= &lt;bi_d&gt;;
  &lt;bi_ddd&gt;    &lt;= &lt;bi_dd&gt;;
  &lt;sload_reg&gt; &lt;= &lt;sload&gt;;
end
 
// Common factor (ar ai) x bi, shared for the calculations of the real and imaginary final products
// 
always @(posedge &lt;clk&gt;)
begin
  &lt;addcommon&gt; &lt;= &lt;ar_d&gt; - &lt;ai_d&gt;;
  &lt;mult0&gt;     &lt;= &lt;addcommon&gt; * &lt;bi_dd&gt;;
  &lt;common&gt;    &lt;= &lt;mult0&gt;;
end

// Accumulation loop (combinatorial) for *Real*
//
always @(&lt;sload_reg&gt; or &lt;pr_int&gt;)
if (&lt;sload_reg&gt;)
&lt;old_result_real&gt; &lt;= 0;
else
// 'sload' is now and opens the accumulation loop.
// The accumulator takes the next multiplier output
// in the same cycle.
&lt;old_result_real&gt; &lt;= &lt;pr_int&gt;;

// Real product
//
always @(posedge &lt;clk&gt;)
begin
  &lt;ar_ddd&gt;   &lt;= &lt;ar_dd&gt;;
  &lt;ar_dddd&gt;  &lt;= &lt;ar_ddd&gt;;
  &lt;addr&gt;     &lt;= &lt;br_ddd&gt; - &lt;bi_ddd&gt;;
  &lt;multr&gt;    &lt;= &lt;addr&gt; * &lt;ar_dddd&gt;;
  &lt;commonr1&gt; &lt;= &lt;common&gt;;
  &lt;pr_int&gt;   &lt;= &lt;multr&gt; + &lt;commonr1&gt; + &lt;old_result_real&gt;;
end

// Accumulation loop (combinatorial) for *Imaginary*
//
always @(&lt;sload_reg&gt; or &lt;pi_int&gt;)
if (&lt;sload_reg&gt;)
&lt;old_result_im&gt; &lt;= 0;
else
// 'sload' is now and opens the accumulation loop.
// The accumulator takes the next multiplier output
// in the same cycle.
&lt;old_result_im&gt; &lt;= &lt;pi_int&gt;;

// Imaginary product
//
always @(posedge &lt;clk&gt;)
begin
  &lt;ai_ddd&gt;   &lt;= &lt;ai_dd&gt;;
  &lt;ai_dddd&gt;  &lt;= &lt;ai_ddd&gt;;
  &lt;addi&gt;     &lt;= &lt;br_ddd&gt; + &lt;bi_ddd&gt;;	 
  &lt;multi&gt;    &lt;= &lt;addi&gt; * &lt;ai_dddd&gt;;
  &lt;commonr2&gt; &lt;= &lt;common&gt;;
  &lt;pi_int&gt;   &lt;= &lt;multi&gt; + &lt;commonr2&gt; + &lt;old_result_im&gt;;
end

assign &lt;pr&gt; = &lt;pr_int&gt;;
assign &lt;pi&gt; = &lt;pi_int&gt;;
				</Template>
				<Template label="Convergent Rounding(Even)" treetype="template">
// This example shows how to infer Convergent Rounding (Even) using pattern
// detect within DSP block (Width of the inputs should be within
// what can be supported by the DSP architecture)
wire_or_reg &lt;clk&gt;; // Clock
wire_or_reg [23:0] &lt;a&gt;; // First Input
wire_or_reg [15:0] &lt;b&gt;; // Second Input
reg signed [23:0] &lt;zlast&gt;; // Convergent Round Output

reg signed [23:0] &lt;areg&gt;;
reg signed [15:0] &lt;breg&gt;;
reg signed [39:0] &lt;z1&gt;;

reg &lt;pattern_detect&gt;;
wire [15:0] &lt;pattern&gt; = 16'b0000000000000000;
wire [39:0] &lt;c&gt;       = 40'b0000000000000000000000000111111111111111; // 15 ones

wire signed [39:0] &lt;multadd&gt;;
wire signed [15:0] &lt;zero&gt;;
reg  signed [39:0] &lt;multadd_reg&gt;;

// Convergent Rounding: LSB Correction Technique
// ---------------------------------------------
// For static convergent rounding, the pattern detector can be used
// to detect the midpoint case. For example, in an 8-bit round, if
// the decimal place is set at 4, the C input should be set to
// 0000.0111.  Round to even rounding should use CARRYIN = "1" and
// check for PATTERN "XXXX.0000" and replace the units place with 0
// if the pattern is matched. See UG193 for more details.

assign &lt;multadd&gt; = &lt;z1&gt; + &lt;c&gt; + 1'b1;

always @(posedge &lt;clk&gt;)
begin
	&lt;areg&gt;  &lt;= &lt;a&gt;;
	&lt;breg&gt;  &lt;= &lt;b&gt;;
	&lt;z1&gt;    &lt;= &lt;areg&gt; * &lt;breg&gt;;
	&lt;pattern_detect&gt; &lt;= &lt;multadd&gt;[15:0] == &lt;pattern&gt; ? 1'b1 : 1'b0;
	&lt;multadd_reg&gt; &lt;= &lt;multadd&gt;;
end

// Unit bit replaced with 0 if pattern is detected
always @(posedge &lt;clk&gt;)
 &lt;zlast&gt; &lt;= &lt;pattern_detect&gt; ? {&lt;multadd_reg&gt;[39:17],1'b0} : &lt;multadd_reg&gt;[39:16];
				</Template>
				<Template label="Convergent Rounding(Odd)" treetype="template">
// This example shows how to infer Convergent Rounding (Odd) using pattern detect within DSP block (Width of the inputs should be within what can be supported by the DSP architecture)
wire_or_reg &lt;clk&gt;; // Clock
wire_or_reg [23:0] &lt;a&gt;; // First Input
wire_or_reg [15:0] &lt;b&gt;; // Second Input
reg signed [23:0] &lt;zlast&gt;; // Convergent Round Output

reg signed [23:0] &lt;areg&gt;;
reg signed [15:0] &lt;breg&gt;;
reg signed [39:0] &lt;z1&gt;;

reg &lt;pattern_detect&gt;;
wire [15:0] &lt;pattern&gt; = 16'b1111111111111111;
wire [39:0] &lt;c&gt; = 40'b0000000000000000000000000111111111111111; // 15 ones

wire signed [39:0] &lt;multadd&gt;;
wire signed [15:0] &lt;zero&gt;;
reg  signed [39:0] &lt;multadd_reg&gt;;

// Convergent Rounding: LSB Correction Technique
// ---------------------------------------------
// For static convergent rounding,  the pattern detector can be
// used to detect  the midpoint case. For example,  in an 8-bit
// round, if the decimal place is  set at 4, the C input should
// be  set to  0000.0111.   Round to  odd  rounding should  use
// CARRYIN =  "0" and  check for  PATTERN "XXXX.1111"  and then
// replace  the  units place  bit  with  1  if the  pattern  is
// matched. See UG193 for details

assign &lt;multadd&gt; = &lt;z1&gt; + &lt;c&gt;;

always @(posedge &lt;clk&gt;)
begin
    &lt;areg&gt;  &lt;= &lt;a&gt;;
	&lt;breg&gt;  &lt;= &lt;b&gt;;
	&lt;z1&gt;    &lt;= &lt;areg&gt; * &lt;breg&gt;;
	&lt;pattern_detect&gt; &lt;= &lt;multadd&gt;[15:0] == &lt;pattern&gt; ? 1'b1 : 1'b0;
	&lt;multadd_reg&gt; &lt;= &lt;multadd&gt;;
end

always @(posedge &lt;clk&gt;)
  &lt;zlast&gt; &lt;= &lt;pattern_detect&gt; ? {&lt;multadd_reg&gt;[39:17],1'b1} : &lt;multadd_reg&gt;[39:16];
				</Template>
				<Template label="Dynamic preadd sub followed by mult add" treetype="template">
// This module describes a dynamic pre add/sub followed by multiplier, adder
// Make sure the widths are less than what is supported by the architecture
parameter SIZEIN = 16;
&lt;wire_or_reg&gt; clk;   // Clock &lt;wire_or_reg&gt;
&lt;wire_or_reg&gt; ce;    // Clock enable
&lt;wire_or_reg&gt; rst;   // Reset
&lt;wire_or_reg&gt; subadd; // Dynamic subadd control
&lt;wire_or_reg&gt;  signed [SIZEIN-1:0] a, b, c, d;  // &lt;wire_or_reg&gt;s
wire signed [2*SIZEIN:0] dynpreaddmultadd_out; // Output

// Declare registers for intermediate values
reg signed [SIZEIN-1:0] &lt;a_reg&gt;, &lt;b_reg&gt;, &lt;c_reg&gt;;
reg signed [SIZEIN:0]   &lt;add_reg&gt;;
reg signed [2*SIZEIN:0] &lt;d_reg&gt;, &lt;m_reg&gt;, &lt;p_reg&gt;;

always @(posedge &lt;clk&gt;)
begin
 if (&lt;rst&gt;)
  begin
   &lt;a_reg&gt;   &lt;= 0;
   &lt;b_reg&gt;   &lt;= 0;
   &lt;c_reg&gt;   &lt;= 0;
   &lt;d_reg&gt;   &lt;= 0;
   &lt;add_reg&gt; &lt;= 0;
   &lt;m_reg&gt;   &lt;= 0;
   &lt;p_reg&gt;   &lt;= 0;
  end
 else if (&lt;ce&gt;)
  begin
   &lt;a_reg&gt;   &lt;= &lt;a&gt;;
   &lt;b_reg&gt;   &lt;= &lt;b&gt;;
   &lt;c_reg&gt;   &lt;= &lt;c&gt;;
   &lt;d_reg&gt;   &lt;= &lt;d&gt;;
   if (&lt;subadd&gt;)
    &lt;add_reg&gt; &lt;= &lt;a&gt; - &lt;b&gt;;
   else
    &lt;add_reg&gt; &lt;= &lt;a&gt; + &lt;b&gt;;
   &lt;m_reg&gt;   &lt;= &lt;add_reg&gt; * &lt;c_reg&gt;;
   &lt;p_reg&gt;   &lt;= &lt;m_reg&gt; + &lt;d_reg&gt;;
  end
end

// Output accumulation result
assign &lt;dynpreaddmultadd_out&gt; = &lt;p_reg&gt;;
				</Template>
				<Template label="MultAdd-3input" treetype="template">
// This module describes a Multiplier,3 input adder (a*b + c + p(feedback))
// This can be packed into 1 DSP block (Ultrascale architecture)
// Make sure the widths are less than what is supported by the architecture

parameter AWIDTH = 16;  // Width of multiplier's 1st input  
parameter BWIDTH = 16;  // Width of multiplier's 2nd input
parameter CWIDTH = 32;  // Width of Adder input
parameter PWIDTH = 33;  // Output Width
&lt;wire_or_reg&gt; &lt;clk&gt;;    // Clock 
&lt;wire_or_reg&gt; &lt;rst&gt;;    // Reset
&lt;wire_or_reg&gt; signed [AWIDTH-1:0] &lt;a&gt;;  // Multiplier input
&lt;wire_or_reg&gt; signed [BWIDTH-1:0] &lt;b&gt;;  // Mutiplier input
&lt;wire_or_reg&gt; signed [CWIDTH-1:0] &lt;c&gt;;  // Adder input
&lt;wire_or_reg&gt; &lt;ce&gt;;     // Clock enable
&lt;wire&gt; signed [PWIDTH-1:0] &lt;p&gt;;        // Output

reg signed [AWIDTH-1:0] &lt;a_r&gt;;
reg signed [BWIDTH-1:0] &lt;b_r&gt;;
reg signed [CWIDTH-1:0] &lt;c_r&gt;;
reg signed [PWIDTH-1:0] &lt;p_r&gt;;

always @ (posedge &lt;clk&gt;)
begin
 if(&lt;rst&gt;)
 begin
  &lt;a_r&gt; &lt;= 0;
  &lt;b_r&gt; &lt;= 0;
  &lt;c_r&gt; &lt;= 0;
  &lt;p_r&gt; &lt;= 0;
 end
 else
  begin
   if(&lt;ce&gt;)
   begin
    &lt;a_r&gt; &lt;= &lt;a&gt;;
    &lt;b_r&gt; &lt;= &lt;b&gt;;
    &lt;c_r&gt; &lt;= &lt;c&gt;;
    &lt;p_r&gt; &lt;= &lt;a_r&gt; * &lt;b_r&gt; + &lt;c_r&gt; + &lt;p_r&gt;; 
   end
  end
end
assign &lt;p&gt; = &lt;p_r&gt;;
				</Template>
				<Template label="Multipy and accumulate" treetype="template">
//  The following code implements a parameterizable Multiply-accumulate unit
//  with synchronous load to reset the accumulator without losing a clock cycle
//  Size of inputs/output should be less than/equal to what is supported by the architecture else extra logic/dsps will be inferred
parameter SIZEIN = &lt;sizein&gt;;     // width of the inputs
parameter SIZEOUT = &lt;sizeout&gt;;   // width of output
wire_or_reg &lt;clk&gt;;               // clock
wire_or_reg &lt;ce&gt;;                // clock enable
wire_or_reg &lt;sload&gt;;             // synchronous load
wire_or_reg signed [SIZEIN-1:0]   &lt;a&gt;;  // 1st input to multiply-accumulate
wire_or_reg signed [SIZEIN-1:0]   &lt;b&gt;;  // 2nd input to multiply-accumulate
wire_or_reg signed [SIZEOUT-1:0] &lt;accum_out&gt;; // output from multiply-accumulate

// Declare registers for intermediate values
reg signed [SIZEIN-1:0]   &lt;a_reg&gt;, &lt;b_reg&gt;;
reg                       &lt;sload_reg&gt;;
reg signed [2*SIZEIN-1:0] &lt;mult_reg&gt;;
reg signed [SIZEOUT-1:0]  &lt;adder_out&gt;, &lt;old_result&gt;;

always @(&lt;sload_reg&gt; or &lt;adder_out&gt;)
begin
 if (&lt;sload_reg&gt;)
    &lt;old_result&gt; &lt;= 0;
 else
    // 'sload' is now and opens the accumulation loop.
    // The accumulator takes the next multiplier output
    // in the same cycle.
    &lt;old_result&gt; &lt;= &lt;adder_out&gt;;
end

always @(posedge &lt;clk&gt;)
 if (&lt;ce&gt;)
  begin
    &lt;a_reg&gt;     &lt;= &lt;a&gt;;
    &lt;b_reg&gt;     &lt;= &lt;b&gt;;
    &lt;mult_reg&gt;  &lt;= &lt;a_reg&gt; * &lt;b_reg&gt;;
    &lt;sload_reg&gt; &lt;= &lt;sload&gt;;
    // Store accumulation result into a register
    &lt;adder_out&gt; &lt;= &lt;old_result&gt; + &lt;mult_reg&gt;;
 end

// Output accumulation result
assign &lt;accum_out&gt; = &lt;adder_out&gt;;
				</Template>
				<Template label="Pre-subtractor with multiplication" treetype="template">
// This code implements a parameterizable subtractor followed by multiplier which will be packed into DSP Block
parameter SIZEIN = 16;  // Size of inputs
wire_or_reg clk; // Clock
wire_or_reg ce;  // Clock enable
wire_or_reg rst; // Reset
wire_or_reg signed [&lt;SIZEIN&gt;-1:0] &lt;a&gt;;  // 1st Input to pre-subtractor
wire_or_reg signed [&lt;SIZEIN&gt;-1:0] &lt;b&gt;;  // 2nd input to pre-subtractor
wire_or_reg signed [&lt;SIZEIN&gt;-1:0] &lt;c&gt;;  // multiplier input
wire_or_reg signed [2*&lt;SIZEIN&gt;:0] &lt;presubmult_out&gt;;

// Declare registers for intermediate values
reg signed [&lt;SIZEIN&gt;-1:0] &lt;a_reg&gt;, &lt;b_reg&gt;, &lt;c_reg&gt;;
reg signed [&lt;SIZEIN&gt;:0]   &lt;add_reg&gt;;
reg signed [2*&lt;SIZEIN&gt;:0] &lt;m_reg&gt;, &lt;p_reg&gt;;

always @(posedge &lt;clk&gt;)
 if (&lt;rst&gt;)
  begin
    &lt;a_reg&gt;   &lt;= 0;
    &lt;b_reg&gt;   &lt;= 0;
    &lt;c_reg&gt;   &lt;= 0;
	  &lt;add_reg&gt; &lt;= 0;
    &lt;m_reg&gt;   &lt;= 0;
    &lt;p_reg&gt;   &lt;= 0;
  end
 else if (&lt;ce&gt;)
  begin
    &lt;a_reg&gt;   &lt;= &lt;a&gt;;
    &lt;b_reg&gt;   &lt;= &lt;b&gt;;
    &lt;c_reg&gt;   &lt;= &lt;c&gt;;
    &lt;add_reg&gt; &lt;= &lt;a&gt; - &lt;b&gt;;
    &lt;m_reg&gt;   &lt;= &lt;add_reg&gt; * &lt;c_reg&gt;;
    &lt;p_reg&gt;   &lt;= &lt;m_reg&gt;;
  end

assign &lt;presubmult_out&gt; = &lt;p_reg&gt;;

				</Template>
				<Template label="Squarer" treetype="template">
// This module implements a parameterizable (a-b) squarer
// which can be implemented in a DSP48E2(ultrascale) by using the pre-adder
// The size should be less than or equal to what is supported
// by the architecture
parameter SIZEIN = 16 // size of the inputs
wire_or_reg &lt;clk&gt;;    // Clock
wire_or_reg &lt;ce&gt;;     // enable
wire_or_reg &lt;rst&gt;;    // reset
wire_or_reg signed [SIZEIN-1:0] &lt;a&gt;; // 1st input
wire_or_reg signed [SIZEIN-1:0] &lt;b&gt;; // seconde input
wire_or_reg signed [2*SIZEIN+1:0] &lt;square_out&gt;; // squared output

// Declare registers for intermediate values
reg signed [SIZEIN-1:0]   &lt;a_reg&gt;, &lt;b_reg&gt;;
reg signed [SIZEIN:0]     &lt;diff_reg&gt;;
reg signed [2*SIZEIN+1:0] &lt;m_reg&gt;, &lt;p_reg&gt;;

always @(posedge &lt;clk&gt;)
begin
 if (&lt;rst&gt;)
  begin
	  &lt;a_reg&gt;    &lt;= 0;
	  &lt;b_reg&gt;    &lt;= 0;
	  &lt;diff_reg&gt; &lt;= 0;
	  &lt;m_reg&gt;    &lt;= 0;
	  &lt;p_reg&gt;    &lt;= 0;
  end
 else
  if (&lt;ce&gt;)
	 begin
      &lt;a_reg&gt;     &lt;= &lt;a&gt;;
      &lt;b_reg&gt;     &lt;= &lt;b&gt;;
      &lt;diff_reg&gt;  &lt;= &lt;a_reg&gt; - &lt;b_reg&gt;;
      &lt;m_reg&gt;     &lt;= &lt;diff_reg&gt; * &lt;diff_reg&gt;;
      &lt;p_reg&gt;     &lt;= &lt;m_reg&gt;;
	end
end

// Output result
assign &lt;square_out&gt; = &lt;p_reg&gt;;

				</Template>
				<Template label="Squarer diff MAC" treetype="template">
// This module performs subtraction of two inputs, squaring on the diff
// and then accumulation 
// This can be implemented in 1 DSP Block (Ultrascale architecture)
parameter SIZEIN = 16; 
parameter SIZEOUT = 40;
&lt;wire_or_reg&gt; clk; // clock input 
&lt;wire_or_reg&gt; ce;  // clock enable
&lt;wire_or_reg&gt; sload; // synchronous load
&lt;wire_or_reg&gt; signed [SIZEIN-1:0]   a; // 1st input 
&lt;wire_or_reg&gt; signed [SIZEIN-1:0]   b; // 2nd input 
wire signed [SIZEOUT+1:0] accum_out; // accumulator output
  
// Declare registers for intermediate values
reg signed [SIZEIN-1:0] 	&lt;a_reg&gt;, &lt;b_reg&gt;;   
reg signed [SIZEIN:0] 	&lt;diff_reg&gt;;
reg                       &lt;sload_reg&gt;;
reg signed [2*SIZEIN+1:0] &lt;m_reg&gt;;
reg signed [SIZEOUT-1:0]  &lt;adder_out&gt;, &lt;old_result&gt;;
  
always @(&lt;sload_reg&gt; or &lt;adder_out&gt;)
 if (&lt;sload_reg&gt;)
  &lt;old_result&gt; &lt;= 0;
 else
  // 'sload' is now and opens the accumulation loop.
  // The accumulator takes the next multiplier output
  // in the same cycle.
  &lt;old_result&gt; &lt;= &lt;adder_out&gt;;
   
always @(posedge &lt;clk&gt;)
if (&lt;ce&gt;)
begin
  &lt;a_reg&gt;     &lt;= &lt;a&gt;;
  &lt;b_reg&gt;     &lt;= &lt;b&gt;;
  &lt;diff_reg&gt;  &lt;= &lt;a_reg&gt; - &lt;b_reg&gt;;	  
  &lt;m_reg&gt;  &lt;= &lt;diff_reg&gt; * &lt;diff_reg&gt;;
  &lt;sload_reg&gt; &lt;= &lt;sload&gt;;
  // Store accumulation result into a register
  &lt;adder_out&gt; &lt;= &lt;old_result&gt; + &lt;m_reg&gt;;
end
   
// Output accumulation result
assign &lt;accum_out&gt; = &lt;adder_out&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="Encoders" treetype="folder">
				<Template label="4-bit Registered Output" treetype="template">
   reg [1:0] &lt;output&gt; = 2'b00;

   &lt;reg_or_wire&gt; [3:0] &lt;input&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;output&gt; &lt;= 2'b00;
      else
         case (&lt;input&gt;)
            4'b0001 : &lt;output&gt; &lt;= 2'b00;
            4'b0010 : &lt;output&gt; &lt;= 2'b01;
            4'b0100 : &lt;output&gt; &lt;= 2'b10;
            4'b1000 : &lt;output&gt; &lt;= 2'b11;
            default : &lt;output&gt; &lt;= 2'b00;
         endcase
				</Template>
				<Template label="8-bit Registered Output" treetype="template">
   reg [2:0] &lt;output&gt; = 3'b000;

   &lt;reg_or_wire&gt; [7:0] &lt;input&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;output&gt; &lt;= 3'b000;
      else
         case (&lt;input&gt;)
            8'b00000001 : &lt;output&gt; &lt;= 3'b000;
            8'b00000010 : &lt;output&gt; &lt;= 3'b001;
            8'b00000100 : &lt;output&gt; &lt;= 3'b010;
            8'b00001000 : &lt;output&gt; &lt;= 3'b011;
            8'b00010000 : &lt;output&gt; &lt;= 3'b100;
            8'b00100000 : &lt;output&gt; &lt;= 3'b101;
            8'b01000000 : &lt;output&gt; &lt;= 3'b110;
            8'b10000000 : &lt;output&gt; &lt;= 3'b111;
            default     : &lt;output&gt; &lt;= 3'b000;
         endcase
				</Template>
			</SubFolder>
			<SubFolder label="Flip Flops" treetype="folder">
				<SubFolder label="D Flip Flop" treetype="folder">
					<SubFolder label="Negedge" treetype="folder">
						<Template label="Simple Register" treetype="template">
   always @(negedge &lt;clock&gt;) begin
      &lt;reg&gt; &lt;= &lt;signal&gt;;
   end
						</Template>
						<Template label="w/ Synchronous Active High Reset" treetype="template">
   always @(negedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else begin
         &lt;reg&gt; &lt;= &lt;signal&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active High Reset and CE" treetype="template">
   always @(negedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else if (&lt;clock_enable&gt;) begin
         &lt;reg&gt; &lt;= &lt;signal&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active Low Reset" treetype="template">
   always @(negedge &lt;clock&gt;)
      if (!&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else begin
         &lt;reg&gt; &lt;= &lt;signal&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active Low Reset and CE" treetype="template">
   always @(negedge &lt;clock&gt; )
      if (!&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else if (&lt;clock_enable&gt;) begin
         &lt;reg&gt; &lt;= &lt;signal&gt;;
      end
						</Template>
					</SubFolder>
					<SubFolder label="Posedge" treetype="folder">
						<Template label="Simple Register" treetype="template">
   always @(posedge &lt;clock&gt;) begin
      &lt;reg&gt; &lt;= &lt;signal&gt;;
   end
						</Template>
						<Template label="w/ Synchronous Active High Reset" treetype="template">
   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else begin
         &lt;reg&gt; &lt;= &lt;signal&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active High Reset and CE" treetype="template">
   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else if (&lt;clock_enable&gt;) begin
         &lt;reg&gt; &lt;= &lt;signal&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active Low Reset" treetype="template">
   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else begin
         &lt;reg&gt; &lt;= &lt;signal&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active Low Reset and CE" treetype="template">
   always @(posedge &lt;clock&gt; )
      if (!&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else if (&lt;clock_enable&gt;) begin
         &lt;reg&gt; &lt;= &lt;signal&gt;;
      end
						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="T Flip Flop" treetype="folder">
					<SubFolder label="Negedge" treetype="folder">
						<Template label="Simple Register" treetype="template">
   always @(negedge &lt;clock&gt;) begin
      &lt;reg&gt; &lt;= ~&lt;reg&gt;;
   end
						</Template>
						<Template label="w/ Synchronous Active High Reset" treetype="template">
   always @(negedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else begin
         &lt;reg&gt; &lt;= ~&lt;reg&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active High Reset and CE" treetype="template">
   always @(negedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else if (&lt;clock_enable&gt;) begin
         &lt;reg&gt; &lt;= ~&lt;reg&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active Low Reset" treetype="template">
   always @(negedge &lt;clock&gt;)
      if (!&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else begin
         &lt;reg&gt; &lt;= ~&lt;reg&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active Low Reset and CE" treetype="template">
   always @(negedge &lt;clock&gt; )
      if (!&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else if (&lt;clock_enable&gt;) begin
         &lt;reg&gt; &lt;= ~&lt;reg&gt;;
      end
						</Template>
					</SubFolder>
					<SubFolder label="Posedge" treetype="folder">
						<Template label="Simple Register" treetype="template">
   always @(posedge &lt;clock&gt;) begin
      &lt;reg&gt; &lt;= ~&lt;reg&gt;;
   end
						</Template>
						<Template label="w/ Synchronous Active High Reset" treetype="template">
   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else begin
         &lt;reg&gt; &lt;= ~&lt;reg&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active High Reset and CE" treetype="template">
   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else if (&lt;clock_enable&gt;) begin
         &lt;reg&gt; &lt;= ~&lt;reg&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active Low Reset" treetype="template">
   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else begin
         &lt;reg&gt; &lt;= ~&lt;reg&gt;;
      end
						</Template>
						<Template label="w/ Synchronous Active Low Reset and CE" treetype="template">
   always @(posedge &lt;clock&gt; )
      if (!&lt;reset&gt;) begin
         &lt;reg&gt; &lt;= 1'b0;
      end else if (&lt;clock_enable&gt;) begin
         &lt;reg&gt; &lt;= ~&lt;reg&gt;;
      end
						</Template>
					</SubFolder>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Logical Shifters" treetype="folder">
				<Template label="2-bit select" treetype="template">
// The following contains SystemVerilog constructs and should not be used if using a tool that does not support this standard
   logic [3:0] &lt;data_out&gt;;

   always @*
      case (&lt;2-bit_select&gt;)
         2'b00  : &lt;data_out&gt; = &lt;data_in&gt;;
         2'b01  : &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 1;
         2'b10  : &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 2;
         default: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 3;
      endcase
				</Template>
				<Template label="3-bit select" treetype="template">
// The following contains SystemVerilog constructs and should not be used if using a tool that does not support this standard
   logic [7:0] &lt;data_out&gt;;

   always @*
      case (&lt;3-bit_select&gt;)
         3'b000 : &lt;data_out&gt; = &lt;data_in&gt;;
         3'b001 : &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 1;
         3'b010 : &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 2;
         3'b011 : &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 3;
         3'b100 : &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 4;
         3'b101 : &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 5;
         3'b110 : &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 6;
         default: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 7;
      endcase
				</Template>
				<Template label="4-bit select" treetype="template">
// The following contains SystemVerilog constructs and should not be used if using a tool that does not support this standard
   logic [15:0] &lt;data_out&gt;;

   always @*
      case (&lt;4-bit_select&gt;)
         4'b0000: &lt;data_out&gt; = &lt;data_in&gt;;
         4'b0001: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 1;
         4'b0010: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 2;
         4'b0011: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 3;
         4'b0100: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 4;
         4'b0101: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 5;
         4'b0110: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 6;
         4'b0111: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 7;
         4'b1000: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 8;
         4'b1001: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 9;
         4'b1010: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 10;
         4'b1011: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 11;
         4'b1100: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 12;
         4'b1101: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 13;
         4'b1110: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 14;
         default: &lt;data_out&gt; = &lt;data_in&gt; &lt;&lt; 15;
      endcase
				</Template>
			</SubFolder>
			<SubFolder label="Misc" treetype="folder">
				<Template label="7-Segment Display Hex Conversion" treetype="template">
// 7-segment encoding
//      0
//     ---
//  5 |   | 1
//     --- &lt;--6
//  4 |   | 2
//     ---
//      3

   always @(&lt;4-bit_hex_input&gt;)
      case (&lt;4-bit_hex_input&gt;)
          4'b0001 : &lt;7-seg_output&gt; = 7'b1111001;   // 1
          4'b0010 : &lt;7-seg_output&gt; = 7'b0100100;   // 2
          4'b0011 : &lt;7-seg_output&gt; = 7'b0110000;   // 3
          4'b0100 : &lt;7-seg_output&gt; = 7'b0011001;   // 4
          4'b0101 : &lt;7-seg_output&gt; = 7'b0010010;   // 5
          4'b0110 : &lt;7-seg_output&gt; = 7'b0000010;   // 6
          4'b0111 : &lt;7-seg_output&gt; = 7'b1111000;   // 7
          4'b1000 : &lt;7-seg_output&gt; = 7'b0000000;   // 8
          4'b1001 : &lt;7-seg_output&gt; = 7'b0010000;   // 9
          4'b1010 : &lt;7-seg_output&gt; = 7'b0001000;   // A
          4'b1011 : &lt;7-seg_output&gt; = 7'b0000011;   // b
          4'b1100 : &lt;7-seg_output&gt; = 7'b1000110;   // C
          4'b1101 : &lt;7-seg_output&gt; = 7'b0100001;   // d
          4'b1110 : &lt;7-seg_output&gt; = 7'b0000110;   // E
          4'b1111 : &lt;7-seg_output&gt; = 7'b0001110;   // F
          default : &lt;7-seg_output&gt; = 7'b1000000;   // 0
      endcase
				</Template>
				<Template label="Asynchronous Input Synchronization (Reduces Issues w/ Metastability)" treetype="template">
// Asynchronous Input Synchronization
//
// The following code is an example of synchronizing an asynchronous input
// of a design to reduce the probability of metastability affecting a circuit.
//
// The following synthesis and implementation attributes is added to the code
// in order improve the MTBF characteristics of the implementation:
//
//  ASYNC_REG="TRUE" - Specifies registers will be receiving asynchronous data
//                     input to allow tools to report and improve metastability
//
// The following parameters are available for customization:
//
//   SYNC_STAGES     - Integer value for number of synchronizing registers, must be 2 or higher
//   PIPELINE_STAGES - Integer value for number of registers on the output of the
//                     synchronizer for the purpose of improveing performance.
//                     Particularly useful for high-fanout nets.
//   INIT            - Initial value of synchronizer registers upon startup, 1'b0 or 1'b1.

   parameter SYNC_STAGES = 3;
   parameter PIPELINE_STAGES = 1;
   parameter INIT = 1'b0;

   wire &lt;sync_out&gt;;

   (* ASYNC_REG="TRUE" *) reg [SYNC_STAGES-1:0] sreg = {SYNC_STAGES{INIT}};

   always @(posedge clk)
     sreg &lt;= {sreg[SYNC_STAGES-2:0], async_in};

   generate
      if (PIPELINE_STAGES==0) begin: no_pipeline

         assign sync_out = sreg[SYNC_STAGES-1];

      end else if (PIPELINE_STAGES==1) begin: one_pipeline

         reg sreg_pipe = INIT;

         always @(posedge clk)
            sreg_pipe &lt;= sreg[SYNC_STAGES-1];

         assign sync_out = sreg_pipe;

      end else begin: multiple_pipeline

        (* shreg_extract = "no" *) reg [PIPELINE_STAGES-1:0] sreg_pipe = {PIPELINE_STAGES{INIT}};

         always @(posedge clk)
            sreg_pipe &lt;= {sreg_pipe[PIPELINE_STAGES-2:0], sreg[SYNC_STAGES-1]};

         assign sync_out = sreg_pipe[PIPELINE_STAGES-1];

      end
   endgenerate
				</Template>
				<Template label="One-shot, Debounce Circuit" treetype="template">
   reg [2:0] &lt;reg_name&gt; = 3'b000;

   always @(posedge &lt;clock&gt;)
      if (reset == 1)
         &lt;reg_name&gt; &lt;= 3'b000;
      else
         &lt;reg_name&gt; &lt;= {&lt;reg_name&gt;[1:0], &lt;input&gt;};

   assign &lt;output&gt; = &lt;reg_name&gt;[0] &amp; &lt;reg_name&gt;[1] &amp; !&lt;reg_name&gt;[2];
				</Template>
				<Template label="Open Drain Output (bused reg)" treetype="template">
   integer i;

   always @*
      for (i = 0; i &lt;= &lt;upper_val&gt;; i=i+1)
         &lt;output&gt;[i] = &lt;internal_out&gt;[i] ? 1'bz : 1'b0;
				</Template>
				<Template label="Open Drain Output (single signal)" treetype="template">
   assign &lt;output&gt; = &lt;internal_out&gt; ? 1'bz : 1'b0;
				</Template>
				<Template label="Output Clock forwarding Using DDR" treetype="template">
   // Clock forwarding circuit using the double data-rate register
   //       Xilinx 7series
   // Xilinx HDL Language Template, version 2016.4

   ODDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE" or "SAME_EDGE" 
      .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) clock_forward_inst (
      .Q(&lt;output_clock&gt;),   // 1-bit DDR output
      .C(&lt;internal_clock&gt;), // 1-bit clock input
      .CE(&lt;stop_clock&gt;),    // 1-bit clock enable input
      .D1(1'b0), // 1-bit data input (positive edge)
      .D2(1'b1), // 1-bit data input (negative edge)
      .R(&lt;hold_clock_low&gt;), // 1-bit reset
      .S(&lt;hold_clock_high&gt;) // 1-bit set
   );

   // End of clock_forward_inst instantiation
				</Template>
				<Template label="Output Clock forwarding Using DDR (Info)" treetype="template">
//  A common method for supplying an external clock from the FPGA to drive
//  other devices on the PCB board is to use clock forwarding via a double
//  data-rate register.  This provides an external clock with a relatively
//  small offset delay and does not consume any additional DLL/DCM/PLL/MMCM, clock
//  buffers or input pins.  The basic technique is to supply the input clock
//  to an output DDR register where one value is tied to a logic 0 and the
//  other is tied to a logic 1.  A clock can be made with the same phase
//  relationship (plus the added offset delay) or 180 degrees out of phase by
//  changing the 1 and 0 values to the inputs to the DDR register.  Set SRTYPE
//  to "SYNC" to avoid possible glitches on the clock if the set/reset signals
//  are used.  for FPGA architectures which use two separate clocks into the
//  DDR register, you may use a simple inversion of duty-cycle is not important
//  however for output clocks that you wish to retain the duty-cycle as much as
//  possible, it is suggested to supply a 0 degree and 180 degree clock from a
//  DLL/DCM/PLL/MMCM to the input clocks to the output DDR component.

				</Template>
				<Template label="Pulse Width Modulation Circuit" treetype="template">
   parameter PWM_PRECISION_WIDTH = &lt;value&gt;;

   reg &lt;pwm_output&gt; = 1'b0;
   reg [PWM_PRECISION_WIDTH-1:0] &lt;duty_cycle_reg&gt; = {PWM_PRECISION_WIDTH{1'b0}};
   reg [PWM_PRECISION_WIDTH-1:0] &lt;temp_reg&gt; = {PWM_PRECISION_WIDTH{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;duty_cycle_reg&gt; &lt;= 0;
      else if (&lt;new_duty_cycle&gt;)
         &lt;duty_cycle_reg&gt; &lt;= &lt;new_duty_cycle&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;temp_reg&gt; &lt;= 0;
      else if (&amp;&lt;temp_reg&gt;)
         &lt;temp_reg&gt; &lt;= &lt;duty_cycle_reg&gt;;
      else if (&lt;pwm_output&gt;)
         &lt;temp_reg&gt; &lt;= &lt;temp_reg&gt; + 1;
      else
         &lt;temp_reg&gt; &lt;= &lt;temp_reg&gt; - 1;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;pwm_output&gt; &lt;= 1'b0;
      else if (&amp;&lt;temp_reg&gt;)
         &lt;pwm_output&gt; &lt;= ~&lt;pwm_output&gt;;
				</Template>
			</SubFolder>
			<SubFolder label="Multiplexers" treetype="folder">
				<SubFolder label="Combinatorial" treetype="folder">
					<Template label="2-to-1 (assign)" treetype="template">
   assign &lt;output_wire&gt; = &lt;1-bit_select&gt; ? &lt;input1&gt; : &lt;input0&gt;;
					</Template>
					<Template label="4-to-1 (always)" treetype="template">
   always @(&lt;2-bit_select&gt;, &lt;input1&gt;, &lt;input2&gt;, &lt;input3&gt;, &lt;input4&gt;)
      case (&lt;2-bit_select&gt;)
         2'b00: &lt;output&gt; = &lt;input1&gt;;
         2'b01: &lt;output&gt; = &lt;input2&gt;;
         2'b10: &lt;output&gt; = &lt;input3&gt;;
         2'b11: &lt;output&gt; = &lt;input4&gt;;
      endcase
					</Template>
					<Template label="8-to-1 (always)" treetype="template">
   always @(&lt;3-bit_select&gt;, &lt;input1&gt;, &lt;input2&gt;, &lt;input3&gt;, &lt;input4&gt;, &lt;input5&gt;,
            &lt;input6&gt;, &lt;input7&gt;, &lt;input8&gt;)
      case (&lt;3-bit_select&gt;)
         3'b000: &lt;output&gt; = &lt;input1&gt;;
         3'b001: &lt;output&gt; = &lt;input2&gt;;
         3'b010: &lt;output&gt; = &lt;input3&gt;;
         3'b011: &lt;output&gt; = &lt;input4&gt;;
         3'b100: &lt;output&gt; = &lt;input5&gt;;
         3'b101: &lt;output&gt; = &lt;input6&gt;;
         3'b110: &lt;output&gt; = &lt;input7&gt;;
         3'b111: &lt;output&gt; = &lt;input8&gt;;
      endcase
					</Template>
				</SubFolder>
				<SubFolder label="Synchronous" treetype="folder">
					<Template label="2-to-1" treetype="template">
   always @(posedge &lt;clock&gt;)
      if (&lt;1-bit_select&gt;)
         &lt;output_wire&gt; &lt;= &lt;input1&gt;;
      else
         &lt;output_wire&gt; &lt;= &lt;input0&gt;;
					</Template>
					<Template label="4-to-1" treetype="template">
   always @(posedge &lt;clock&gt;)
      case (&lt;2-bit_select&gt;)
         2'b00: &lt;output&gt; &lt;= &lt;input1&gt;;
         2'b01: &lt;output&gt; &lt;= &lt;input2&gt;;
         2'b10: &lt;output&gt; &lt;= &lt;input3&gt;;
         2'b11: &lt;output&gt; &lt;= &lt;input4&gt;;
      endcase
					</Template>
					<Template label="8-to-1" treetype="template">
   always @(posedge &lt;clock&gt;)
      case (&lt;3-bit_select&gt;)
         3'b000: &lt;output&gt; &lt;= &lt;input1&gt;;
         3'b001: &lt;output&gt; &lt;= &lt;input2&gt;;
         3'b010: &lt;output&gt; &lt;= &lt;input3&gt;;
         3'b011: &lt;output&gt; &lt;= &lt;input4&gt;;
         3'b100: &lt;output&gt; &lt;= &lt;input5&gt;;
         3'b101: &lt;output&gt; &lt;= &lt;input6&gt;;
         3'b110: &lt;output&gt; &lt;= &lt;input7&gt;;
         3'b111: &lt;output&gt; &lt;= &lt;input8&gt;;
      endcase
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<SubFolder label="Simple Dual Port" treetype="folder">
						<Template label="1 Clock" treetype="template">
  //  Xilinx Simple Dual Port Single Clock RAM
  //  This code implements a parameterizable SDP single clock memory.
  //  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;; // Write address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;; // Read address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;          // RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                          // Clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                           // Write enable
  &lt;wire_or_reg&gt; &lt;enb&gt;;                           // Read Enable, for additional power savings, disable when not in use
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                          // Output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                        // Output register enable
  wire [RAM_WIDTH-1:0] &lt;doutb&gt;;                  // RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;) begin
    if (&lt;wea&gt;)
      &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
    if (enb)
      &lt;ram_data&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];
  end

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;doutb&gt; = &lt;ram_data&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data&gt;;

      assign &lt;doutb&gt; = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
						</Template>
						<Template label="1 Clock w/ Byte-write" treetype="template">
  //  Xilinx Simple Dual Port Single Clock RAM with Byte-write
  //  This code implements a parameterizable SDP single clock memory.
  //  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter NB_COL = &lt;col&gt;;                       // Specify number of columns (number of bytes)
  parameter COL_WIDTH = &lt;width&gt;;                  // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;; // Write address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;; // Read address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dina&gt;; // RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                          // Clock
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;wea&gt;;              // Byte-write enable
  &lt;wire_or_reg&gt; &lt;enb&gt;;                           // Read Enable, for additional power savings, disable when not in use
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                          // Output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                        // Output register enable
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;doutb&gt;;         // RAM output data

  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data&gt; = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;enb&gt;)
      &lt;ram_data&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge &lt;clka&gt;)
         if (&lt;wea&gt;[i])
           &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
      end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;doutb&gt; = &lt;ram_data&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data&gt;;

      assign &lt;doutb&gt; = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
						</Template>
						<Template label="2 Clock" treetype="template">
  //  Xilinx Simple Dual Port 2 Clock RAM
  //  This code implements a parameterizable SDP dual clock memory.
  //  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;; // Write address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;; // Read address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;          // RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                          // Write clock
  &lt;wire_or_reg&gt; &lt;clkb&gt;;                          // Read clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                           // Write enable
  &lt;wire_or_reg&gt; &lt;enb&gt;;                           // Read Enable, for additional power savings, disable when not in use
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                          // Output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                        // Output register enable
  wire [RAM_WIDTH-1:0] &lt;doutb&gt;;                  // RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;wea&gt;)
      &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;

  always @(posedge &lt;clkb&gt;)
    if (&lt;enb&gt;)
      &lt;ram_data&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;doutb&gt; = &lt;ram_data&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clkb&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data&gt;;

      assign &lt;doutb&gt; = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
						</Template>
						<Template label="2 Clock w/ Byte-write" treetype="template">
  //  Xilinx Simple Dual Port 2 Clock RAM with Byte-write
  //  This code implements a parameterizable SDP dual clock memory.
  //  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter NB_COL = &lt;col&gt;;                       // Specify number of columns (number of bytes)
  parameter COL_WIDTH = &lt;width&gt;;                  // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;   // Write address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;   // Read address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dina&gt;;   // RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                            // Write clock
  &lt;wire_or_reg&gt; &lt;clkb&gt;;                            // Read clock
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;wea&gt;;                // Byte-write enable
  &lt;wire_or_reg&gt; &lt;enb&gt;;  			   // Read Enable, for additional power savings, disable when not in use
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                            // Output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                          // Output register enable
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;doutb&gt;;           // RAM output data

  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data&gt; = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge &lt;clkb&gt;)
    if (&lt;enb&gt;)
      &lt;ram_data&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge &lt;clka&gt;)
         if (&lt;wea&gt;[i])
           &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
      end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;doutb&gt; = &lt;ram_data&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge &lt;clkb&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data&gt;;

      assign &lt;doutb&gt; = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
						</Template>
					</SubFolder>
					<SubFolder label="Single Port" treetype="folder">
						<SubFolder label="Byte-wide Write Enable" treetype="folder">
							<Template label="Read First Mode" treetype="template">
  //  Xilinx Single Port Byte-Write Read First RAM
  //  This code implements a parameterizable single-port byte-write read-first memory where when data
  //  is written to the memory, the output reflects the prior contents of the memory location.
  //  If a reset or enable is not necessary, it may be tied off or removed from the code.
  //  Modify the parameters for the desired RAM characteristics.

  parameter NB_COL = &lt;col&gt;;                       // Specify number of columns (number of bytes)
  parameter COL_WIDTH = &lt;width&gt;;                  // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dina&gt;;  // RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Clock
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;wea&gt;;               // Byte-write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Output register enable
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;douta&gt;;          // RAM output data

  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data&gt; = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;) begin
      &lt;ram_data&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];
    end

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge &lt;clka&gt;)
         if (&lt;ena&gt;)
           if (&lt;wea&gt;[i])
             &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
      end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data&gt;;

      assign &lt;douta&gt; = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
							<Template label="Write First Mode" treetype="template">
  //  Xilinx Single Port Byte-Write Write First RAM
  //  This code implements a parameterizable single-port byte-write write-first memory where when data
  //  is written to the memory, the output reflects the new memory contents.
  //  If a reset or enable is not necessary, it may be tied off or removed from the code.
  //  Modify the parameters for the desired RAM characteristics.

  parameter NB_COL = &lt;col&gt;;                       // Specify number of columns (number of bytes)
  parameter COL_WIDTH = &lt;width&gt;;                  // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dina&gt;;  // RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Clock
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;wea&gt;;               // Byte-write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Output register enable
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;douta&gt;;          // RAM output data

  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data&gt; = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge &lt;clka&gt;)
         if (&lt;ena&gt;)
           if (&lt;wea&gt;[i]) begin
             &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             &lt;ram_data&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else
             &lt;ram_data&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;ram_name&gt;[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH];

      end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data&gt;;

      assign &lt;douta&gt; = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
						</SubFolder>
						<Template label="No Change Mode" treetype="template">
  //  Xilinx Single Port No Change RAM
  //  This code implements a parameterizable single-port no-change memory where when data is written
  //  to the memory, the output remains unchanged.  This is the most power efficient write mode.
  //  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;           // RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                            // Write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Output register enable
  wire [RAM_WIDTH-1:0] &lt;douta&gt;;                   // RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;)
      if (&lt;wea&gt;)
        &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
      else
        &lt;ram_data&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data&gt;;

      assign &lt;douta&gt; = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
						</Template>
						<Template label="Read First Mode" treetype="template">
  //  Xilinx Single Port Read First RAM
  //  This code implements a parameterizable single-port read-first memory where when data
  //  is written to the memory, the output reflects the prior contents of the memory location.
  //  If the output data is not needed during writes or the last read value is desired to be
  //  retained, it is suggested to set WRITE_MODE to NO_CHANGE as it is more power efficient.
  //  If a reset or enable is not necessary, it may be tied off or removed from the code.
  //  Modify the parameters for the desired RAM characteristics.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;           // RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                            // Write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Output register enable
  wire [RAM_WIDTH-1:0] &lt;douta&gt;;                   // RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;) begin
      if (&lt;wea&gt;)
        &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
      &lt;ram_data&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];
    end

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data&gt;;

      assign &lt;douta&gt; = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
						</Template>
						<Template label="Write First Mode" treetype="template">
  //  Xilinx Single Port Write First RAM
  //  This code implements a parameterizable single-port write-first memory where when data
  //  is written to the memory, the output reflects the same data being written to the memory.
  //  If the output data is not needed during writes or the last read value is desired to be
  //  it is suggested to use a No Change as it is more power efficient.
  //  If a reset or enable is not necessary, it may be tied off or removed from the code.
  //  Modify the parameters for the desired RAM characteristics.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;           // RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                            // Write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;; 			  // Output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Output register enable
  wire [RAM_WIDTH-1:0] &lt;douta&gt;;                   // RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;)
      if (&lt;wea&gt;) begin
        &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
        &lt;ram_data&gt; &lt;= &lt;dina&gt;;
      end else
        &lt;ram_data&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regcea?)
          douta_reg &lt;= &lt;ram_data&gt;;

      assign &lt;douta&gt; = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
						</Template>
					</SubFolder>
					<SubFolder label="True Dual Port" treetype="folder">
						<SubFolder label="1 Clock" treetype="folder">
							<Template label="No Change Mode" treetype="template">
//  Xilinx True Dual Port RAM No Change Single Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  This is a no change RAM which retains the last read value on the output during writes
//  which is the most power efficient mode.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;  // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;           // Port A RAM input data
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dinb&gt;;           // Port B RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                            // Port A write enable
  &lt;wire_or_reg&gt; &lt;web&gt;;                            // Port B write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // Port A RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;enb&gt;;                            // Port B RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                           // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Port A output register enable
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                         // Port B output register enable
  wire [RAM_WIDTH-1:0] &lt;douta&gt;;                   // Port A RAM output data
  wire [RAM_WIDTH-1:0] &lt;doutb&gt;;                   // Port B RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data_a&gt; = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] &lt;ram_data_b&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;)
      if (&lt;wea&gt;)
        &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
      else
        &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];

  always @(posedge &lt;clka&gt;)
    if (&lt;enb&gt;)
      if (&lt;web&gt;)
        &lt;ram_name&gt;[&lt;addrb&gt;] &lt;= &lt;dinb&gt;;
      else
        &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clka&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = &lt;douta_reg&gt;;
      assign &lt;doutb&gt; = &lt;doutb_reg&gt;;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
							<Template label="Read First Mode" treetype="template">
//  Xilinx True Dual Port RAM Read First Single Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the prior memory contents at the write
//  address are presented on the output port.  If the output data is
//  not needed during writes or the last read value is desired to be retained,
//  it is suggested to use a no change RAM as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;  // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;           // Port A RAM input data
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dinb&gt;;           // Port B RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                            // Port A write enable
  &lt;wire_or_reg&gt; &lt;web&gt;;                            // Port B write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // Port A RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;enb&gt;;                            // Port B RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                           // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Port A output register enable
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                         // Port B output register enable
  wire [RAM_WIDTH-1:0] &lt;douta&gt;;                   // Port A RAM output data
  wire [RAM_WIDTH-1:0] &lt;doutb&gt;;                   // Port B RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data_a&gt; = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] &lt;ram_data_b&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;) begin
      if (&lt;wea&gt;)
        &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
      &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];
    end

  always @(posedge &lt;clka&gt;)
    if (&lt;enb&gt;) begin
      if (&lt;web&gt;)
        &lt;ram_name&gt;[&lt;addrb&gt;] &lt;= &lt;dinb&gt;;
      &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];
    end

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clka&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = &lt;douta_reg&gt;;
      assign &lt;doutb&gt; = &lt;doutb_reg&gt;;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
							<Template label="Read First Mode w/ Byte-write" treetype="template">
//  Xilinx True Dual Port RAM Byte Write Read First Single Clock RAM
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the prior memory contents at the write
//  address are presented on the output port.

  parameter NB_COL = &lt;col&gt;;                       // Specify number of columns (number of bytes)
  parameter COL_WIDTH = &lt;width&gt;;                  // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;   // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;   // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dina&gt;;   // Port A RAM input data
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dinb&gt;;   // Port B RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                            // Clock
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;wea&gt;;                // Port A write enable
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;web&gt;;                // Port B write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                             // Port A RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;enb&gt;;                             // Port B RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;				 // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                            // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                          // Port A output register enable
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                          // Port B output register enable
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;douta&gt;; // Port A RAM output data
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;doutb&gt;; // Port B RAM output data

  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data_a&gt; = {(NB_COL*COL_WIDTH){1'b0}};
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data_b&gt; = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;) begin
      &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];
    end

  always @(posedge &lt;clka&gt;)
    if (&lt;enb&gt;) begin
      &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];
    end

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge &lt;clka&gt;)
         if (&lt;ena&gt;)
           if (&lt;wea&gt;[i])
             &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
       always @(posedge &lt;clka&gt;)
         if (&lt;enb&gt;)
           if (&lt;web&gt;[i])
             &lt;ram_name&gt;[&lt;addrb&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dinb&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};
      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clka&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = douta_reg;
      assign &lt;doutb&gt; = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
							<Template label="Write First Mode" treetype="template">
//  Xilinx True Dual Port RAM Write First Single Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  This implements write-first mode where the data being written to the RAM also resides on
//  the output port.  If the output data is not needed during writes or the last read value is
//  desired to be retained, it is suggested to use no change as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;  // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;           // Port A RAM input data
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dinb&gt;;           // Port B RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                            // Port A write enable
  &lt;wire_or_reg&gt; &lt;web&gt;;                            // Port B write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // Port A RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;enb&gt;;                            // Port B RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                           // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Port A output register enable
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                         // Port B output register enable
  wire [RAM_WIDTH-1:0] &lt;douta&gt;;                   // Port A RAM output data
  wire [RAM_WIDTH-1:0] &lt;doutb&gt;;                   // Port B RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data_a&gt; = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] &lt;ram_data_b&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;)
      if (&lt;wea&gt;) begin
        &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
        &lt;ram_data_a&gt; &lt;= &lt;dina&gt;;
      end else
        &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];

  always @(posedge &lt;clka&gt;)
    if (&lt;enb&gt;)
      if (&lt;web&gt;) begin
        &lt;ram_name&gt;[&lt;addrb&gt;] &lt;= &lt;dinb&gt;;
        &lt;ram_data_b&gt; &lt;= &lt;dinb&gt;;
      end else
        &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clka&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = &lt;douta_reg&gt;;
      assign &lt;doutb&gt; = &lt;doutb_reg&gt;;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
							<Template label="Write First Mode w/ Byte-write" treetype="template">
//  Xilinx True Dual Port RAM Byte Write, Write First Single Clock RAM
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the new memory contents at the write
//  address are presented on the output port.

  parameter NB_COL = &lt;col&gt;;                       // Specify number of columns (number of bytes)
  parameter COL_WIDTH = &lt;width&gt;;                  // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;  // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dina&gt;;  // Port A RAM input data
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dinb&gt;;  // Port B RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Clock
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;wea&gt;;               // Port A write enable
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;web&gt;;		  // Port B write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // Port A RAM Enable, for additional power savings, disable BRAM when not in use
  &lt;wire_or_reg&gt; &lt;enb&gt;;                            // Port B RAM Enable, for additional power savings, disable BRAM when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                           // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Port A output register enable
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                         // Port B output register enable
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;douta&gt;; // Port A RAM output data
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;doutb&gt;; // Port B RAM output data

  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data_a&gt; = {(NB_COL*COL_WIDTH){1'b0}};
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data_b&gt; = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge &lt;clka&gt;)
         if (&lt;ena&gt;)
           if (&lt;wea&gt;[i]) begin
             &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             &lt;ram_data_a&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else begin
             &lt;ram_data_a&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end

       always @(posedge &lt;clka&gt;)
         if (&lt;enb&gt;)
           if (&lt;web&gt;[i]) begin
             &lt;ram_name&gt;[&lt;addrb&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dinb&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             &lt;ram_data_b&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dinb&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else begin
             &lt;ram_data_b&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;ram_name&gt;[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end
     end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};
      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regcea)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clka&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = douta_reg;
      assign &lt;doutb&gt; = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
						</SubFolder>
						<SubFolder label="2 Clock" treetype="folder">
							<Template label="No Change Mode" treetype="template">
//  Xilinx True Dual Port RAM No Change Dual Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  This is a no change RAM which retains the last read value on the output during writes
//  which is the most power efficient mode.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;  // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;           // Port A RAM input data
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dinb&gt;;           // Port B RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Port A clock
  &lt;wire_or_reg&gt; &lt;clkb&gt;;                           // Port B clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                            // Port A write enable
  &lt;wire_or_reg&gt; &lt;web&gt;;                            // Port B write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // Port A RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;enb&gt;;                            // Port B RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                           // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Port A output register enable
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                         // Port B output register enable
  wire [RAM_WIDTH-1:0] &lt;douta&gt;;                   // Port A RAM output data
  wire [RAM_WIDTH-1:0] &lt;doutb&gt;;                   // Port B RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data_a&gt; = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] &lt;ram_data_b&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;)
      if (&lt;wea&gt;)
        &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
      else
        &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];

  always @(posedge &lt;clkb&gt;)
    if (&lt;enb&gt;)
      if (&lt;web&gt;)
        &lt;ram_name&gt;[&lt;addrb&gt;] &lt;= &lt;dinb&gt;;
      else
        &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clkb&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = &lt;douta_reg&gt;;
      assign &lt;doutb&gt; = &lt;doutb_reg&gt;;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
							<Template label="Read First Mode" treetype="template">
//  Xilinx True Dual Port RAM Read First Dual Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the prior memory contents at the write
//  address are presented on the output port.  If the output data is
//  not needed during writes or the last read value is desired to be retained,
//  it is suggested to use a no change RAM as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;  // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dina&gt;;           // Port A RAM input data
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] &lt;dinb&gt;;           // Port B RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Port A clock
  &lt;wire_or_reg&gt; &lt;clkb&gt;;                           // Port B clock
  &lt;wire_or_reg&gt; &lt;wea&gt;;                            // Port A write enable
  &lt;wire_or_reg&gt; &lt;web&gt;;                            // Port B write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // Port A RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;enb&gt;;                            // Port B RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                           // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Port A output register enable
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                         // Port B output register enable
  wire [RAM_WIDTH-1:0] &lt;douta&gt;;                   // Port A RAM output data
  wire [RAM_WIDTH-1:0] &lt;doutb&gt;;                   // Port B RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data_a&gt; = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] &lt;ram_data_b&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;) begin
      if (&lt;wea&gt;)
        &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
      &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];
    end

  always @(posedge &lt;clkb&gt;)
    if (&lt;enb&gt;) begin
      if (&lt;web&gt;)
        &lt;ram_name&gt;[&lt;addrb&gt;] &lt;= &lt;dinb&gt;;
      &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];
    end

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clkb&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = &lt;douta_reg&gt;;
      assign &lt;doutb&gt; = &lt;doutb_reg&gt;;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
							<Template label="Read First Mode w/ Byte-write" treetype="template">
//  Xilinx True Dual Port RAM Byte Write Read First Dual Clock RAM
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the prior memory contents at the write
//  address are presented on the output port.

  parameter NB_COL = &lt;col&gt;;                       // Specify number of columns (number of bytes)
  parameter COL_WIDTH = &lt;width&gt;;                  // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;   // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;   // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dina&gt;;   // Port A RAM input data
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dinb&gt;;   // Port B RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                            // Port A clock
  &lt;wire_or_reg&gt; &lt;clkb&gt;;                            // Port B clock
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;wea&gt;;                // Port A write enable
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;web&gt;;                // Port B write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                             // Port A RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;enb&gt;;                             // Port B RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;				 // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                            // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                          // Port A output register enable
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                          // Port B output register enable
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;douta&gt;; // Port A RAM output data
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;doutb&gt;; // Port B RAM output data

  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data_a&gt; = {(NB_COL*COL_WIDTH){1'b0}};
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data_b&gt; = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;) begin
      &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];
    end

  always @(posedge &lt;clkb&gt;)
    if (&lt;enb&gt;) begin
      &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];
    end

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge &lt;clka&gt;)
         if (&lt;ena&gt;)
           if (&lt;wea&gt;[i])
             &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
       always @(posedge &lt;clkb&gt;)
         if (&lt;enb&gt;)
           if (&lt;web&gt;[i])
             &lt;ram_name&gt;[&lt;addrb&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dinb&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};
      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clkb&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = douta_reg;
      assign &lt;doutb&gt; = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
							<Template label="Write First Mode" treetype="template">
//  Xilinx True Dual Port RAM Write First Dual Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  This implements write-first mode where the data being written to the RAM also resides on
//  the output port.  If the output data is not needed during writes or the last read value is
//  desired to be retained, it is suggested to use no change as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

  parameter RAM_WIDTH = &lt;width&gt;;                  // Specify RAM data width
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] addra;  // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] addrb;  // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] dina;           // Port A RAM input data
  &lt;wire_or_reg&gt; [RAM_WIDTH-1:0] dinb;           // Port B RAM input data
  &lt;wire_or_reg&gt; clka;                           // Port A clock
  &lt;wire_or_reg&gt; clkb;                           // Port B clock
  &lt;wire_or_reg&gt; wea;                            // Port A write enable
  &lt;wire_or_reg&gt; web;                            // Port B write enable
  &lt;wire_or_reg&gt; ena;                            // Port A RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; enb;                            // Port B RAM Enable, for additional power savings, disable port when not in use
  &lt;wire_or_reg&gt; rsta;                           // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; rstb;                           // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; regcea;                         // Port A output register enable
  &lt;wire_or_reg&gt; regceb;                         // Port B output register enable
  wire [RAM_WIDTH-1:0] douta;                   // Port A RAM output data
  wire [RAM_WIDTH-1:0] doutb;                   // Port B RAM output data

  reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] &lt;ram_data_a&gt; = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] &lt;ram_data_b&gt; = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge &lt;clka&gt;)
    if (&lt;ena&gt;)
      if (&lt;wea&gt;) begin
        &lt;ram_name&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
        &lt;ram_data_a&gt; &lt;= &lt;dina&gt;;
      end else
        &lt;ram_data_a&gt; &lt;= &lt;ram_name&gt;[&lt;addra&gt;];

  always @(posedge &lt;clkb&gt;)
    if (&lt;enb&gt;)
      if (&lt;web&gt;) begin
        &lt;ram_name&gt;[&lt;addrb&gt;] &lt;= &lt;dinb&gt;;
        &lt;ram_data_b&gt; &lt;= &lt;dinb&gt;;
      end else
        &lt;ram_data_b&gt; &lt;= &lt;ram_name&gt;[&lt;addrb&gt;];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regcea&gt;)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clkb&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = douta_reg;
      assign &lt;doutb&gt; = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
							<Template label="Write First Mode w/ Byte-write" treetype="template">
//  Xilinx True Dual Port RAM Byte Write, Write First Dual Clock RAM
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the new memory contents at the write
//  address are presented on the output port.

  parameter NB_COL = &lt;col&gt;;                       // Specify number of columns (number of bytes)
  parameter COL_WIDTH = &lt;width&gt;;                  // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = &lt;depth&gt;;                  // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE"; // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = "";                       // Specify name/location of RAM initialization file if using one (leave blank if not)

  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addra&gt;;  // Port A address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [clogb2(RAM_DEPTH-1)-1:0] &lt;addrb&gt;;  // Port B address bus, width determined from RAM_DEPTH
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dina&gt;;  // Port A RAM input data
  &lt;wire_or_reg&gt; [(NB_COL*COL_WIDTH)-1:0] &lt;dinb&gt;;  // Port B RAM input data
  &lt;wire_or_reg&gt; &lt;clka&gt;;                           // Port A clock
  &lt;wire_or_reg&gt; &lt;clkb&gt;;                           // Port B clock
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;wea&gt;;               // Port A write enable
  &lt;wire_or_reg&gt; [NB_COL-1:0] &lt;web&gt;;		  // Port B write enable
  &lt;wire_or_reg&gt; &lt;ena&gt;;                            // Port A RAM Enable, for additional power savings, disable BRAM when not in use
  &lt;wire_or_reg&gt; &lt;enb&gt;;                            // Port B RAM Enable, for additional power savings, disable BRAM when not in use
  &lt;wire_or_reg&gt; &lt;rsta&gt;;                           // Port A output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;rstb&gt;;                           // Port B output reset (does not affect memory contents)
  &lt;wire_or_reg&gt; &lt;regcea&gt;;                         // Port A output register enable
  &lt;wire_or_reg&gt; &lt;regceb&gt;;                         // Port B output register enable
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;douta&gt;; // Port A RAM output data
  wire [(NB_COL*COL_WIDTH)-1:0] &lt;doutb&gt;; // Port B RAM output data

  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_name&gt; [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data_a&gt; = {(NB_COL*COL_WIDTH){1'b0}};
  reg [(NB_COL*COL_WIDTH)-1:0] &lt;ram_data_b&gt; = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, &lt;ram_name&gt;, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          &lt;ram_name&gt;[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge &lt;clka&gt;)
         if (&lt;ena&gt;)
           if (&lt;wea&gt;[i]) begin
             &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             &lt;ram_data_a&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dina&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else begin
             &lt;ram_data_a&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;ram_name&gt;[&lt;addra&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end

       always @(posedge &lt;clkb&gt;)
         if (&lt;enb&gt;)
           if (&lt;web&gt;[i]) begin
             &lt;ram_name&gt;[&lt;addrb&gt;][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dinb&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             &lt;ram_data_b&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;dinb&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else begin
             &lt;ram_data_b&gt;[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= &lt;ram_name&gt;[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end
     end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign &lt;douta&gt; = &lt;ram_data_a&gt;;
       assign &lt;doutb&gt; = &lt;ram_data_b&gt;;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};
      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge &lt;clka&gt;)
        if (&lt;rsta&gt;)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regcea)
          douta_reg &lt;= &lt;ram_data_a&gt;;

      always @(posedge &lt;clkb&gt;)
        if (&lt;rstb&gt;)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (&lt;regceb&gt;)
          doutb_reg &lt;= &lt;ram_data_b&gt;;

      assign &lt;douta&gt; = douta_reg;
      assign &lt;doutb&gt; = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Distributed RAM" treetype="folder">
					<Template label="Dual Port, Async Read" treetype="template">
   parameter RAM_WIDTH = &lt;ram_width&gt;;
   parameter RAM_ADDR_BITS = &lt;ram_addr_bits&gt;;

   (* ram_style="distributed" *)
   reg [RAM_WIDTH-1:0] &lt;ram_name&gt; [(2**RAM_ADDR_BITS)-1:0];

   wire [RAM_WIDTH-1:0] &lt;output_data&gt;;

   &lt;reg_or_wire&gt; [RAM_ADDR_BITS-1:0] &lt;read_address&gt;, &lt;write_address&gt;;
   &lt;reg_or_wire&gt; [RAM_WIDTH-1:0] &lt;input_data&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;write_enable&gt;)
         &lt;ram_name&gt;[&lt;write_address&gt;] &lt;= &lt;input_data&gt;;

   assign &lt;output_data&gt; = &lt;ram_name&gt;[&lt;read_address&gt;];
					</Template>
				</SubFolder>
				<SubFolder label="UltraRAM" treetype="folder">
					<Template label="Simple Dual Port" treetype="template">
//  Xilinx UltraRAM Simple Dual Port.  This code implements 
//  a parameterizable UltraRAM block with 1 Read and 1 write
//  when addra == addrb, old data will show at doutb 
parameter AWIDTH = 12;  // Address Width
parameter DWIDTH = 72;  // Data Width
parameter NBPIPE = 3;   // Number of pipeline Registers
&lt;wire_or_reg&gt; &lt;clk&gt;;                    // Clock 
&lt;wire_or_reg&gt; &lt;rstb&gt;;                   // Reset
&lt;wire_or_reg&gt; &lt;wea&gt;;                    // Write Enable
&lt;wire_or_reg&gt; &lt;regceb&gt;;                 // Output Register Enable
&lt;wire_or_reg&gt; &lt;mem_en&gt;;                 // Memory Enable
&lt;wire_or_reg&gt; [DWIDTH-1:0] &lt;dina&gt;;      // Data &lt;wire_or_reg&gt;  
&lt;wire_or_reg&gt; [AWIDTH-1:0] &lt;addra&gt;;     // Write Address
&lt;wire_or_reg&gt; [AWIDTH-1:0] &lt;addrb&gt;;     // Read  Address
reg [DWIDTH-1:0] &lt;doutb&gt;; // Data Output

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] &lt;mem&gt;[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration
reg [DWIDTH-1:0] &lt;memreg&gt;;              
reg [DWIDTH-1:0] &lt;mem_pipe_reg&gt;[NBPIPE-1:0];    // Pipelines for memory
reg &lt;mem_en_pipe_reg&gt;[NBPIPE:0];                // Pipelines for memory enable  

integer          i;

// RAM : Both READ and WRITE have a latency of one
always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_en&gt;) 
  begin
   if(&lt;wea&gt;)
     &lt;mem&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;

   &lt;memreg&gt; &lt;= &lt;mem&gt;[&lt;addrb&gt;];
  end
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge &lt;clk&gt;)
begin
 &lt;mem_en_pipe_reg&gt;[0] &lt;= &lt;mem_en&gt;;
 for (i=0; i&lt;NBPIPE; i=i+1)
   &lt;mem_en_pipe_reg&gt;[i+1] &lt;= &lt;mem_en_pipe_reg&gt;[i];
end

// RAM output data goes through a pipeline.
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;mem_en_pipe_reg&gt;[0])
  &lt;mem_pipe_reg&gt;[0] &lt;= &lt;memreg&gt;;
end    

always @ (posedge &lt;clk&gt;)
begin
 for (i = 0; i &lt; &lt;NBPIPE-1; i = i+1)
  if (&lt;mem_en_pipe_reg&gt;[i+1])
   &lt;mem_pipe_reg&gt;[i+1] &lt;= &lt;mem_pipe_reg&gt;[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;rstb&gt;)
   &lt;doutb&gt; &lt;= 0;
 else if (&lt;mem_en_pipe_reg&gt;[NBPIPE] &amp;&amp; &lt;regceb&gt;)
   &lt;doutb&gt; &lt;= &lt;mem_pipe_reg&gt;[NBPIPE-1];
end

					</Template>
					<SubFolder label="Single Port" treetype="folder">
						<Template label="No Change Mode" treetype="template">
//  Xilinx UltraRAM Single Port No Change Mode.  This code implements 
//  a parameterizable UltraRAM block in No Change mode. The behavior of this RAM is 
//  when data is written, the output of RAM is unchanged. Only when write is
//  inactive data corresponding to the address is presented on the output port.

parameter AWIDTH = 12;  // Address Width
parameter DWIDTH = 72;  // Data Width
parameter NBPIPE = 3;   // Number of pipeline Registers
&lt;wire_or_reg&gt; &lt;clk&gt;;                    // Clock 
&lt;wire_or_reg&gt; &lt;rst&gt;;                    // Reset
&lt;wire_or_reg&gt; &lt;we&gt;;                     // Write Enable
&lt;wire_or_reg&gt; &lt;regce&gt;;                  // Output Register Enable
&lt;wire_or_reg&gt; &lt;mem_en&gt;;                 // Memory Enable
&lt;wire_or_reg&gt; [DWIDTH-1:0] &lt;din&gt;;       // Data Input  
&lt;wire_or_reg&gt; [AWIDTH-1:0] &lt;addr&gt;;      // Address Input
reg [DWIDTH-1:0] &lt;dout&gt;;                // Data Output

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] &lt;mem&gt;[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration
reg [DWIDTH-1:0] &lt;memreg&gt;;              
reg [DWIDTH-1:0] &lt;mem_pipe_reg&gt;[NBPIPE-1:0];    // Pipelines for memory
reg &lt;mem_en_pipe_reg&gt;[NBPIPE:0];                // Pipelines for memory enable  

integer          i;

// RAM : Both READ and WRITE have a latency of one
always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_en&gt;) 
  begin
   if(&lt;we&gt;)
    &lt;mem&gt;[&lt;addr&gt;] &lt;= &lt;din&gt;;
   else
    &lt;memreg&gt; &lt;= &lt;mem&gt;[&lt;addr&gt;];
  end
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge &lt;clk&gt;)
begin
 &lt;mem_en_pipe_reg&gt;[0] &lt;= &lt;mem_en&gt;;
 for (i=0; i&lt;NBPIPE; i=i+1)
   &lt;mem_en_pipe_reg&gt;[i+1] &lt;= &lt;mem_en_pipe_reg&gt;[i];
end

// RAM output data goes through a pipeline.
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;mem_en_pipe_reg&gt;[0])
  &lt;mem_pipe_reg&gt;[0] &lt;= &lt;memreg&gt;;
end    

always @ (posedge &lt;clk&gt;)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (&lt;mem_en_pipe_reg&gt;[i+1])
   &lt;mem_pipe_reg&gt;[i+1] &lt;= &lt;mem_pipe_reg&gt;[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;rst&gt;)
   &lt;dout&gt; &lt;= 0;
 else if (&lt;mem_en_pipe_reg&gt;[NBPIPE] &amp;&amp; &lt;regce&gt;)
   &lt;dout&gt; &lt;= &lt;mem_pipe_reg&gt;[NBPIPE-1];
end
						</Template>
						<Template label="Read First Mode" treetype="template">
//  Xilinx UltraRAM Single Port Read First Mode.  This code implements 
//  a parameterizable UltraRAM block in read first mode. The behavior of this RAM is 
//  when data is written, the old memory contents at the write address are 
//  presented on the output port.
//
parameter AWIDTH = 12;  // Address Width
parameter DWIDTH = 72;  // Data Width
parameter NBPIPE = 3;   // Number of pipeline Registers
&lt;wire_or_reg&gt; &lt;clk&gt;;                    // Clock 
&lt;wire_or_reg&gt; &lt;rst&gt;;                    // Reset
&lt;wire_or_reg&gt; &lt;we&gt;;                     // Write Enable
&lt;wire_or_reg&gt; &lt;regce&gt;;                  // Output Register Enable
&lt;wire_or_reg&gt; &lt;mem_en&gt;;                 // Memory Enable
&lt;wire_or_reg&gt; [DWIDTH-1:0] &lt;din&gt;;       // Data Input  
&lt;wire_or_reg&gt; [AWIDTH-1:0] &lt;addr&gt;;      // Address Input
reg [DWIDTH-1:0] &lt;dout&gt;;                // Data Output

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] &lt;mem&gt;[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration
reg [DWIDTH-1:0] &lt;memreg&gt;;              
reg [DWIDTH-1:0] &lt;mem_pipe_reg&gt;[NBPIPE-1:0];    // Pipelines for memory
reg &lt;mem_en_pipe_reg&gt;[NBPIPE:0];                // Pipelines for memory enable  

integer          i;

// RAM : Both READ and WRITE have a latency of one
always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_en&gt;) 
  begin
   if(&lt;we&gt;)
    &lt;mem&gt;[&lt;addr&gt;] &lt;= &lt;din&gt;;
   &lt;memreg&gt; &lt;= &lt;mem&gt;[&lt;addr&gt;];
  end
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge &lt;clk&gt;)
begin
 &lt;mem_en_pipe_reg&gt;[0] &lt;= &lt;mem_en&gt;;
 for (i=0; i&lt;NBPIPE; i=i+1)
   &lt;mem_en_pipe_reg&gt;[i+1] &lt;= &lt;mem_en_pipe_reg&gt;[i];
end

// RAM output data goes through a pipeline.
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;mem_en_pipe_reg&gt;[0])
  &lt;mem_pipe_reg&gt;[0] &lt;= &lt;memreg&gt;;
end    

always @ (posedge &lt;clk&gt;)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (&lt;mem_en_pipe_reg&gt;[i+1])
   &lt;mem_pipe_reg&gt;[i+1] &lt;= &lt;mem_pipe_reg&gt;[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;rst&gt;)
   &lt;dout&gt; &lt;= 0;
 else if (&lt;mem_en_pipe_reg&gt;[NBPIPE] &amp;&amp; &lt;regce&gt;)
   &lt;dout&gt; &lt;= &lt;mem_pipe_reg&gt;[NBPIPE-1];
end
						</Template>
						<Template label="Write First Mode" treetype="template">
//  Xilinx UltraRAM Single Port Write First Mode.  This code implements 
//  a parameterizable UltraRAM block in write first mode. The behavior of this RAM is 
//  when data is written, the new memory contents at the write address are 
//  presented on the output port.
//
parameter AWIDTH = 12;  // Address Width
parameter DWIDTH = 72;  // Data Width
parameter NBPIPE = 3;   // Number of pipeline Registers
&lt;wire_or_reg&gt; &lt;clk&gt;;                    // Clock 
&lt;wire_or_reg&gt; &lt;rst&gt;;                    // Reset
&lt;wire_or_reg&gt; &lt;we&gt;;                     // Write Enable
&lt;wire_or_reg&gt; &lt;regce&gt;;                  // Output Register Enable
&lt;wire_or_reg&gt; &lt;mem_en&gt;;                 // Memory Enable
&lt;wire_or_reg&gt; [DWIDTH-1:0] &lt;din&gt;;       // Data Input  
&lt;wire_or_reg&gt; [AWIDTH-1:0] &lt;addr&gt;;      // Address Input
reg [DWIDTH-1:0] &lt;dout&gt;;                // Data Output

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] &lt;mem&gt;[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration
reg [DWIDTH-1:0] &lt;memreg&gt;;              
reg [DWIDTH-1:0] &lt;mem_pipe_reg&gt;[NBPIPE-1:0];    // Pipelines for memory
reg &lt;mem_en_pipe_reg&gt;[NBPIPE:0];                // Pipelines for memory enable  

integer          i;

// RAM : Both READ and WRITE have a latency of one
always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_en&gt;) 
  begin
   if(&lt;we&gt;)
    begin
     &lt;mem&gt;[&lt;addr&gt;] &lt;= &lt;din&gt;;
     &lt;memreg&gt; &lt;= &lt;din&gt;;
    end
   else
    &lt;memreg&gt; &lt;= &lt;mem&gt;[&lt;addr&gt;];
  end
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge &lt;clk&gt;)
begin
 &lt;mem_en_pipe_reg&gt;[0] &lt;= &lt;mem_en&gt;;
 for (i=0; i&lt;NBPIPE; i=i+1)
   &lt;mem_en_pipe_reg&gt;[i+1] &lt;= &lt;mem_en_pipe_reg&gt;[i];
end

// RAM output data goes through a pipeline.
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;mem_en_pipe_reg&gt;[0])
  &lt;mem_pipe_reg&gt;[0] &lt;= &lt;memreg&gt;;
end    

always @ (posedge &lt;clk&gt;)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (&lt;mem_en_pipe_reg&gt;[i+1])
   &lt;mem_pipe_reg&gt;[i+1] &lt;= &lt;mem_pipe_reg&gt;[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;rst&gt;)
   &lt;dout&gt; &lt;= 0;
 else if (&lt;mem_en_pipe_reg&gt;[NBPIPE] &amp;&amp; &lt;regce&gt;)
   &lt;dout&gt; &lt;= &lt;mem_pipe_reg&gt;[NBPIPE-1];
end
						</Template>
					</SubFolder>
					<SubFolder label="True Dual Port" treetype="folder">
						<Template label="Byte-Write" treetype="template">
//  Xilinx UltraRAM True Dual Port Mode - Byte write.  This code implements 
//  a parameterizable UltraRAM block with write/read on both ports in 
//  No change behavior on both the ports . The behavior of this RAM is 
//  when data is written, the output of RAM is unchanged w.r.t each port. 
//  Only when write is inactive data corresponding to the address is 
//  presented on the output port.
//

parameter AWIDTH = 12;  // Address Width
parameter DWIDTH = 72;  // Data Width
parameter NUM_COL = 9;   // Number of columns
parameter DWIDTH  = 72;  // Data Width, (Byte * NUM_COL) 

parameter NBPIPE = 3;   // Number of pipeline Registers

&lt;wire_or_reg&gt; &lt;clk&gt;;                     // Clock 
// Port A
&lt;wire_or_reg&gt; &lt;rsta&gt;;                    // Reset
&lt;wire_or_reg&gt; [NUM_COL-1:0] &lt;wea&gt;;       // Write Enable
&lt;wire_or_reg&gt; &lt;regcea&gt;;                  // Output Register Enable
&lt;wire_or_reg&gt; &lt;mem_ena&gt;;                 // Memory Enable
&lt;wire_or_reg&gt; [DWIDTH-1:0] &lt;dina&gt;;       // Data Input 
&lt;wire_or_reg&gt; [AWIDTH-1:0] &lt;addra&gt;;      // Address Input
reg [DWIDTH-1:0] &lt;douta&gt;;                // Data Output

// Port B
&lt;wire_or_reg&gt; &lt;rstb&gt;;                    // Reset
&lt;wire_or_reg&gt; [NUM_COL-1:0] &lt;web&gt;;       // Write Enable
&lt;wire_or_reg&gt; &lt;regceb&gt;;                  // Output Register Enable
&lt;wire_or_reg&gt; &lt;mem_enb&gt;;                 // Memory Enable
&lt;wire_or_reg&gt; [DWIDTH-1:0] &lt;dinb&gt;;       // Data Input 
&lt;wire_or_reg&gt; [AWIDTH-1:0] &lt;addrb&gt;;      // Address Input
reg [DWIDTH-1:0] &lt;doutb&gt;;                // Data Output

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] &lt;mem&gt;[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration

reg [DWIDTH-1:0] &lt;memrega&gt;;              
reg [DWIDTH-1:0] &lt;mem_pipe_rega&gt;[NBPIPE-1:0];    // Pipelines for memory
reg &lt;mem_en_pipe_rega&gt;[NBPIPE:0];                // Pipelines for memory enable  

reg [DWIDTH-1:0] &lt;memregb&gt;;              
reg [DWIDTH-1:0] &lt;mem_pipe_regb&gt;[NBPIPE-1:0];    // Pipelines for memory
reg &lt;mem_en_pipe_regb&gt;[NBPIPE:0];                // Pipelines for memory enable  
integer          i;

// RAM : Both READ and WRITE have a latency of one
always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_ena&gt;) 
  begin
   for(i = 0;i&lt;NUM_COL;i=i+1) 
	 if(&lt;wea&gt;[i])
    &lt;mem&gt;[&lt;addra&gt;][i*CWIDTH +: CWIDTH] &lt;= &lt;dina&gt;[i*CWIDTH +: CWIDTH];
 end
end

always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_ena&gt;)
  if(~|&lt;wea&gt;)
    &lt;memrega&gt; &lt;= &lt;mem&gt;[&lt;addra&gt;];
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge &lt;clk&gt;)
begin
 &lt;mem_en_pipe_rega&gt;[0] &lt;= &lt;mem_ena&gt;;
 for (i=0; i&lt;NBPIPE; i=i+1)
   &lt;mem_en_pipe_rega&gt;[i+1] &lt;= &lt;mem_en_pipe_rega&gt;[i];
end

// RAM output data goes through a pipeline.
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;mem_en_pipe_rega&gt;[0])
  &lt;mem_pipe_rega&gt;[0] &lt;= &lt;memrega&gt;;
end    

always @ (posedge &lt;clk&gt;)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (&lt;mem_en_pipe_rega&gt;[i+1])
   &lt;mem_pipe_rega&gt;[i+1] &lt;= &lt;mem_pipe_rega&gt;[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;rsta&gt;)
   &lt;douta&gt; &lt;= 0;
 else if (&lt;mem_en_pipe_rega&gt;[NBPIPE] &amp;&amp; &lt;regcea&gt;)
   &lt;douta&gt; &lt;= &lt;mem_pipe_rega&gt;[NBPIPE-1];
end

always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_enb&gt;) 
  begin
   for(i = 0;i&lt;NUM_COL;i=i+1) 
	 if(&lt;web&gt;[i])
    &lt;mem&gt;[&lt;addrb&gt;][i*CWIDTH +: CWIDTH] &lt;= &lt;dinb&gt;[i*CWIDTH +: CWIDTH];
 end
end

always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_enb&gt;)
  if(~|&lt;web&gt;)
    &lt;memregb&gt; &lt;= &lt;mem&gt;[&lt;addrb&gt;];
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge &lt;clk&gt;)
begin
 &lt;mem_en_pipe_regb&gt;[0] &lt;= &lt;mem_enb&gt;;
 for (i=0; i&lt;NBPIPE; i=i+1)
   &lt;mem_en_pipe_regb&gt;[i+1] &lt;= &lt;mem_en_pipe_regb&gt;[i];
end

// RAM output data goes through a pipeline.
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;mem_en_pipe_regb&gt;[0])
  &lt;mem_pipe_regb&gt;[0] &lt;= &lt;memregb&gt;;
end    

always @ (posedge &lt;clk&gt;)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (&lt;mem_en_pipe_regb&gt;[i+1])
   &lt;mem_pipe_regb&gt;[i+1] &lt;= &lt;mem_pipe_regb&gt;[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge &lt;clkb&gt;)
begin
 if (&lt;rstb&gt;)
   &lt;doutb&gt; &lt;= 0;
 else if (&lt;mem_en_pipe_regb&gt;[NBPIPE] &amp;&amp; &lt;regceb&gt;)
   &lt;doutb&gt; &lt;= &lt;mem_pipe_regb&gt;[NBPIPE-1];
end
						</Template>
						<Template label="Non Byte-write" treetype="template">
//  Xilinx UltraRAM True Dual Port Mode.  This code implements 
//  a parameterizable UltraRAM block with write/read on both ports in 
//  No change behavior on both the ports . The behavior of this RAM is 
//  when data is written, the output of RAM is unchanged w.r.t each port. 
//  Only when write is inactive data corresponding to the address is 
//  presented on the output port.
//

parameter AWIDTH = 12;  // Address Width
parameter DWIDTH = 72;  // Data Width
parameter NBPIPE = 3;   // Number of pipeline Registers

&lt;wire_or_reg&gt; &lt;clk&gt;;                    // Clock 
// Port A
&lt;wire_or_reg&gt; &lt;rsta&gt;;                    // Reset
&lt;wire_or_reg&gt; &lt;wea&gt;;                     // Write Enable
&lt;wire_or_reg&gt; &lt;regcea&gt;;                  // Output Register Enable
&lt;wire_or_reg&gt; &lt;mem_ena&gt;;                 // Memory Enable
&lt;wire_or_reg&gt; [DWIDTH-1:0] &lt;dina&gt;;       // Data Input 
&lt;wire_or_reg&gt; [AWIDTH-1:0] &lt;addra&gt;;      // Address Input
reg [DWIDTH-1:0] &lt;douta&gt;;                // Data Output

// Port B
&lt;wire_or_reg&gt; &lt;rstb&gt;;                    // Reset
&lt;wire_or_reg&gt; &lt;web&gt;;                     // Write Enable
&lt;wire_or_reg&gt; &lt;regceb&gt;;                  // Output Register Enable
&lt;wire_or_reg&gt; &lt;mem_enb&gt;;                 // Memory Enable
&lt;wire_or_reg&gt; [DWIDTH-1:0] &lt;dinb&gt;;       // Data Input 
&lt;wire_or_reg&gt; [AWIDTH-1:0] &lt;addrb&gt;;      // Address Input
reg [DWIDTH-1:0] &lt;doutb&gt;;                // Data Output

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] &lt;mem&gt;[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration

reg [DWIDTH-1:0] &lt;memrega&gt;;              
reg [DWIDTH-1:0] &lt;mem_pipe_rega&gt;[NBPIPE-1:0];    // Pipelines for memory
reg &lt;mem_en_pipe_rega&gt;[NBPIPE:0];                // Pipelines for memory enable  

reg [DWIDTH-1:0] &lt;memregb&gt;;              
reg [DWIDTH-1:0] &lt;mem_pipe_regb&gt;[NBPIPE-1:0];    // Pipelines for memory
reg &lt;mem_en_pipe_regb&gt;[NBPIPE:0];                // Pipelines for memory enable  
integer          i;

// RAM : Both READ and WRITE have a latency of one
always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_ena&gt;) 
  begin
   if(&lt;wea&gt;)
    &lt;mem&gt;[&lt;addra&gt;] &lt;= &lt;dina&gt;;
   else
    &lt;memrega&gt; &lt;= &lt;mem&gt;[&lt;addra&gt;];
  end
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge &lt;clk&gt;)
begin
 &lt;mem_en_pipe_rega&gt;[0] &lt;= &lt;mem_ena&gt;;
 for (i=0; i&lt;NBPIPE; i=i+1)
   &lt;mem_en_pipe_rega&gt;[i+1] &lt;= &lt;mem_en_pipe_rega&gt;[i];
end

// RAM output data goes through a pipeline.
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;mem_en_pipe_rega&gt;[0])
  &lt;mem_pipe_rega&gt;[0] &lt;= &lt;memrega&gt;;
end    

always @ (posedge &lt;clk&gt;)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (&lt;mem_en_pipe_rega&gt;[i+1])
   &lt;mem_pipe_rega&gt;[i+1] &lt;= &lt;mem_pipe_rega&gt;[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;rsta&gt;)
   &lt;douta&gt; &lt;= 0;
 else if (&lt;mem_en_pipe_rega&gt;[NBPIPE] &amp;&amp; &lt;regcea&gt;)
   &lt;douta&gt; &lt;= &lt;mem_pipe_rega&gt;[NBPIPE-1];
end


always @ (posedge &lt;clk&gt;)
begin
 if(&lt;mem_enb&gt;) 
  begin
   if(&lt;web&gt;)
    &lt;mem&gt;[&lt;addrb&gt;] &lt;= &lt;dinb&gt;;
   else
    &lt;memregb&gt; &lt;= &lt;mem&gt;[&lt;addrb&gt;];
  end
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge &lt;clk&gt;)
begin
 &lt;mem_en_pipe_regb&gt;[0] &lt;= &lt;mem_enb&gt;;
 for (i=0; i&lt;NBPIPE; i=i+1)
   &lt;mem_en_pipe_regb&gt;[i+1] &lt;= &lt;mem_en_pipe_regb&gt;[i];
end

// RAM output data goes through a pipeline.
always @ (posedge &lt;clk&gt;)
begin
 if (&lt;mem_en_pipe_regb&gt;[0])
  &lt;mem_pipe_regb&gt;[0] &lt;= &lt;memregb&gt;;
end    

always @ (posedge &lt;clk&gt;)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (&lt;mem_en_pipe_regb&gt;[i+1])
   &lt;mem_pipe_regb&gt;[i+1] &lt;= &lt;mem_pipe_regb&gt;[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge &lt;clkb&gt;)
begin
 if (&lt;rstb&gt;)
   &lt;doutb&gt; &lt;= 0;
 else if (&lt;mem_en_pipe_regb&gt;[NBPIPE] &amp;&amp; &lt;regceb&gt;)
   &lt;doutb&gt; &lt;= &lt;mem_pipe_regb&gt;[NBPIPE-1];
end

						</Template>
					</SubFolder>
				</SubFolder>
			</SubFolder>
			<SubFolder label="ROM/Lookup Table" treetype="folder">
				<Template label="Using $readmemb" treetype="template">
   parameter ROM_WIDTH = &lt;rom_width&gt;;
   parameter ROM_ADDR_BITS = &lt;rom_addr_bits&gt;;

   (* rom_style="{distributed | block}" *)
   reg [ROM_WIDTH-1:0] &lt;rom_name&gt; [(2**ROM_ADDR_BITS)-1:0];
   reg [ROM_WIDTH-1:0] &lt;output_data&gt;;

   &lt;reg_or_wire&gt; [ROM_ADDR_BITS-1:0] &lt;address&gt;;

   initial
      $readmemb("&lt;data_file_name&gt;", &lt;rom_name&gt;, 0, (2**ROM_ADDR_BITS)-1);

   always @(posedge &lt;clock&gt;)
      if (&lt;enable&gt;)
         &lt;output_data&gt; &lt;= &lt;rom_name&gt;[&lt;address&gt;];
				</Template>
				<Template label="Using $readmemh" treetype="template">
   parameter ROM_WIDTH = &lt;rom_width&gt;;
   parameter ROM_ADDR_BITS = &lt;rom_addr_bits&gt;;

   (* rom_style="{distributed | block}" *)
   reg [ROM_WIDTH-1:0] &lt;rom_name&gt; [(2**ROM_ADDR_BITS)-1:0];
   reg [ROM_WIDTH-1:0] &lt;output_data&gt;;

   &lt;reg_or_wire&gt; [ROM_ADDR_BITS-1:0] &lt;address&gt;;

   initial
      $readmemh("&lt;data_file_name&gt;", &lt;rom_name&gt;, 0, (2**ROM_ADDR_BITS)-1);

   always @(posedge &lt;clock&gt;)
      if (&lt;enable&gt;)
         &lt;output_data&gt; &lt;= &lt;rom_name&gt;[&lt;address&gt;];
				</Template>
				<Template label="Using 4-bit Case Statement" treetype="template">
   parameter ROM_WIDTH = &lt;rom_width&gt;;

   reg [ROM_WIDTH-1:0] &lt;output_data&gt;;
   &lt;reg_or_wire&gt; [3:0] &lt;address&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;enable&gt;)
         case (&lt;address&gt;)
            4'b0000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b0001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b0010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b0011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b0100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b0101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b0110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b0111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b1000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b1001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b1010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b1011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b1100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b1101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b1110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            4'b1111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            default: &lt;output_data&gt; &lt;= &lt;value&gt;;
         endcase
				</Template>
				<Template label="Using 5-bit Case Statement" treetype="template">
   parameter ROM_WIDTH = &lt;rom_width&gt;;

   reg [ROM_WIDTH-1:0] &lt;output_data&gt;;
   &lt;reg_or_wire&gt; [4:0] &lt;address&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;enable&gt;)
         case (&lt;address&gt;)
            5'b00000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b00001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b00010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b00011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b00100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b00101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b00110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b00111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b01000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b01001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b01010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b01011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b01100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b01101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b01110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b01111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b10000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b10001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b10010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b10011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b10100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b10101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b10110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b10111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b11000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b11001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b11010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b11011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b11100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b11101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b11110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            5'b11111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            default:  &lt;output_data&gt; &lt;= &lt;value&gt;;
         endcase
				</Template>
				<Template label="Using 6-bit Case Statement" treetype="template">
   parameter ROM_WIDTH = &lt;rom_width&gt;;

   reg [ROM_WIDTH-1:0] &lt;output_data&gt;;
   &lt;reg_or_wire&gt; [5:0] &lt;address&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;enable&gt;)
         case (&lt;address&gt;)
            6'b000000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b000001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b000010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b000011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b000100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b000101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b000110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b000111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b001000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b001001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b001010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b001011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b001100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b001101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b001110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b001111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b010000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b010001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b010010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b010011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b010100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b010101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b010110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b010111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b011000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b011001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b011010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b011011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b011100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b011101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b011110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b011111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b100000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b100001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b100010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b100011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b100100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b100101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b100110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b100111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b101000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b101001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b101010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b101011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b101100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b101101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b101110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b101111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b110000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b110001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b110010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b110011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b110100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b110101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b110110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b110111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b111000: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b111001: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b111010: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b111011: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b111100: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b111101: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b111110: &lt;output_data&gt; &lt;= &lt;value&gt;;
            6'b111111: &lt;output_data&gt; &lt;= &lt;value&gt;;
            default:   &lt;output_data&gt; &lt;= &lt;value&gt;;
         endcase
				</Template>
			</SubFolder>
			<SubFolder label="Shift Registers" treetype="folder">
				<SubFolder label="Parallel In, Serial Out" treetype="folder">
					<Template label="Simple Shift Register" treetype="template">
   parameter piso_shift = &lt;shift_width&gt;;

   reg [piso_shift-2:0] &lt;reg_name&gt; = {piso_shift-1{1'b0}};
   reg                  &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (&lt;load_signal&gt;) begin
         &lt;reg_name&gt; &lt;= &lt;input&gt;[piso_shift-1:1];
         &lt;output&gt;    &lt;= &lt;input&gt;[0];
      end
      else begin
         &lt;reg_name&gt; &lt;= {1'b0, &lt;reg_name&gt;[piso_shift-2:1]};
         &lt;output&gt;   &lt;= &lt;reg_name&gt;[0];
      end
					</Template>
					<Template label="w/ CE" treetype="template">
   parameter piso_shift = &lt;shift_width&gt;;

   reg [piso_shift-2:0] &lt;reg_name&gt; = {piso_shift-1{1'b0}};
   reg                  &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (&lt;load_signal&gt;) begin
         &lt;reg_name&gt; &lt;= &lt;input&gt;[piso_shift-1:1];
         &lt;output&gt;    &lt;= &lt;input&gt;[0];
      end
      else if (&lt;clock_enable&gt;) begin
         &lt;reg_name&gt; &lt;= {1'b0, &lt;reg_name&gt;[piso_shift-2:1]};
         &lt;output&gt;   &lt;= &lt;reg_name&gt;[0];
      end
					</Template>
					<Template label="w/ CE and Sync Active High Reset" treetype="template">
   parameter piso_shift = &lt;shift_width&gt;;

   reg [piso_shift-2:0] &lt;reg_name&gt; = {piso_shift-1{1'b0}};
   reg                  &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;reg_name&gt; &lt;= 0;
         &lt;output&gt;    &lt;= 1'b0;
      end
      else if (&lt;load_signal&gt;) begin
         &lt;reg_name&gt; &lt;= &lt;input&gt;[piso_shift-1:1];
         &lt;output&gt;    &lt;= &lt;input&gt;[0];
      end
      else if (&lt;clock_enable&gt;) begin
         &lt;reg_name&gt; &lt;= {1'b0, &lt;reg_name&gt;[piso_shift-2:1]};
         &lt;output&gt;   &lt;= &lt;reg_name&gt;[0];
      end
					</Template>
					<Template label="w/ CE and Sync Active Low Reset" treetype="template">
   parameter piso_shift = &lt;shift_width&gt;;

   reg [piso_shift-2:0] &lt;reg_name&gt; = {piso_shift-1{1'b0}};
   reg                  &lt;output&gt; = 1'b0;

   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;) begin
         &lt;reg_name&gt; &lt;= 0;
         &lt;output&gt;    &lt;= 1'b0;
      end
      else if (&lt;load_signal&gt;) begin
         &lt;reg_name&gt; &lt;= &lt;input&gt;[piso_shift-1:1];
         &lt;output&gt;    &lt;= &lt;input&gt;[0];
      end
      else if (&lt;clock_enable&gt;) begin
         &lt;reg_name&gt; &lt;= {1'b0, &lt;reg_name&gt;[piso_shift-2:1]};
         &lt;output&gt;   &lt;= &lt;reg_name&gt;[0];
      end
					</Template>
				</SubFolder>
				<SubFolder label="Serial In, Serial Out" treetype="folder">
					<Template label="Simple Shift Register" treetype="template">
   parameter shift = &lt;shift_length&gt;;

   reg [shift-1:0] &lt;reg_name&gt; = {shift{1'b0}};

   always @(posedge &lt;clock&gt;)
      &lt;reg_name&gt;  &lt;= {&lt;input&gt;, &lt;reg_name&gt;[shift-1:1]};

   assign &lt;output&gt; = &lt;reg_name&gt;[0];
					</Template>
					<Template label="w/ CE" treetype="template">
   parameter siso_shift = &lt;shift_length&gt;;

   reg [siso_shift-1:0] &lt;reg_name&gt; = {siso_shift{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;clock_enable&gt;)
         &lt;reg_name&gt;  &lt;= {&lt;input&gt;, &lt;reg_name&gt;[siso_shift-1:1]};

   assign &lt;output&gt; = &lt;reg_name&gt;[0];
					</Template>
					<Template label="w/ CE and Sync Active High Reset" treetype="template">
   // Note: By using a reset for this shift register, this cannot
   //       be placed in an SRL shift register LUT.

   parameter siso_shift = &lt;shift_length&gt;;

   reg [siso_shift-1:0] &lt;reg_name&gt; = {siso{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= 0;
      else if (&lt;clock_enable&gt;)
         &lt;reg_name&gt;  &lt;= {&lt;input&gt;, &lt;reg_name&gt;[siso_shift-1:1]};

   assign &lt;output&gt; = &lt;reg_name&gt;[0];
					</Template>
					<Template label="w/ CE and Sync Active Low Reset" treetype="template">
   // Note: By using a reset for this shift register, this cannot
   //       be placed in an SRL shift register LUT.

   parameter siso_shift = &lt;shift_length&gt;;

   reg [siso_shift-1:0] &lt;reg_name&gt; = {siso{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (!&lt;reset&gt;)
         &lt;reg_name&gt; &lt;= 0;
      else if (&lt;clock_enable&gt;)
         &lt;reg_name&gt;  &lt;= {&lt;input&gt;, &lt;reg_name&gt;[siso_shift-1:1]};

   assign &lt;output&gt; = &lt;reg_name&gt;[0];
					</Template>
				</SubFolder>
				<SubFolder label="SRL" treetype="folder">
					<Template label="Dynamic Depth SRL /w no register on output (bus)" treetype="template">
   // Shift register depth will be selectable from 1 (SELECT is all zeroes) to 2**depth_select_bits (SELECT is all ones) deep
   // Note: The following code with produce an SRL without a register on the output.
   //       For improved clock-to-out times, it is suggested to infer a register on the
   //       output of the SRL code when minimum of two clock cycle latency is possible.

   parameter depth_select_bits = &lt;number_of_select_bits&gt;;
   parameter data_width = &lt;width_of_data&gt;;

   wire/reg [data_width-1:0] &lt;data_in&gt;, &lt;data_out&gt;;
   wire/reg [depth_select_bits-1:0] &lt;select&gt;;
   reg [2**depth_select_bits-1:0] &lt;shift_reg&gt; [data_width-1:0];

   integer srl_index;
   initial
      for (srl_index = 0; srl_index &lt; data_width; srl_index = srl_index + 1)
         &lt;shift_reg&gt;[srl_index] = {2**depth_select_bits{1'b0}};

   genvar i;
   generate
      for (i=0; i &lt; data_width; i=i+1)
      begin: &lt;label&gt;
         always @(posedge &lt;clock&gt;)
            if (&lt;clock_enable&gt;)
	       &lt;shift_reg&gt;[i] &lt;= {&lt;shift_reg&gt;[i][2**depth_select_bits-2:0], &lt;data_in&gt;[i]};

	 assign &lt;data_out&gt;[i] = &lt;shift_reg&gt;[i][&lt;select&gt;];
      end
   endgenerate
					</Template>
					<Template label="Dynamic Depth SRL /w no register on output (single)" treetype="template">
   // Shift register depth will be selectable from 1 (SELECT is all zeroes) to 2**depth_select_bits (SELECT is all ones) deep
   // Note: The following code with produce an SRL without a register on the output.
   //       For improved clock-to-out times, it is suggested to infer a register on the
   //       output of the SRL code when minimum of two clock cycle latency is possible.

   parameter depth_select_bits = &lt;number_of_select_bits&gt;;

   wire/reg &lt;data_in&gt;, &lt;data_out&gt;;
   wire/reg [depth_select_bits-1:0] &lt;select&gt;;
   reg [2**depth_select_bits-1:0] &lt;shift_reg&gt; = {2**depth_select_bits{1'b0}};

  always @(posedge &lt;clock&gt;)
    if (&lt;clock_enable&gt;)
      &lt;shift_reg&gt;&lt;= {&lt;shift_reg&gt;[2**depth_select_bits-2:0], &lt;data_in&gt;};

  assign &lt;data_out&gt; = &lt;shift_reg&gt;[&lt;select&gt;];
					</Template>
					<Template label="Dynamic Depth SRL /w register on output (bus)" treetype="template">
   // Shift register depth will be selectable from 2 (SELECT is all zeroes) to 2**depth_select_bits+1 (SELECT is all ones) deep
   // Note: The following code with produce an SRL a register on the output for improved clock-to-out performance.
   //       As a result of this, the shift register has a minimum of 2 clock delays.

   parameter depth_select_bits = &lt;depth&gt;, // Specify depth as a power of 2
   parameter data_width = &lt;width&gt;         // Specify data width

   reg [data_width-1:0] &lt;data_out&gt;;     // Shift register output
   wire/reg [data_width-1:0] &lt;data_in&gt;; // Shift register input
   wire/reg [depth_select_bits-1:0] &lt;srl_select&gt;; // Dynamic select input to SRL

   wire [data_width-1:0] &lt;srl_out&gt;; // Intermediate signal between SRL and Register (do not connect to this)
   reg [2**depth_select_bits-1:0] &lt;shift_reg&gt; [data_width-1:0];

   integer srl_index;
   initial
      for (srl_index = 0; srl_index &lt; data_width; srl_index = srl_index + 1)
         &lt;shift_reg&gt;[srl_index] = {2**depth_select_bits{1'b0}};

   genvar i;
   generate
      for (i=0; i &lt; data_width; i=i+1)
      begin: &lt;label&gt;
         always @(posedge &lt;clock&gt;)
            if (&lt;clock_enable&gt;)
               &lt;shift_reg&gt;[i]&lt;= {&lt;shift_reg&gt;[i][2**depth_select_bits-2:0], &lt;data_in&gt;[i]};

         assign &lt;srl_out&gt;[i] = &lt;shift_reg&gt;[i][&lt;srl_select&gt;];
       end
   endgenerate

   always @(posedge &lt;clock&gt;)
      if (&lt;clock_enable&gt;)
         &lt;data_out&gt; &lt;= &lt;srl_out&gt;;
					</Template>
					<Template label="Static Shift SRL (bus)" treetype="template">
   parameter clock_cycles = &lt;number_of_clock_cycles&gt;;
   parameter data_width = &lt;width_of_data&gt;;

   wire/reg [data_width-1:0] &lt;data_in&gt;, &lt;data_out&gt;;
   reg [clock_cycles-1:0] &lt;shift_reg&gt; [data_width-1:0];

   integer srl_index;
   initial
      for (srl_index = 0; srl_index &lt; data_width; srl_index = srl_index + 1)
         &lt;shift_reg&gt;[srl_index] = {clock_cycles{1'b0}};

   genvar i;
   generate
      for (i=0; i &lt; data_width; i=i+1)
      begin: &lt;label&gt;
         always @(posedge &lt;clock&gt;)
            if (&lt;clock_enable&gt;)
               &lt;shift_reg&gt;[i] &lt;= {&lt;shift_reg&gt;[i][clock_cycles-2:0], &lt;data_in&gt;[i]};

         assign &lt;data_out&gt;[i] = &lt;shift_reg&gt;[i][clock_cycles-1];
      end
   endgenerate
					</Template>
					<Template label="Static Shift SRL (single-bit)" treetype="template">
   parameter clock_cycles = &lt;number_of_clock_cycles&gt;;

   wire/reg &lt;data_in&gt;, &lt;data_out&gt;;
   reg [clock_cycles-1:0] &lt;shift_reg&gt; = {clock_cycles{1'b0}};

   always @(posedge &lt;clock&gt;)
      if (&lt;clock_enable&gt;)
         &lt;shift_reg&gt; &lt;= {&lt;shift_reg&gt;[clock_cycles-2:0], &lt;data_in&gt;};

   assign &lt;data_out&gt; = &lt;shift_reg&gt;[clock_cycles-1];
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="State-Machines" treetype="folder">
				<Template label="Info (State-machine)" treetype="template">
//  Finite State-machines
//
//  There are several methods to code state-machines however following certain
// coding styles ensures the synthesis tool FSM (Finite State-Machine)
// extraction algorithms properly identify and optimize the state-machine as
// well as possibly improving the simulation, timing and debug of the circuit.
// The following examples are broken down into Mealy vs. Moore, One-hot vs.
// Binary and Safe vs. Fast implementations.  The basic trade-offs for each
// implementation is explained below.  The general recommendation for the
// choice of state-machine depends on the target architecture and specifics of
// the state-machine size and behavior.
//
//  Mealy vs. Moore Styles
//
//  There are two well-known implementation styles for state-machines, Mealy
// and Moore.  The main difference between Mealy and Moore styles is the Mealy
// state-machine determines the output values based on both the current state
// as well as the inputs to the state-machine where Moore determines its
// outputs solely on the state.  In general, Moore type of state-machines
// implement best in FPGAs due to the fact that most often one-hot
// state-machines is the chosen encoding method and there is little or no
// decode and thus logic necessary for output values.  If a binary encoding is
// used, it is possible that a more compact and sometimes faster state-machine
// can be built using the Mealy method however this is not always true and not
// easy to determine without knowing more specifics of the state-machine.
//
//  One-hot vs. Binary Encoding
//
//  There are several encoding methods for state-machine design however the two
// most popular for FPGA design are binary and one-hot.  Most modern synthesis tools
// contain FSM extraction algorithms that can identify state-machine code and choose
// the best encoding method for the size, type and target architecture.  Even though
// this facility exists, many times it can be most advantageous to manually code
// and control the best encoding scheme for the design to allow better control
// and possibly ease debug of the implemented design.  It is suggested to
// consult the synthesis tool documentation for details about the state-machine
// extraction capabilities of the synthesis tool you are using.
//
//  Safe vs. Fast
//
//  When coding a state-machine, there are two generally conflicting goals that
// must be understood, safe vs. fast.  A safe state-machine implementation
// refers to the case where if a state-machine should get an unknown input or
// into an unknown state that it can recover into a known state the next clock
// cycle and resume from that recovery state.  On the other hand, if this
// requirement is discarded (no recovery state) many times the state-machine
// can be implemented with less logic and more speed than if state-machine
// recovery is necessary.  How to design a safe state-machine generally
// involves coding in a default state into the state-machine next-state case
// clause and/or specifying to the synthesis tool to implement the
// state-machine encoding in a "safe" mode.  If a safe state-machine is desired
// many times binary encoding works best due to the fact there are generally fewer
// unassigned states with that encoding method.  Again it is suggested to consult
// the synthesis tool documentation for details about implementing a safe
// state-machine.
//
// SystemVerilog Enumerated Type
//
// SystemVerilog adds a new data type enum, short for enumerated, which in many cases
// is beneficial for state-machine creation. Enum allows for named stated without
// implicit mapping to a register encoding.  The benefit this provides to synthesis is
// flexibility in state-machine encoding techniques and for simulation, the ability to
// display and query specific states by name to improve overall debugging. For these
// reasons, it is encouraged to use enum types when SystemVerilog is available.
				</Template>
				<SubFolder label="Mealy" treetype="folder">
					<SubFolder label="Binary (parameter)" treetype="folder">
						<SubFolder label="Fast" treetype="folder">
							<Template label="4 States" treetype="template">
   parameter &lt;state1&gt; = 2'b00;
   parameter &lt;state2&gt; = 2'b01;
   parameter &lt;state3&gt; = 2'b10;
   parameter &lt;state4&gt; = 2'b11;

   reg [1:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
							<Template label="8 States" treetype="template">
   parameter &lt;state1&gt; = 3'b000;
   parameter &lt;state2&gt; = 3'b001;
   parameter &lt;state3&gt; = 3'b010;
   parameter &lt;state4&gt; = 3'b011;
   parameter &lt;state5&gt; = 3'b100;
   parameter &lt;state6&gt; = 3'b101;
   parameter &lt;state7&gt; = 3'b110;
   parameter &lt;state8&gt; = 3'b111;

   reg [2:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
							<Template label="16 States" treetype="template">
   parameter &lt;state1&gt;  = 4'b0000;
   parameter &lt;state2&gt;  = 4'b0001;
   parameter &lt;state3&gt;  = 4'b0010;
   parameter &lt;state4&gt;  = 4'b0011;
   parameter &lt;state5&gt;  = 4'b0100;
   parameter &lt;state6&gt;  = 4'b0101;
   parameter &lt;state7&gt;  = 4'b0110;
   parameter &lt;state8&gt;  = 4'b0111;
   parameter &lt;state9&gt;  = 4'b1000;
   parameter &lt;state10&gt; = 4'b1001;
   parameter &lt;state11&gt; = 4'b1010;
   parameter &lt;state12&gt; = 4'b1011;
   parameter &lt;state13&gt; = 4'b1100;
   parameter &lt;state14&gt; = 4'b1101;
   parameter &lt;state15&gt; = 4'b1110;
   parameter &lt;state16&gt; = 4'b1111;

   reg [3:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state9&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state10&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state11&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state12&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state13&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state14&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state15&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state16&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
						</SubFolder>
						<SubFolder label="Safe" treetype="folder">
							<Template label="4 States" treetype="template">
   parameter &lt;state1&gt; = 2'b00;
   parameter &lt;state2&gt; = 2'b01;
   parameter &lt;state3&gt; = 2'b10;
   parameter &lt;state4&gt; = 2'b11;

   reg [1:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;state&gt; &lt;= &lt;state1&gt;;
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            default : begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
							<Template label="8 States" treetype="template">
   parameter &lt;state1&gt; = 3'b000;
   parameter &lt;state2&gt; = 3'b001;
   parameter &lt;state3&gt; = 3'b010;
   parameter &lt;state4&gt; = 3'b011;
   parameter &lt;state5&gt; = 3'b100;
   parameter &lt;state6&gt; = 3'b101;
   parameter &lt;state7&gt; = 3'b110;
   parameter &lt;state8&gt; = 3'b111;

   reg [2:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;state&gt; &lt;= &lt;state1&gt;;
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            default : begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
							<Template label="16 States" treetype="template">
   parameter &lt;state1&gt;  = 4'b0000;
   parameter &lt;state2&gt;  = 4'b0001;
   parameter &lt;state3&gt;  = 4'b0010;
   parameter &lt;state4&gt;  = 4'b0011;
   parameter &lt;state5&gt;  = 4'b0100;
   parameter &lt;state6&gt;  = 4'b0101;
   parameter &lt;state7&gt;  = 4'b0110;
   parameter &lt;state8&gt;  = 4'b0111;
   parameter &lt;state9&gt;  = 4'b1000;
   parameter &lt;state10&gt; = 4'b1001;
   parameter &lt;state11&gt; = 4'b1010;
   parameter &lt;state12&gt; = 4'b1011;
   parameter &lt;state13&gt; = 4'b1100;
   parameter &lt;state14&gt; = 4'b1101;
   parameter &lt;state15&gt; = 4'b1110;
   parameter &lt;state16&gt; = 4'b1111;

   reg [3:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;state&gt; &lt;= &lt;state1&gt;;
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state9&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state10&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state11&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state12&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state13&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state14&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state15&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state16&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            default : begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
						</SubFolder>
					</SubFolder>
					<SubFolder label="One-Hot (parameter)" treetype="folder">
						<SubFolder label="Fast" treetype="folder">
							<Template label="4 States" treetype="template">
   parameter &lt;state1&gt; = 4'b0001;
   parameter &lt;state2&gt; = 4'b0010;
   parameter &lt;state3&gt; = 4'b0100;
   parameter &lt;state4&gt; = 4'b1000;

   reg [3:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;state&gt; &lt;= &lt;state1&gt;;
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
							<Template label="8 States" treetype="template">
   parameter &lt;state1&gt; = 8'b00000001;
   parameter &lt;state2&gt; = 8'b00000010;
   parameter &lt;state3&gt; = 8'b00000100;
   parameter &lt;state4&gt; = 8'b00001000;
   parameter &lt;state5&gt; = 8'b00010000;
   parameter &lt;state6&gt; = 8'b00100000;
   parameter &lt;state7&gt; = 8'b01000000;
   parameter &lt;state8&gt; = 8'b10000000;

    reg [7:0] state = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;state&gt; &lt;= &lt;state1&gt;;
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
							<Template label="16 States" treetype="template">
   parameter &lt;state1&gt;  = 16'b0000000000000001;
   parameter &lt;state2&gt;  = 16'b0000000000000010;
   parameter &lt;state3&gt;  = 16'b0000000000000100;
   parameter &lt;state4&gt;  = 16'b0000000000001000;
   parameter &lt;state5&gt;  = 16'b0000000000010000;
   parameter &lt;state6&gt;  = 16'b0000000000100000;
   parameter &lt;state7&gt;  = 16'b0000000001000000;
   parameter &lt;state8&gt;  = 16'b0000000010000000;
   parameter &lt;state9&gt;  = 16'b0000000100000000;
   parameter &lt;state10&gt; = 16'b0000001000000000;
   parameter &lt;state11&gt; = 16'b0000010000000000;
   parameter &lt;state12&gt; = 16'b0000100000000000;
   parameter &lt;state13&gt; = 16'b0001000000000000;
   parameter &lt;state14&gt; = 16'b0010000000000000;
   parameter &lt;state15&gt; = 16'b0100000000000000;
   parameter &lt;state16&gt; = 16'b1000000000000000;

   reg [15:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;state&gt; &lt;= &lt;state1&gt;;
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state9&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state10&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state11&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state12&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state13&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state14&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state15&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state16&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
						</SubFolder>
						<SubFolder label="Safe" treetype="folder">
							<Template label="4 States" treetype="template">
   parameter &lt;state1&gt; = 4'b0001;
   parameter &lt;state2&gt; = 4'b0010;
   parameter &lt;state3&gt; = 4'b0100;
   parameter &lt;state4&gt; = 4'b1000;

   reg [3:0] state = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;state&gt; &lt;= &lt;state1&gt;;
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            default : begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
							<Template label="8 States" treetype="template">
   parameter &lt;state1&gt; = 8'b00000001;
   parameter &lt;state2&gt; = 8'b00000010;
   parameter &lt;state3&gt; = 8'b00000100;
   parameter &lt;state4&gt; = 8'b00001000;
   parameter &lt;state5&gt; = 8'b00010000;
   parameter &lt;state6&gt; = 8'b00100000;
   parameter &lt;state7&gt; = 8'b01000000;
   parameter &lt;state8&gt; = 8'b10000000;

   reg [7:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;state&gt; &lt;= &lt;state1&gt;;
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            default : begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
							<Template label="16 States" treetype="template">
   parameter &lt;state1&gt;  = 16'b0000000000000001;
   parameter &lt;state2&gt;  = 16'b0000000000000010;
   parameter &lt;state3&gt;  = 16'b0000000000000100;
   parameter &lt;state4&gt;  = 16'b0000000000001000;
   parameter &lt;state5&gt;  = 16'b0000000000010000;
   parameter &lt;state6&gt;  = 16'b0000000000100000;
   parameter &lt;state7&gt;  = 16'b0000000001000000;
   parameter &lt;state8&gt;  = 16'b0000000010000000;
   parameter &lt;state9&gt;  = 16'b0000000100000000;
   parameter &lt;state10&gt; = 16'b0000001000000000;
   parameter &lt;state11&gt; = 16'b0000010000000000;
   parameter &lt;state12&gt; = 16'b0000100000000000;
   parameter &lt;state13&gt; = 16'b0001000000000000;
   parameter &lt;state14&gt; = 16'b0010000000000000;
   parameter &lt;state15&gt; = 16'b0100000000000000;
   parameter &lt;state16&gt; = 16'b1000000000000000;

   reg [15:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;)
         &lt;state&gt; &lt;= &lt;state1&gt;;
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state9&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state10&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state11&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state12&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state13&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state14&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state15&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            &lt;state16&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
            end
            default : begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
            end
         endcase

   assign &lt;output1&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   assign &lt;output2&gt; = &lt;logic_equation_based_on_states_and_inputs&gt;;
   // Add other output equations as necessary
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Moore" treetype="folder">
					<SubFolder label="Binary (parameter)" treetype="folder">
						<SubFolder label="Fast" treetype="folder">
							<Template label="4 States" treetype="template">
   parameter &lt;state1&gt; = 2'b00;
   parameter &lt;state2&gt; = 2'b01;
   parameter &lt;state3&gt; = 2'b10;
   parameter &lt;state4&gt; = 2'b11;

   reg [1:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
         endcase
							</Template>
							<Template label="8 States" treetype="template">
   parameter &lt;state1&gt; = 3'b000;
   parameter &lt;state2&gt; = 3'b001;
   parameter &lt;state3&gt; = 3'b010;
   parameter &lt;state4&gt; = 3'b011;
   parameter &lt;state5&gt; = 3'b100;
   parameter &lt;state6&gt; = 3'b101;
   parameter &lt;state7&gt; = 3'b110;
   parameter &lt;state8&gt; = 3'b111;

   reg [2:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
         endcase
							</Template>
							<Template label="16 States" treetype="template">
   parameter &lt;state1&gt;  = 4'b0000;
   parameter &lt;state2&gt;  = 4'b0001;
   parameter &lt;state3&gt;  = 4'b0010;
   parameter &lt;state4&gt;  = 4'b0011;
   parameter &lt;state5&gt;  = 4'b0100;
   parameter &lt;state6&gt;  = 4'b0101;
   parameter &lt;state7&gt;  = 4'b0110;
   parameter &lt;state8&gt;  = 4'b0111;
   parameter &lt;state9&gt;  = 4'b1000;
   parameter &lt;state10&gt; = 4'b1001;
   parameter &lt;state11&gt; = 4'b1010;
   parameter &lt;state12&gt; = 4'b1011;
   parameter &lt;state13&gt; = 4'b1100;
   parameter &lt;state14&gt; = 4'b1101;
   parameter &lt;state15&gt; = 4'b1110;
   parameter &lt;state16&gt; = 4'b1111;

   reg [3:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state9&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state10&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state11&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state12&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state13&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state14&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state15&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state16&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
         endcase
							</Template>
						</SubFolder>
						<SubFolder label="Safe" treetype="folder">
							<Template label="4 States" treetype="template">
   parameter &lt;state1&gt; = 2'b00;
   parameter &lt;state2&gt; = 2'b01;
   parameter &lt;state3&gt; = 2'b10;
   parameter &lt;state4&gt; = 2'b11;

   reg [1:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            default : begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
         endcase
							</Template>
							<Template label="8 States" treetype="template">
   parameter &lt;state1&gt; = 3'b000;
   parameter &lt;state2&gt; = 3'b001;
   parameter &lt;state3&gt; = 3'b010;
   parameter &lt;state4&gt; = 3'b011;
   parameter &lt;state5&gt; = 3'b100;
   parameter &lt;state6&gt; = 3'b101;
   parameter &lt;state7&gt; = 3'b110;
   parameter &lt;state8&gt; = 3'b111;

   reg [2:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            default : begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
         endcase
							</Template>
							<Template label="16 States" treetype="template">
   parameter &lt;state1&gt;  = 4'b0000;
   parameter &lt;state2&gt;  = 4'b0001;
   parameter &lt;state3&gt;  = 4'b0010;
   parameter &lt;state4&gt;  = 4'b0011;
   parameter &lt;state5&gt;  = 4'b0100;
   parameter &lt;state6&gt;  = 4'b0101;
   parameter &lt;state7&gt;  = 4'b0110;
   parameter &lt;state8&gt;  = 4'b0111;
   parameter &lt;state9&gt;  = 4'b1000;
   parameter &lt;state10&gt; = 4'b1001;
   parameter &lt;state11&gt; = 4'b1010;
   parameter &lt;state12&gt; = 4'b1011;
   parameter &lt;state13&gt; = 4'b1100;
   parameter &lt;state14&gt; = 4'b1101;
   parameter &lt;state15&gt; = 4'b1110;
   parameter &lt;state16&gt; = 4'b1111;

   reg [3:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state9&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state10&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state11&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state12&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state13&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state14&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state15&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state16&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            default : begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
         endcase
							</Template>
						</SubFolder>
					</SubFolder>
					<SubFolder label="One-Hot (parameter)" treetype="folder">
						<SubFolder label="Fast" treetype="folder">
							<Template label="4 States" treetype="template">
   parameter &lt;state1&gt; = 4'b0001;
   parameter &lt;state2&gt; = 4'b0010;
   parameter &lt;state3&gt; = 4'b0100;
   parameter &lt;state4&gt; = 4'b1000;

   reg [3:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
         endcase
							</Template>
							<Template label="8 States" treetype="template">
   parameter &lt;state1&gt; = 8'b00000001;
   parameter &lt;state2&gt; = 8'b00000010;
   parameter &lt;state3&gt; = 8'b00000100;
   parameter &lt;state4&gt; = 8'b00001000;
   parameter &lt;state5&gt; = 8'b00010000;
   parameter &lt;state6&gt; = 8'b00100000;
   parameter &lt;state7&gt; = 8'b01000000;
   parameter &lt;state8&gt; = 8'b10000000;

   reg [7:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
         endcase
							</Template>
							<Template label="16 States" treetype="template">
   parameter &lt;state1&gt;  = 16'b0000000000000001;
   parameter &lt;state2&gt;  = 16'b0000000000000010;
   parameter &lt;state3&gt;  = 16'b0000000000000100;
   parameter &lt;state4&gt;  = 16'b0000000000001000;
   parameter &lt;state5&gt;  = 16'b0000000000010000;
   parameter &lt;state6&gt;  = 16'b0000000000100000;
   parameter &lt;state7&gt;  = 16'b0000000001000000;
   parameter &lt;state8&gt;  = 16'b0000000010000000;
   parameter &lt;state9&gt;  = 16'b0000000100000000;
   parameter &lt;state10&gt; = 16'b0000001000000000;
   parameter &lt;state11&gt; = 16'b0000010000000000;
   parameter &lt;state12&gt; = 16'b0000100000000000;
   parameter &lt;state13&gt; = 16'b0001000000000000;
   parameter &lt;state14&gt; = 16'b0010000000000000;
   parameter &lt;state15&gt; = 16'b0100000000000000;
   parameter &lt;state16&gt; = 16'b1000000000000000;

   reg [15:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state9&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state10&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state11&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state12&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state13&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state14&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state15&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state16&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
         endcase
							</Template>
						</SubFolder>
						<SubFolder label="Safe" treetype="folder">
							<Template label="4 States" treetype="template">
   parameter &lt;state1&gt; = 4'b0001;
   parameter &lt;state2&gt; = 4'b0010;
   parameter &lt;state3&gt; = 4'b0100;
   parameter &lt;state4&gt; = 4'b1000;

   reg [3:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            default: begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
	    end
         endcase
							</Template>
							<Template label="8 States" treetype="template">
   parameter &lt;state1&gt; = 8'b00000001;
   parameter &lt;state2&gt; = 8'b00000010;
   parameter &lt;state3&gt; = 8'b00000100;
   parameter &lt;state4&gt; = 8'b00001000;
   parameter &lt;state5&gt; = 8'b00010000;
   parameter &lt;state6&gt; = 8'b00100000;
   parameter &lt;state7&gt; = 8'b01000000;
   parameter &lt;state8&gt; = 8'b10000000;

   reg [7:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            default: begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
	    end
         endcase
							</Template>
							<Template label="16 States" treetype="template">
   parameter &lt;state1&gt;  = 16'b0000000000000001;
   parameter &lt;state2&gt;  = 16'b0000000000000010;
   parameter &lt;state3&gt;  = 16'b0000000000000100;
   parameter &lt;state4&gt;  = 16'b0000000000001000;
   parameter &lt;state5&gt;  = 16'b0000000000010000;
   parameter &lt;state6&gt;  = 16'b0000000000100000;
   parameter &lt;state7&gt;  = 16'b0000000001000000;
   parameter &lt;state8&gt;  = 16'b0000000010000000;
   parameter &lt;state9&gt;  = 16'b0000000100000000;
   parameter &lt;state10&gt; = 16'b0000001000000000;
   parameter &lt;state11&gt; = 16'b0000010000000000;
   parameter &lt;state12&gt; = 16'b0000100000000000;
   parameter &lt;state13&gt; = 16'b0001000000000000;
   parameter &lt;state14&gt; = 16'b0010000000000000;
   parameter &lt;state15&gt; = 16'b0100000000000000;
   parameter &lt;state16&gt; = 16'b1000000000000000;

   reg [15:0] &lt;state&gt; = &lt;state1&gt;;

   always @(posedge &lt;clock&gt;)
      if (&lt;reset&gt;) begin
         &lt;state&gt; &lt;= &lt;state1&gt;;
         &lt;outputs&gt; &lt;= &lt;initial_values&gt;;
      end
      else
         case (state)
            &lt;state1&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state2&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state3&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state4&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state5&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state6&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state7&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state8&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state9&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state10&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state11&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state12&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state13&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state14&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state15&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            &lt;state16&gt; : begin
               if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else if (&lt;condition&gt;)
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               else
                  &lt;state&gt; &lt;= &lt;next_state&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
            end
            default: begin  // Fault Recovery
               &lt;state&gt; &lt;= &lt;state1&gt;;
               &lt;outputs&gt; &lt;= &lt;values&gt;;
	    end
         endcase
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Tristate Buffers" treetype="folder">
				<SubFolder label="Active High" treetype="folder">
					<Template label="Using Always" treetype="template">
   always @(&lt;enable&gt; or &lt;data&gt;)
      if (&lt;enable&gt;)
         &lt;output_reg&gt; = &lt;data&gt;;
      else
         &lt;output_reg&gt; = 1'bz;
					</Template>
					<Template label="Using Wire Assignment" treetype="template">
   assign &lt;output_wire&gt; = &lt;enable&gt; ? &lt;data&gt; : 1'bz;
					</Template>
				</SubFolder>
				<SubFolder label="Active Low" treetype="folder">
					<Template label="Using Always" treetype="template">
   always @(&lt;enable&gt; or &lt;data&gt;)
      if (!&lt;enable&gt;)
         &lt;output_reg&gt; = &lt;data&gt;;
      else
         &lt;output_reg&gt; = 1'bz;
					</Template>
					<Template label="Using Wire Assignment" treetype="template">
   assign &lt;output_wire&gt; = &lt;enable&gt; ? 1'bz : &lt;data&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Conditional" treetype="folder">
			<SubFolder label="Case" treetype="folder">
				<Template label="2-input Select" treetype="template">
   case (&lt;2-bit select&gt;)
      2'b00  : begin
                  &lt;statement&gt;;
               end
      2'b01  : begin
                  &lt;statement&gt;;
               end
      2'b10  : begin
                  &lt;statement&gt;;
               end
      2'b11  : begin
                  &lt;statement&gt;;
               end
      default: begin
                  &lt;statement&gt;;
               end
   endcase
				</Template>
				<Template label="3-input Select" treetype="template">
   case (&lt;3-bit select&gt;)
      3'b000 : begin
                  &lt;statement&gt;;
               end
      3'b001 : begin
                  &lt;statement&gt;;
               end
      3'b010 : begin
                  &lt;statement&gt;;
               end
      3'b011 : begin
                  &lt;statement&gt;;
               end
      3'b100 : begin
                  &lt;statement&gt;;
               end
      3'b101 : begin
                  &lt;statement&gt;;
               end
      3'b110 : begin
                  &lt;statement&gt;;
               end
      3'b111 : begin
                  &lt;statement&gt;;
               end
      default: begin
                  &lt;statement&gt;;
               end
   endcase
				</Template>
				<Template label="4-input Select" treetype="template">
   case (&lt;4-bit select&gt;)
      4'b0000: begin
                  &lt;statement&gt;;
               end
      4'b0001: begin
                  &lt;statement&gt;;
               end
      4'b0010: begin
                  &lt;statement&gt;;
               end
      4'b0011: begin
                  &lt;statement&gt;;
               end
      4'b0100: begin
                  &lt;statement&gt;;
               end
      4'b0101: begin
                  &lt;statement&gt;;
               end
      4'b0110: begin
                  &lt;statement&gt;;
               end
      4'b0111: begin
                  &lt;statement&gt;;
               end
      4'b1000: begin
                  &lt;statement&gt;;
               end
      4'b1001: begin
                  &lt;statement&gt;;
               end
      4'b1010: begin
                  &lt;statement&gt;;
               end
      4'b1011: begin
                  &lt;statement&gt;;
               end
      4'b1100: begin
                  &lt;statement&gt;;
               end
      4'b1101: begin
                  &lt;statement&gt;;
               end
      4'b1110: begin
                  &lt;statement&gt;;
               end
      4'b1111: begin
                  &lt;statement&gt;;
               end
      default: begin
                  &lt;statement&gt;;
               end
   endcase
				</Template>
				<Template label="5-input Select" treetype="template">
   case (&lt;5-bit select&gt;)
      5'b00000: begin
                   &lt;statement&gt;;
                end
      5'b00001: begin
                   &lt;statement&gt;;
                end
      5'b00010: begin
                   &lt;statement&gt;;
                end
      5'b00011: begin
                   &lt;statement&gt;;
                end
      5'b00100: begin
                   &lt;statement&gt;;
                end
      5'b00101: begin
                   &lt;statement&gt;;
                end
      5'b00110: begin
                   &lt;statement&gt;;
                end
      5'b00111: begin
                   &lt;statement&gt;;
                end
      5'b01000: begin
                   &lt;statement&gt;;
                end
      5'b01001: begin
                   &lt;statement&gt;;
                end
      5'b01010: begin
                   &lt;statement&gt;;
                end
      5'b01011: begin
                   &lt;statement&gt;;
                end
      5'b01100: begin
                   &lt;statement&gt;;
                end
      5'b01101: begin
                   &lt;statement&gt;;
                end
      5'b01110: begin
                   &lt;statement&gt;;
                end
      5'b01111: begin
                   &lt;statement&gt;;
                end
      5'b10000: begin
                   &lt;statement&gt;;
                end
      5'b10001: begin
                   &lt;statement&gt;;
                end
      5'b10010: begin
                   &lt;statement&gt;;
                end
      5'b10011: begin
                   &lt;statement&gt;;
                end
      5'b10100: begin
                   &lt;statement&gt;;
                end
      5'b10101: begin
                   &lt;statement&gt;;
                end
      5'b10110: begin
                   &lt;statement&gt;;
                end
      5'b10111: begin
                   &lt;statement&gt;;
                end
      5'b11000: begin
                   &lt;statement&gt;;
                end
      5'b11001: begin
                   &lt;statement&gt;;
                end
      5'b11010: begin
                   &lt;statement&gt;;
                end
      5'b11011: begin
                   &lt;statement&gt;;
                end
      5'b11100: begin
                   &lt;statement&gt;;
                end
      5'b11101: begin
                   &lt;statement&gt;;
                end
      5'b11110: begin
                   &lt;statement&gt;;
                end
      5'b11111: begin
                   &lt;statement&gt;;
                end
      default : begin
                   &lt;statement&gt;;
                end
   endcase
				</Template>
				<Template label="6-input Select" treetype="template">
   case (&lt;6-bit select&gt;)
      6'b000000: begin
                    &lt;statement&gt;;
                 end
      6'b000001: begin
                    &lt;statement&gt;;
                 end
      6'b000010: begin
                    &lt;statement&gt;;
                 end
      6'b000011: begin
                    &lt;statement&gt;;
                 end
      6'b000100: begin
                    &lt;statement&gt;;
                 end
      6'b000101: begin
                    &lt;statement&gt;;
                 end
      6'b000110: begin
                    &lt;statement&gt;;
                 end
      6'b000111: begin
                    &lt;statement&gt;;
                 end
      6'b001000: begin
                    &lt;statement&gt;;
                 end
      6'b001001: begin
                    &lt;statement&gt;;
                 end
      6'b001010: begin
                    &lt;statement&gt;;
                 end
      6'b001011: begin
                    &lt;statement&gt;;
                 end
      6'b001100: begin
                    &lt;statement&gt;;
                 end
      6'b001101: begin
                    &lt;statement&gt;;
                 end
      6'b001110: begin
                    &lt;statement&gt;;
                 end
      6'b001111: begin
                    &lt;statement&gt;;
                 end
      6'b010000: begin
                    &lt;statement&gt;;
                 end
      6'b010001: begin
                    &lt;statement&gt;;
                 end
      6'b010010: begin
                    &lt;statement&gt;;
                 end
      6'b010011: begin
                    &lt;statement&gt;;
                 end
      6'b010100: begin
                    &lt;statement&gt;;
                 end
      6'b010101: begin
                    &lt;statement&gt;;
                 end
      6'b010110: begin
                    &lt;statement&gt;;
                 end
      6'b010111: begin
                    &lt;statement&gt;;
                 end
      6'b011000: begin
                    &lt;statement&gt;;
                 end
      6'b011001: begin
                    &lt;statement&gt;;
                 end
      6'b011010: begin
                    &lt;statement&gt;;
                 end
      6'b011011: begin
                    &lt;statement&gt;;
                 end
      6'b011100: begin
                    &lt;statement&gt;;
                 end
      6'b011101: begin
                    &lt;statement&gt;;
                 end
      6'b011110: begin
                    &lt;statement&gt;;
                 end
      6'b011111: begin
                    &lt;statement&gt;;
                 end
      6'b100000: begin
                    &lt;statement&gt;;
                 end
      6'b100001: begin
                    &lt;statement&gt;;
                 end
      6'b100010: begin
                    &lt;statement&gt;;
                 end
      6'b100011: begin
                    &lt;statement&gt;;
                 end
      6'b100100: begin
                    &lt;statement&gt;;
                 end
      6'b100101: begin
                    &lt;statement&gt;;
                 end
      6'b100110: begin
                    &lt;statement&gt;;
                 end
      6'b100111: begin
                    &lt;statement&gt;;
                 end
      6'b101000: begin
                    &lt;statement&gt;;
                 end
      6'b101001: begin
                    &lt;statement&gt;;
                 end
      6'b101010: begin
                    &lt;statement&gt;;
                 end
      6'b101011: begin
                    &lt;statement&gt;;
                 end
      6'b101100: begin
                    &lt;statement&gt;;
                 end
      6'b101101: begin
                    &lt;statement&gt;;
                 end
      6'b101110: begin
                    &lt;statement&gt;;
                 end
      6'b101111: begin
                    &lt;statement&gt;;
                 end
      6'b110000: begin
                    &lt;statement&gt;;
                 end
      6'b110001: begin
                    &lt;statement&gt;;
                 end
      6'b110010: begin
                    &lt;statement&gt;;
                 end
      6'b110011: begin
                    &lt;statement&gt;;
                 end
      6'b110100: begin
                    &lt;statement&gt;;
                 end
      6'b110101: begin
                    &lt;statement&gt;;
                 end
      6'b110110: begin
                    &lt;statement&gt;;
                 end
      6'b110111: begin
                    &lt;statement&gt;;
                 end
      6'b111000: begin
                    &lt;statement&gt;;
                 end
      6'b111001: begin
                    &lt;statement&gt;;
                 end
      6'b111010: begin
                    &lt;statement&gt;;
                 end
      6'b111011: begin
                    &lt;statement&gt;;
                 end
      6'b111100: begin
                    &lt;statement&gt;;
                 end
      6'b111101: begin
                    &lt;statement&gt;;
                 end
      6'b111110: begin
                    &lt;statement&gt;;
                 end
      6'b111111: begin
                    &lt;statement&gt;;
                 end
      default  : begin
                    &lt;statement&gt;;
                 end
   endcase
				</Template>
			</SubFolder>
			<Template label="Continuous Assignment (2-to-1 MUX)" treetype="template">
   assign &lt;output&gt; = &lt;1-bit_select&gt; ? &lt;input1&gt; : &lt;input0&gt;;
			</Template>
			<Template label="If / Else If / Else Statement" treetype="template">
   if (&lt;condition&gt;) begin
      &lt;statement&gt;;
   end
   else if (&lt;condition&gt;) begin
      &lt;statement&gt;;
   end
   else begin
      &lt;statement&gt;;
   end
			</Template>
		</SubFolder>
		<Template label="Continuous Assignment" treetype="template">
   assign &lt;wire_name&gt; = &lt;signal_or_value&gt;;
		</Template>
		<SubFolder label="Example Modules" treetype="folder">
			<SubFolder label="DSP" treetype="folder">
				<Template label="Complex Multiplier" treetype="template">
//  Complex Multiplier
//  The following code implements a parameterizable complex multiplier
//  The style described uses 3 DSP's to implement the complex multiplier
//  taking advantage of the pre-adder, so widths chosen should be less than what the architecture supports or else extra-logic/extra DSPs will be inferred
module cmult # (
                parameter AWIDTH = 16, // size of 1st input of multiplier
                          BWIDTH = 18  // size of 2nd input of multiplier
               )
               (
                input clk,
                input signed [AWIDTH-1:0] 	    ar, ai,
                input signed [BWIDTH-1:0] 	    br, bi,
                output signed [AWIDTH+BWIDTH:0] pr, pi
                );

reg signed [AWIDTH-1:0]	ai_d, ai_dd, ai_ddd, ai_dddd;
reg signed [AWIDTH-1:0]	ar_d, ar_dd, ar_ddd, ar_dddd;
reg signed [BWIDTH-1:0]	bi_d, bi_dd, bi_ddd, br_d, br_dd, br_ddd;
reg signed [AWIDTH:0]		addcommon;
reg signed [BWIDTH:0]		addr, addi;
reg signed [AWIDTH+BWIDTH:0]	mult0, multr, multi, pr_int, pi_int;
reg signed [AWIDTH+BWIDTH:0]	common, commonr1, commonr2;

always @(posedge clk)
  begin
    ar_d   &lt;= ar;
    ar_dd  &lt;= ar_d;
    ai_d   &lt;= ai;
    ai_dd  &lt;= ai_d;
    br_d   &lt;= br;
    br_dd  &lt;= br_d;
    br_ddd &lt;= br_dd;
    bi_d   &lt;= bi;
    bi_dd  &lt;= bi_d;
    bi_ddd &lt;= bi_dd;
  end

   // Common factor (ar ai) x bi, shared for the calculations of the real and imaginary final products
   //
always @(posedge clk)
  begin
    addcommon &lt;= ar_d - ai_d;
    mult0     &lt;= addcommon * bi_dd;
    common    &lt;= mult0;
  end

   // Real product
   //
always @(posedge clk)
  begin
    ar_ddd   &lt;= ar_dd;
    ar_dddd  &lt;= ar_ddd;
    addr     &lt;= br_ddd - bi_ddd;
    multr    &lt;= addr * ar_dddd;
    commonr1 &lt;= common;
    pr_int   &lt;= multr + commonr1;
  end

   // Imaginary product
   //
always @(posedge clk)
  begin
    ai_ddd   &lt;= ai_dd;
    ai_dddd  &lt;= ai_ddd;
    addi     &lt;= br_ddd + bi_ddd;
    multi    &lt;= addi * ai_dddd;
    commonr2 &lt;= common;
    pi_int   &lt;= multi + commonr2;
  end

assign pr = pr_int;
assign pi = pi_int;

endmodule // cmult
// The following is an instantiation template for cmult
/*
cmult # (.AWIDTH(16),
         .BWIDTH(18)
        )
your_instance_name
        (
         .clk(clk),
         .ar(ar),
         .ai(ai),
         .br(br),
         .bi(bi),
         .pr(pr),
         .pi(pi)
        );
*/

				</Template>
				<Template label="Complex Multiply Accumulate" treetype="template">
// This module describes a Complex Multiplier with accumulation (pr+i.pi) = (ar+i.ai)*(br+i.bi)
// This can be packed into 3 DSP blocks (Ultrascale architecture)
// Make sure the widths are less than what is supported by the architecture
module cmacc # (
                parameter AWIDTH = 16, 
                          BWIDTH = 18, 
                          SIZEOUT = 40
               )
               (
                 input clk,        // clock input 
                 input sload,      // synchronous load
                 input signed [AWIDTH-1:0] ar,  // 1st input of multiplier - real part
                 input signed [AWIDTH-1:0] ai,  // 1st input of multiplier - imaginary part
                 input signed [BWIDTH-1:0]   br, // 2nd input of multiplier - real part
                 input signed [BWIDTH-1:0]   bi, // 2nd input of multiplier - imaginary part
                 output signed [SIZEOUT-1:0] pr, // Output - Real part
                 output signed [SIZEOUT-1:0] pi  // Output - Imaginary part
               );
                
reg signed [AWIDTH-1:0] 	ai_d, ai_dd, ai_ddd, ai_dddd;
reg signed [AWIDTH-1:0]	ar_d, ar_dd, ar_ddd, ar_dddd;
reg signed [BWIDTH-1:0]	bi_d, bi_dd, bi_ddd, br_d, br_dd, br_ddd;
reg signed [AWIDTH:0]	addcommon;
reg signed [BWIDTH:0]	addr, addi;
reg signed [AWIDTH+BWIDTH:0]	mult0, multr, multi;	 
reg signed [SIZEOUT-1:0]	pr_int, pi_int, old_result_real, old_result_im;
reg signed [AWIDTH+BWIDTH:0]	common, commonr1, commonr2;

reg sload_reg;   
 
always @(posedge clk)
begin
  ar_d      &lt;= ar;
  ar_dd     &lt;= ar_d;
  ai_d      &lt;= ai;
  ai_dd     &lt;= ai_d;
  br_d      &lt;= br;
  br_dd     &lt;= br_d;
  br_ddd    &lt;= br_dd;
  bi_d      &lt;= bi;
  bi_dd     &lt;= bi_d;
  bi_ddd    &lt;= bi_dd;
  sload_reg &lt;= sload;
end
 
// Common factor (ar ai) x bi, shared for the calculations of the real and imaginary final products
// 
always @(posedge clk)
begin
  addcommon &lt;= ar_d - ai_d;
  mult0     &lt;= addcommon * bi_dd;
  common    &lt;= mult0;
end

// Accumulation loop (combinatorial) for *Real*
//
always @(sload_reg or pr_int)
if (sload_reg)
old_result_real &lt;= 0;
else
// 'sload' is now and opens the accumulation loop.
// The accumulator takes the next multiplier output
// in the same cycle.
old_result_real &lt;= pr_int;

// Real product
//
always @(posedge clk)
begin
  ar_ddd   &lt;= ar_dd;
  ar_dddd  &lt;= ar_ddd;
  addr     &lt;= br_ddd - bi_ddd;
  multr    &lt;= addr * ar_dddd;
  commonr1 &lt;= common;
  pr_int   &lt;= multr + commonr1 + old_result_real;
end

// Accumulation loop (combinatorial) for *Imaginary*
//
always @(sload_reg or pi_int)
if (sload_reg)
old_result_im &lt;= 0;
else
// 'sload' is now and opens the accumulation loop.
// The accumulator takes the next multiplier output
// in the same cycle.
old_result_im &lt;= pi_int;

// Imaginary product
//
always @(posedge clk)
begin
  ai_ddd   &lt;= ai_dd;
  ai_dddd  &lt;= ai_ddd;
  addi     &lt;= br_ddd + bi_ddd;	 
  multi    &lt;= addi * ai_dddd;
  commonr2 &lt;= common;
  pi_int   &lt;= multi + commonr2 + old_result_im;
end

assign pr = pr_int;
assign pi = pi_int;
     
endmodule // cmacc
/*
// The following is an instantiation template for
// cmacc
cmacc #(
        .AWIDTH(AWIDTH), 
        .BWIDTH(BWIDTH), 
        .SIZEOUT(SIZEOUT) 
        )
  your_instance_name 
        ( 
         .clk(clk),        
         .sload(sload),      
         .ar(ar),  
         .ai(ai),  
         .br(br), 
         .bi(bi), 
         .pr(pr), 
         .pi(pi)  
        );
*/
				</Template>
				<Template label="Convergent Rounding(Even)" treetype="template">
// This example shows how to infer Convergent Rounding (Even) using pattern
// detect within DSP block (Width of the inputs should be within
// what can be supported by the DSP architecture)
module convergentRoundingEven (
                               input clk,
                               input [23:0] a,
                               input [15:0] b,
                    		   output reg signed [23:0] zlast
                              );

reg signed [23:0] areg;
reg signed [15:0] breg;
reg signed [39:0] z1;

reg pattern_detect;
wire [15:0] pattern = 16'b0000000000000000;
wire [39:0] c = 40'b0000000000000000000000000111111111111111; // 15 ones

wire signed [39:0] multadd;
wire signed [15:0] zero;
reg  signed [39:0] multadd_reg;

// Convergent Rounding: LSB Correction Technique
// ---------------------------------------------
// For static convergent rounding, the pattern detector can be used
// to detect the midpoint case. For example, in an 8-bit round, if
// the decimal place is set at 4, the C input should be set to
// 0000.0111.  Round to even rounding should use CARRYIN = "1" and
// check for PATTERN "XXXX.0000" and replace the units place with 0
// if the pattern is matched. See UG193 for more details.

assign multadd = z1 + c + 1'b1;

always @(posedge clk)
begin
	areg  &lt;= a;
	breg  &lt;= b;
	z1    &lt;= areg * breg;
	pattern_detect &lt;= multadd[15:0] == pattern ? 1'b1 : 1'b0;
	multadd_reg &lt;= multadd;
end

// Unit bit replaced with 0 if pattern is detected
always @(posedge clk)
 zlast &lt;= pattern_detect ? {multadd_reg[39:17],1'b0} : multadd_reg[39:16];

endmodule // convergentRoundingEven
/*
// The following is an instantiation template for
// convergentRoundingEven
convergentRoundingEven your_instance_name (
                                           .clk(clk),
                                           .a(a),
                                           .b(b),
                                           .zlast(zlast)
                                          );
*/
				</Template>
				<Template label="Convergent Rounding(Odd)" treetype="template">
// This example shows how to infer Convergent Rounding
// (Odd) using pattern detect within DSP block (Width of the inputs should be within
// what can be supported by the DSP architecture)
module convergentRoundingOdd (
                              input clk,
                              input [23:0] a,
                              input [15:0] b,
                  			  output reg signed [23:0] zlast
                             );

reg signed [23:0] areg;
reg signed [15:0] breg;
reg signed [39:0] z1;

reg pattern_detect;
wire [15:0] pattern = 16'b1111111111111111;
wire [39:0] c = 40'b0000000000000000000000000111111111111111; // 15 ones

wire signed [39:0] multadd;
wire signed [15:0] zero;
reg  signed [39:0] multadd_reg;

// Convergent Rounding: LSB Correction Technique
// ---------------------------------------------
// For static convergent rounding,  the pattern detector can be
// used to detect  the midpoint case. For example,  in an 8-bit
// round, if the decimal place is  set at 4, the C input should
// be  set to  0000.0111.   Round to  odd  rounding should  use
// CARRYIN =  "0" and  check for  PATTERN "XXXX.1111"  and then
// replace  the  units place  bit  with  1  if the  pattern  is
// matched. See UG193 for details

assign multadd = z1 + c;

always @(posedge clk)
begin
    areg  &lt;= a;
	breg  &lt;= b;
	z1    &lt;= areg * breg;
	pattern_detect &lt;= multadd[15:0] == pattern ? 1'b1 : 1'b0;
	multadd_reg &lt;= multadd;
end

always @(posedge clk)
  zlast &lt;= pattern_detect ? {multadd_reg[39:17],1'b1} : multadd_reg[39:16];

endmodule // convergentRoundingOdd
/*
// The following is an instantiation template for
// convergentRoundingOdd
convergentRoundingOdd your_instance_name (
                                           .clk(clk),
                                           .a(a),
                                           .b(b),
                                           .zlast(zlast)
                                          );
*/
				</Template>
				<Template label="Dynamic preadd sub followed by mult add" treetype="template">
// This module describes a dynamic pre add/sub followed by multiplier, adder
// Make sure the widths are less than what is supported by the architecture
module dynpreaddmultadd  # (
                            parameter SIZEIN = 16
                           )
                          (
                            input clk,   // Clock input
                            input ce,    // Clock enable
                            input rst,   // Reset
                            input subadd, // Dynamic subadd control
                            input  signed [SIZEIN-1:0] a, b, c, d,  // Inputs
                            output signed [2*SIZEIN:0] dynpreaddmultadd_out // Output
                          );

// Declare registers for intermediate values
reg signed [SIZEIN-1:0] a_reg, b_reg, c_reg;
reg signed [SIZEIN:0]   add_reg;
reg signed [2*SIZEIN:0] d_reg, m_reg, p_reg;

always @(posedge clk)
begin
 if (rst)
  begin
   a_reg   &lt;= 0;
   b_reg   &lt;= 0;
   c_reg   &lt;= 0;
   d_reg   &lt;= 0;
   add_reg &lt;= 0;
   m_reg   &lt;= 0;
   p_reg   &lt;= 0;
  end
 else if (ce)
  begin
   a_reg   &lt;= a;
   b_reg   &lt;= b;
   c_reg   &lt;= c;
   d_reg   &lt;= d;
   if (subadd)
    add_reg &lt;= a - b;
   else
    add_reg &lt;= a + b;
   m_reg   &lt;= add_reg * c_reg;
   p_reg   &lt;= m_reg + d_reg;
  end
end

// Output accumulation result
assign dynpreaddmultadd_out = p_reg;
   
endmodule // dynpreaddmultadd
/*
// The following is an instantiation template for
// dynpreaddmultadd
dynpreaddmultadd  #(
                    .SIZEIN(SIZEIN)
                   )
     your_instance_name  
                   (
                   .clk(clk),
                   .clk(clk),
                   .ce(ce),
                   .rst(rst),
                   .subadd(subadd),
                   .a(a),
                   .dynpreaddmultadd_out(dynpreaddmultadd_out)
                   );
*/
				</Template>
				<Template label="FIR Symmetric Systolic Filter" treetype="template">
// Top module is sfir_even_symmetric_systolic_top
// Two submodules sfir_shifter and sfir_even_symmetric_systolic_element are
// instantiated in the toplevel

// sfir_shifter submodule
// This module is a shift register which shifts data by the specified taps
(* dont_touch = "yes" *)
module sfir_shifter #(
                      parameter dsize = 16,      // data bus width
                                nbtap = 4        // shift amount
                     )
                     (
                      input clk,                 // clock
                      input [dsize-1:0] datain,  // data input
                      output [dsize-1:0] dataout // data output
                     );

(* srl_style = "srl_register" *) reg [dsize-1:0] tmp [0:2*nbtap-1];
integer i;

always @(posedge clk)
 begin
  tmp[0] &lt;= datain;
  for (i=0; i&lt;=2*nbtap-2; i=i+1)
    tmp[i+1] &lt;= tmp[i];
 end

assign dataout = tmp[2*nbtap-1];
endmodule

// sfir_even_symmetric_systolic_element - sub module which is used in top
module sfir_even_symmetric_systolic_element #(
                                              parameter dsize = 16
                                             )
                 (
                  input clk,
                  input signed [dsize-1:0] coeffin,
                  input signed [dsize-1:0] datain,
                  input signed [dsize-1:0] datazin,
                  input signed [2*dsize-1:0] cascin,
                  output signed [dsize-1:0] cascdata,
                  output reg signed [2*dsize-1:0] cascout
                  );

reg signed [dsize-1:0]   coeff;
reg signed [dsize-1:0]   data;
reg signed [dsize-1:0]   dataz;
reg signed [dsize-1:0]   datatwo;
reg signed [dsize:0]     preadd;
reg signed [2*dsize-1:0] product;

assign cascdata = datatwo;

always @(posedge clk)
 begin
   coeff   &lt;= coeffin;
   data    &lt;= datain;
   datatwo &lt;= data;
   dataz   &lt;= datazin;
   preadd  &lt;= datatwo + dataz;
   product &lt;= preadd  * coeff;
   cascout &lt;= product + cascin;
 end

endmodule


module sfir_even_symmetric_systolic_top #(
                                          parameter nbtap = 4,
                                                    dsize = 16,
                                                    psize = 2*dsize
                                         )
                       (
                        input clk,
                        input signed [dsize-1:0] datain,
                        output signed [2*dsize-1:0] firout
                       );

wire signed [dsize-1:0] h [nbtap-1:0];
wire signed [dsize-1:0] arraydata [nbtap-1:0];
wire signed [psize-1:0] arrayprod [nbtap-1:0];

wire signed [dsize-1:0] shifterout;
reg  signed [dsize-1:0] dataz [nbtap-1:0];

assign h[0] =    7;
assign h[1] =   14;
assign h[2] = -138;
assign h[3] =  129;

assign firout = arrayprod[nbtap-1]; // Connect last product to output

sfir_shifter #(
                .dsize(dsize),
                .nbtap(nbtap)
               )
shifter_inst0 (
                .clk(clk),
                .datain(datain),
                .dataout(shifterout)
                );

generate
 genvar I;
   for (I=0; I&lt;nbtap; I=I+1)
     if (I==0)
       sfir_even_symmetric_systolic_element #(
                                              .dsize(dsize)
                                             )
                                   fte_inst0 (
                                              .clk(clk),
                                              .coeffin(h[I]),
                                              .datain(datain),
                                              .datazin(shifterout),
                                              .cascin({32{1'b0}}),
                                              .cascdata(arraydata[I]),
                                              .cascout(arrayprod[I])
                                              );
     else
       sfir_even_symmetric_systolic_element #(
                                              .dsize(dsize)
                                             )
                                   fte_inst  (
                                              .clk(clk),
                                              .coeffin(h[I]),
                                              .datain(arraydata[I-1]),
                                              .datazin(shifterout),
                                              .cascin(arrayprod[I-1]),
                                              .cascdata(arraydata[I]),
                                              .cascout(arrayprod[I])
                                              );
endgenerate
endmodule // sfir_even_symmetric_systolic_top

// The following is an instantiation template for
// sfir_even_symmetric_systolic_top
/*
sfir_even_symmetric_systolic_top #(
                                   .nbtap(4),
                                   .dsize(16),
                                   .psize(2*dsize)
                                 )
   your_instance_name  (
                       .clk(clk),
                       .datain(datain),
                       .firout(firout)
                      );
*/
				</Template>
				<Template label="MultAdd-3input" treetype="template">
// This module describes a Multiplier,3 input adder (a*b + c + p(feedback))
// This can be packed into 1 DSP block (Ultrascale architecture)
// Make sure the widths are less than what is supported by the architecture
module mult_add_3 #(
                    parameter AWIDTH = 16,      // Width of multiplier's 1st input
                              BWIDTH = 16,      // Width of multiplier's 2nd input
                              CWIDTH = 32,      // Width of Adder input    
                              PWIDTH = 33       // Output width
                   )
                   (
                    input clk,      // Clock
                    input rst,      // Reset
                    input signed [AWIDTH-1:0] a,  // Multipler input
                    input signed [BWIDTH-1:0] b,  // Multiplier input
                    input signed [CWIDTH-1:0] c,  // Adder input
                    input ce,                     // Clock enable  
                    output signed [PWIDTH-1:0] p  // Output
                   );

reg signed [AWIDTH-1:0] a_r;
reg signed [BWIDTH-1:0] b_r;
reg signed [CWIDTH-1:0] c_r;
reg signed [PWIDTH-1:0] p_r;

always @ (posedge clk)
begin
 if(rst)
 begin
  a_r &lt;= 0;
  b_r &lt;= 0;
  c_r &lt;= 0;
  p_r &lt;= 0;
 end
 else
  begin
   if(ce)
   begin
    a_r &lt;= a;
    b_r &lt;= b;
    c_r &lt;= c;
    p_r   &lt;= a_r * b_r + c_r + p_r; 
   end
  end
end
assign p = p_r;

endmodule                   
/* 
 The following is an instantation template for  mult_add_3 
 
 mult_add_3 # (
               .AWIDTH(AWIDTH),
               .BWIDTH(BWIDTH),
               .CWIDTH(CWIDTH),
               .PWIDTH(PWIDTH)
              )
your_instance_name 
             (
              .clk(clk),
              .rst(rst),
              .a(a),
              .b(b),
              .c(c),
              .ce(ce),
              .p(p)
             );
*/
				</Template>
				<Template label="Multipy and accumulate" treetype="template">
//  Multiply-accumulate unit
//  The following code implements a parameterizable Multiply-accumulate unit
//  with synchronous load to reset the accumulator without losing a clock cycle
//  Size of inputs/output should be less than/equal to what is supported by the architecture else extra logic/dsps will be inferred
module macc  # (
                parameter SIZEIN = 16,   // width of the inputs
                          SIZEOUT = 40   // width of output
               )
               (
                input clk,
                input ce,
                input sload,
                input signed [SIZEIN-1:0]   a,
                input signed [SIZEIN-1:0]   b,
                output signed [SIZEOUT-1:0] accum_out
               );

// Declare registers for intermediate values
reg signed [SIZEIN-1:0]   a_reg, b_reg;
reg                       sload_reg;
reg signed [2*SIZEIN-1:0] mult_reg;
reg signed [SIZEOUT-1:0]  adder_out, old_result;

always @(sload_reg or adder_out)
begin
 if (sload_reg)
    old_result &lt;= 0;
 else
  // 'sload' is now and opens the accumulation loop.
  // The accumulator takes the next multiplier output
  // in the same cycle.
    old_result &lt;= adder_out;
end

always @(posedge clk)
 if (ce)
  begin
    a_reg     &lt;= a;
    b_reg     &lt;= b;
    mult_reg  &lt;= a_reg * b_reg;
    sload_reg &lt;= sload;
    // Store accumulation result into a register
    adder_out &lt;= old_result + mult_reg;
 end

// Output accumulation result
assign accum_out = adder_out;

endmodule // macc
// The following is an instantiation template for macc
/*
macc  # (
         .SIZEIN(16),   // width of the inputs
         .SIZEOUT(40)   // width of output
        )
your_instance_name
        (
         .clk(clk),
         .ce(ce),
         .sload(sload),
         .a(a),
         .b(b),
         .accum_out(accum_out)
        );
*/

				</Template>
				<Template label="Pre-subtractor with multiplication" treetype="template">
// This code implements a parameterizable subtractor followed by multiplier which will be packed into DSP Block
// Operation : (a-b) * c
module presubmult  # (
                      parameter SIZEIN = 16  // Size of inputs
                     )
                     (
                      input clk, // Clock
                      input ce,  // Clock enable
                      input rst, // Reset
                      input signed [SIZEIN-1:0] a, // 1st input to pre-adder
                      input signed [SIZEIN-1:0] b, // 2nd input to pre-adder
                      input signed [SIZEIN-1:0] c, // multiplier input
                      output signed [2*SIZEIN:0] presubmult_out
                     );

// Declare registers for intermediate values
reg signed [SIZEIN-1:0] a_reg, b_reg, c_reg;
reg signed [SIZEIN:0]   add_reg;
reg signed [2*SIZEIN:0] m_reg, p_reg;

always @(posedge clk)
 if (rst)
  begin
    a_reg   &lt;= 0;
    b_reg   &lt;= 0;
    c_reg   &lt;= 0;
    add_reg &lt;= 0;
    m_reg   &lt;= 0;
    p_reg   &lt;= 0;
  end
 else if (ce)
  begin
    a_reg   &lt;= a;
    b_reg   &lt;= b;
    c_reg   &lt;= c;
    add_reg &lt;= a - b;
    m_reg   &lt;= add_reg * c_reg;
    p_reg   &lt;= m_reg;
  end

assign presubmult_out = p_reg;

endmodule // presubmult
// The following is an instantiation template for presubmult
/*
presubmult  # (
                .SIZEIN(16)  // Size of inputs
               )
your_instance_name (
                    .clk(clk),  // Clock
                    .ce(ce),    // enable
                    .rst(rst),  // Reset
                    .a(a),
                    .b(b),
                    .c(c),
                    .presubmult_out(presubmult_out)
                   );
*/
				</Template>
				<Template label="Squarer" treetype="template">
// This module implements a parameterizable (a-b) squarer
// which can be implemented in a DSP48E2(ultrascale) by using the pre-adder
// The size should be less than or equal to what is supported
// by the architecture
module squarediffmult # (
                         parameter SIZEIN = 16  // size of the inputs
                        )
                        (
                          input clk,    // Clock
                          input ce,     // enable
                          input rst,    // reset
                          input signed [SIZEIN-1:0] a, // 1st input
                          input signed [SIZEIN-1:0] b, // seconde input
                          output signed [2*SIZEIN+1:0] square_out
                        );

// Declare registers for intermediate values
reg signed [SIZEIN-1:0]   a_reg, b_reg;
reg signed [SIZEIN:0]     diff_reg;
reg signed [2*SIZEIN+1:0] m_reg, p_reg;

always @(posedge clk)
begin
 if (rst)
  begin
    a_reg    &lt;= 0;
    b_reg    &lt;= 0;
    diff_reg &lt;= 0;
    m_reg    &lt;= 0;
    p_reg    &lt;= 0;
  end
 else
  if (ce)
   begin
      a_reg     &lt;= a;
      b_reg     &lt;= b;
      diff_reg  &lt;= a_reg - b_reg;
      m_reg     &lt;= diff_reg * diff_reg;
      p_reg     &lt;= m_reg;
   end
end

// Output result
assign square_out = p_reg;

endmodule // squarediffmult

// The following is an instantiation template for
// squarediffmult
/*
squarediffmult # (
                  .SIZEIN(16)
                 )
your_instance_name (
                    clk(clk),
                    ce(ce),
                    rst(rst),
                    a(a),
                    b(b),
                    square_out(square_out)
                   );
*/
				</Template>
				<Template label="Squarer diff MAC" treetype="template">
// This module performs subtraction of two inputs, squaring on the diff
// and then accumulation 
// This can be implemented in 1 DSP Block (Ultrascale architecture)
module squarediffmacc  # (
                          parameter SIZEIN = 16, 
                                    SIZEOUT = 40
                         )
                        (
                         input clk, // clock input 
                         input ce,  // clock enable
                         input sload, // synchronous load
                         input signed [SIZEIN-1:0]   a, // 1st input
                         input signed [SIZEIN-1:0]   b, // 2nd input
                         output signed [SIZEOUT+1:0] accum_out // accumulator output
                        );
  
// Declare registers for intermediate values
reg signed [SIZEIN-1:0] 	a_reg, b_reg;   
reg signed [SIZEIN:0] 	diff_reg;
reg                       sload_reg;
reg signed [2*SIZEIN+1:0] m_reg;
reg signed [SIZEOUT-1:0]  adder_out, old_result;
  
  always @(sload_reg or adder_out)
  if (sload_reg)
    old_result &lt;= 0;
  else
    // 'sload' is now and opens the accumulation loop.
    // The accumulator takes the next multiplier output
    // in the same cycle.
    old_result &lt;= adder_out;
     
  always @(posedge clk)
  if (ce)
  begin
    a_reg     &lt;= a;
    b_reg     &lt;= b;
    diff_reg  &lt;= a_reg - b_reg;	  
    m_reg  &lt;= diff_reg * diff_reg;
    sload_reg &lt;= sload;
    // Store accumulation result into a register
    adder_out &lt;= old_result + m_reg;
  end
     
  // Output accumulation result
  assign accum_out = adder_out;
     
endmodule // squarediffmacc
/*
// The following is an instantiation template for
// squarediffmacc
squarediffmacc #(
                 .SIZEIN(SIZEIN),
                 .SIZEOUT(SIZEOUT)
                )
                (
                .clk(clk),
                .clk(clk),
                .ce(ce),
                .sload(sload),
                .a(a),
                .b(b),
                .accum_out(accum_out)
                );
*/
				</Template>
			</SubFolder>
			<SubFolder label="Misc" treetype="folder">
				<Template label="Asynchronous Input Synchronization (Reduces Issues w/ Metastability)" treetype="template">
// Asynchronous Input Synchronization
//
// The following code is an example of synchronizing an asynchronous input
// of a design to reduce the probability of metastability affecting a circuit.
//
// The following synthesis and implementation attributes is added to the code
// in order improve the MTBF characteristics of the implementation:
//
//  ASYNC_REG="TRUE" - Specifies registers will be receiving asynchronous data
//                     input to allow tools to report and improve metastability
//
// The following parameters are available for customization:
//
//   SYNC_STAGES     - Integer value for number of synchronizing registers, must be 2 or higher
//   PIPELINE_STAGES - Integer value for number of registers on the output of the
//                     synchronizer for the purpose of improveing performance.
//                     Particularly useful for high-fanout nets.
//   INIT            - Initial value of synchronizer registers upon startup, 1'b0 or 1'b1.

module async_input_sync #(
   parameter SYNC_STAGES = 3,
   parameter PIPELINE_STAGES = 1,
   parameter INIT = 1'b0
) (
   input clk,
   input async_in,
   output sync_out
);

   (* ASYNC_REG="TRUE" *) reg [SYNC_STAGES-1:0] sreg = {SYNC_STAGES{INIT}};

   always @(posedge clk)
     sreg &lt;= {sreg[SYNC_STAGES-2:0], async_in};

   generate
      if (PIPELINE_STAGES==0) begin: no_pipeline

         assign sync_out = sreg[SYNC_STAGES-1];

      end else if (PIPELINE_STAGES==1) begin: one_pipeline

         reg sreg_pipe = INIT;

         always @(posedge clk)
            sreg_pipe &lt;= sreg[SYNC_STAGES-1];

         assign sync_out = sreg_pipe;

      end else begin: multiple_pipeline

        (* shreg_extract = "no" *) reg [PIPELINE_STAGES-1:0] sreg_pipe = {PIPELINE_STAGES{INIT}};

         always @(posedge clk)
            sreg_pipe &lt;= {sreg_pipe[PIPELINE_STAGES-2:0], sreg[SYNC_STAGES-1]};

         assign sync_out = sreg_pipe[PIPELINE_STAGES-1];

      end
   endgenerate

endmodule

// The following is an instantiation template for async_input_sync
/*
// Asynchronous Input Synchronization
async_input_sync #(
   .SYNC_STAGES(3),
   .PIPELINE_STAGES(1),
   .INIT(1'b0)
) your_instance_name (
   .clk(clk),
   .async_in(async_in),
   .sync_out(sync_out)
);
*/
				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<SubFolder label="BlockRAM" treetype="folder">
					<SubFolder label="Simple Dual Port" treetype="folder">
						<Template label="1 Clock" treetype="template">
//  Xilinx Simple Dual Port Single Clock RAM
//  This code implements a parameterizable SDP single clock memory.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_simple_dual_port_1_clock_ram #(
  parameter RAM_WIDTH = 64,                       // Specify RAM data width
  parameter RAM_DEPTH = 512,                      // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra, // Write address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb, // Read address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,          // RAM input data
  input clka,                          // Clock
  input wea,                           // Write enable
  input enb,                           // Read Enable, for additional power savings, disable when not in use
  input rstb,                          // Output reset (does not affect memory contents)
  input regceb,                        // Output register enable
  output [RAM_WIDTH-1:0] doutb         // RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka) begin
    if (wea)
      BRAM[addra] &lt;= dina;
    if (enb)
      ram_data &lt;= BRAM[addrb];
  end

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign doutb = ram_data;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rstb)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data;

      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_simple_dual_port_1_clock_ram
/*
//  Xilinx Simple Dual Port Single Clock RAM
  xilinx_simple_dual_port_1_clock_ram #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Write address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Read address bus, width determined from RAM_DEPTH
    .dina(dina),     // RAM input data, width determined from RAM_WIDTH
    .clka(clka),     // Clock
    .wea(wea),       // Write enable
    .enb(enb),	     // Read Enable, for additional power savings, disable when not in use
    .rstb(rstb),     // Output reset (does not affect memory contents)
    .regceb(regceb), // Output register enable
    .doutb(doutb)    // RAM output data, width determined from RAM_WIDTH
  );
*/
						</Template>
						<Template label="1 Clock w/ Byte-write" treetype="template">
//  Xilinx Simple Dual Port Single Clock RAM with Byte-write
//  This code implements a parameterizable SDP single clock memory.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_simple_dual_port_byte_write_1_clock_ram #(
  parameter NB_COL    = 8,                        // Specify number of columns (number of bytes)
  parameter COL_WIDTH = 8,                        // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = 512,                      // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Write address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,  // Read address bus, width determined from RAM_DEPTH
  input [(NB_COL*COL_WIDTH)-1:0] dina,  // RAM input data
  input clka,                           // Clock
  input [NB_COL-1:0] wea,               // Byte-write enable
  input enb,                            // Read Enable, for additional power savings, disable when not in use
  input rstb,                           // Output reset (does not affect memory contents)
  input regceb,                         // Output register enable
  output [(NB_COL*COL_WIDTH)-1:0] doutb // RAM output data
);

  reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (enb)
      ram_data &lt;= BRAM[addrb];

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge clka)
         if (wea[i])
           BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
      end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign doutb = ram_data;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge clka)
        if (rstb)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data;

      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_simple_dual_port_byte_write_1_clock_ram
/*
//  Xilinx Simple Dual Port Single Clock RAM with Byte-write
  xilinx_simple_dual_port_byte_write_1_clock_ram #(
    .NB_COL(4),                           // Specify number of columns (number of bytes)
    .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Write address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Read address bus, width determined from RAM_DEPTH
    .dina(dina),     // RAM input data, width determined from NB_COL*COL_WIDTH
    .clka(clka),     // Clock
    .wea(wea),       // Byte-write enable, width determined from NB_COL
    .enb(enb),       // Read Enable, for additional power savings, disable when not in use
    .rstb(rstb),     // Output reset (does not affect memory contents)
    .regceb(regceb), // Output register enable
    .doutb(doutb)    // RAM output data, width determined from NB_COL*COL_WIDTH
  );
*/
						</Template>
						<Template label="2 Clock" treetype="template">
//  Xilinx Simple Dual Port 2 Clock RAM
//  This code implements a parameterizable SDP dual clock memory.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_simple_dual_port_2_clock_ram #(
  parameter RAM_WIDTH = 36,                       // Specify RAM data width
  parameter RAM_DEPTH = 512,                      // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra, // Write address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb, // Read address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,          // RAM input data
  input clka,                          // Write clock
  input clkb,                          // Read clock
  input wea,                           // Write enable
  input enb,                           // Read Enable, for additional power savings, disable when not in use
  input rstb,                          // Output reset (does not affect memory contents)
  input regceb,                        // Output register enable
  output [RAM_WIDTH-1:0] doutb         // RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (wea)
      BRAM[addra] &lt;= dina;

  always @(posedge clkb)
    if (enb)
      ram_data &lt;= BRAM[addrb];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign doutb = ram_data;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clkb)
        if (rstb)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data;

      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_simple_dual_port_2_clock_ram
/*
//  Xilinx Simple Dual Port 2 Clock RAM
  xilinx_simple_dual_port_2_clock_ram #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),    // Write address bus, width determined from RAM_DEPTH
    .addrb(addrb),    // Read address bus, width determined from RAM_DEPTH
    .dina(dina),      // RAM input data, width determined from RAM_WIDTH
    .clka(clka),      // Write clock
    .clkb(clkb),      // Read clock
    .wea(wea),        // Write enable
    .enb(enb),        // Read Enable, for additional power savings, disable when not in use
    .rstb(rstb),      // Output reset (does not affect memory contents)
    .regceb(regceb),  // Output register enable
    .doutb(doutb)     // RAM output data, width determined from RAM_WIDTH
  );

*/
						</Template>
						<Template label="2 Clock w/ Byte-write" treetype="template">
//  Xilinx Simple Dual Port 2 Clock RAM with Byte-write
//  This code implements a parameterizable SDP dual clock memory.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_simple_dual_port_byte_write_2_clock_ram #(
  parameter NB_COL    = 8,                           // Specify number of columns (number of bytes)
  parameter COL_WIDTH = 8,                        // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = 512,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Write address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,  // Read address bus, width determined from RAM_DEPTH
  input [(NB_COL*COL_WIDTH)-1:0] dina,  // RAM input data
  input clka,                           // Write clock
  input clkb,                           // Read clock
  input [NB_COL-1:0] wea,               // Byte-write enable
  input enb,                            // Read Enable, for additional power savings, disable when not in use
  input rstb,                           // Output reset (does not affect memory contents)
  input regceb,                         // Output register enable
  output [(NB_COL*COL_WIDTH)-1:0] doutb // RAM output data
);

  reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge clkb)
    if (enb)
      ram_data &lt;= BRAM[addrb];

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge clka)
         if (wea[i])
           BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
      end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign doutb = ram_data;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge clkb)
        if (rstb)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data;

      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_simple_dual_port_byte_write_2_clock_ram
/*
//  Xilinx Simple Dual Port 2 Clock RAM with Byte-write
  xilinx_simple_dual_port_byte_write_2_clock_ram #(
    .NB_COL(4),                           // Specify number of columns (number of bytes)
    .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Write address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Read address bus, width determined from RAM_DEPTH
    .dina(dina),     // RAM input data, width determined from NB_COL*COL_WIDTH
    .clka(clka),     // Write clock
    .clkb(clkb),     // Read clock
    .wea(wea),       // Byte-write enable, width determined from NB_COL
    .enb(enb),       // Read Enable, for additional power savings, disable when not in use
    .rstb(rstb),     // Output reset (does not affect memory contents)
    .regceb(regceb), // Output register enable
    .doutb(doutb)    // RAM output data, width determined from NB_COL*COL_WIDTH
  );
*/
						</Template>
					</SubFolder>
					<SubFolder label="Single Port" treetype="folder">
						<SubFolder label="Byte-wide Write Enable" treetype="folder">
							<Template label="Read First Mode" treetype="template">
//  Xilinx Single Port Byte-Write Read First RAM
//  This code implements a parameterizable single-port byte-write read-first memory where when data
//  is written to the memory, the output reflects the prior contents of the memory location.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.
//  Modify the parameters for the desired RAM characteristics.

module xilinx_single_port_byte_write_ram_read_first #(
  parameter NB_COL = 4,                           // Specify number of columns (number of bytes)
  parameter COL_WIDTH = 9,                        // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Address bus, width determined from RAM_DEPTH
  input [(NB_COL*COL_WIDTH)-1:0] dina,  // RAM input data
  input clka,                           // Clock
  input [NB_COL-1:0] wea,               // Byte-write enable
  input ena,                            // RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Output reset (does not affect memory contents)
  input regcea,                         // Output register enable
  output [(NB_COL*COL_WIDTH)-1:0] douta // RAM output data
);

  reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena) begin
      ram_data &lt;= BRAM[addra];
    end

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge clka)
         if (ena)
           if (wea[i])
             BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
      end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data;

      assign douta = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_single_port_byte_write_ram_read_first
/*
  //  Xilinx Single Port Byte-Write Read First RAM
  xilinx_single_port_byte_write_ram_read_first #(
    .NB_COL(4),                           // Specify number of columns (number of bytes)
    .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),     // Address bus, width determined from RAM_DEPTH
    .dina(dina),       // RAM input data, width determined from NB_COL*COL_WIDTH
    .clka(clka),       // Clock
    .wea(wea),         // Byte-write enable, width determined from NB_COL
    .ena(ena),         // RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),       // Output reset (does not affect memory contents)
    .regcea(regcea),   // Output register enable
    .douta(douta)      // RAM output data, width determined from NB_COL*COL_WIDTH
  );
*/
							</Template>
							<Template label="Write First Mode" treetype="template">
//  Xilinx Single Port Byte-Write Write First RAM
//  This code implements a parameterizable single-port byte-write write-first memory where when data
//  is written to the memory, the output reflects the new memory contents.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.
//  Modify the parameters for the desired RAM characteristics.

module xilinx_single_port_byte_write_ram_write_first #(
  parameter NB_COL = 4,                           // Specify number of columns (number of bytes)
  parameter COL_WIDTH = 9,                        // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Address bus, width determined from RAM_DEPTH
  input [(NB_COL*COL_WIDTH)-1:0] dina,  // RAM input data
  input clka,                           // Clock
  input [NB_COL-1:0] wea,               // Byte-write enable
  input ena,                            // RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Output reset (does not affect memory contents)
  input regcea,                         // Output register enable
  output [(NB_COL*COL_WIDTH)-1:0] douta          // RAM output data
);

  reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena) begin
      ram_data &lt;= BRAM[addra];
    end

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge clka)
         if (ena)
           if (wea[i]) begin
             BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             ram_data[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else begin
             ram_data[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end
      end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data;

      assign douta = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_single_port_byte_write_ram_write_first
/*
  //  Xilinx Single Port Byte-Write Write First RAM
  xilinx_single_port_byte_write_ram_write_first #(
    .NB_COL(4),                           // Specify number of columns (number of bytes)
    .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),     // Address bus, width determined from RAM_DEPTH
    .dina(dina),       // RAM input data, width determined from NB_COL*COL_WIDTH
    .clka(clka),       // Clock
    .wea(wea),         // Byte-write enable, width determined from NB_COL
    .ena(ena),         // RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),       // Output reset (does not affect memory contents)
    .regcea(regcea),   // Output register enable
    .douta(douta)      // RAM output data, width determined from NB_COL*COL_WIDTH
  );
*/
							</Template>
						</SubFolder>
						<Template label="No Change Mode" treetype="template">
//  Xilinx Single Port No Change RAM
//  This code implements a parameterizable single-port no-change memory where when data is written
//  to the memory, the output remains unchanged.  This is the most power efficient write mode.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_single_port_ram_no_change #(
  parameter RAM_WIDTH = 18,                       // Specify RAM data width
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,           // RAM input data
  input clka,                           // Clock
  input wea,                            // Write enable
  input ena,                            // RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Output reset (does not affect memory contents)
  input regcea,                         // Output register enable
  output [RAM_WIDTH-1:0] douta          // RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena)
      if (wea)
        BRAM[addra] &lt;= dina;
      else
        ram_data &lt;= BRAM[addra];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data;

      assign douta = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_single_port_ram_no_change
/*
  //  Xilinx Single Port No Change RAM
  xilinx_single_port_ram_no_change #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),    // Address bus, width determined from RAM_DEPTH
    .dina(dina),      // RAM input data, width determined from RAM_WIDTH
    .clka(clka),      // Clock
    .wea(wea),        // Write enable
    .ena(ena),        // RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),      // Output reset (does not affect memory contents)
    .regcea(regcea),  // Output register enable
    .douta(douta)     // RAM output data, width determined from RAM_WIDTH
  );

*/
						</Template>
						<Template label="Read First Mode" treetype="template">
//  Xilinx Single Port Read First RAM
//  This code implements a parameterizable single-port read-first memory where when data
//  is written to the memory, the output reflects the prior contents of the memory location.
//  If the output data is not needed during writes or the last read value is desired to be
//  retained, it is suggested to set WRITE_MODE to NO_CHANGE as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.
//  Modify the parameters for the desired RAM characteristics.

module xilinx_single_port_ram_read_first #(
  parameter RAM_WIDTH = 18,                       // Specify RAM data width
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,           // RAM input data
  input clka,                           // Clock
  input wea,                            // Write enable
  input ena,                            // RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Output reset (does not affect memory contents)
  input regcea,                         // Output register enable
  output [RAM_WIDTH-1:0] douta          // RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena) begin
      if (wea)
        BRAM[addra] &lt;= dina;
      ram_data &lt;= BRAM[addra];
    end

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data;

      assign douta = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_single_port_ram_read_first
/*
  //  Xilinx Single Port Read First RAM
  xilinx_single_port_ram_read_first #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),     // Address bus, width determined from RAM_DEPTH
    .dina(dina),       // RAM input data, width determined from RAM_WIDTH
    .clka(clka),       // Clock
    .wea(wea),         // Write enable
    .ena(ena),         // RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),       // Output reset (does not affect memory contents)
    .regcea(regcea),   // Output register enable
    .douta(douta)      // RAM output data, width determined from RAM_WIDTH
  );
*/
						</Template>
						<Template label="Write First Mode" treetype="template">
//  Xilinx Single Port Write First RAM
//  This code implements a parameterizable single-port write-first memory where when data
//  is written to the memory, the output reflects the same data being written to the memory.
//  If the output data is not needed during writes or the last read value is desired to be
//  it is suggested to use a No Change as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.
//  Modify the parameters for the desired RAM characteristics.

module xilinx_single_port_ram_write_first #(
  parameter RAM_WIDTH = 18,                       // Specify RAM data width
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,           // RAM input data
  input clka,                           // Clock
  input wea,                            // Write enable
  input ena,                            // RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Output reset (does not affect memory contents)
  input regcea,                         // Output register enable
  output [RAM_WIDTH-1:0] douta          // RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena)
      if (wea) begin
        BRAM[addra] &lt;= dina;
        ram_data &lt;= dina;
      end else
        ram_data &lt;= BRAM[addra];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data;

      assign douta = douta_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_single_port_ram_write_first
/*
  //  Xilinx Single Port Write First RAM
  xilinx_single_port_ram_write_first #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),     // Address bus, width determined from RAM_DEPTH
    .dina(dina),       // RAM input data, width determined from RAM_WIDTH
    .clka(clka),       // Clock
    .wea(wea),         // Write enable
    .ena(ena),         // RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),       // Output reset (does not affect memory contents)
    .regcea(regcea),   // Output register enable
    .douta(douta)      // RAM output data, width determined from RAM_WIDTH
  );
*/
						</Template>
					</SubFolder>
					<SubFolder label="True Dual Port" treetype="folder">
						<SubFolder label="1 Clock" treetype="folder">
							<Template label="No Change Mode" treetype="template">
//  Xilinx True Dual Port RAM, No Change, Single Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  This is a no change RAM which retains the last read value on the output during writes
//  which is the most power efficient mode.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_true_dual_port_no_change_1_clock_ram #(
  parameter RAM_WIDTH = 18,                       // Specify RAM data width
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,  // Port B address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,           // Port A RAM input data
  input [RAM_WIDTH-1:0] dinb,           // Port B RAM input data
  input clka,                           // Clock
  input wea,                            // Port A write enable
  input web,                            // Port B write enable
  input ena,                            // Port A RAM Enable, for additional power savings, disable port when not in use
  input enb,                            // Port B RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Port A output reset (does not affect memory contents)
  input rstb,                           // Port B output reset (does not affect memory contents)
  input regcea,                         // Port A output register enable
  input regceb,                         // Port B output register enable
  output [RAM_WIDTH-1:0] douta,         // Port A RAM output data
  output [RAM_WIDTH-1:0] doutb          // Port B RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data_a = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] ram_data_b = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena)
      if (wea)
        BRAM[addra] &lt;= dina;
      else
        ram_data_a &lt;= BRAM[addra];

  always @(posedge clka)
    if (enb)
      if (web)
        BRAM[addrb] &lt;= dinb;
      else
        ram_data_b &lt;= BRAM[addrb];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clka)
        if (rstb)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_no_change_1_clock_ram
/*
  //  Xilinx True Dual Port RAM, No Change, Single Clock
  xilinx_true_dual_port_no_change_1_clock_ram #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from RAM_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from RAM_WIDTH
    .clka(clka),     // Clock
    .wea(wea),       // Port A write enable
    .web(web),       // Port B write enable
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from RAM_WIDTH
    .doutb(doutb)    // Port B RAM output data, width determined from RAM_WIDTH
  );
*/
							</Template>
							<Template label="Read First Mode" treetype="template">
//  Xilinx True Dual Port RAM, Read First, Single Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the prior memory contents at the write
//  address are presented on the output port.  If the output data is
//  not needed during writes or the last read value is desired to be retained,
//  it is suggested to use a no change RAM as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_true_dual_port_read_first_1_clock_ram #(
  parameter RAM_WIDTH = 18,                       // Specify RAM data width
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,  // Port B address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,           // Port A RAM input data
  input [RAM_WIDTH-1:0] dinb,           // Port B RAM input data
  input clka,                           // Clock
  input wea,                            // Port A write enable
  input web,                            // Port B write enable
  input ena,                            // Port A RAM Enable, for additional power savings, disable port when not in use
  input enb,                            // Port B RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Port A output reset (does not affect memory contents)
  input rstb,                           // Port B output reset (does not affect memory contents)
  input regcea,                         // Port A output register enable
  input regceb,                         // Port B output register enable
  output [RAM_WIDTH-1:0] douta,         // Port A RAM output data
  output [RAM_WIDTH-1:0] doutb          // Port B RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data_a = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] ram_data_b = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena) begin
      if (wea)
        BRAM[addra] &lt;= dina;
      ram_data_a &lt;= BRAM[addra];
    end

  always @(posedge clka)
    if (enb) begin
      if (web)
        BRAM[addrb] &lt;= dinb;
      ram_data_b &lt;= BRAM[addrb];
    end

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clka)
        if (rstb)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_read_first_1_clock_ram
/*
  //  Xilinx True Dual Port RAM, Read First, Single Clock
  xilinx_true_dual_port_read_first_1_clock_ram #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from RAM_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from RAM_WIDTH
    .clka(clka),     // Clock
    .wea(wea),       // Port A write enable
    .web(web),       // Port B write enable
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from RAM_WIDTH
    .doutb(doutb)    // Port B RAM output data, width determined from RAM_WIDTH
  );
*/
							</Template>
							<Template label="Read First Mode w/ Byte-write" treetype="template">
//  Xilinx True Dual Port RAM Byte Write Read First Single Clock RAM
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the prior memory contents at the write
//  address are presented on the output port.

module xilinx_true_dual_port_read_first_byte_write_1_clock_ram #(
  parameter NB_COL = 4,                           // Specify number of columns (number of bytes)
  parameter COL_WIDTH = 9,                        // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,   // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,   // Port B address bus, width determined from RAM_DEPTH
  input [(NB_COL*COL_WIDTH)-1:0] dina,   // Port A RAM input data
  input [(NB_COL*COL_WIDTH)-1:0] dinb,   // Port B RAM input data
  input clka,                            // Clock
  input [NB_COL-1:0] wea,                // Port A write enable
  input [NB_COL-1:0] web,                // Port B write enable
  input ena,                             // Port A RAM Enable, for additional power savings, disable port when not in use
  input enb,                             // Port B RAM Enable, for additional power savings, disable port when not in use
  input rsta,                            // Port A output reset (does not affect memory contents)
  input rstb,                            // Port B output reset (does not affect memory contents)
  input regcea,                          // Port A output register enable
  input regceb,                          // Port B output register enable
  output [(NB_COL*COL_WIDTH)-1:0] douta, // Port A RAM output data
  output [(NB_COL*COL_WIDTH)-1:0] doutb  // Port B RAM output data
);

  reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data_a = {(NB_COL*COL_WIDTH){1'b0}};
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data_b = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena) begin
      ram_data_a &lt;= BRAM[addra];
    end

  always @(posedge clka)
    if (enb) begin
      ram_data_b &lt;= BRAM[addrb];
    end

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge clka)
         if (ena)
           if (wea[i])
             BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
       always @(posedge clka)
         if (enb)
           if (web[i])
             BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};
      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clka)
        if (rstb)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_read_first_byte_write_1_clock_ram
/*
  //  Xilinx True Dual Port RAM Byte Write Read First Single Clock RAM
  xilinx_true_dual_port_read_first_byte_write_1_clock_ram #(
    .NB_COL(4),                           // Specify number of columns (number of bytes)
    .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from NB_COL*COL_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from NB_COL*COL_WIDTH
    .clka(clka),     // Clock
    .wea(wea),       // Port A write enable, width determined from NB_COL
    .web(web),       // Port B write enable, width determined from NB_COL
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from NB_COL*COL_WIDTH
    .doutb(doutb)    // Port B RAM output data, width determined from NB_COL*COL_WIDTH
  );

*/
							</Template>
							<Template label="Write First Mode" treetype="template">
//  Xilinx True Dual Port RAM, Write First with Single Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  This implements write-first mode where the data being written to the RAM also resides on
//  the output port.  If the output data is not needed during writes or the last read value is
//  desired to be retained, it is suggested to use no change as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_true_dual_port_write_first_1_clock_ram #(
  parameter RAM_WIDTH = 18,                       // Specify RAM data width
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,  // Port B address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,           // Port A RAM input data
  input [RAM_WIDTH-1:0] dinb,           // Port B RAM input data
  input clka,                           // Clock
  input wea,                            // Port A write enable
  input web,                            // Port B write enable
  input ena,                            // Port A RAM Enable, for additional power savings, disable port when not in use
  input enb,                            // Port B RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Port A output reset (does not affect memory contents)
  input rstb,                           // Port B output reset (does not affect memory contents)
  input regcea,                         // Port A output register enable
  input regceb,                         // Port B output register enable
  output [RAM_WIDTH-1:0] douta,         // Port A RAM output data
  output [RAM_WIDTH-1:0] doutb          // Port B RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data_a = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] ram_data_b = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena)
      if (wea) begin
        BRAM[addra] &lt;= dina;
        ram_data_a &lt;= dina;
      end else
        ram_data_a &lt;= BRAM[addra];

  always @(posedge clka)
    if (enb)
      if (web) begin
        BRAM[addrb] &lt;= dinb;
        ram_data_b &lt;= dinb;
      end else
        ram_data_b &lt;= BRAM[addrb];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clka)
        if (rstb)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_write_first_1_clock_ram
/*
  //  Xilinx True Dual Port RAM, Write First with Single Clock
  xilinx_true_dual_port_write_first_1_clock_ram #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from RAM_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from RAM_WIDTH
    .clka(clka),     // Clock
    .wea(wea),       // Port A write enable
    .web(web),       // Port B write enable
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from RAM_WIDTH
    .doutb(doutb)    // Port B RAM output data, width determined from RAM_WIDTH
  );
*/
							</Template>
							<Template label="Write First Mode w/ Byte-write" treetype="template">
//  Xilinx True Dual Port RAM Byte Write, Write First Single Clock RAM
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the new memory contents at the write
//  address are presented on the output port.

module xilinx_true_dual_port_write_first_byte_write_1_clock_ram #(
  parameter NB_COL = 4,                           // Specify number of columns (number of bytes)
  parameter COL_WIDTH = 9,                        // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,   // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,   // Port B address bus, width determined from RAM_DEPTH
  input [(NB_COL*COL_WIDTH)-1:0] dina,   // Port A RAM input data
  input [(NB_COL*COL_WIDTH)-1:0] dinb,   // Port B RAM input data
  input clka,                            // Clock
  input [NB_COL-1:0] wea,                // Port A write enable
  input [NB_COL-1:0] web,                // Port B write enable
  input ena,                             // Port A RAM Enable, for additional power savings, disable BRAM when not in use
  input enb,                             // Port B RAM Enable, for additional power savings, disable BRAM when not in use
  input rsta,                            // Port A output reset (does not affect memory contents)
  input rstb,                            // Port B output reset (does not affect memory contents)
  input regcea,                          // Port A output register enable
  input regceb,                          // Port B output register enable
  output [(NB_COL*COL_WIDTH)-1:0] douta, // Port A RAM output data
  output [(NB_COL*COL_WIDTH)-1:0] doutb  // Port B RAM output data
);

  reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data_a = {(NB_COL*COL_WIDTH){1'b0}};
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data_b = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge clka)
         if (ena)
           if (wea[i]) begin
             BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             ram_data_a[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else begin
             ram_data_a[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end

       always @(posedge clka)
         if (enb)
           if (web[i]) begin
             BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             ram_data_b[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else begin
             ram_data_b[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end
     end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};
      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clka)
        if (rstb)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_write_first_byte_write_1_clock_ram
/*
  //  Xilinx True Dual Port RAM Byte Write Write-First Single Clock RAM
  xilinx_true_dual_port_write_first_byte_write_1_clock_ram #(
    .NB_COL(4),                           // Specify number of columns (number of bytes)
    .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from NB_COL*COL_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from NB_COL*COL_WIDTH
    .clka(clka),     // Port A clock
    .wea(wea),       // Port A write enable, width determined from NB_COL
    .web(web),       // Port B write enable, width determined from NB_COL
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from NB_COL*COL_WIDTH
    .doutb(doutb)    // Port B RAM output data, width determined from NB_COL*COL_WIDTH
  );
*/
							</Template>
						</SubFolder>
						<SubFolder label="2 Clock" treetype="folder">
							<Template label="No Change Mode" treetype="template">
//  Xilinx True Dual Port RAM, No Change, Dual Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  This is a no change RAM which retains the last read value on the output during writes
//  which is the most power efficient mode.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_true_dual_port_no_change_2_clock_ram #(
  parameter RAM_WIDTH = 18,                       // Specify RAM data width
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,  // Port B address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,           // Port A RAM input data
  input [RAM_WIDTH-1:0] dinb,           // Port B RAM input data
  input clka,                           // Port A clock
  input clkb,                           // Port B clock
  input wea,                            // Port A write enable
  input web,                            // Port B write enable
  input ena,                            // Port A RAM Enable, for additional power savings, disable port when not in use
  input enb,                            // Port B RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Port A output reset (does not affect memory contents)
  input rstb,                           // Port B output reset (does not affect memory contents)
  input regcea,                         // Port A output register enable
  input regceb,                         // Port B output register enable
  output [RAM_WIDTH-1:0] douta,         // Port A RAM output data
  output [RAM_WIDTH-1:0] doutb          // Port B RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data_a = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] ram_data_b = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena)
      if (wea)
        BRAM[addra] &lt;= dina;
      else
        ram_data_a &lt;= BRAM[addra];

  always @(posedge clkb)
    if (enb)
      if (web)
        BRAM[addrb] &lt;= dinb;
      else
        ram_data_b &lt;= BRAM[addrb];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clkb)
        if (rstb)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_no_change_2_clock_ram
/*
  //  Xilinx True Dual Port RAM, No Change, Dual Clock
  xilinx_true_dual_port_no_change_2_clock_ram #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from RAM_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from RAM_WIDTH
    .clka(clka),     // Port A clock
    .clkb(clkb),     // Port B clock
    .wea(wea),       // Port A write enable
    .web(web),       // Port B write enable
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from RAM_WIDTH
    .doutb(doutb)    // Port B RAM output data, width determined from RAM_WIDTH
  );
*/
							</Template>
							<Template label="Read First Mode" treetype="template">
//  Xilinx True Dual Port RAM, Read First, Dual Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the prior memory contents at the write
//  address are presented on the output port.  If the output data is
//  not needed during writes or the last read value is desired to be retained,
//  it is suggested to use a no change RAM as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_true_dual_port_read_first_2_clock_ram #(
  parameter RAM_WIDTH = 18,                       // Specify RAM data width
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,  // Port B address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,           // Port A RAM input data
  input [RAM_WIDTH-1:0] dinb,           // Port B RAM input data
  input clka,                           // Port A clock
  input clkb,                           // Port B clock
  input wea,                            // Port A write enable
  input web,                            // Port B write enable
  input ena,                            // Port A RAM Enable, for additional power savings, disable port when not in use
  input enb,                            // Port B RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Port A output reset (does not affect memory contents)
  input rstb,                           // Port B output reset (does not affect memory contents)
  input regcea,                         // Port A output register enable
  input regceb,                         // Port B output register enable
  output [RAM_WIDTH-1:0] douta,         // Port A RAM output data
  output [RAM_WIDTH-1:0] doutb          // Port B RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data_a = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] ram_data_b = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena) begin
      if (wea)
        BRAM[addra] &lt;= dina;
      ram_data_a &lt;= BRAM[addra];
    end

  always @(posedge clkb)
    if (enb) begin
      if (web)
        BRAM[addrb] &lt;= dinb;
      ram_data_b &lt;= BRAM[addrb];
    end

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clkb)
        if (rstb)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_read_first_2_clock_ram
/*
  //  Xilinx True Dual Port RAM, Read First, Dual Clock
  xilinx_true_dual_port_read_first_2_clock_ram #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from RAM_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from RAM_WIDTH
    .clka(clka),     // Port A clock
    .clkb(clkb),     // Port B clock
    .wea(wea),       // Port A write enable
    .web(web),       // Port B write enable
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from RAM_WIDTH
    .douta(douta)    // Port B RAM output data, width determined from RAM_WIDTH
  );
*/
							</Template>
							<Template label="Read First Mode w/ Byte-write" treetype="template">
//  Xilinx True Dual Port RAM Byte Write Read First Dual Clock RAM
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the prior memory contents at the write
//  address are presented on the output port.

module xilinx_true_dual_port_read_first_byte_write_2_clock_ram #(
  parameter NB_COL = 4,                           // Specify number of columns (number of bytes)
  parameter COL_WIDTH = 9,                        // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,   // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,   // Port B address bus, width determined from RAM_DEPTH
  input [(NB_COL*COL_WIDTH)-1:0] dina,   // Port A RAM input data
  input [(NB_COL*COL_WIDTH)-1:0] dinb,   // Port B RAM input data
  input clka,                            // Port A clock
  input clkb,                            // Port B clock
  input [NB_COL-1:0] wea,                // Port A write enable
  input [NB_COL-1:0] web,                // Port B write enable
  input ena,                             // Port A RAM Enable, for additional power savings, disable port when not in use
  input enb,                             // Port B RAM Enable, for additional power savings, disable port when not in use
  input rsta,                            // Port A output reset (does not affect memory contents)
  input rstb,                            // Port B output reset (does not affect memory contents)
  input regcea,                          // Port A output register enable
  input regceb,                          // Port B output register enable
  output [(NB_COL*COL_WIDTH)-1:0] douta, // Port A RAM output data
  output [(NB_COL*COL_WIDTH)-1:0] doutb  // Port B RAM output data
);

  reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data_a = {(NB_COL*COL_WIDTH){1'b0}};
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data_b = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena) begin
      ram_data_a &lt;= BRAM[addra];
    end

  always @(posedge clkb)
    if (enb) begin
      ram_data_b &lt;= BRAM[addrb];
    end

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge clka)
         if (ena)
           if (wea[i])
             BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
       always @(posedge clkb)
         if (enb)
           if (web[i])
             BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};
      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clkb)
        if (rstb)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_read_first_byte_write_2_clock_ram
/*
  //  Xilinx True Dual Port RAM Byte Write Read First Dual Clock RAM
  xilinx_true_dual_port_read_first_byte_write_2_clock_ram #(
    .NB_COL(4),                           // Specify number of columns (number of bytes)
    .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from NB_COL*COL_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from NB_COL*COL_WIDTH
    .clka(clka),     // Port A clock
    .clkb(clkb),     // Port B clock
    .wea(wea),       // Port A write enable, width determined from NB_COL
    .web(web),       // Port B write enable, width determined from NB_COL
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from NB_COL*COL_WIDTH
    .doutb(doutb)    // Port B RAM output data, width determined from NB_COL*COL_WIDTH
  );
*/
							</Template>
							<Template label="Write First Mode" treetype="template">
//  Xilinx True Dual Port RAM, Write First with Dual Clock
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  This implements write-first mode where the data being written to the RAM also resides on
//  the output port.  If the output data is not needed during writes or the last read value is
//  desired to be retained, it is suggested to use no change as it is more power efficient.
//  If a reset or enable is not necessary, it may be tied off or removed from the code.

module xilinx_true_dual_port_write_first_2_clock_ram #(
  parameter RAM_WIDTH = 18,                       // Specify RAM data width
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,  // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,  // Port B address bus, width determined from RAM_DEPTH
  input [RAM_WIDTH-1:0] dina,           // Port A RAM input data
  input [RAM_WIDTH-1:0] dinb,           // Port B RAM input data
  input clka,                           // Port A clock
  input clkb,                           // Port B clock
  input wea,                            // Port A write enable
  input web,                            // Port B write enable
  input ena,                            // Port A RAM Enable, for additional power savings, disable port when not in use
  input enb,                            // Port B RAM Enable, for additional power savings, disable port when not in use
  input rsta,                           // Port A output reset (does not affect memory contents)
  input rstb,                           // Port B output reset (does not affect memory contents)
  input regcea,                         // Port A output register enable
  input regceb,                         // Port B output register enable
  output [RAM_WIDTH-1:0] douta,         // Port A RAM output data
  output [RAM_WIDTH-1:0] doutb          // Port B RAM output data
);

  reg [RAM_WIDTH-1:0] BRAM [RAM_DEPTH-1:0];
  reg [RAM_WIDTH-1:0] ram_data_a = {RAM_WIDTH{1'b0}};
  reg [RAM_WIDTH-1:0] ram_data_b = {RAM_WIDTH{1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {RAM_WIDTH{1'b0}};
    end
  endgenerate

  always @(posedge clka)
    if (ena)
      if (wea) begin
        BRAM[addra] &lt;= dina;
        ram_data_a &lt;= dina;
      end else
        ram_data_a &lt;= BRAM[addra];

  always @(posedge clkb)
    if (enb)
      if (web) begin
        BRAM[addrb] &lt;= dinb;
        ram_data_b &lt;= dinb;
      end else
        ram_data_b &lt;= BRAM[addrb];

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [RAM_WIDTH-1:0] douta_reg = {RAM_WIDTH{1'b0}};
      reg [RAM_WIDTH-1:0] doutb_reg = {RAM_WIDTH{1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clkb)
        if (rstb)
          doutb_reg &lt;= {RAM_WIDTH{1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_write_first_2_clock_ram
/*
  //  Xilinx True Dual Port RAM, Write First with Dual Clock
  xilinx_true_dual_port_write_first_2_clock_ram #(
    .RAM_WIDTH(18),                       // Specify RAM data width
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from RAM_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from RAM_WIDTH
    .clka(clka),     // Port A clock
    .clkb(clkb),     // Port B clock
    .wea(wea),       // Port A write enable
    .web(web),       // Port B write enable
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from RAM_WIDTH
    .doutb(doutb)    // Port B RAM output data, width determined from RAM_WIDTH
  );
*/
							</Template>
							<Template label="Write First Mode w/ Byte-write" treetype="template">
//  Xilinx True Dual Port RAM Byte Write, Write First Dual Clock RAM
//  This code implements a parameterizable true dual port memory (both ports can read and write).
//  The behavior of this RAM is when data is written, the new memory contents at the write
//  address are presented on the output port.

module xilinx_true_dual_port_write_first_byte_write_2_clock_ram #(
  parameter NB_COL = 4,                           // Specify number of columns (number of bytes)
  parameter COL_WIDTH = 9,                        // Specify column width (byte width, typically 8 or 9)
  parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)
  parameter RAM_PERFORMANCE = "HIGH_PERFORMANCE", // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
  parameter INIT_FILE = ""                        // Specify name/location of RAM initialization file if using one (leave blank if not)
) (
  input [clogb2(RAM_DEPTH-1)-1:0] addra,   // Port A address bus, width determined from RAM_DEPTH
  input [clogb2(RAM_DEPTH-1)-1:0] addrb,   // Port B address bus, width determined from RAM_DEPTH
  input [(NB_COL*COL_WIDTH)-1:0] dina,   // Port A RAM input data
  input [(NB_COL*COL_WIDTH)-1:0] dinb,   // Port B RAM input data
  input clka,                            // Port A clock
  input clkb,                            // Port B clock
  input [NB_COL-1:0] wea,                // Port A write enable
  input [NB_COL-1:0] web,                // Port B write enable
  input ena,                             // Port A RAM Enable, for additional power savings, disable BRAM when not in use
  input enb,                             // Port B RAM Enable, for additional power savings, disable BRAM when not in use
  input rsta,                            // Port A output reset (does not affect memory contents)
  input rstb,                            // Port B output reset (does not affect memory contents)
  input regcea,                          // Port A output register enable
  input regceb,                          // Port B output register enable
  output [(NB_COL*COL_WIDTH)-1:0] douta, // Port A RAM output data
  output [(NB_COL*COL_WIDTH)-1:0] doutb  // Port B RAM output data
);

  reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data_a = {(NB_COL*COL_WIDTH){1'b0}};
  reg [(NB_COL*COL_WIDTH)-1:0] ram_data_b = {(NB_COL*COL_WIDTH){1'b0}};

  // The following code either initializes the memory values to a specified file or to all zeros to match hardware
  generate
    if (INIT_FILE != "") begin: use_init_file
      initial
        $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);
    end else begin: init_bram_to_zero
      integer ram_index;
      initial
        for (ram_index = 0; ram_index &lt; RAM_DEPTH; ram_index = ram_index + 1)
          BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};
    end
  endgenerate

  generate
  genvar i;
     for (i = 0; i &lt; NB_COL; i = i+1) begin: byte_write
       always @(posedge clka)
         if (ena)
           if (wea[i]) begin
             BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             ram_data_a[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else begin
             ram_data_a[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end

       always @(posedge clkb)
         if (enb)
           if (web[i]) begin
             BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
             ram_data_b[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end else begin
             ram_data_b[(i+1)*COL_WIDTH-1:i*COL_WIDTH] &lt;= BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH];
           end
     end
  endgenerate

  //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)
  generate
    if (RAM_PERFORMANCE == "LOW_LATENCY") begin: no_output_register

      // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing
       assign douta = ram_data_a;
       assign doutb = ram_data_b;

    end else begin: output_register

      // The following is a 2 clock cycle read latency with improve clock-to-out timing

      reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};
      reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};

      always @(posedge clka)
        if (rsta)
          douta_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regcea)
          douta_reg &lt;= ram_data_a;

      always @(posedge clkb)
        if (rstb)
          doutb_reg &lt;= {(NB_COL*COL_WIDTH){1'b0}};
        else if (regceb)
          doutb_reg &lt;= ram_data_b;

      assign douta = douta_reg;
      assign doutb = doutb_reg;

    end
  endgenerate

  //  The following function calculates the address width based on specified RAM depth
  function integer clogb2;
    input integer depth;
      for (clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
  endfunction

endmodule

// The following is an instantiation template for xilinx_true_dual_port_write_first_byte_write_2_clock_ram
/*
  //  Xilinx True Dual Port RAM Byte Write Write-First Dual Clock RAM
  xilinx_true_dual_port_write_first_byte_write_2_clock_ram #(
    .NB_COL(4),                           // Specify number of columns (number of bytes)
    .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)
    .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)
    .RAM_PERFORMANCE("HIGH_PERFORMANCE"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    .INIT_FILE("")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
  ) your_instance_name (
    .addra(addra),   // Port A address bus, width determined from RAM_DEPTH
    .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH
    .dina(dina),     // Port A RAM input data, width determined from NB_COL*COL_WIDTH
    .dinb(dinb),     // Port B RAM input data, width determined from NB_COL*COL_WIDTH
    .clka(clka),     // Port A clock
    .clkb(clkb),     // Port B clock
    .wea(wea),       // Port A write enable, width determined from NB_COL
    .web(web),       // Port B write enable, width determined from NB_COL
    .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use
    .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use
    .rsta(rsta),     // Port A output reset (does not affect memory contents)
    .rstb(rstb),     // Port B output reset (does not affect memory contents)
    .regcea(regcea), // Port A output register enable
    .regceb(regceb), // Port B output register enable
    .douta(douta),   // Port A RAM output data, width determined from NB_COL*COL_WIDTH
    .doutb(doutb)    // Port B RAM output data, width determined from NB_COL*COL_WIDTH
  );
*/
							</Template>
						</SubFolder>
					</SubFolder>
				</SubFolder>
				<SubFolder label="UltraRAM" treetype="folder">
					<Template label="Simple Dual Port" treetype="template">
//  Xilinx UltraRAM Simple Dual Port.  This code implements 
//  a parameterizable UltraRAM block 1 Read and 1 write. 
//  when addra == addrb, old data will show at doutb 
module xilinx_ultraram_simple_dual_port #(
  parameter AWIDTH = 12,  // Address Width
  parameter DWIDTH = 72,  // Data Width
  parameter NBPIPE = 3   // Number of pipeline Registers
 ) ( 
    input clk,                    // Clock 
    input rstb,                   // Reset
    input wea,                    // Write Enable
    input regceb,                 // Output Register Enable
    input mem_en,                 // Memory Enable
    input [DWIDTH-1:0] dina,      // Data Input  
    input [AWIDTH-1:0] addra,     // Write Address
    input [AWIDTH-1:0] addrb,     // Read  Address
    output reg [DWIDTH-1:0] doutb // Data Output
   );

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] mem[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration
reg [DWIDTH-1:0] memreg;              
reg [DWIDTH-1:0] mem_pipe_reg[NBPIPE-1:0];    // Pipelines for memory
reg mem_en_pipe_reg[NBPIPE:0];                // Pipelines for memory enable  

integer          i;

// RAM : Both READ and WRITE have a latency of one
always @ (posedge clk)
begin
 if(mem_en) 
  begin
   if(wea)
     mem[addra] &lt;= dina;

   memreg &lt;= mem[addrb];
  end
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge clk)
begin
 mem_en_pipe_reg[0] &lt;= mem_en;
 for (i=0; i&lt;NBPIPE; i=i+1)
   mem_en_pipe_reg[i+1] &lt;= mem_en_pipe_reg[i];
end

// RAM output data goes through a pipeline.
always @ (posedge clk)
begin
 if (mem_en_pipe_reg[0])
  mem_pipe_reg[0] &lt;= memreg;
end    

always @ (posedge clk)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (mem_en_pipe_reg[i+1])
   mem_pipe_reg[i+1] &lt;= mem_pipe_reg[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge clk)
begin
 if (rstb)
   doutb &lt;= 0;
 else if (mem_en_pipe_reg[NBPIPE] &amp;&amp; regceb)
   doutb &lt;= mem_pipe_reg[NBPIPE-1];
end
endmodule
/* 
// The following is an instantation template for
// xilinx_ultraram_simple_dual_port

   xilinx_ultraram_simple_dual_port # (
                                             .AWIDTH(AWIDTH),
                                             .DWIDTH(DWIDTH),
                                             .NBPIPE(NBPIPE)
                                            )
                      your_instance_name    (
                                             clk(clk),   
                                             rstb(rstb),   
                                             wea(wea),    
                                             regceb(regceb), 
                                             mem_en(mem_en),
                                             dina(dina), 
                                             addra(addra),
                                             addrb(addrb),
                                             doutb(doutb)
                                            );
*/                                            
					</Template>
					<SubFolder label="Single Port" treetype="folder">
						<Template label="No Change Mode" treetype="template">
//  Xilinx UltraRAM Single Port No Change Mode.  This code implements 
//  a parameterizable UltraRAM block in No Change mode. The behavior of this RAM is 
//  when data is written, the output of RAM is unchanged. Only when write is
//  inactive data corresponding to the address is presented on the output port.
//
module xilinx_ultraram_single_port_no_change #(
  parameter AWIDTH = 12,  // Address Width
  parameter DWIDTH = 72,  // Data Width
  parameter NBPIPE = 3    // Number of pipeline Registers
 ) ( 
    input clk,                    // Clock 
    input rst,                    // Reset
    input we,                     // Write Enable
    input regce,                  // Output Register Enable
    input mem_en,                 // Memory Enable
    input [DWIDTH-1:0] din,       // Data Input  
    input [AWIDTH-1:0] addr,      // Address Input
    output reg [DWIDTH-1:0] dout  // Data Output
   );

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] mem[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration
reg [DWIDTH-1:0] memreg;              
reg [DWIDTH-1:0] mem_pipe_reg[NBPIPE-1:0];    // Pipelines for memory
reg mem_en_pipe_reg[NBPIPE:0];                // Pipelines for memory enable  

integer          i;

// RAM : Read has one latency, Write has one latency as well.
always @ (posedge clk)
begin
 if(mem_en) 
  begin
	 if(we)
    mem[addr] &lt;= din;
	 else
	  memreg &lt;= mem[addr];
  end     
end
// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge clk)
begin
mem_en_pipe_reg[0] &lt;= mem_en;
 for (i=0; i&lt;NBPIPE; i=i+1)
  mem_en_pipe_reg[i+1] &lt;= mem_en_pipe_reg[i];
end

// RAM output data goes through a pipeline.
always @ (posedge clk)
begin
 if (mem_en_pipe_reg[0])
  mem_pipe_reg[0] &lt;= memreg;
end

always @ (posedge clk)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (mem_en_pipe_reg[i+1])
    mem_pipe_reg[i+1] &lt;= mem_pipe_reg[i];
end

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge clk)
begin
 if (rst)
  dout &lt;= 0;
 else if (mem_en_pipe_reg[NBPIPE] &amp;&amp; regce)
  dout &lt;= mem_pipe_reg[NBPIPE-1];
end 
endmodule
/* 
// The following is an instantation template for
// xilinx_ultraram_single_port_no_change

   xilinx_ultraram_single_port_no_change # (
                                             .AWIDTH(AWIDTH),
                                             .DWIDTH(DWIDTH),
                                             .NBPIPE(NBPIPE)
                                            )
                      your_instance_name    (
                                             clk(clk),   
                                             rst(rst),   
                                             we(we),    
                                             regce(regce), 
                                             mem_en(mem_en),
                                             din(din), 
                                             addr(addr),
                                             dout(dout)
                                            );
*/                                            
						</Template>
						<Template label="Read First Mode" treetype="template">
//  Xilinx UltraRAM Single Port Read First Mode.  This code implements 
//  a parameterizable UltraRAM block in read first mode. The behavior of this RAM is 
//  when data is written, the old memory contents at the write address are 
//  presented on the output port.
//
module xilinx_ultraram_single_port_read_first #(
  parameter AWIDTH = 12,  // Address Width
  parameter DWIDTH = 72,  // Data Width
  parameter NBPIPE = 3    // Number of pipeline Registers
 ) ( 
    input clk,                    // Clock 
    input rst,                    // Reset
    input we,                     // Write Enable
    input regce,                  // Output Register Enable
    input mem_en,                 // Memory Enable
    input [DWIDTH-1:0] din,       // Data Input  
    input [AWIDTH-1:0] addr,      // Address Input
    output reg [DWIDTH-1:0] dout  // Data Output
   );

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] mem[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration
reg [DWIDTH-1:0] memreg;              
reg [DWIDTH-1:0] mem_pipe_reg[NBPIPE-1:0];    // Pipelines for memory
reg mem_en_pipe_reg[NBPIPE:0];                // Pipelines for memory enable  

integer          i;

// RAM : Both READ and WRITE have a latency of one
always @ (posedge clk)
begin
 if(mem_en) 
  begin
   if(we)
    mem[addr] &lt;= din;
   memreg &lt;= mem[addr];
  end
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge clk)
begin
 mem_en_pipe_reg[0] &lt;= mem_en;
 for (i=0; i&lt;NBPIPE; i=i+1)
   mem_en_pipe_reg[i+1] &lt;= mem_en_pipe_reg[i];
end

// RAM output data goes through a pipeline.
always @ (posedge clk)
begin
 if (mem_en_pipe_reg[0])
  mem_pipe_reg[0] &lt;= memreg;
end    

always @ (posedge clk)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (mem_en_pipe_reg[i+1])
   mem_pipe_reg[i+1] &lt;= mem_pipe_reg[i];
end      

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge clk)
begin
 if (rst)
   dout &lt;= 0;
 else if (mem_en_pipe_reg[NBPIPE] &amp;&amp; regce)
   dout &lt;= mem_pipe_reg[NBPIPE-1];
end
endmodule
/* 
// The following is an instantation template for
// xilinx_ultraram_single_port_read_first 

   xilinx_ultraram_single_port_read_first # (
                                             .AWIDTH(AWIDTH),
                                             .DWIDTH(DWIDTH),
                                             .NBPIPE(NBPIPE)
                                            )
                      your_instance_name    (
                                             clk(clk),   
                                             rst(rst),   
                                             we(we),    
                                             regce(regce), 
                                             mem_en(mem_en),
                                             din(din), 
                                             addr(addr),
                                             dout(dout)
                                            );
*/                                            
						</Template>
						<Template label="Write First Mode" treetype="template">
//  Xilinx UltraRAM Single Port Write First Mode.  This code implements 
//  a parameterizable UltraRAM block in write first mode. The behavior of this RAM is 
//  when data is written, the new memory contents at the write address are 
//  presented on the output port.
//
module xilinx_ultraram_single_port_write_first #(
  parameter AWIDTH = 12,  // Address Width
  parameter DWIDTH = 72,  // Data Width
  parameter NBPIPE = 3    // Number of pipeline Registers
 ) ( 
    input clk,                    // Clock 
    input rst,                    // Reset
    input we,                     // Write Enable
    input regce,                  // Output Register Enable
    input mem_en,                 // Memory Enable
    input [DWIDTH-1:0] din,       // Data Input  
    input [AWIDTH-1:0] addr,      // Address Input
    output reg [DWIDTH-1:0] dout  // Data Output
   );

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] mem[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration
reg [DWIDTH-1:0] memreg;              
reg [DWIDTH-1:0] mem_pipe_reg[NBPIPE-1:0];    // Pipelines for memory
reg mem_en_pipe_reg[NBPIPE:0];                // Pipelines for memory enable  

integer          i;

// RAM : Both READ and WRITE have a latency of one
always @ (posedge clk)
begin
 if(mem_en) 
  begin
    if(we)
    begin
   	  mem[addr] &lt;= din;
	    memreg &lt;= din;
	  end
    else
	    memreg &lt;= mem[addr];
  end      
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge clk)
begin
 mem_en_pipe_reg[0] &lt;= mem_en;
 for (i=0; i&lt;NBPIPE; i=i+1)
   mem_en_pipe_reg[i+1] &lt;= mem_en_pipe_reg[i];
end

// RAM output data goes through a pipeline.
always @ (posedge clk)
begin
 if (mem_en_pipe_reg[0])
  mem_pipe_reg[0] &lt;= memreg;
end  
   
always @ (posedge clk)
begin
  for (i = 0; i &lt; NBPIPE-1; i = i+1)
   if (mem_en_pipe_reg[i+1])
     mem_pipe_reg[i+1] &lt;= mem_pipe_reg[i];
end         
   
// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge clk)
begin
 if (rst)
  dout &lt;= 0;
 else if (mem_en_pipe_reg[NBPIPE] &amp;&amp; regce)
  dout &lt;= mem_pipe_reg[NBPIPE-1];
end   
endmodule
/* 
// The following is an instantation template for
// xilinx_ultraram_single_port_write_first 

   xilinx_ultraram_single_port_write_first # (
                                             .AWIDTH(AWIDTH),
                                             .DWIDTH(DWIDTH),
                                             .NBPIPE(NBPIPE)
                                            )
                      your_instance_name    (
                                             clk(clk),   
                                             rst(rst),   
                                             we(we),    
                                             regce(regce), 
                                             mem_en(mem_en),
                                             din(din), 
                                             addr(addr),
                                             dout(dout)
                                            );
*/                                            
						</Template>
					</SubFolder>
					<SubFolder label="True Dual Port" treetype="folder">
						<Template label="Byte-Write" treetype="template">
//  Xilinx UltraRAM True Dual Port Mode - Byte write.  This code implements 
//  a parameterizable UltraRAM block with write/read on both ports in 
//  No change behavior on both the ports . The behavior of this RAM is 
//  when data is written, the output of RAM is unchanged w.r.t each port. 
//  Only when write is inactive data corresponding to the address is 
//  presented on the output port.
//
module xilinx_ultraram_true_dual_port_bytewrite #(
  parameter AWIDTH  = 12,  // Address Width
  parameter NUM_COL = 9,   // Number of columns
  parameter DWIDTH  = 72,  // Data Width, (Byte * NUM_COL) 
  parameter NBPIPE  = 3    // Number of pipeline Registers
 ) ( 
    input clk,                    // Clock
    // Port A
    input rsta,                   // Reset
    input [NUM_COL-1:0] wea,      // Write Enable
    input regcea,                 // Output Register Enable
    input mem_ena,                // Memory Enable
    input [DWIDTH-1:0] dina,      // Data Input  
    input [AWIDTH-1:0] addra,     // Address Input
    output reg [DWIDTH-1:0] douta,// Data Output

    // Port B
    input rstb,                   // Reset
    input [NUM_COL-1:0] web,      // Write Enable
    input regceb,                 // Output Register Enable
    input mem_enb,                // Memory Enable
    input [DWIDTH-1:0] dinb,      // Data Input  
    input [AWIDTH-1:0] addrb,     // Address Input
    output reg [DWIDTH-1:0] doutb // Data Output
   );

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] mem[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration

reg [DWIDTH-1:0] memrega;              
reg [DWIDTH-1:0] mem_pipe_rega[NBPIPE-1:0];    // Pipelines for memory
reg mem_en_pipe_rega[NBPIPE:0];                // Pipelines for memory enable  

reg [DWIDTH-1:0] memregb;              
reg [DWIDTH-1:0] mem_pipe_regb[NBPIPE-1:0];    // Pipelines for memory
reg mem_en_pipe_regb[NBPIPE:0];                // Pipelines for memory enable  

integer          i;
localparam CWIDTH = DWIDTH/NUM_COL;

// RAM : Read has one latency, Write has one latency as well.
always @ (posedge clk)
begin
 if(mem_ena) 
  begin
  for(i = 0;i&lt;NUM_COL;i=i+1) 
	 if(wea[i])
    mem[addra][i*CWIDTH +: CWIDTH] &lt;= dina[i*CWIDTH +: CWIDTH];
  end     
end

always @ (posedge clk)
begin
 if(mem_ena)
  if(~|wea)
    memrega &lt;= mem[addra];
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge clk)
begin
mem_en_pipe_rega[0] &lt;= mem_ena;
 for (i=0; i&lt;NBPIPE; i=i+1)
  mem_en_pipe_rega[i+1] &lt;= mem_en_pipe_rega[i];
end

// RAM output data goes through a pipeline.
always @ (posedge clk)
begin
 if (mem_en_pipe_rega[0])
  mem_pipe_rega[0] &lt;= memrega;
end

always @ (posedge clk)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (mem_en_pipe_rega[i+1])
    mem_pipe_rega[i+1] &lt;= mem_pipe_rega[i];
end

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge clk)
begin
 if (rsta)
  douta &lt;= 0;
 else if (mem_en_pipe_rega[NBPIPE] &amp;&amp; regcea)
  douta &lt;= mem_pipe_rega[NBPIPE-1];
end 

// RAM : Read has one latency, Write has one latency as well.
always @ (posedge clk)
begin
 if(mem_enb) 
  begin
  for(i=0;i&lt;NUM_COL;i=i+1)
	 if(web[i])
    mem[addrb][i*CWIDTH +: CWIDTH] &lt;= dinb[i*CWIDTH +: CWIDTH];
  end     
end

always @ (posedge clk)
begin
 if(mem_enb)
  if(~|web)
    memregb &lt;= mem[addrb];
end

// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge clk)
begin
mem_en_pipe_regb[0] &lt;= mem_enb;
 for (i=0; i&lt;NBPIPE; i=i+1)
  mem_en_pipe_regb[i+1] &lt;= mem_en_pipe_regb[i];
end

// RAM output data goes through a pipeline.
always @ (posedge clk)
begin
 if (mem_en_pipe_regb[0])
  mem_pipe_regb[0] &lt;= memregb;
end

always @ (posedge clk)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (mem_en_pipe_regb[i+1])
    mem_pipe_regb[i+1] &lt;= mem_pipe_regb[i];
end

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge clk)
begin
 if (rsta)
  doutb &lt;= 0;
 else if (mem_en_pipe_regb[NBPIPE] &amp;&amp; regceb)
  doutb &lt;= mem_pipe_regb[NBPIPE-1];
end 

endmodule
/* 
// The following is an instantation template for
// xilinx_ultraram_true_dual_port_bytewrite

   xilinx_ultraram_true_dual_port_bytewrite # (
                                             .AWIDTH(AWIDTH),
                                             .DWIDTH(DWIDTH),
                                             .NBPIPE(NBPIPE)
                                            )
                      your_instance_name    (
                                             clk(clk),   
                                             rsta(rsta),   
                                             wea(wea),    
                                             regcea(regcea), 
                                             mem_ena(mem_ena),
                                             dina(dina), 
                                             addra(addra),
                                             douta(douta),
                                             rstb(rstb),   
                                             web(web),    
                                             regceb(regceb), 
                                             mem_enb(mem_enb),
                                             dinb(dinb), 
                                             addrb(addrb),
                                             doutb(doutb)
                                            );
*/                                           
						</Template>
						<Template label="Non Byte-write" treetype="template">
//  Xilinx UltraRAM True Dual Port Mode.  This code implements 
//  a parameterizable UltraRAM block with write/read on both ports in 
//  No change behavior on both the ports . The behavior of this RAM is 
//  when data is written, the output of RAM is unchanged w.r.t each port. 
//  Only when write is inactive data corresponding to the address is 
//  presented on the output port.
//
module xilinx_ultraram_true_dual_port #(
  parameter AWIDTH = 12,  // Address Width
  parameter DWIDTH = 72,  // Data Width
  parameter NBPIPE = 3    // Number of pipeline Registers
 ) ( 
    input clk,                    // Clock
    // Port A
    input rsta,                   // Reset
    input wea,                    // Write Enable
    input regcea,                 // Output Register Enable
    input mem_ena,                // Memory Enable
    input [DWIDTH-1:0] dina,      // Data Input  
    input [AWIDTH-1:0] addra,     // Address Input
    output reg [DWIDTH-1:0] douta,// Data Output

    // Port B
    input rstb,                   // Reset
    input web,                    // Write Enable
    input regceb,                 // Output Register Enable
    input mem_enb,                // Memory Enable
    input [DWIDTH-1:0] dinb,      // Data Input  
    input [AWIDTH-1:0] addrb,     // Address Input
    output reg [DWIDTH-1:0] doutb // Data Output
   );

(* ram_style = "ultra" *)
reg [DWIDTH-1:0] mem[(1&lt;&lt;AWIDTH)-1:0];        // Memory Declaration

reg [DWIDTH-1:0] memrega;              
reg [DWIDTH-1:0] mem_pipe_rega[NBPIPE-1:0];    // Pipelines for memory
reg mem_en_pipe_rega[NBPIPE:0];                // Pipelines for memory enable  

reg [DWIDTH-1:0] memregb;              
reg [DWIDTH-1:0] mem_pipe_regb[NBPIPE-1:0];    // Pipelines for memory
reg mem_en_pipe_regb[NBPIPE:0];                // Pipelines for memory enable  

integer          i;

// RAM : Read has one latency, Write has one latency as well.
always @ (posedge clk)
begin
 if(mem_ena) 
  begin
	 if(wea)
    mem[addra] &lt;= dina;
	 else
	  memrega &lt;= mem[addra];
  end     
end
// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge clk)
begin
mem_en_pipe_rega[0] &lt;= mem_ena;
 for (i=0; i&lt;NBPIPE; i=i+1)
  mem_en_pipe_rega[i+1] &lt;= mem_en_pipe_rega[i];
end

// RAM output data goes through a pipeline.
always @ (posedge clk)
begin
 if (mem_en_pipe_rega[0])
  mem_pipe_rega[0] &lt;= memrega;
end

always @ (posedge clk)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (mem_en_pipe_rega[i+1])
    mem_pipe_rega[i+1] &lt;= mem_pipe_rega[i];
end

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge clk)
begin
 if (rsta)
  douta &lt;= 0;
 else if (mem_en_pipe_rega[NBPIPE] &amp;&amp; regcea)
  douta &lt;= mem_pipe_rega[NBPIPE-1];
end 

// RAM : Read has one latency, Write has one latency as well.
always @ (posedge clk)
begin
 if(mem_enb) 
  begin
	 if(web)
    mem[addrb] &lt;= dinb;
	 else
	  memregb &lt;= mem[addrb];
  end     
end
// The enable of the RAM goes through a pipeline to produce a
// series of pipelined enable signals required to control the data
// pipeline.
always @ (posedge clk)
begin
mem_en_pipe_regb[0] &lt;= mem_enb;
 for (i=0; i&lt;NBPIPE; i=i+1)
  mem_en_pipe_regb[i+1] &lt;= mem_en_pipe_regb[i];
end

// RAM output data goes through a pipeline.
always @ (posedge clk)
begin
 if (mem_en_pipe_regb[0])
  mem_pipe_regb[0] &lt;= memregb;
end

always @ (posedge clk)
begin
 for (i = 0; i &lt; NBPIPE-1; i = i+1)
  if (mem_en_pipe_regb[i+1])
    mem_pipe_regb[i+1] &lt;= mem_pipe_regb[i];
end

// Final output register gives user the option to add a reset and
// an additional enable signal just for the data ouptut
always @ (posedge clk)
begin
 if (rsta)
  doutb &lt;= 0;
 else if (mem_en_pipe_regb[NBPIPE] &amp;&amp; regceb)
  doutb &lt;= mem_pipe_regb[NBPIPE-1];
end 
endmodule
/* 
// The following is an instantation template for
// xilinx_ultraram_true_dual_port

   xilinx_ultraram_true_dual_port # (
                                             .AWIDTH(AWIDTH),
                                             .DWIDTH(DWIDTH),
                                             .NBPIPE(NBPIPE)
                                            )
                      your_instance_name    (
                                             clk(clk),   
                                             rsta(rsta),   
                                             wea(wea),    
                                             regcea(regcea), 
                                             mem_ena(mem_ena),
                                             dina(dina), 
                                             addra(addra),
                                             douta(douta),
                                             rstb(rstb),   
                                             web(web),    
                                             regceb(regceb), 
                                             mem_enb(mem_enb),
                                             dinb(dinb), 
                                             addrb(addrb),
                                             doutb(doutb)
                                            );
*/                                            

						</Template>
					</SubFolder>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Generate" treetype="folder">
			<Template label="Conditional Instances (case)" treetype="template">
   generate
      case (&lt;constant_expression&gt;)
         &lt;value&gt;: begin: &lt;label_1&gt;
                     &lt;code&gt;
                  end
         &lt;value&gt;: begin: &lt;label_2&gt;
                     &lt;code&gt;
                  end
         default: begin: &lt;label_3&gt;
                     &lt;code&gt;
                  end
      endcase
   endgenerate
			</Template>
			<Template label="Conditional Instances (if)" treetype="template">
   generate
      if (&lt;condition&gt;) begin: &lt;label_1&gt;
         &lt;code&gt;;
      end else if (&lt;condition&gt;) begin: &lt;label_2&gt;
         &lt;code&gt;;
      end else begin: &lt;label_3&gt;
         &lt;code&gt;;
      end
   endgenerate
			</Template>
			<Template label="Generate Multiple Instances" treetype="template">
   genvar &lt;var&gt;;
   generate
      for (&lt;var&gt;=0; &lt;var&gt; &lt; &lt;limit&gt;; &lt;var&gt;=&lt;var&gt;+1)
      begin: &lt;label&gt;
         &lt;instantiation&gt;
      end
   endgenerate
			</Template>
			<Template label="Nested Generates Multiple Instances" treetype="template">
   genvar &lt;var1&gt;, &lt;var2&gt;;
   generate
      for (&lt;var1&gt;=0; &lt;var1&gt; &lt; &lt;limit&gt;; &lt;var1&gt;=&lt;var1&gt;+1)
      begin: &lt;label_1&gt;
         for (&lt;var2&gt;=0; &lt;var2&gt; &lt; &lt;limit&gt;; &lt;var2&gt;=&lt;var2&gt;+1)
         begin: &lt;label_2&gt;
            &lt;code&gt;
         end
      end
   endgenerate
			</Template>
		</SubFolder>
		<SubFolder label="Ports" treetype="folder">
			<Template label="ANSI-style" treetype="template">
module &lt;module_name&gt; (
   input      &lt;input_port_name&gt;,
   // ...&lt;other_inputs&gt;...
   output     &lt;output_port_name&gt;,
   // ...&lt;other_outputs&gt;...
   output reg &lt;output_reg_name&gt;,
   // ...&lt;other_registered_outputs&gt;...
   inout      &lt;inout_port_name&gt;,
   // ...&lt;other_inouts&gt;...
   inout reg  &lt;inout_reg_name&gt;
   // ...&lt;other_registered_inouts&gt;...
);
			</Template>
			<SubFolder label="Registered" treetype="folder">
				<SubFolder label="Output" treetype="folder">
					<Template label="1-bit" treetype="template">
   output reg &lt;name&gt;;
					</Template>
					<Template label="2-bit" treetype="template">
   output reg [1:0] &lt;name&gt;;
					</Template>
					<Template label="3-bit" treetype="template">
   output reg [2:0] &lt;name&gt;;
					</Template>
					<Template label="4-bit" treetype="template">
   output reg [3:0] &lt;name&gt;;
					</Template>
					<Template label="8-bit" treetype="template">
   output reg [7:0] &lt;name&gt;;
					</Template>
					<Template label="16-bit" treetype="template">
   output reg [15:0] &lt;name&gt;;
					</Template>
					<Template label="32-bit" treetype="template">
   output reg [31:0] &lt;name&gt;;
					</Template>
					<Template label="64-bit" treetype="template">
   output reg [63:0] &lt;name&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="Simple Declaration" treetype="folder">
				<SubFolder label="Bidirectional (inout)" treetype="folder">
					<Template label="1-bit" treetype="template">
   inout &lt;name&gt;;
					</Template>
					<Template label="2-bit" treetype="template">
   inout [1:0] &lt;name&gt;;
					</Template>
					<Template label="3-bit" treetype="template">
   inout [2:0] &lt;name&gt;;
					</Template>
					<Template label="4-bit" treetype="template">
   inout [3:0] &lt;name&gt;;
					</Template>
					<Template label="8-bit" treetype="template">
   inout [7:0] &lt;name&gt;;
					</Template>
					<Template label="16-bit" treetype="template">
   inout [15:0] &lt;name&gt;;
					</Template>
					<Template label="32-bit" treetype="template">
   inout [31:0] &lt;name&gt;;
					</Template>
					<Template label="64-bit" treetype="template">
   inout [63:0] &lt;name&gt;;
					</Template>
				</SubFolder>
				<SubFolder label="Input" treetype="folder">
					<Template label="1-bit" treetype="template">
   input &lt;name&gt;;
					</Template>
					<Template label="2-bit" treetype="template">
   input [1:0] &lt;name&gt;;
					</Template>
					<Template label="3-bit" treetype="template">
   input [2:0] &lt;name&gt;;
					</Template>
					<Template label="4-bit" treetype="template">
   input [3:0] &lt;name&gt;;
					</Template>
					<Template label="8-bit" treetype="template">
   input [7:0] &lt;name&gt;;
					</Template>
					<Template label="16-bit" treetype="template">
   input [15:0] &lt;name&gt;;
					</Template>
					<Template label="32-bit" treetype="template">
   input [31:0] &lt;name&gt;;
					</Template>
					<Template label="64-bit" treetype="template">
   input [63:0] &lt;name&gt;;
					</Template>
				</SubFolder>
				<SubFolder label="Output" treetype="folder">
					<Template label="1-bit" treetype="template">
   output &lt;name&gt;;
					</Template>
					<Template label="2-bit" treetype="template">
   output [1:0] &lt;name&gt;;
					</Template>
					<Template label="3-bit" treetype="template">
   output [2:0] &lt;name&gt;;
					</Template>
					<Template label="4-bit" treetype="template">
   output [3:0] &lt;name&gt;;
					</Template>
					<Template label="8-bit" treetype="template">
   output [7:0] &lt;name&gt;;
					</Template>
					<Template label="16-bit" treetype="template">
   output [15:0] &lt;name&gt;;
					</Template>
					<Template label="32-bit" treetype="template">
   output [31:0] &lt;name&gt;;
					</Template>
					<Template label="64-bit" treetype="template">
   output [63:0] &lt;name&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="Signal, Constant &amp; Variable Declarations" treetype="folder">
			<SubFolder label="Parameter" treetype="folder">
				<Template label="Info (Parameter)" treetype="template">
// information on the Verilog Parameter, Local Parameter,
//     Defparam and Named Parameter Value Assignment
// =======================================================
//
// Parameters are a method within Verilog in order to define constants
// within the code.  They are very useful in order to define bus widths,
// memory depths, state-machine assignments, clock periods and other useful
// constants used throughout the design and testbench.  Parameters can bring
// more meaning and documentation to the code or can be used to make the
// code more parameterizable and thus help enable re-use or help adjust to
// late changes in the design.  There are two main types of parameters, the
// parameter and local parameter.  A local parameter acts the same as a
// parameter however its contents cannot be modified via a defparam or a
// named parameter value assignment in the instantiation.  A named parameter value
// assignment allows a respecification of the parameter value within the instance
// declaration of the instantiation of the component.  Both local parameters
// and parameters can be sized to a specified number of bits and/or can be typed
// to be either a signed value, an integer, a real number, a time (64-bit
// precision) or a realtime (double-precision floating point) value.

// Example declaring a parameter and local parameter

// Define pi as a local real number parameter since I do not want to ever change this

localparam real pi = 3.14;

// Define BUS_WIDTH as a parameter with a default value of 8

parameter BUS_WIDTH = 8;

// Use this parameter to define the width of a declared register

reg [BUS_WIDTH-1:0] my_reg;

// Use a named parameter value assignment when I instantiate UUT to change BUS_WIDTH to 16 for the instantiated

my_design #(
   .BUS_WIDTH(16)
) UUT (
   .A(A),
   .B(B),
   .C(C)
);
				</Template>
				<SubFolder label="Local Parameter" treetype="folder">
					<Template label="Signed, ranged local parameter" treetype="template">
   localparam signed [upper:lower] &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Signed, unranged local parameter" treetype="template">
   localparam signed &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Un-typed, ranged local parameter" treetype="template">
   localparam [upper:lower] &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Un-typed, unranged local parameter" treetype="template">
   localparam &lt;name&gt; = &lt;value&gt;;
					</Template>
				</SubFolder>
				<SubFolder label="Parameter" treetype="folder">
					<Template label="Signed, ranged parameter" treetype="template">
   parameter signed [upper:lower] &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Signed, unranged parameter" treetype="template">
   parameter signed &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Un-typed, ranged parameter" treetype="template">
   parameter [upper:lower] &lt;name&gt; = &lt;value&gt;;
					</Template>
					<Template label="Un-typed, unranged parameter" treetype="template">
   parameter &lt;name&gt; = &lt;value&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
			<SubFolder label="reg" treetype="folder">
				<Template label="2-dimensional 1k x 18" treetype="template">
   reg [17:0] &lt;name&gt; [1023:0];
				</Template>
				<Template label="2-dimensional 2k x 9" treetype="template">
   reg [8:0] &lt;name&gt; [2047:0];
				</Template>
				<Template label="2-dimensional 4k x 4" treetype="template">
   reg [3:0] &lt;name&gt; [4095:0];
				</Template>
				<Template label="2-dimensional 8k x 2" treetype="template">
   reg [1:0] &lt;name&gt; [8191:0];
				</Template>
				<Template label="2-dimensional 16k x 1" treetype="template">
   reg &lt;name&gt; [16383:0];
				</Template>
				<Template label="2-dimensional 16 x 1" treetype="template">
   reg &lt;name&gt; [15:0];
				</Template>
				<Template label="2-dimensional 32 x 1" treetype="template">
   reg &lt;name&gt; [31:0];
				</Template>
				<Template label="2-dimensional 512 x 36" treetype="template">
   reg [35:0] &lt;name&gt; [511:0];
				</Template>
				<SubFolder label="Initialized" treetype="folder">
					<SubFolder label="Signed" treetype="folder">
						<Template label="8-bit" treetype="template">
   reg signed [7:0] &lt;name&gt; = 8'sh00;
						</Template>
						<Template label="9-bit" treetype="template">
   reg signed [8:0] &lt;name&gt; = 9'sh000;
						</Template>
						<Template label="16-bit" treetype="template">
   reg signed [15:0] &lt;name&gt; = 16'sh0000;
						</Template>
						<Template label="18-bit" treetype="template">
   reg signed [17:0] &lt;name&gt; = 18'sh00000;
						</Template>
						<Template label="32-bit" treetype="template">
   reg signed [31:0] &lt;name&gt; = 32'sh00000000;
						</Template>
						<Template label="64-bit" treetype="template">
   reg signed [63:0] &lt;name&gt; = 64'sh0000000000000000;
						</Template>
					</SubFolder>
					<SubFolder label="Unsigned" treetype="folder">
						<Template label="1-bit" treetype="template">
   reg &lt;name&gt; = 1'b0;
						</Template>
						<Template label="2-bit" treetype="template">
   reg [1:0] &lt;name&gt; = 2'b00;
						</Template>
						<Template label="3-bit" treetype="template">
   reg [2:0] &lt;name&gt; = 3'b000;
						</Template>
						<Template label="4-bit" treetype="template">
   reg [3:0] &lt;name&gt; = 4'h0;
						</Template>
						<Template label="8-bit" treetype="template">
   reg [7:0] &lt;name&gt; = 8'h00;
						</Template>
						<Template label="16-bit" treetype="template">
   reg [15:0] &lt;name&gt; = 16'h0000;
						</Template>
						<Template label="32-bit" treetype="template">
   reg [31:0] &lt;name&gt; = 32'h00000000;
						</Template>
						<Template label="64-bit" treetype="template">
   reg [63:0] &lt;name&gt; = 64'h0000000000000000;
						</Template>
					</SubFolder>
				</SubFolder>
				<SubFolder label="Uninitialized" treetype="folder">
					<SubFolder label="Signed" treetype="folder">
						<Template label="8-bit" treetype="template">
   reg signed [7:0] &lt;name&gt;;
						</Template>
						<Template label="9-bit" treetype="template">
   reg signed [8:0] &lt;name&gt;;
						</Template>
						<Template label="16-bit" treetype="template">
   reg signed [15:0] &lt;name&gt;;
						</Template>
						<Template label="18-bit" treetype="template">
   reg signed [17:0] &lt;name&gt;;
						</Template>
						<Template label="32-bit" treetype="template">
   reg signed [31:0] &lt;name&gt;;
						</Template>
						<Template label="64-bit" treetype="template">
   reg signed [63:0] &lt;name&gt;;
						</Template>
					</SubFolder>
					<SubFolder label="Unsigned" treetype="folder">
						<Template label="1-bit" treetype="template">
   reg &lt;name&gt;;
						</Template>
						<Template label="2-bit" treetype="template">
   reg [1:0] &lt;name&gt;;
						</Template>
						<Template label="3-bit" treetype="template">
   reg [2:0] &lt;name&gt;;
						</Template>
						<Template label="4-bit" treetype="template">
   reg [3:0] &lt;name&gt;;
						</Template>
						<Template label="8-bit" treetype="template">
   reg [7:0] &lt;name&gt;;
						</Template>
						<Template label="16-bit" treetype="template">
   reg [15:0] &lt;name&gt;;
						</Template>
						<Template label="32-bit" treetype="template">
   reg [31:0] &lt;name&gt;;
						</Template>
						<Template label="64-bit" treetype="template">
   reg [63:0] &lt;name&gt;;
						</Template>
					</SubFolder>
				</SubFolder>
			</SubFolder>
			<SubFolder label="wire" treetype="folder">
				<SubFolder label="Signed" treetype="folder">
					<Template label="8-bit" treetype="template">
   wire signed [7:0] &lt;name&gt;;
					</Template>
					<Template label="9-bit" treetype="template">
   wire signed [8:0] &lt;name&gt;;
					</Template>
					<Template label="16-bit" treetype="template">
   wire signed [15:0] &lt;name&gt;;
					</Template>
					<Template label="18-bit" treetype="template">
   wire signed [17:0] &lt;name&gt;;
					</Template>
					<Template label="32-bit" treetype="template">
   wire signed [31:0] &lt;name&gt;;
					</Template>
					<Template label="64-bit" treetype="template">
   wire signed [63:0] &lt;name&gt;;
					</Template>
				</SubFolder>
				<SubFolder label="Unsigned" treetype="folder">
					<Template label="1-bit" treetype="template">
   wire &lt;name&gt;;
					</Template>
					<Template label="2-bit" treetype="template">
   wire [1:0] &lt;name&gt;;
					</Template>
					<Template label="3-bit" treetype="template">
   wire [2:0] &lt;name&gt;;
					</Template>
					<Template label="4-bit" treetype="template">
   wire [3:0] &lt;name&gt;;
					</Template>
					<Template label="8-bit" treetype="template">
   wire [7:0] &lt;name&gt;;
					</Template>
					<Template label="16-bit" treetype="template">
   wire [15:0] &lt;name&gt;;
					</Template>
					<Template label="32-bit" treetype="template">
   wire [31:0] &lt;name&gt;;
					</Template>
					<Template label="64-bit" treetype="template">
   wire [63:0] &lt;name&gt;;
					</Template>
				</SubFolder>
			</SubFolder>
		</SubFolder>
		<SubFolder label="System Tasks &amp; Functions" treetype="folder">
			<SubFolder label="Read Memory File" treetype="folder">
				<Template label="Binary Data ($readmemb)" treetype="template">
   reg [&lt;memory_width&gt;] &lt;reg_name&gt; [&lt;memory_depth&gt;];

   initial
      $readmemb ("&lt;file_name&gt;", &lt;reg_name&gt;, &lt;start_address&gt;, &lt;end_address&gt;);
				</Template>
				<Template label="Hex Data ($readmemh)" treetype="template">
   reg [&lt;memory_width&gt;] &lt;reg_name&gt; [&lt;memory_depth&gt;];

   initial
      $readmemh ("&lt;file_name&gt;", &lt;reg_name&gt;, &lt;start_address&gt;, &lt;end_address&gt;);
				</Template>
				<Template label="Info ($readmemb/h)" treetype="template">
// information on the $readmemb and $readmemh system functions
// ===========================================================
//
// $readmemb is a system function which will read binary data from a
// specified file and place it in an array. The syntax is the following:
// $readmemb ("&lt;file_name&gt;", &lt;reg_name&gt;, &lt;start_address&gt;, &lt;end_address&gt;);
// where the &lt;file_name&gt; is the name and location of the file containing
// the binary data, the &lt;reg_name&gt; is a 2-D register array in which the
// memory data is stored, and the last two comma separated  numbers
// specify the beginning and ending address of the data.  The data file
// may only contain binary data, white spaces and comments.  This function
// must be executed within an initial block.
//
// $readmemh is the same as $readmemb with the exception that it
// inputs hex data as the read values.
//
// In the past, these functions could only be used for simulation
// purposes however synthesis tools now has the ability to initialize RAM
// and ROM arrays using this construct.
//
// Example of reading binary data from a file:

   reg  [31:0] rom_data [1023:0];

   initial
     $readmemb("../data/mem_file.dat", rom_data, 0, 7);

// The initialization file may only contain white spaces, address
// labels (denoted by @&lt;address&gt;), comments and the actual binary
// or hexadecimal data.
// The following is a small example of a binary memory file data:

// This is a comment

1111000011110000     // This specifies these 16-bits to the first address
1010_0101_1010_0101  // This is for the second address with underscores
                     // to make this more readable
&lt;more entries like above to fill up the array&gt;

// Optionally, we can change addresses
@025 // Now at address 025
11111111_00000000

// Addresses can also be specified in-line
@035 00000000_11111111

// It is highly suggested to fill all memory contents with a known value
//  when initializing memories.
				</Template>
			</SubFolder>
			<Template label="Signed Conversion ($signed)" treetype="template">
   $signed(&lt;argument&gt;);
			</Template>
			<Template label="Unsigned Conversion ($unsigned)" treetype="template">
   $unsigned(&lt;argument&gt;);
			</Template>
		</SubFolder>
	</Folder>
	<Folder label="Xilinx Parameterized Macros (XPM)" treetype="folder">
		<Template label="0_Info (Usage Instructions)" treetype="template">
//
// The following instructions describe how to prepare Vivado to use the XPM libraries:
// 1. Create or open a Vivado project
// 2. Set the property to enable XPMs:
//    set_property XPM_LIBRARIES {XPM_CDC XPM_MEMORY XPM_FIFO} [current_project]
//
// Note: This is a project property and as such you will need to specify it for each new project created.
//
// 2. Select the XPM template that you wish to use from below
// 3. Copy the contents of the template and paste into your own source file.
//    Set parameters/generics, and wire ports according to the documentation provided as code comments.
//
// Note: Be sure to read and comply with all code comments to properly use the XPMs.
//
//


		</Template>
		<SubFolder label="Clock Domain Crossing Synchronizers (XPM_CDC)" treetype="folder">
			<Template label="Asynchronous Reset Synchronizer" treetype="template">
/*
XPM_CDC instantiation template for Asynchronous Reset Synchronizer
Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| DEST_SYNC_FF         | Integer            | Valid range : 2 - 10. Default value = 4.                                |
|---------------------------------------------------------------------------------------------------------------------|
| Number of register stages used to synchronize signal in the destination clock domain.                               |
| This parameter also determines the minimum width of the asserted reset signal.                                      |
+---------------------------------------------------------------------------------------------------------------------+
| RST_ACTIVE_HIGH      | Integer            | Must be 0 or 1. Default value = 0.                                      |
|---------------------------------------------------------------------------------------------------------------------|
| Defines the polarity of the asynchronous reset signal.                                                              |
| 0: Active low asynchronous reset signal                                                                             |
| 1: Active high asynchronous reset signal                                                                            |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| src_arst       | Input     | 1                                     |           |             | Required             |
|---------------------------------------------------------------------------------------------------------------------|
| Source asynchronous reset signal.                                                                                   |
+---------------------------------------------------------------------------------------------------------------------+
| dest_clk       | Input     | 1                                     |           | Rising-edge | Required             |
|---------------------------------------------------------------------------------------------------------------------|
| Destination clock.                                                                                                  |
+---------------------------------------------------------------------------------------------------------------------+
| dest_arst      | Output    | 1                                     | dest_clk* |             | Required             |
|---------------------------------------------------------------------------------------------------------------------|
| src_arst asynchronous reset signal synchronized to destination clock domain.  This output is registered.            |
| * Signal asserts asynchronously but deasserts synchronously to dest_clk.  Width of the reset signal is at least     |
|   (DEST_SYNC_FF*dest_clk) period.                                                                                   |
+---------------------------------------------------------------------------------------------------------------------+
*/

//   xpm_cdc_async_rst  : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//      instance        : may be changed to meet design requirements.  The instance name (xpm_cdc_async_rst_inst)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_cdc_async_rst: Clock Domain Crossing Asynchronous Reset Synchronizer
// Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_async_rst #(

  //Common module parameters
  .DEST_SYNC_FF    (4), // integer; range: 2-10
  .RST_ACTIVE_HIGH (0)  // integer; 0=active low reset, 1=active high reset

) xpm_cdc_async_rst_inst (

  .src_arst  (src_arst),
  .dest_clk  (dest_clk),
  .dest_arst (dest_arst)

);

// End of xpm_cdc_async_rst_inst instance declaration

			</Template>
			<Template label="Bus Synchronizer with Full Handshake" treetype="template">
/*
XPM_CDC instantiation template for Bus Synchronizer with Full Handshake
Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| DEST_EXT_HSK         | Integer            | Must be 0 or 1. Default value = 1.                                      |
|---------------------------------------------------------------------------------------------------------------------|
| 0: An internal handshake will be implemented in the macro to acknowledge receipt of data on the destination clock   |
|    domain.                                                                                                          |
|    When using this option, the valid dest_out output must be consumed immediately to avoid any data loss.           |
| 1: External handshake logic must be implemented by the user to knowledge receipt of data on the destination clock   |
|    domain.                                                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| DEST_SYNC_FF         | Integer            | Valid range: 2 - 10. Default value = 4.                                 |
|---------------------------------------------------------------------------------------------------------------------|
| Number of register stages used to synchronize signal in the destination clock domain.                               |
+---------------------------------------------------------------------------------------------------------------------+
| SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
| 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
+---------------------------------------------------------------------------------------------------------------------+
| SRC_SYNC_FF          | Integer            | Valid range: 2 - 10. Default value = 4.                                 |
|---------------------------------------------------------------------------------------------------------------------|
| Number of register stages used to synchronize signal in the source clock domain.                                    |
+---------------------------------------------------------------------------------------------------------------------+
| WIDTH                | Integer            | Valid range: 1 - 1024.  Default value = 1.                              |
|---------------------------------------------------------------------------------------------------------------------|
| Width of bus that will be synchronized to destination clock domain.                                                 |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| src_clk        | Input     | 1                                     |          | Rising-edge | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Source clock.                                                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| src_in         | Input     | WIDTH                                 | src_clk  |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Input bus that will be synchronized to the destination clock domain.                                                |
+---------------------------------------------------------------------------------------------------------------------+
| src_send       | Input     | 1                                     | src_clk  | Active-high | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Assertion of this signal allows the src_in bus to be synchronized to the destination clock domain.                  |
| This signal should only be asserted when src_rcv is deasserted, indicating that the previous data transfer          |
| is complete.                                                                                                        |
| This signal should only be deasserted once src_rcv is asserted, acknowledging that the src_in has been received by  |
| the destination logic.                                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| src_rcv        | Output    | 1                                     | src_clk  | Active-high | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Acknowledgement from destination logic that src_in has been received.  This signal will be deasserted once          |
| destination handshake has fully completed, thus completing a full data transfer.  This output is registered.        |
+---------------------------------------------------------------------------------------------------------------------+
| dest_clk       | Input     | 1                                     |          | Rising-edge |  Required             |
|---------------------------------------------------------------------------------------------------------------------|
| Destination clock.                                                                                                  |
+---------------------------------------------------------------------------------------------------------------------+
| dest_out       | Output    | WIDTH                                 | dest_clk |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Input bus (src_in) synchronized to destination clock domain.  This output is registered.                            |
+---------------------------------------------------------------------------------------------------------------------+
| dest_req       | Output    | 1                                     | dest_clk | Active-high | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Assertion of this signal indicates that new dest_out data has been received and is ready to be used or captured     |
| by the destination logic.                                                                                           |
| When DEST_EXT_HSK = 1, this signal will deassert once the source handshake acknowledges that the destination clock  |
| domain has received the transferred data.                                                                           |
| When DEST_EXT_HSK = 0, this signal asserts for one clock period when dest_out bus is valid.                         |
| This output is registered.                                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| dest_ack       | Input     | 1                                     | dest_clk | Active-high | Tie to 1'b0           |
|---------------------------------------------------------------------------------------------------------------------|
| Destination logic acknowledgement if DEST_EXT_HSK = 1.  Unused when DEST_EXT_HSK = 0.                               |
| Asserting this signal indicates that data on dest_out has been captured by the destination logic.                   |
| This signal should be deasserted once dest_req is deasserted, completing the handshake on the destination clock     |
| domain and indicating that the destination logic is ready for a new data transfer.                                  |
+---------------------------------------------------------------------------------------------------------------------+
*/

//   xpm_cdc_handshake  : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//      instance        : may be changed to meet design requirements.  The instance name (xpm_cdc_handshake_inst)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_cdc_handshake: Clock Domain Crossing Synchronizer with Full Handshake
// Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_handshake #(

  //Common module parameters
  .DEST_EXT_HSK   (1), // integer; 0=user handshake, 1=internal handshake
  .DEST_SYNC_FF   (4), // integer; range: 2-10
  .SIM_ASSERT_CHK (0), // integer; 0=disable simulation messages, 1=enable simulation messages
  .SRC_SYNC_FF    (4), // integer; range: 2-10
  .WIDTH          (1)  // integer; range: 1-1024

) xpm_cdc_handshake_inst (

  .src_clk  (src_clk),
  .src_in   (src_in),
  .src_send (src_send),
  .src_rcv  (src_rcv),
  .dest_clk (dest_clk),
  .dest_req (dest_req),
  .dest_ack (dest_ack), // optional; required when DEST_EXT_HSK = 1
  .dest_out (dest_out)
);

// End of xpm_cdc_handshake_inst instance declaration

			</Template>
			<Template label="Pulse Transfer" treetype="template">
/*
XPM_CDC instantiation template for Pulse Transfer
Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| DEST_SYNC_FF         | Integer            | Valid range : 2 - 10. Default value = 4.                                |
|---------------------------------------------------------------------------------------------------------------------|
| Number of register stages used to synchronize signal in the destination clock domain.                               |
+---------------------------------------------------------------------------------------------------------------------+
| REG_OUTPUT           | Integer            | Must be 0 or 1.  Default value = 0.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Disable registered output                                                                                        |
| 1: Enable registered output                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| RST_USED             | Integer            | Must be 0 or 1. Default value = 1.                                      |
|---------------------------------------------------------------------------------------------------------------------|
| 0 : No resets implemented.                                                                                          |
| 1 : Resets implemented.                                                                                             |
| When RST_USED = 0, src_pulse input must always be defined during simulation since there is no reset logic to        |
| recover from an x-propagating through the macro.                                                                    |
+---------------------------------------------------------------------------------------------------------------------+
| SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
| 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| src_clk        | Input     | 1                                     |          | Rising-edge | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Source clock.                                                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| src_rst        | Input     | 1                                     | src_clk  | Active-high |  Tie to 1'b0          |
|---------------------------------------------------------------------------------------------------------------------|
| Unused when RST_USED = 0. Source reset signal if RST_USED = 1. Resets all logic in source clock domain.             |
| To fully reset the macro, src_rst and dest_rst must be asserted simultaneously for at least                         |
| ((DEST_SYNC_FF+2)*dest_clk_period) + (2*src_clk_period).                                                            |
+---------------------------------------------------------------------------------------------------------------------+
| src_pulse      | Input     | 1                                     | src_clk  | Rising-edge | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Rising edge of this signal initiates a pulse transfer to the destination clock domain.                              |
| The minimum gap between each pulse transfer must be at the minimum 2*(larger(src_clk period, dest_clk period)).     |
| This is measured between the falling edge of a src_pulse to the rising edge of the next src_pulse.  This minimum    |
| gap will guarantee that each rising edge of src_pulse will generate a pulse the size of one dest_clk period in the  |
| destination clock domain.                                                                                           |
| When RST_USED = 1, pulse transfers will not be guaranteed while src_rst and/or dest_rst are asserted.               |
+---------------------------------------------------------------------------------------------------------------------+
| dest_clk       | Input     | 1                                     |          | Rising-edge |  Required             |
|---------------------------------------------------------------------------------------------------------------------|
| Destination clock.                                                                                                  |
+---------------------------------------------------------------------------------------------------------------------+
| dest_rst       | Input     | 1                                     | dest_clk | Active-high |  Tie to 1'b0          |
|---------------------------------------------------------------------------------------------------------------------|
| Unused when RST_USED = 0. Destination reset signal if RST_USED = 1. Resets all logic in destination clock domain.   |
| To fully reset the macro, src_rst and dest_rst must be asserted simultaneously for at least                         |
| ((DEST_SYNC_FF+2)*dest_clk_period) + (2*src_clk_period).                                                            |
+---------------------------------------------------------------------------------------------------------------------+
| dest_pulse     | Output    | 1                                     | dest_clk | Active-high | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Outputs a pulse the size of one dest_clk period when a pulse transfer is correctly initiated on src_pulse input.    |
| This output is combinatorial unless REG_OUTPUT is set to 1.                                                         |
+---------------------------------------------------------------------------------------------------------------------+
*/

//    xpm_cdc_pulse     : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//      instance        : may be changed to meet design requirements.  The instance name (xpm_cdc_pulse_inst)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_cdc_pulse: Clock Domain Crossing Pulse Transfer
// Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_pulse #(
  //Common module parameters
  .DEST_SYNC_FF   (4), // integer; range: 2-10
  .REG_OUTPUT     (0), // integer; 0=disable registered output,   1=enable registered output
  .RST_USED       (1), // integer; 0=no reset, 1=implement reset
  .SIM_ASSERT_CHK (0)  // integer; 0=disable simulation messages, 1=enable simulation messages

) xpm_cdc_pulse_inst (
  .src_clk    (src_clk),
  .src_rst    (src_rst),   // optional; required when RST_USED = 1
  .src_pulse  (src_pulse),
  .dest_clk   (dest_clk),
  .dest_rst   (dest_rst),  // optional; required when RST_USED = 1
  .dest_pulse (dest_pulse)
);

// End of xpm_cdc_pulse_inst instance declaration

			</Template>
			<Template label="Single-bit Array Synchronizer" treetype="template">
/*
XPM_CDC instantiation template for Single-bit Array Synchronizer
Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| DEST_SYNC_FF         | Integer            | Valid range : 2 - 10. Default value = 4.                                |
|---------------------------------------------------------------------------------------------------------------------|
| Number of register stages used to synchronize signal in the destination clock domain.                               |
+---------------------------------------------------------------------------------------------------------------------+
| SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
| 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
+---------------------------------------------------------------------------------------------------------------------+
| SRC_INPUT_REG        | Integer            | Must be 0 or 1.  Default value = 1.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Do not register input (src_in)                                                                                   |
| 1: Register input (src_in) once using src_clk                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| WIDTH                | Integer            | Valid range: 1-1024.  Default value = 2.                                |
|---------------------------------------------------------------------------------------------------------------------|
| Width of single-bit array (src_in) that will be synchronized to destination clock domain.                           |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| src_clk        | Input     | 1                                     |          | Rising-edge |  Tie to 1'b0          |
|---------------------------------------------------------------------------------------------------------------------|
| Unused when SRC_INPUT_REG = 0.  Input clock signal for src_in if SRC_INPUT_REG = 1.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| src_in         | Input     | WIDTH                                 | src_clk  |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Input single-bit array to be synchronized to destination clock domain. It is assumed that each bit of the array is  |
| unrelated to the others.  This is reflected in the constraints applied to this macro.                               |
| To transfer a binary value losslessly across the two clock domains, use the xpm_cdc_gray macro instead.             |
+---------------------------------------------------------------------------------------------------------------------+
| dest_clk       | Input     | 1                                     |          | Rising-edge |  Required             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for the destination clock domain.                                                                      |
+---------------------------------------------------------------------------------------------------------------------+
| dest_out       | Output    | WIDTH                                 | dest_clk |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| src_in synchronized to the destination clock domain.  This output is registered.                                    |
+---------------------------------------------------------------------------------------------------------------------+
*/

// xpm_cdc_array_single : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//      instance        : may be changed to meet design requirements.  The instance name (xpm_cdc_array_single_inst)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_cdc_array_single: Clock Domain Crossing Single-bit Array Synchronizer
// Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_array_single #(

  //Common module parameters
  .DEST_SYNC_FF   (4), // integer; range: 2-10
  .SIM_ASSERT_CHK (0), // integer; 0=disable simulation messages, 1=enable simulation messages
  .SRC_INPUT_REG  (1), // integer; 0=do not register input, 1=register input
  .WIDTH          (2)  // integer; range: 1-1024

) xpm_cdc_array_single_inst (

  .src_clk  (src_clk),  // optional; required when SRC_INPUT_REG = 1
  .src_in   (src_in),
  .dest_clk (dest_clk),
  .dest_out (dest_out)

);

// End of xpm_cdc_array_single_inst instance declaration

			</Template>
			<Template label="Single-bit Synchronizer" treetype="template">
/*
XPM_CDC instantiation template for Single-bit Synchronizer
Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| DEST_SYNC_FF         | Integer            | Valid range: 2 - 10. Default value = 4.                                 |
|---------------------------------------------------------------------------------------------------------------------|
| Number of register stages used to synchronize signal in the destination clock domain.                               |
+---------------------------------------------------------------------------------------------------------------------+
| SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
| 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
+---------------------------------------------------------------------------------------------------------------------+
| SRC_INPUT_REG        | Integer            | Must be 0 or 1.  Default value = 1.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Do not register input (src_in)                                                                                   |
| 1: Register input (src_in) once using src_clk                                                                       |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| src_clk        | Input     | 1                                     |          | Rising-edge |  Tie to 1'b0          |
|---------------------------------------------------------------------------------------------------------------------|
| Input clock signal for src_in if SRC_INPUT_REG = 1.  Unused when SRC_INPUT_REG = 0.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| src_in         | Input     | 1                                     | src_clk  |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Input signal to be synchronized to dest_clk domain.                                                                 |
+---------------------------------------------------------------------------------------------------------------------+
| dest_clk       | Input     | 1                                     |          | Rising-edge | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for the destination clock domain.                                                                      |
+---------------------------------------------------------------------------------------------------------------------+
| dest_out       | Output    | 1                                     | dest_clk |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| src_in synchronized to the destination clock domain.  This output is registered.                                    |
+---------------------------------------------------------------------------------------------------------------------+
*/

//    xpm_cdc_single    : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//      instance        : may be changed to meet design requirements.  The instance name (xpm_cdc_single_inst)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_cdc_single: Clock Domain Crossing Single-bit Synchronizer
// Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_single #(

  //Common module parameters
  .DEST_SYNC_FF   (4), // integer; range: 2-10
  .SIM_ASSERT_CHK (0), // integer; 0=disable simulation messages, 1=enable simulation messages
  .SRC_INPUT_REG  (1)  // integer; 0=do not register input, 1=register input

) xpm_cdc_single_inst (

  .src_clk  (src_clk),  // optional; required when SRC_INPUT_REG = 1
  .src_in   (src_in),
  .dest_clk (dest_clk),
  .dest_out (dest_out)

);

// End of xpm_cdc_single_inst instance declaration

			</Template>
			<Template label="Synchronizer via Gray Encoding" treetype="template">
/*
XPM_CDC instantiation template for Synchronizer via Gray Encoding
Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| DEST_SYNC_FF         | Integer            | Valid range: 2 - 10. Default value = 4.                                 |
|---------------------------------------------------------------------------------------------------------------------|
| Number of register stages used to synchronize signal in the destination clock domain.                               |
+---------------------------------------------------------------------------------------------------------------------+
| REG_OUTPUT           | Integer            | Must be 0 or 1.  Default value = 0.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Disable registered output                                                                                        |
| 1: Enable registered output                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
| 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
+---------------------------------------------------------------------------------------------------------------------+
| SIM_LOSSLESS_GRAY_CHK| Integer            | Must be 0 or 1.  Default value = 0.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Disable simulation message that reports whether src_in_bin is incrementing or decrementing by one, guaranteeing  |
|    lossless synchronization of a gray coded bus.                                                                    |
| 1: Enable simulation message that reports whether src_in_bin is incrementing or decrementing by one, guaranteeing   |
|    lossless synchronization of a gray coded bus.                                                                    |
+---------------------------------------------------------------------------------------------------------------------+
| WIDTH                | Integer            | Valid range: 2 - 32. Default value = 2.                                 |
|---------------------------------------------------------------------------------------------------------------------|
| Width of binary input bus that will be synchronized to destination clock domain.                                    |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| src_clk        | Input     | 1                                     |          | Rising-edge | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Source clock.                                                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| src_in_bin     | Input     | WIDTH                                 | src_clk  |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Binary input bus that will be synchronized to the destination clock domain.                                         |
+---------------------------------------------------------------------------------------------------------------------+
| dest_clk       | Input     | 1                                     |          | Rising-edge | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Destination clock.                                                                                                  |
+---------------------------------------------------------------------------------------------------------------------+
| dest_out_bin   | Output    | WIDTH                                 | dest_clk |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Binary input bus (src_in_bin) synchronized to destination clock domain.  This output is combinatorial unless        |
| REG_OUTPUT is set to 1.                                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
*/

//    xpm_cdc_gray      : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//      instance        : may be changed to meet design requirements.  The instance name (xpm_cdc_gray_inst)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_cdc_gray: Clock Domain Crossing Synchronizer via Gray Encoding
// Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_gray #(

  //Common module parameters
  .DEST_SYNC_FF          (4), // integer; range: 2-10
  .REG_OUTPUT            (0), // integer; 0=disable registered output,   1=enable registered output
  .SIM_ASSERT_CHK        (0), // integer; 0=disable simulation messages, 1=enable simulation messages
  .SIM_LOSSLESS_GRAY_CHK (0), // integer; 0=disable lossless check, 1=enable lossless check
  .WIDTH                 (2)  // integer; range: 2-32

) xpm_cdc_gray_inst (
  .src_clk      (src_clk),
  .src_in_bin   (src_in_bin),
  .dest_clk     (dest_clk),
  .dest_out_bin (dest_out_bin)
);

// End of xpm_cdc_gray_inst instance declaration

			</Template>
			<Template label="Synchronous Reset Synchronizer" treetype="template">
/*
XPM_CDC instantiation template for Synchronous Reset Synchronizer
Refer to the targeted device family architecture libraries guide for XPM_CDC documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| DEST_SYNC_FF         | Integer            | Valid range : 2 - 10.  Default value = 4.                               |
|---------------------------------------------------------------------------------------------------------------------|
| Number of register stages used to synchronize signal in the destination clock domain.                               |
+---------------------------------------------------------------------------------------------------------------------+
| INIT                 | Integer            | Must be 0 or 1.  Default value = 1.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Initializes synchronization registers to 0                                                                       |
| 1: Initializes synchronization registers to 1                                                                       |
| The option to initialize the synchronization registers means that there is no complete x-propagation behavior       |
| modeled in this macro.  For complete x-propagation modelling, use the xpm_cdc_single macro.                         |
+---------------------------------------------------------------------------------------------------------------------+
| SIM_ASSERT_CHK       | Integer            | Must be 0 or 1.  Default value = 0.                                     |
|---------------------------------------------------------------------------------------------------------------------|
| 0: Disable simulation message reporting, messages related to potential misuse will not be reported.                 |
| 1: Enable simulation message reporting, messages related to potential misuse will be reported.                      |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain   | Sense       | Handling if unused    |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| src_rst        | Input     | 1                                     |          |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Source reset signal.                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| dest_clk       | Input     | 1                                     |          | Rising-edge | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| Destination clock.                                                                                                  |
+---------------------------------------------------------------------------------------------------------------------+
| dest_rst       | Output    | 1                                     | dest_clk |             | Required              |
|---------------------------------------------------------------------------------------------------------------------|
| src_rst synchronized to the destination clock domain.  This output is registered.                                   |
+---------------------------------------------------------------------------------------------------------------------+
*/

//    xpm_cdc_sync_rst  : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//      instance        : may be changed to meet design requirements.  The instance name (xpm_cdc_sync_rst_inst)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_cdc_sync_rst: Clock Domain Crossing Synchronous Reset Synchronizer
// Xilinx Parameterized Macro, Version 2016.4
xpm_cdc_sync_rst #(

  //Common module parameters
  .DEST_SYNC_FF   (4), // integer; range: 2-10
  .INIT           (1), // integer; 0=initialize synchronization registers to 0,
                       //          1=initialize synchronization registers to 1
  .SIM_ASSERT_CHK (0)  // integer; 0=disable simulation messages, 1=enable simulation messages

) xpm_cdc_sync_rst_inst (

  .src_rst  (src_rst),
  .dest_clk (dest_clk),
  .dest_rst (dest_rst)

);

// End of xpm_cdc_sync_rst_inst instance declaration

			</Template>
		</SubFolder>
		<SubFolder label="FIFO (XPM_FIFO)" treetype="folder">
			<Template label="Asynchronous FIFO" treetype="template">
/*
XPM_FIFO instantiation template for Asynchronous FIFO configurations
Refer to the targeted device family architecture libraries guide for XPM_FIFO documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name          | Data type          | Restrictions, if applicable                                          |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| FIFO_MEMORY_TYPE        | String             | Must be "auto", "block", or "distributed"                            |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the fifo memory primitive (resource type) to use:                                                         |
|   "auto": Allow Vivado Synthesis to choose                                                                          |
|   "block": Block RAM FIFO                                                                                           |
|   "distributed": Distributed RAM FIFO                                                                               |
+---------------------------------------------------------------------------------------------------------------------+
| FIFO_WRITE_DEPTH        | Integer            | Must be between 16 and 4194304                                       |
|---------------------------------------------------------------------------------------------------------------------|
| Defines the FIFO Write Depth, must be power of two                                                                  |
| In standard READ_MODE, the effective depth = FIFO_WRITE_DEPTH-1                                                     |
| In First-Word-Fall-Through READ_MODE, the effective depth = FIFO_WRITE_DEPTH+1                                      |
+---------------------------------------------------------------------------------------------------------------------+
| RELATED_CLOCKS          | Integer            | Must be 0 or 1                                                       |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies if the wr_clk and rd_clk are related having the same source but different clock ratios                    |
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_DATA_WIDTH        | Integer            | Must be between 1 and 4096                                           |
|---------------------------------------------------------------------------------------------------------------------|
| Defines the width of the write data port, din                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| WR_DATA_COUNT_WIDTH     | Integer            | Must be between 1 and log2(FIFO_WRITE_DEPTH)+1                       |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies the width of wr_data_count                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| READ_MODE               | String             | Must be "std" or "fwft"                                              |
|---------------------------------------------------------------------------------------------------------------------|
|  "std": standard read mode                                                                                          |
|  "fwft": First-Word-Fall-Through read mode                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| FIFO_READ_LATENCY       | Integer            | Must be &gt;= 0                                                         |
|---------------------------------------------------------------------------------------------------------------------|
|  Number of output register stages in the read data path                                                             |
|  If READ_MODE = "fwft", then the only applicable value is 0.                                                        |
+---------------------------------------------------------------------------------------------------------------------+
| FULL_RESET_VALUE        | Integer            | Must be 0 or 1                                                       |
|---------------------------------------------------------------------------------------------------------------------|
|  Sets FULL and PROG_FULL to FULL_RESET_VALUE during reset                                                           |
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH         | Integer            | Must be between &gt;= 1                                                 |
|---------------------------------------------------------------------------------------------------------------------|
| Defines the width of the read data port, dout                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| RD_DATA_COUNT_WIDTH     | Integer            | Must be between 1 and log2(FIFO_READ_DEPTH)+1                        |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies the width of rd_data_count                                                                                |
| FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH                                                 |
+---------------------------------------------------------------------------------------------------------------------+
| CDC_SYNC_STAGES         | Integer            | Must be between 2 to 8                                               |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies the number of synchronization stages on the CDC path                                                      |
+---------------------------------------------------------------------------------------------------------------------+
| ECC_MODE                | String             | Must be "no_ecc" or "en_ecc"                                         |
|---------------------------------------------------------------------------------------------------------------------|
| "no_ecc" : Disables ECC                                                                                             |
| "en_ecc" : Enables both ECC Encoder and Decoder                                                                     |
+---------------------------------------------------------------------------------------------------------------------+
| PROG_FULL_THRESH        | Integer            | Must be between "Min_Value" and "Max_Value"                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies the maximum number of write words in the FIFO at or above which prog_full is asserted.                    |
| Min_Value = 3 + (READ_MODE*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))+CDC_SYNC_STAGES                                    |
| Min_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))                                 |
+---------------------------------------------------------------------------------------------------------------------+
| PROG_EMPTY_THRESH       | Integer            | Must be between "Min_Value" and "Max_Value"                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies the minimum number of read words in the FIFO at or below which prog_empty is asserted                     |
| Min_Value = 3 + (READ_MODE*2)                                                                                       |
| Min_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE*2)                                                                    |
+---------------------------------------------------------------------------------------------------------------------+
| DOUT_RESET_VALUE        | String             | Must be &gt;="0". Valid hexa decimal value                              |
|---------------------------------------------------------------------------------------------------------------------|
| Reset value of read data path.                                                                                      |
+---------------------------------------------------------------------------------------------------------------------+
| WAKEUP_TIME             | Integer            | Must be 0 or 2                                                       |
|---------------------------------------------------------------------------------------------------------------------|
| 0 : Disable sleep.                                                                                                  |
| 2 : Use Sleep Pin.                                                                                                  |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| sleep          | Input     | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Dynamic power saving: If sleep is High, the memory/fifo block is in power saving mode.                              |
| Synchronous to the slower of wr_clk and rd_clk.                                                                     |
+---------------------------------------------------------------------------------------------------------------------+
| rst            | Input     | 1                                     | wr_clk | Active-high | Required                |
+---------------------------------------------------------------------------------------------------------------------+
| wr_clk         | Input     | 1                                     |        | Rising edge | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Write clock: Used for write operation.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| wr_en          | Input     | 1                                     | wr_clk | Active-high | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Write Enable: If the FIFO is not full, asserting this signal causes data (on din) to be written to the FIFO         |
+---------------------------------------------------------------------------------------------------------------------+
| din            | Input     | WRITE_DATA_WIDTH                      | wr_clk |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Write Data: The input data bus used when writing the FIFO.                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| full           | Output    | 1                                     | wr_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Full Flag: When asserted, this signal indicates that the FIFO is full.                                              |
| Write requests are ignored when the FIFO is full, initiating a write when the FIFO is full is not destructive       |
| to the contents of the FIFO.                                                                                        |
+---------------------------------------------------------------------------------------------------------------------+
| overflow       | Output    | 1                                     | wr_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Overflow: This signal indicates that a write request (wren) during the prior clock cycle was rejected,              |
| because the FIFO is full. Overflowing the FIFO is not destructive to the contents of the FIFO.                      |
+---------------------------------------------------------------------------------------------------------------------+
| wr_rst_busy    | Output    | 1                                     | wr_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Write Reset Busy: Active-High indicator that the FIFO write domain is currently in a reset state.                   |
+---------------------------------------------------------------------------------------------------------------------+
| rd_clk         | Input     | 1                                     |        | Rising edge | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Read clock: Used for read operation.                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| rd_en          | Input     | 1                                     | rd_clk | Active-high | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Read Enable: If the FIFO is not empty, asserting this signal causes data (on dout) to be read from the FIFO         |
+---------------------------------------------------------------------------------------------------------------------+
| dout           | Output    | READ_DATA_WIDTH                       | rd_clk |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Read Data: The output data bus is driven when reading the FIFO.                                                     |
+---------------------------------------------------------------------------------------------------------------------+
| empty          | Output    | 1                                     | rd_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Empty Flag: When asserted, this signal indicates that the FIFO is empty.                                            |
| Read requests are ignored when the FIFO is empty, initiating a read while empty is not destructive to the FIFO.     |
+---------------------------------------------------------------------------------------------------------------------+
| underflow      | Output    | 1                                     | rd_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Underflow: Indicates that the read request (rd_en) during the previous clock cycle was rejected                     |
| because the FIFO is empty. Under flowing the FIFO is not destructive to the FIFO.                                   |
+---------------------------------------------------------------------------------------------------------------------+
| rd_rst_busy    | Output    | 1                                     | rd_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Read Reset Busy: Active-High indicator that the FIFO read domain is currently in a reset state.                     |
+---------------------------------------------------------------------------------------------------------------------+
| prog_full      | Output    | 1                                     | wr_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Programmable Full: This signal is asserted when the number of words in the FIFO is greater than or equal            |
| to the programmable full threshold value.                                                                           |
| It is de-asserted when the number of words in the FIFO is less than the programmable full threshold value.          |
+---------------------------------------------------------------------------------------------------------------------+
| wr_data_count  | Output    | WR_DATA_COUNT_WIDTH                   | wr_clk |             | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Write Data Count: This bus indicates the number of words written into the FIFO.                                     |
+---------------------------------------------------------------------------------------------------------------------+
| prog_empty     | Output    | 1                                     | rd_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Programmable Empty: This signal is asserted when the number of words in the FIFO is less than or equal              |
| to the programmable empty threshold value.                                                                          |
| It is de-asserted when the number of words in the FIFO exceeds the programmable empty threshold value.              |
+---------------------------------------------------------------------------------------------------------------------+
| rd_data_count  | Output    | RD_DATA_COUNT_WIDTH                   | rd_clk |             | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Read Data Count: This bus indicates the number of words read from the FIFO.                                         |
+---------------------------------------------------------------------------------------------------------------------+
| injectsbiterr  | Intput    | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Single Bit Error Injection: Injects a single bit error if the ECC feature is used on block RAMs or                  |
| built-in FIFO macros.                                                                                               |
+---------------------------------------------------------------------------------------------------------------------+
| injectdbiterr  | Intput    | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Double Bit Error Injection: Injects a double bit error if the ECC feature is used on block RAMs or                  |
| built-in FIFO macros.                                                                                               |
+---------------------------------------------------------------------------------------------------------------------+
| sbiterr        | Output    | 1                                     |        | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Single Bit Error: Indicates that the ECC decoder detected and fixed a single-bit error.                             |
+---------------------------------------------------------------------------------------------------------------------+
| dbiterr        | Output    | 1                                     |        | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Double Bit Error: Indicates that the ECC decoder detected a double-bit error and data in the FIFO core is corrupted.|
+---------------------------------------------------------------------------------------------------------------------+
*/

//  xpm_fifo_async      : In order to incorporate this function into the design, the following module instantiation
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//        module        : may be changed to meet design requirements.  The instance name (xpm_fifo_async)
//     instantiation    : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected, unless
//                      : otherwise specified.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_fifo_async: Asynchronous FIFO
// Xilinx Parameterized Macro, Version 2016.4
xpm_fifo_async # (

  .FIFO_MEMORY_TYPE          ("block"),           //string; "auto", "block", or "distributed";
  .ECC_MODE                  ("no_ecc"),         //string; "no_ecc" or "en_ecc";
  .RELATED_CLOCKS            (0),                //positive integer; 0 or 1
  .FIFO_WRITE_DEPTH          (2048),             //positive integer
  .WRITE_DATA_WIDTH          (32),               //positive integer
  .WR_DATA_COUNT_WIDTH       (12),               //positive integer
  .PROG_FULL_THRESH          (10),               //positive integer
  .FULL_RESET_VALUE          (0),                //positive integer; 0 or 1
  .READ_MODE                 ("std"),            //string; "std" or "fwft";
  .FIFO_READ_LATENCY         (1),                //positive integer;
  .READ_DATA_WIDTH           (32),               //positive integer
  .RD_DATA_COUNT_WIDTH       (12),               //positive integer
  .PROG_EMPTY_THRESH         (10),               //positive integer
  .DOUT_RESET_VALUE          ("0"),              //string
  .CDC_SYNC_STAGES           (2),                //positive integer
  .WAKEUP_TIME               (0)                 //positive integer; 0 or 2;

) xpm_fifo_async_inst (

  .rst              (rst),
  .wr_clk           (wr_clk),
  .wr_en            (wr_en),
  .din              (din),
  .full             (full),
  .overflow         (overflow),
  .wr_rst_busy      (wr_rst_busy),
  .rd_clk           (rd_clk),
  .rd_en            (rd_en),
  .dout             (dout),
  .empty            (empty),
  .underflow        (underflow),
  .rd_rst_busy      (rd_rst_busy),
  .prog_full        (prog_full),
  .wr_data_count    (wr_data_count),
  .prog_empty       (prog_empty),
  .rd_data_count    (rd_data_count),
  .sleep            (1'b0),
  .injectsbiterr    (1'b0),
  .injectdbiterr    (1'b0),
  .sbiterr          (),
  .dbiterr          ()

);

// End of xpm_fifo_async instance declaration


			</Template>
			<Template label="Synchronous FIFO" treetype="template">
/*
XPM_FIFO instantiation template for Synchronous FIFO configurations
Refer to the targeted device family architecture libraries guide for XPM_FIFO documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name          | Data type          | Restrictions, if applicable                                          |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| FIFO_MEMORY_TYPE        | String             | Must be "auto", "block", "distributed" or "ultra"                    |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the fifo memory primitive (resource type) to use:                                                         |
|   "auto": Allow Vivado Synthesis to choose                                                                          |
|   "block": Block RAM FIFO                                                                                           |
|   "distributed": Distributed RAM FIFO                                                                               |
|   "ultra": URAM FIFO                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| FIFO_WRITE_DEPTH        | Integer            | Must be between 16 and 4194304                                       |
|---------------------------------------------------------------------------------------------------------------------|
| Defines the FIFO Write Depth, must be power of two                                                                  |
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_DATA_WIDTH        | Integer            | Must be between 1 and 4096                                           |
|---------------------------------------------------------------------------------------------------------------------|
| Defines the width of the write data port, din                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| WR_DATA_COUNT_WIDTH     | Integer            | Must be between 1 and log2(FIFO_WRITE_DEPTH)+1                       |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies the width of wr_data_count                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| READ_MODE               | String             | Must be "std" or "fwft"                                              |
|---------------------------------------------------------------------------------------------------------------------|
|  "std": standard read mode                                                                                          |
|  "fwft": First-Word-Fall-Through read mode                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| FIFO_READ_LATENCY       | Integer            | Must be &gt;= 0                                                         |
|---------------------------------------------------------------------------------------------------------------------|
|  Number of output register stages in the read data path                                                             |
|  If READ_MODE = "fwft", then the only applicable value is 0.                                                        |
+---------------------------------------------------------------------------------------------------------------------+
| FULL_RESET_VALUE        | Integer            | Must be 0 or 1                                                       |
|---------------------------------------------------------------------------------------------------------------------|
|  Sets FULL and PROG_FULL to FULL_RESET_VALUE during reset                                                           |
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH         | Integer            | Must be between &gt;= 1                                                 |
|---------------------------------------------------------------------------------------------------------------------|
| Defines the width of the read data port, dout                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| RD_DATA_COUNT_WIDTH     | Integer            | Must be between 1 and log2(FIFO_READ_DEPTH)+1                        |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies the width of rd_data_count                                                                                |
| FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH                                                 |
+---------------------------------------------------------------------------------------------------------------------+
| ECC_MODE                | String             | Must be "no_ecc" or "en_ecc"                                         |
|---------------------------------------------------------------------------------------------------------------------|
| "no_ecc" : Disables ECC                                                                                             |
| "en_ecc" : Enables both ECC Encoder and Decoder                                                                     |
+---------------------------------------------------------------------------------------------------------------------+
| PROG_FULL_THRESH        | Integer            | Must be between "Min_Value" and "Max_Value"                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies the maximum number of write words in the FIFO at or above which prog_full is asserted.                    |
| Min_Value = 3 + (READ_MODE*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))+CDC_SYNC_STAGES                                    |
| Min_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE*2*(FIFO_WRITE_DEPTH/FIFO_READ_DEPTH))                                 |
+---------------------------------------------------------------------------------------------------------------------+
| PROG_EMPTY_THRESH       | Integer            | Must be between "Min_Value" and "Max_Value"                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specifies the minimum number of read words in the FIFO at or below which prog_empty is asserted                     |
| Min_Value = 3 + (READ_MODE*2)                                                                                       |
| Min_Value = (FIFO_WRITE_DEPTH-3) - (READ_MODE*2)                                                                    |
+---------------------------------------------------------------------------------------------------------------------+
| DOUT_RESET_VALUE        | String             | Must be &gt;="0". Valid hexa decimal value                              |
|---------------------------------------------------------------------------------------------------------------------|
| Reset value of read data path.                                                                                      |
+---------------------------------------------------------------------------------------------------------------------+
| WAKEUP_TIME             | Integer            | Must be 0 or 2                                                       |
|---------------------------------------------------------------------------------------------------------------------|
| 0 : Disable sleep.                                                                                                  |
| 2 : Use Sleep Pin.                                                                                                  |
+---------------------------------------------------------------------------------------------------------------------+


Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| sleep          | Input     | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Dynamic power saving: If sleep is High, the memory/fifo block is in power saving mode.                              |
| Synchronous to the slower of wr_clk and rd_clk when COMMON_CLOCK = 0, otherwise synchronous to rd_clk.              |
+---------------------------------------------------------------------------------------------------------------------+
| rst            | Input     | 1                                     | wr_clk | Active-high | Tie to 1'b0             |
+---------------------------------------------------------------------------------------------------------------------+
| wr_clk         | Input     | 1                                     |        | Rising edge | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Write clock: Used for write operation.                                                                              |
| When parameter COMMON_CLOCK = 1, wr_clk is used for both write and read operation.                                  |
+---------------------------------------------------------------------------------------------------------------------+
| wr_en          | Input     | 1                                     | wr_clk | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Write Enable: If the FIFO is not full, asserting this signal causes data (on din) to be written to the FIFO         |
+---------------------------------------------------------------------------------------------------------------------+
| din            | Input     | WRITE_DATA_WIDTH                      | wr_clk |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Write Data: The input data bus used when writing the FIFO.                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| full           | Output    | 1                                     | wr_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Full Flag: When asserted, this signal indicates that the FIFO is full.                                              |
| Write requests are ignored when the FIFO is full, initiating a write when the FIFO is full is not destructive       |
| to the contents of the FIFO.                                                                                        |
+---------------------------------------------------------------------------------------------------------------------+
| prog_full      | Output    | 1                                     | wr_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Programmable Full: This signal is asserted when the number of words in the FIFO is greater than or equal            |
| to the programmable full threshold value.                                                                           |
| It is de-asserted when the number of words in the FIFO is less than the programmable full threshold value.          |
+---------------------------------------------------------------------------------------------------------------------+
| wr_data_count  | Output    | WR_DATA_COUNT_WIDTH                   | wr_clk |             | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Write Data Count: This bus indicates the number of words written into the FIFO.                                     |
+---------------------------------------------------------------------------------------------------------------------+
| overflow       | Output    | 1                                     | wr_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Overflow: This signal indicates that a write request (wren) during the prior clock cycle was rejected,              |
| because the FIFO is full. Overflowing the FIFO is not destructive to the contents of the FIFO.                      |
+---------------------------------------------------------------------------------------------------------------------+
| wr_rst_busy    | Output    | 1                                     | wr_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Write Reset Busy: Active-High indicator that the FIFO write domain is currently in a reset state.                   |
+---------------------------------------------------------------------------------------------------------------------+
| rd_en          | Input     | 1                                     | rd_clk | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Read Enable: If the FIFO is not empty, asserting this signal causes data (on dout) to be read from the FIFO         |
+---------------------------------------------------------------------------------------------------------------------+
| dout           | Output    | READ_DATA_WIDTH                       | rd_clk |             | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Read Data: The output data bus is driven when reading the FIFO.                                                     |
+---------------------------------------------------------------------------------------------------------------------+
| empty          | Output    | 1                                     | rd_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Empty Flag: When asserted, this signal indicates that the FIFO is empty.                                            |
| Read requests are ignored when the FIFO is empty, initiating a read while empty is not destructive to the FIFO.     |
+---------------------------------------------------------------------------------------------------------------------+
| prog_empty     | Output    | 1                                     | rd_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Programmable Empty: This signal is asserted when the number of words in the FIFO is less than or equal              |
| to the programmable empty threshold value.                                                                          |
| It is de-asserted when the number of words in the FIFO exceeds the programmable empty threshold value.              |
+---------------------------------------------------------------------------------------------------------------------+
| rd_data_count  | Output    | RD_DATA_COUNT_WIDTH                   | rd_clk |             | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Read Data Count: This bus indicates the number of words read from the FIFO.                                         |
+---------------------------------------------------------------------------------------------------------------------+
| underflow      | Output    | 1                                     | rd_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Underflow: Indicates that the read request (rd_en) during the previous clock cycle was rejected                     |
| because the FIFO is empty. Under flowing the FIFO is not destructive to the FIFO.                                   |
+---------------------------------------------------------------------------------------------------------------------+
| rd_rst_busy    | Output    | 1                                     | rd_clk | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Read Reset Busy: Active-High indicator that the FIFO read domain is currently in a reset state.                     |
+---------------------------------------------------------------------------------------------------------------------+
| injectsbiterr  | Intput    | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Single Bit Error Injection: Injects a single bit error if the ECC feature is used on block RAMs or                  |
| built-in FIFO macros.                                                                                               |
+---------------------------------------------------------------------------------------------------------------------+
| injectdbiterr  | Intput    | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Double Bit Error Injection: Injects a double bit error if the ECC feature is used on block RAMs or                  |
| built-in FIFO macros.                                                                                               |
+---------------------------------------------------------------------------------------------------------------------+
| sbiterr        | Output    | 1                                     |        | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Single Bit Error: Indicates that the ECC decoder detected and fixed a single-bit error.                             |
+---------------------------------------------------------------------------------------------------------------------+
| dbiterr        | Output    | 1                                     |        | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Double Bit Error: Indicates that the ECC decoder detected a double-bit error and data in the FIFO core is corrupted.|
+---------------------------------------------------------------------------------------------------------------------+
*/

//  xpm_fifo_sync       : In order to incorporate this function into the design, the following module instantiation
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//        module        : may be changed to meet design requirements.  The instance name (xpm_fifo_sync)
//     instantiation    : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected, unless
//                      : otherwise specified.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_fifo_sync: Synchronous FIFO
// Xilinx Parameterized Macro, Version 2016.4
xpm_fifo_sync # (

  .FIFO_MEMORY_TYPE          ("block"),           //string; "auto", "block", "distributed", or "ultra";
  .ECC_MODE                  ("no_ecc"),         //string; "no_ecc" or "en_ecc";
  .FIFO_WRITE_DEPTH          (2048),             //positive integer
  .WRITE_DATA_WIDTH          (32),               //positive integer
  .WR_DATA_COUNT_WIDTH       (12),               //positive integer
  .PROG_FULL_THRESH          (10),               //positive integer
  .FULL_RESET_VALUE          (0),                //positive integer; 0 or 1
  .READ_MODE                 ("std"),            //string; "std" or "fwft";
  .FIFO_READ_LATENCY         (1),                //positive integer;
  .READ_DATA_WIDTH           (32),               //positive integer
  .RD_DATA_COUNT_WIDTH       (12),               //positive integer
  .PROG_EMPTY_THRESH         (10),               //positive integer
  .DOUT_RESET_VALUE          ("0"),              //string
  .WAKEUP_TIME               (0)                 //positive integer; 0 or 2;

) xpm_fifo_sync_inst (

  .sleep            (1'b0),
  .rst              (rst),
  .wr_clk           (wr_clk),
  .wr_en            (wr_en),
  .din              (din),
  .full             (full),
  .prog_full        (prog_full),
  .wr_data_count    (wr_data_count),
  .overflow         (overflow),
  .wr_rst_busy      (wr_rst_busy),
  .rd_en            (rd_en),
  .dout             (dout),
  .empty            (empty),
  .prog_empty       (prog_empty),
  .rd_data_count    (rd_data_count),
  .underflow        (underflow),
  .rd_rst_busy      (rd_rst_busy),
  .injectsbiterr    (1'b0),
  .injectdbiterr    (1'b0),
  .sbiterr          (),
  .dbiterr          ()

);

// End of xpm_fifo_sync instance declaration
			</Template>
		</SubFolder>
		<SubFolder label="Memory (XPM_MEMORY)" treetype="folder">
			<SubFolder label="Memory File (MEM)" treetype="folder">
				<Template label="Info" treetype="template">
// Information on the Memory File (MEM) for initializing memories
// ==============================================================
//
// A Memory (MEM) file is a text file that describes contiguous blocks of data. MEM files
// can be edited directly. XPM_MEMORY allows the free-form use of both // and /*...*/
// commenting styles.
// The format of MEM files is an industry standard, which consists of two basic elements:
// a hexadecimal address specifier and hexadecimal data values. An address specifier is
// indicated by an @ character followed by the hexadecimal address value. There are no
// spaces between the @ character and the first hexadecimal character.
// Hexadecimal data values follow the hexadecimal address value, separated by spaces,
// tabs, or carriage-return characters. Data values can consist of as many hexadecimal
// characters as desired. However, when a value has an odd number of hexadecimal
// characters, the first hexadecimal character is assumed to be a zero.
// For example, hexadecimal values:
//   A, C74, and 84F21
// are interpreted as the values:
//   0A, 0C74, and 084F21
//
// The common 0x hexadecimal prefix is not allowed. Using this prefix on MEM file
// hexadecimal values is flagged as a syntax error.
// There must be at least one data value following an address, up to as many data values
// that belong to the previous address value.
//
// Following is an example of the most common MEM file format:
//   @0000 3A @0001 7B @0002 C4 @0003 56 @0004 02
//   @0005 6F @0006 89...
// A MEM file can have as many contiguous data blocks as required. While the gap of
// address ranges between data blocks can be any size, no two data blocks can overlap
// an address range
				</Template>
			</SubFolder>
			<SubFolder label="RAM" treetype="folder">
				<Template label="Dual Port Distributed RAM" treetype="template">
/*
XPM_MEMORY instantiation template for dual port distributed RAM configurations
Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_SIZE          | Integer            | Must be integer multiple of [WRITE|READ]_DATA_WIDTH_[A|B]               |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the total memory array size, in bits.                                                                       |
| For example, enter 65536 for a 2kx32 RAM.                                                                           |
+---------------------------------------------------------------------------------------------------------------------+
| CLOCKING_MODE        | String             | Must be "common_clock" or "independent_clock"                           |
|---------------------------------------------------------------------------------------------------------------------|
| Designate whether port A and port B are clocked with a common clock or with independent clocks:                     |
|   "common_clock": Common clocking; clock both port A and port B with clka                                           |
|   "independent_clock": Independent clocking; clock port A with clka and port B with clkb                            |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
|   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
|   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
|   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
|   information on the syntax. Initialization of memory happens through the file name specified only when parameter   |
|   MEMORY_INIT_PARAM value is equal to "".                                                                           |                                                                                       |
|   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_PARAM   | String             | Must be exactly "" or the string of hex characters (in quotes)           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
| containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
| Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
| narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
| memory is 8 locations, then the parameter value should be passed as shown below.                                    |
|   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
|                                  |                   |                                                              |
|                                  0th                7th                                                             |
|                                location            location                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| USE_MEM_INIT         | Integer             | Must be 0 or 1                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
| Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
| Parameter.                                                                                                          |
|    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
|    Initial memory contents will be all 0's                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_DATA_WIDTH_A   | Integer            | Must be &gt; 0 and equal to the value of READ_DATA_WIDTH_A                 |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A write data input port dina, in bits.                                                |
| The values of WRITE_DATA_WIDTH_A and READ_DATA_WIDTH_A must be equal.                                               |
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_A                |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A read data output port douta, in bits.                                               |
| The values of READ_DATA_WIDTH_A and WRITE_DATA_WIDTH_A must be equal.                                               |
+---------------------------------------------------------------------------------------------------------------------+
| BYTE_WRITE_WIDTH_A   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_A                        |
|---------------------------------------------------------------------------------------------------------------------|
| To enable byte-wide writes on port A, specify the byte width, in bits:                                              |
|   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                              |
|   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |
| Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A)       |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A address port addra, in bits.                                                        |
| Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A).|
+---------------------------------------------------------------------------------------------------------------------+
| READ_RESET_VALUE_A   | String             |                                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
+---------------------------------------------------------------------------------------------------------------------+
| READ_LATENCY_A       | Integer             | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
| number of clka cycles.                                                                                              |
| To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
| output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
| Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH_B    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_B                |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port B read data output port doutb, in bits.                                               |
| The values of READ_DATA_WIDTH_B and WRITE_DATA_WIDTH_B must be equal.                                               |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_B         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B)       |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port B address port addrb, in bits.                                                        |
| Must be large enough to access the entire memory from port B, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B).|
+---------------------------------------------------------------------------------------------------------------------+
| READ_RESET_VALUE_B   | String             |                                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |
+---------------------------------------------------------------------------------------------------------------------+
| READ_LATENCY_B       | Integer             | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |
| number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |
| To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
| output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
| Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| clka           | Input     | 1                                     |        | Rising edge | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port A. Also clocks port B when parameter CLOCKING_MODE is "common_clock".                         |
+---------------------------------------------------------------------------------------------------------------------+
| rsta           | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Reset signal for the final port A output register stage.                                                            |
| Synchronously resets output port douta to the value specified by parameter READ_RESET_VALUE_A.                      |
+---------------------------------------------------------------------------------------------------------------------+
| ena            | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port A.                                                                                    |
| Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
+---------------------------------------------------------------------------------------------------------------------+
| regcea         | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock Enable for the last register stage on the output data path.                                                   |
+---------------------------------------------------------------------------------------------------------------------+
| wea            | Input     | WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A | clka   | Active-high | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |
| In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |
| For example, to synchronously write only bits [15:8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be 4'b0010.   |
+---------------------------------------------------------------------------------------------------------------------+
| addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port A write and read operations.                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| dina           | Input     | WRITE_DATA_WIDTH_A                    | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data input for port A write operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data output for port A read operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| clkb           | Input     | 1                                     |        | Rising edge | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port B when parameter CLOCKING_MODE is "independent_clock".                                        |
| Unused when parameter CLOCKING_MODE is "common_clock".                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| rstb           | Input     | 1                                     | *      | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Reset signal for the final port B output register stage.                                                            |
| Synchronously resets output port doutb to the value specified by parameter READ_RESET_VALUE_B.                      |
+---------------------------------------------------------------------------------------------------------------------+
| enb            | Input     | 1                                     | *      | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port B.                                                                                    |
| Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
+---------------------------------------------------------------------------------------------------------------------+
| regceb         | Input     | 1                                     | *      | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Do not change from the provided value.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| addrb          | Input     | ADDR_WIDTH_B                          | *      |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port B write and read operations.                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| doutb          | Output   | READ_DATA_WIDTH_B                      | *      |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data output for port B read operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| * clka when parameter CLOCKING_MODE is "common_clock". clkb when parameter CLOCKING_MODE is "independent_clock".    |
+---------------------------------------------------------------------------------------------------------------------+
*/

//  xpm_memory_dpdistram: In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//       instance       : may be changed to meet design requirements.  The instance name (xpm_memory_dpdistram)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_memory_dpdistram: Dual Port distributed RAM
// Xilinx Parameterized Macro, Version 2016.4
xpm_memory_dpdistram # (

  // Common module parameters
  .MEMORY_SIZE        (2048),                //positive integer
  .CLOCKING_MODE      ("common_clock"),      //string; "common_clock", "independent_clock" 
  .MEMORY_INIT_FILE   ("none"),              //string; "none" or "&lt;filename&gt;.mem" 
  .MEMORY_INIT_PARAM  (""    ),              //string;
  .USE_MEM_INIT       (1),                   //integer; 0,1
  .MESSAGE_CONTROL    (0),                   //integer; 0,1

  // Port A module parameters
  .WRITE_DATA_WIDTH_A (32),                  //positive integer
  .READ_DATA_WIDTH_A  (32),                  //positive integer
  .BYTE_WRITE_WIDTH_A (32),                  //integer; 8, 9, or WRITE_DATA_WIDTH_A value
  .ADDR_WIDTH_A       (6),                   //positive integer
  .READ_RESET_VALUE_A ("0"),                 //string
  .READ_LATENCY_A     (2),                   //non-negative integer

  // Port B module parameters
  .READ_DATA_WIDTH_B  (32),                  //positive integer
  .ADDR_WIDTH_B       (6),                   //positive integer
  .READ_RESET_VALUE_B ("0"),                 //string
  .READ_LATENCY_B     (2)                    //non-negative integer

) xpm_memory_dpdistram_inst (

  // Port A module ports
  .clka   (clka),
  .rsta   (rsta),
  .ena    (ena),
  .regcea (regcea),
  .wea    (wea),
  .addra  (addra),
  .dina   (dina),
  .douta  (douta),

  // Port B module ports
  .clkb   (clkb),
  .rstb   (rstb),
  .enb    (enb),
  .regceb (regceb),
  .addrb  (addrb),
  .doutb  (doutb)

);

// End of xpm_memory_dpdistram instance declaration

				</Template>
				<Template label="Simple Dual Port RAM" treetype="template">
/*
XPM_MEMORY instantiation template for simple dual port RAM configurations
Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_SIZE          | Integer            | Must be integer multiple of [WRITE|READ]_DATA_WIDTH_[A|B]               |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the total memory array size, in bits.                                                                       |
| For example, enter 65536 for a 2kx32 RAM.                                                                           |
| When ECC is enabled and set to "encode_only", then the memory size has to be multiples of READ_DATA_WIDTH_B         |
| When ECC is enabled and set to "decode_only", then the memory size has to be multiples of WRITE_DATA_WIDTH_A        |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", "block" or "ultra"                       |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the memory primitive (resource type) to use:                                                              |
|   "auto": Allow Vivado Synthesis to choose                                                                          |
|   "distributed": Distributed memory                                                                                 |
|   "block": Block memory                                                                                             |
|   "ultra": Ultra RAM memory                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| CLOCKING_MODE        | String             | Must be "common_clock" or "independent_clock"                           |
|---------------------------------------------------------------------------------------------------------------------|
| Designate whether port A and port B are clocked with a common clock or with independent clocks:                     |
|   "common_clock": Common clocking; clock both port A and port B with clka                                           |
|   "independent_clock": Independent clocking; clock port A with clka and port B with clkb                            |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
|   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
|   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
|   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
|   information on the syntax. Initialization of memory happens through the file name specified only when parameter   |
|   MEMORY_INIT_PARAM value is equal to "".                                                                           |
|   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_PARAM   | String             | Must be exactly "" or the string of hex characters (in quotes)           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
| containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
| Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
| narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
| memory is 8 locations, then the parameter value should be passed as shown below.                                    |
|   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
|                                  |                   |                                                              |
|                                  0th                7th                                                             |
|                                location            location                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| USE_MEM_INIT         | Integer             | Must be 0 or 1                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
| Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
| Parameter.                                                                                                          |
|    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
|    Initial memory contents will be all 0's                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| WAKEUP_TIME          | String             | Must be "disable_sleep" or "use_sleep_pin"                              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
| dynamic power saving option                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_DATA_WIDTH_A   | Integer            | Must be &gt; 0                                                             |
| When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_A has to be         |
| multiples of 64-bits                                                                                                |
| When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_A has to be multiples of 72-bits                |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A write data input port dina, in bits.                                                |
+---------------------------------------------------------------------------------------------------------------------+
| BYTE_WRITE_WIDTH_A   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_A                        |
|---------------------------------------------------------------------------------------------------------------------|
| To enable byte-wide writes on port A, specify the byte width, in bits:                                              |
|   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                              |
|   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |
| Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/WRITE_DATA_WIDTH_A)              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A address port addra, in bits.                                                        |
| Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_A).       |
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH_B    | Integer            | Must be &gt; 0                                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port B read data output port doutb, in bits.                                               |
| When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_B has to be multiples of 72-bits                 |
| When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_B has to be          |
| multiples of 64-bits                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_B         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/READ_DATA_WIDTH_B)               |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port B address port addrb, in bits.                                                        |
| Must be large enough to access the entire memory from port B, i.e. &gt;= $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B).        |
+---------------------------------------------------------------------------------------------------------------------+
| READ_RESET_VALUE_B   | String             |                                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |
| As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
| If the read data width is 8, then specify READ_RESET_VALUE_B = "EA";                                                |
| When ECC is enabled, then reset value is not supported                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| READ_LATENCY_B       | Integer             | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |
| number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |
| To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
| output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
| Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_MODE_B         | String              | Must be "write_first", "read_first", or "no_change".                   |
|                                            | For distributed memory, must be "read_first".                          |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the write mode of port B:                                                                                 |
|   "write_first": Write-first write mode                                                                             |
|   "read_first": Read-first write mode                                                                               |
|   "no_change": No-change write mode                                                                                 |
| Distributed memory configurations require read-first write mode."write_first" mode is compatible only with UltraRAM |
+---------------------------------------------------------------------------------------------------------------------+
| ECC_MODE             | String              | Must be "no_ecc", "encode_only", "decode_only"                         |
|                                            | or "both_encode_and_decode".                                           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify ECC mode on both ports of the memory primitive                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| AUTO_SLEEP_TIME      | Integer             | Must be 0 or 3-15                                                      |
|---------------------------------------------------------------------------------------------------------------------|
| Number of clk[a|b] cycles to auto-sleep, if feature is available in architecture                                    |
|   0 : Disable auto-sleep feature                                                                                    |
|   3-15 : Number of auto-sleep latency cycles                                                                        |
|   Do not change from the value provided in the template instantiation                                               |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| sleep          | Input     | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| sleep signal to enable the dynamic power saving feature.                                                            |
+---------------------------------------------------------------------------------------------------------------------+
| clka           | Input     | 1                                     |        | Rising edge | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port A. Also clocks port B when parameter CLOCKING_MODE is "common_clock".                         |
+---------------------------------------------------------------------------------------------------------------------+
| ena            | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port A.                                                                                    |
| Must be high on clock cycles when write operations are initiated. Pipelined internally.                             |
+---------------------------------------------------------------------------------------------------------------------+
| wea            | Input     | WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A | clka   | Active-high | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |
| In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |
| For example, to synchronously write only bits [15:8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be 4'b0010.   |
+---------------------------------------------------------------------------------------------------------------------+
| addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port A write operations.                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| dina           | Input     | WRITE_DATA_WIDTH_A                    | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data input for port A write operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |
| "decode_only" mode).                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |
| "decode_only" mode).                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| clkb           | Input     | 1                                     |        | Rising edge | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port B when parameter CLOCKING_MODE is "independent_clock".                                        |
| Unused when parameter CLOCKING_MODE is "common_clock".                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| rstb           | Input     | 1                                     | *      | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Reset signal for the final port B output register stage.                                                            |
| Synchronously resets output port doutb to the value specified by parameter READ_RESET_VALUE_B.                      |
+---------------------------------------------------------------------------------------------------------------------+
| enb            | Input     | 1                                     | *      | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port B.                                                                                    |
| Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |
+---------------------------------------------------------------------------------------------------------------------+
| regceb         | Input     | 1                                     | *      | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock Enable for the last register stage on the output data path.                                                   |
+---------------------------------------------------------------------------------------------------------------------+
| addrb          | Input     | ADDR_WIDTH_B                          | *      |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port B read operations.                                                                                 |
+---------------------------------------------------------------------------------------------------------------------+
| doutb          | Output    | READ_DATA_WIDTH_B                     | *      |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data output for port B read operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| sbiterrb       | Output    | 1                                     | *      | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate single bit error occurrence on the data output of port B.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| dbiterrb       | Output    | 1                                     | *      | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate double bit error occurrence on the data output of port B.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| * clka when parameter CLOCKING_MODE is "common_clock". clkb when parameter CLOCKING_MODE is "independent_clock".    |
+---------------------------------------------------------------------------------------------------------------------+
*/

//  xpm_memory_sdpram   : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//       instance       : may be changed to meet design requirements.  The instance name (xpm_memory_sdpram)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_memory_sdpram: Simple Dual Port RAM
// Xilinx Parameterized Macro, Version 2016.4
xpm_memory_sdpram # (

  // Common module parameters
  .MEMORY_SIZE        (2048),            //positive integer
  .MEMORY_PRIMITIVE   ("auto"),          //string; "auto", "distributed", "block" or "ultra";
  .CLOCKING_MODE      ("common_clock"),  //string; "common_clock", "independent_clock" 
  .MEMORY_INIT_FILE   ("none"),          //string; "none" or "&lt;filename&gt;.mem" 
  .MEMORY_INIT_PARAM  (""    ),          //string;
  .USE_MEM_INIT       (1),               //integer; 0,1
  .WAKEUP_TIME        ("disable_sleep"), //string; "disable_sleep" or "use_sleep_pin" 
  .MESSAGE_CONTROL    (0),               //integer; 0,1
  .ECC_MODE           ("no_ecc"),        //string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
  .AUTO_SLEEP_TIME    (0),               //Do not Change

  // Port A module parameters
  .WRITE_DATA_WIDTH_A (32),              //positive integer
  .BYTE_WRITE_WIDTH_A (32),              //integer; 8, 9, or WRITE_DATA_WIDTH_A value
  .ADDR_WIDTH_A       (6),               //positive integer

  // Port B module parameters
  .READ_DATA_WIDTH_B  (32),              //positive integer
  .ADDR_WIDTH_B       (6),               //positive integer
  .READ_RESET_VALUE_B ("0"),             //string
  .READ_LATENCY_B     (2),               //non-negative integer
  .WRITE_MODE_B       ("no_change")     //string; "write_first", "read_first", "no_change" 

) xpm_memory_sdpram_inst (

  // Common module ports
  .sleep          (1'b0),

  // Port A module ports
  .clka           (clka),
  .ena            (ena),
  .wea            (wea),
  .addra          (addra),
  .dina           (dina),
  .injectsbiterra (1'b0),
  .injectdbiterra (1'b0),

  // Port B module ports
  .clkb           (clkb),
  .rstb           (rstb),
  .enb            (enb),
  .regceb         (regceb),
  .addrb          (addrb),
  .doutb          (doutb),
  .sbiterrb       (),
  .dbiterrb       ()

);

// End of xpm_memory_sdpram instance declaration

				</Template>
				<Template label="Single Port RAM" treetype="template">
/*
XPM_MEMORY instantiation template for single port RAM configurations
Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_SIZE          | Integer            | Must be integer multiple of [WRITE|READ]_DATA_WIDTH_A                   |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the total memory array size, in bits.                                                                       |
| For example, enter 65536 for a 2kx32 RAM.                                                                           |
| When ECC is enabled and set to "encode_only", then the memory size has to be multiples of READ_DATA_WIDTH_A         |
| When ECC is enabled and set to "decode_only", then the memory size has to be multiples of WRITE_DATA_WIDTH_A        |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", "block" or "ultra"                       |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the memory primitive (resource type) to use:                                                              |
|   "auto": Allow Vivado Synthesis to choose                                                                          |
|   "distributed": Distributed memory                                                                                 |
|   "block": Block memory                                                                                             |
|   "ultra": Ultra RAM memory                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
|   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
|   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
|   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
|   information on the syntax. Initialization of memory happens through the file name specified only when parameter   |
|   MEMORY_INIT_PARAM value is equal to "".                                                                           |
|   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_PARAM   | String             | Must be exactly "" or the string of hex characters (in quotes)           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
| containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
| Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
| narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
| memory is 8 locations, then the parameter value should be passed as shown below.                                    |
|   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
|                                  |                   |                                                              |
|                                  0th                7th                                                             |
|                                location            location                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| USE_MEM_INIT         | Integer             | Must be 0 or 1                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
| Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
| Parameter.                                                                                                          |
|    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
|    Initial memory contents will be all 0's                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| WAKEUP_TIME          | String             | Must be "disable_sleep"  or "use_sleep_pin"                             |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
| dynamic power saving option                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_DATA_WIDTH_A   | Integer            | Must be &gt; 0 and equal to the value of READ_DATA_WIDTH_A                 |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A write data input port dina, in bits.                                                |
| The values of WRITE_DATA_WIDTH_A and READ_DATA_WIDTH_A must be equal.                                               |
| When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_A has to be         |
| multiples of 64-bits                                                                                                |
| When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_A has to be multiples of 72-bits                |
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_A                |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A read data output port douta, in bits.                                               |
| The values of READ_DATA_WIDTH_A and WRITE_DATA_WIDTH_A must be equal.                                               |
| When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_A has to be multiples of 72-bits                 |
| When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_A has to be          |
| multiples of 64-bits                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| BYTE_WRITE_WIDTH_A   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_A                        |
|---------------------------------------------------------------------------------------------------------------------|
| To enable byte-wide writes on port A, specify the byte width, in bits:                                              |
|   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                              |
|   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |
| Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A)       |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A address port addra, in bits.                                                        |
| Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A).|
+---------------------------------------------------------------------------------------------------------------------+
| READ_RESET_VALUE_A   | String             |                                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
| As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
| If the read data width is 8, then specify READ_RESET_VALUE_A = "EA";                                                |
| When ECC is enabled, then reset value is not supported                                                              |                 
+---------------------------------------------------------------------------------------------------------------------+
| READ_LATENCY_A       | Integer             | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
| number of clka cycles.                                                                                              |
| To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
| output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
| Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_MODE_A         | String              | Must be "write_first", "read_first", or "no_change".                   |
|                                            | For distributed memory, must be "read_first".                          |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the write mode of port A:                                                                                 |
|   "write_first": Write-first write mode                                                                             |
|   "read_first": Read-first write mode                                                                               |
|   "no_change": No-change write mode                                                                                 |
| Distributed memory configurations require read-first write mode.                                                    |
+---------------------------------------------------------------------------------------------------------------------+
| ECC_MODE             | String              | Must be "no_ecc", "encode_only", "decode_only"                         |
|                                            | or "both_encode_and_decode".                                           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify ECC mode on port A of the memory primitive                                                                  |
+---------------------------------------------------------------------------------------------------------------------+
| AUTO_SLEEP_TIME      | Integer             | Must be 0 or 3-15                                                      |
|---------------------------------------------------------------------------------------------------------------------|
| Number of clka cycles to auto-sleep, if feature is available in architecture                                        |
|   0    : Disable auto-sleep feature                                                                                 |
|   3-15 : Number of auto-sleep latency cycles                                                                        |
|   Do not change from the value provided in the template instantiation                                               |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| sleep          | Input     | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| sleep signal to enable the dynamic power saving feature.                                                            |
+---------------------------------------------------------------------------------------------------------------------+
| clka           | Input     | 1                                     |        | Rising edge | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port A.                                                                                            |
+---------------------------------------------------------------------------------------------------------------------+
| rsta           | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Reset signal for the final port A output register stage.                                                            |
| Synchronously resets output port douta to the value specified by parameter READ_RESET_VALUE_A.                      |
+---------------------------------------------------------------------------------------------------------------------+
| ena            | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port A.                                                                                    |
| Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
+---------------------------------------------------------------------------------------------------------------------+
| regcea         | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock Enable for the last register stage on the output data path.                                                   |
+---------------------------------------------------------------------------------------------------------------------+
| wea            | Input     | WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A | clka   | Active-high | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |
| In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |
| For example, to synchronously write only bits [15:8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be 4'b0010.   |
+---------------------------------------------------------------------------------------------------------------------+
| addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port A write and read operations.                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| dina           | Input     | WRITE_DATA_WIDTH_A                    | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data input for port A write operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |
| "decode_only" mode).                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |
| "decode_only" mode).                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data output for port A read operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| sbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate single bit error occurrence on the data output of port A.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| dbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate double bit error occurrence on the data output of port A.                                 |
+---------------------------------------------------------------------------------------------------------------------+
*/

//  xpm_memory_spram    : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//      instance        : may be changed to meet design requirements.  The instance name (xpm_memory_spram)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_memory_spram: Single Port RAM
// Xilinx Parameterized Macro, Version 2016.4
xpm_memory_spram # (

  // Common module parameters
  .MEMORY_SIZE        (2048),           //positive integer
  .MEMORY_PRIMITIVE   ("auto"),         //string; "auto", "distributed", "block" or "ultra";
  .MEMORY_INIT_FILE   ("none"),         //string; "none" or "&lt;filename&gt;.mem" 
  .MEMORY_INIT_PARAM  (""    ),         //string;
  .USE_MEM_INIT       (1),              //integer; 0,1
  .WAKEUP_TIME        ("disable_sleep"),//string; "disable_sleep" or "use_sleep_pin" 
  .MESSAGE_CONTROL    (0),              //integer; 0,1

  // Port A module parameters
  .WRITE_DATA_WIDTH_A (32),             //positive integer
  .READ_DATA_WIDTH_A  (32),             //positive integer
  .BYTE_WRITE_WIDTH_A (32),             //integer; 8, 9, or WRITE_DATA_WIDTH_A value
  .ADDR_WIDTH_A       (6),              //positive integer
  .READ_RESET_VALUE_A ("0"),            //string
  .ECC_MODE           ("no_ecc"),       //string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
  .AUTO_SLEEP_TIME    (0),              //Do not Change
  .READ_LATENCY_A     (2),              //non-negative integer
  .WRITE_MODE_A       ("read_first")    //string; "write_first", "read_first", "no_change" 

) xpm_memory_spram_inst (

  // Common module ports
  .sleep          (1'b0),

  // Port A module ports
  .clka           (clka),
  .rsta           (rsta),
  .ena            (ena),
  .regcea         (regcea),
  .wea            (wea),
  .addra          (addra),
  .dina           (dina),
  .injectsbiterra (1'b0),
  .injectdbiterra (1'b0),
  .douta          (douta),
  .sbiterra       (),
  .dbiterra       ()

);

// End of xpm_memory_spram instance declaration

				</Template>
				<Template label="True Dual Port RAM" treetype="template">
/*
XPM_MEMORY instantiation template for true dual port RAM configurations
Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_SIZE          | Integer            | Must be integer multiple of [WRITE|READ]_DATA_WIDTH_[A|B]               |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the total memory array size, in bits.                                                                       |
| For example, enter 65536 for a 2kx32 RAM.                                                                           |
| When ECC is enabled and set to "encode_only", then the memory size has to be multiples of READ_DATA_WIDTH_[A|B]     |
| When ECC is enabled and set to "decode_only", then the memory size has to be multiples of WRITE_DATA_WIDTH_[A|B]    |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", "block" or "ultra"                       |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the memory primitive (resource type) to use:                                                              |
|   "auto": Allow Vivado Synthesis to choose                                                                          |
|   "distributed": Distributed memory                                                                                 |
|   "block": Block memory                                                                                             |
|   "ultra": Ultra RAM memory                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| CLOCKING_MODE        | String             | Must be "common_clock" or "independent_clock"                           |
|---------------------------------------------------------------------------------------------------------------------|
| Designate whether port A and port B are clocked with a common clock or with independent clocks:                     |
|   "common_clock": Common clocking; clock both port A and port B with clka                                           |
|   "independent_clock": Independent clocking; clock port A with clka and port B with clkb                            |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
|   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
|   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
|   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
|   information on the syntax. Initialization of memory happens through the file name specified only when parameter   |
|   MEMORY_INIT_PARAM value is equal to "".                                                                           |                                                                                        |
|   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_PARAM   | String             | Must be exactly "" or the string of hex characters (in quotes)           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
| containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
| Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
| narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
| memory is 8 locations, then the parameter value should be passed as shown below.                                    |
|   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
|                                  |                   |                                                              |
|                                  0th                7th                                                             |
|                                location            location                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| USE_MEM_INIT         | Integer             | Must be 0 or 1                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
| Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
| Parameter.                                                                                                          |
|    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
|    Initial memory contents will be all 0's                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| WAKEUP_TIME          | String             | Must be "disable_sleep" or "use_sleep_pin"                              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
| dynamic power saving option                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| ECC_MODE             | String              | Must be "no_ecc", "encode_only", "decode_only"                         |
|                                            | or "both_encode_and_decode".                                           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify ECC mode on both ports of the memory primitive                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| AUTO_SLEEP_TIME      | Integer             | Must be 0 or 3-15                                                      |
|---------------------------------------------------------------------------------------------------------------------|
| Number of clk[a|b] cycles to auto-sleep, if feature is available in architecture                                    |
|   0 : Disable auto-sleep feature                                                                                    |
|   3-15 : Number of auto-sleep latency cycles                                                                        |
|   Do not change from the value provided in the template instantiation                                               |
+---------------------------------------------------------------------------------------------------------------------+
| MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_DATA_WIDTH_A   | Integer            | Must be &gt; 0 and equal to the value of READ_DATA_WIDTH_A                 |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A write data input port dina, in bits.                                                |
| The values of WRITE_DATA_WIDTH_A and READ_DATA_WIDTH_A must be equal.                                               |
| When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_A has to be         |
| multiples of 64-bits                                                                                                |
| When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_A has to be multiples of 72-bits                |
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_A                |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A read data output port douta, in bits.                                               |
| The values of READ_DATA_WIDTH_A and WRITE_DATA_WIDTH_A must be equal.                                               |
| When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_A has to be multiples of 72-bits                 |
| When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_A has to be          |
| multiples of 64-bits                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| BYTE_WRITE_WIDTH_A   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_A                        |
|---------------------------------------------------------------------------------------------------------------------|
| To enable byte-wide writes on port A, specify the byte width, in bits:                                              |
|   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 8                              |
|   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_A is an integer multiple of 9                              |
| Or to enable word-wide writes on port A, specify the same value as for WRITE_DATA_WIDTH_A.                          |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A)       |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A address port addra, in bits.                                                        |
| Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_A).|
+---------------------------------------------------------------------------------------------------------------------+
| READ_RESET_VALUE_A   | String             |                                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
| As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
| If the read data width is 8, then specify READ_RESET_VALUE_A = "EA";                                                |
| When ECC is enabled, then reset value is not supported                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| READ_LATENCY_A       | Integer             | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
| number of clka cycles.                                                                                              |
| To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
| output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
| Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_MODE_A         | String             | Must be "write_first", "read_first", or "no_change".                    |
|                                           | For distributed memory, must be read_first.                             |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the write mode of port A:                                                                                 |
|   "write_first": Write-first write mode                                                                             |
|   "read_first" : Read-first write mode                                                                              |
|   "no_change"  : No-change write mode                                                                               |
| Distributed memory configurations require read-first write mode.                                                    |
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_DATA_WIDTH_B   | Integer            | Must be &gt; 0 and equal to the value of READ_DATA_WIDTH_B                 |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port B write data input port dinb, in bits.                                                |
| The values of WRITE_DATA_WIDTH_B and READ_DATA_WIDTH_B must be equal.                                               |
| When ECC is enabled and set to "encode_only" or "both_encode_and_decode", then WRITE_DATA_WIDTH_B has to be         |
| multiples of 64-bits                                                                                                |
| When ECC is enabled and set to "decode_only", then WRITE_DATA_WIDTH_B has to be multiples of 72-bits                |
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH_B    | Integer            | Must be &gt; 0 and equal to the value of WRITE_DATA_WIDTH_B                |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port B read data output port doutb, in bits.                                               |
| The values of READ_DATA_WIDTH_B and WRITE_DATA_WIDTH_B must be equal.                                               |
| When ECC is enabled and set to "encode_only", then READ_DATA_WIDTH_B has to be multiples of 72-bits                 |
| When ECC is enabled and set to "decode_only" or "both_encode_and_decode", then READ_DATA_WIDTH_B has to be          |
| multiples of 64-bits                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| BYTE_WRITE_WIDTH_B   | Integer            | Must be 8, 9, or the value of WRITE_DATA_WIDTH_B                        |
|---------------------------------------------------------------------------------------------------------------------|
| To enable byte-wide writes on port B, specify the byte width, in bits:                                              |
|   8: 8-bit byte-wide writes, legal when WRITE_DATA_WIDTH_B is an integer multiple of 8                              |
|   9: 9-bit byte-wide writes, legal when WRITE_DATA_WIDTH_B is an integer multiple of 9                              |
| Or to enable word-wide writes on port B, specify the same value as for WRITE_DATA_WIDTH_B.                          |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_B         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B)       |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port B address port addrb, in bits.                                                        |
| Must be large enough to access the entire memory from port B, i.e. &gt;= $clog2(MEMORY_SIZE/[WRITE|READ]_DATA_WIDTH_B).|
+---------------------------------------------------------------------------------------------------------------------+
| READ_RESET_VALUE_B   | String             |                                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |
| As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
| If the read data width is 8, then specify READ_RESET_VALUE_B = "EA";                                                |
| When ECC is enabled, then reset value is not supported                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| READ_LATENCY_B       | Integer             | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |
| number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |
| To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
| output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
| Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
+---------------------------------------------------------------------------------------------------------------------+
| WRITE_MODE_B         | String              | Must be "write_first", "read_first", or "no_change".                   |
|                                            | For distributed memory, must be "read_first".                          |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the write mode of port B:                                                                                 |
|   "write_first": Write-first write mode                                                                             |
|   "read_first": Read-first write mode                                                                               |
|   "no_change": No-change write mode                                                                                 |
| Distributed memory configurations require read-first write mode.                                                    |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| sleep          | Input     | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| sleep signal to enable the dynamic power saving feature.                                                            |
+---------------------------------------------------------------------------------------------------------------------+
| clka           | Input     | 1                                     |        | Rising edge | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port A. Also clocks port B when parameter CLOCKING_MODE is "common_clock".                         |
+---------------------------------------------------------------------------------------------------------------------+
| rsta           | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Reset signal for the final port A output register stage.                                                            |
| Synchronously resets output port douta to the value specified by parameter READ_RESET_VALUE_A.                      |
+---------------------------------------------------------------------------------------------------------------------+
| ena            | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port A.                                                                                    |
| Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
+---------------------------------------------------------------------------------------------------------------------+
| regcea         | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock Enable for the last register stage on the output data path.                                                   |
+---------------------------------------------------------------------------------------------------------------------+
| wea            | Input     | WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A | clka   | Active-high | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Write enable vector for port A input data port dina. 1 bit wide when word-wide writes are used.                     |
| In byte-wide write configurations, each bit controls the writing one byte of dina to address addra.                 |
| For example, to synchronously write only bits [15:8] of dina when WRITE_DATA_WIDTH_A is 32, wea would be 4'b0010.   |
+---------------------------------------------------------------------------------------------------------------------+
| addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port A write and read operations.                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| dina           | Input     | WRITE_DATA_WIDTH_A                    | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data input for port A write operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |
| "decode_only" mode).
+---------------------------------------------------------------------------------------------------------------------+
| injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |
| "decode_only" mode).                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data output for port A read operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| sbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate single bit error occurrence on the data output of port A.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| dbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate double bit error occurrence on the data output of port A.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| clkb           | Input     | 1                                     |        | Rising edge | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port B when parameter CLOCKING_MODE is "independent_clock".                                        |
| Unused when parameter CLOCKING_MODE is "common_clock".                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| rstb           | Input     | 1                                     | *      | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Reset signal for the final port B output register stage.                                                            |
| Synchronously resets output port doutb to the value specified by parameter READ_RESET_VALUE_B.                      |
+---------------------------------------------------------------------------------------------------------------------+
| enb            | Input     | 1                                     | *      | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port B.                                                                                    |
| Must be high on clock cycles when read or write operations are initiated. Pipelined internally.                     |
+---------------------------------------------------------------------------------------------------------------------+
| regceb         | Input     | 1                                     | *      | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock Enable for the last register stage on the output data path.                                                   |
+---------------------------------------------------------------------------------------------------------------------+
| web            | Input     | WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B | *      | Active-high | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Write enable vector for port B input data port dinb. 1 bit wide when word-wide writes are used.                     |
| In byte-wide write configurations, each bit controls the writing one byte of dinb to address addrb.                 |
| For example, to synchronously write only bits [15:8] of dinb when WRITE_DATA_WIDTH_B is 32, web would be 4'b0010.   |
+---------------------------------------------------------------------------------------------------------------------+
| addrb          | Input     | ADDR_WIDTH_B                          | *      |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port B write and read operations.                                                                       |
+---------------------------------------------------------------------------------------------------------------------+
| dinb           | Input     | WRITE_DATA_WIDTH_B                    | *      |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data input for port B write operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| injectsbiterrb | Input     | 1                                     | *      | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Controls single bit error injection on input data when ECC enabled (Error injection capability is not available in  |
| "decode_only" mode).                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| injectdbiterrb | Input     | 1                                     | *      | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Controls double bit error injection on input data when ECC enabled (Error injection capability is not available in  |
| "decode_only" mode).                                                                                                |
+---------------------------------------------------------------------------------------------------------------------+
| doutb          | Output   | READ_DATA_WIDTH_B                      | *      |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data output for port B read operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| sbiterrb       | Output   | 1                                      | *      | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate single bit error occurrence on the data output of port B.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| dbiterrb       | Output   | 1                                      | *      | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate double bit error occurrence on the data output of port A.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| * clka when parameter CLOCKING_MODE is "common_clock". clkb when parameter CLOCKING_MODE is "independent_clock".    |
+---------------------------------------------------------------------------------------------------------------------+
*/

//  xpm_memory_tdpram   : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//       instance       : may be changed to meet design requirements.  The instance name (xpm_memory_tdpram)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_memory_tdpram: True Dual Port RAM
// Xilinx Parameterized Macro, Version 2016.4
xpm_memory_tdpram # (

  // Common module parameters
  .MEMORY_SIZE        (2048),            //positive integer
  .MEMORY_PRIMITIVE   ("auto"),          //string; "auto", "distributed", "block" or "ultra";
  .CLOCKING_MODE      ("common_clock"),  //string; "common_clock", "independent_clock" 
  .MEMORY_INIT_FILE   ("none"),          //string; "none" or "&lt;filename&gt;.mem" 
  .MEMORY_INIT_PARAM  (""    ),          //string;
  .USE_MEM_INIT       (1),               //integer; 0,1
  .WAKEUP_TIME        ("disable_sleep"), //string; "disable_sleep" or "use_sleep_pin" 
  .MESSAGE_CONTROL    (0),               //integer; 0,1
  .ECC_MODE           ("no_ecc"),        //string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
  .AUTO_SLEEP_TIME    (0),               //Do not Change

  // Port A module parameters
  .WRITE_DATA_WIDTH_A (32),              //positive integer
  .READ_DATA_WIDTH_A  (32),              //positive integer
  .BYTE_WRITE_WIDTH_A (32),              //integer; 8, 9, or WRITE_DATA_WIDTH_A value
  .ADDR_WIDTH_A       (6),               //positive integer
  .READ_RESET_VALUE_A ("0"),             //string
  .READ_LATENCY_A     (2),               //non-negative integer
  .WRITE_MODE_A       ("no_change"),     //string; "write_first", "read_first", "no_change" 

  // Port B module parameters
  .WRITE_DATA_WIDTH_B (32),              //positive integer
  .READ_DATA_WIDTH_B  (32),              //positive integer
  .BYTE_WRITE_WIDTH_B (32),              //integer; 8, 9, or WRITE_DATA_WIDTH_B value
  .ADDR_WIDTH_B       (6),               //positive integer
  .READ_RESET_VALUE_B ("0"),             //vector of READ_DATA_WIDTH_B bits
  .READ_LATENCY_B     (2),               //non-negative integer
  .WRITE_MODE_B       ("no_change")      //string; "write_first", "read_first", "no_change" 

) xpm_memory_tdpram_inst (

  // Common module ports
  .sleep          (1'b0),

  // Port A module ports
  .clka           (clka),
  .rsta           (rsta),
  .ena            (ena),
  .regcea         (regcea),
  .wea            (wea),
  .addra          (addra),
  .dina           (dina),
  .injectsbiterra (1'b0),
  .injectdbiterra (1'b0),
  .douta          (douta),
  .sbiterra       (),
  .dbiterra       (),

  // Port B module ports
  .clkb           (clkb),
  .rstb           (rstb),
  .enb            (enb),
  .regceb         (regceb),
  .web            (web),
  .addrb          (addrb),
  .dinb           (dinb),
  .injectsbiterrb (1'b0),
  .injectdbiterrb (1'b0),
  .doutb          (doutb),
  .sbiterrb       (),
  .dbiterrb       ()

);

// End of xpm_memory_tdpram instance declaration

				</Template>
			</SubFolder>
			<SubFolder label="ROM" treetype="folder">
				<Template label="Dual Port ROM" treetype="template">
/*
XPM_MEMORY instantiation template for dual port ROM configurations
Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_SIZE          | Integer            | Must be integer multiple of READ_DATA_WIDTH_[A|B]                       |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the total memory array size, in bits.                                                                       |
| For example, enter 65536 for a 2kx32 ROM.                                                                           |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", or "block"                               |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the memory primitive (resource type) to use:                                                              |
|   "auto": Allow Vivado Synthesis to choose                                                                          |
|   "distributed": Distributed memory                                                                                 |
|   "block": Block memory                                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| CLOCKING_MODE        | String             | Must be "common_clock" or "independent_clock"                           |
|---------------------------------------------------------------------------------------------------------------------|
| Designate whether port A and port B are clocked with a common clock or with independent clocks:                     |
|   "common_clock": Common clocking; clock both port A and port B with clka                                           |
|   "independent_clock": Independent clocking; clock port A with clka and port B with clkb                            |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
|   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
|   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
|   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
|   information on the syntax. Initialization of memory happens through the file name specified only when parameter   |
|   MEMORY_INIT_PARAM value is equal to "".                                                                           |                                                                                       |
|   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_PARAM   | String             | Must be exactly "" or the string of hex characters (in quotes)           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
| containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
| Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
| narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
| memory is 8 locations, then the parameter value should be passed as shown below.                                    |
|   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
|                                  |                   |                                                              |
|                                  0th                7th                                                             |
|                                location            location                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| USE_MEM_INIT         | Integer             | Must be 0 or 1                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
| Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
| Parameter.                                                                                                          |
|    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
|    Initial memory contents will be all 0's                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| WAKEUP_TIME          | String             | Must be "disable_sleep" or "use_sleep_pin"                              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
| dynamic power saving option                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| ECC_MODE             | String              | Must be "no_ecc", "encode_only", "decode_only"                         |
|                                            | or "both_encode_and_decode".                                           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify ECC mode on all ports of the memory primitive (ECC with Initialization is currently not supported)          |
+---------------------------------------------------------------------------------------------------------------------+
| AUTO_SLEEP_TIME      | Integer             | Must be 0 or 3-15                                                      |
|---------------------------------------------------------------------------------------------------------------------|
| Must be set to 0                                                                                                    |
|   0 : Disable auto-sleep feature                                                                                    |
+---------------------------------------------------------------------------------------------------------------------+
| MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0                                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A read data output port douta, in bits.                                               |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/READ_DATA_WIDTH_A)               |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A address port addra, in bits.                                                        |
| Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A).        |
+---------------------------------------------------------------------------------------------------------------------+
| READ_RESET_VALUE_A   | String             |                                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
| For example, to reset the value of port douta to all 0's when READ_DATA_WIDTH_A is 32, specify 32'h0.               |
+---------------------------------------------------------------------------------------------------------------------+
| READ_LATENCY_A       | Integer             | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
| number of clka cycles.                                                                                              |
| To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
| output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
| Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH_B    | Integer            | Must be &gt; 0                                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port B read data output port doutb, in bits.                                               |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_B         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/READ_DATA_WIDTH_B)               |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port B address port addrb, in bits.                                                        |
| Must be large enough to access the entire memory from port B, i.e. &gt;= $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B).        |
+---------------------------------------------------------------------------------------------------------------------+
| READ_RESET_VALUE_B   | String             |                                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the reset value of the port B final output register stage in response to rstb input port is assertion.      |
+---------------------------------------------------------------------------------------------------------------------+
| READ_LATENCY_B       | Integer             | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the number of register stages in the port B read data pipeline. Read data output to port doutb takes this   |
| number of clkb cycles (clka when CLOCKING_MODE is "common_clock").                                                  |
| To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
| output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
| Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| sleep          | Input     | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| sleep signal to enable the dynamic power saving feature.                                                            |
+---------------------------------------------------------------------------------------------------------------------+
| clka           | Input     | 1                                     |        | Rising edge | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port A. Also clocks port B when parameter CLOCKING_MODE is "common_clock".                         |
+---------------------------------------------------------------------------------------------------------------------+
| rsta           | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Reset signal for the final port A output register stage.                                                            |
| Synchronously resets output port douta to the value specified by parameter READ_RESET_VALUE_A.                      |
+---------------------------------------------------------------------------------------------------------------------+
| ena            | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port A.                                                                                    |
| Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |
+---------------------------------------------------------------------------------------------------------------------+
| regcea         | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Do not change from the provided value.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port A read operations.                                                                                 |
+---------------------------------------------------------------------------------------------------------------------+
| injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Do not change from the provided value.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Do not change from the provided value.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data output for port A read operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| sbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Leave open.                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| dbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Leave open.                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| clkb           | Input     | 1                                     |        | Rising edge | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port B when parameter CLOCKING_MODE is "independent_clock".                                        |
| Unused when parameter CLOCKING_MODE is "common_clock".                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| rstb           | Input     | 1                                     | *      | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Reset signal for the final port B output register stage.                                                            |
| Synchronously resets output port doutb to the value specified by parameter READ_RESET_VALUE_B.                      |
+---------------------------------------------------------------------------------------------------------------------+
| enb            | Input     | 1                                     | *      | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port B.                                                                                    |
| Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |
+---------------------------------------------------------------------------------------------------------------------+
| regceb         | Input     | 1                                     | *      | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Do not change from the provided value.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| addrb          | Input     | ADDR_WIDTH_B                          | *      |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port B read operations.                                                                                 |
+---------------------------------------------------------------------------------------------------------------------+
| injectsbiterrb | Input     | 1                                     | *      | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Do not change from the provided value.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| injectdbiterrb | Input     | 1                                     | *      | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Do not change from the provided value.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| doutb          | Output   | READ_DATA_WIDTH_B                      | *      |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data output for port B read operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| sbiterrb       | Output   | 1                                      | *      | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Leave open.                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| dbiterrb       | Output   | 1                                      | *      | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Leave open.                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| * clka when parameter CLOCKING_MODE is "common_clock". clkb when parameter CLOCKING_MODE is "independent_clock".    |
+---------------------------------------------------------------------------------------------------------------------+
*/

//  xpm_memory_dprom    : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//       instance       : may be changed to meet design requirements.  The instance name (xpm_memory_dprom)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_memory_dprom: Dual Port ROM
// Xilinx Parameterized Macro, Version 2016.4
xpm_memory_dprom # (

  // Common module parameters
  .MEMORY_SIZE        (2048),            //positive integer
  .MEMORY_PRIMITIVE   ("auto"),          //string; "auto", "distributed", or "block";
  .CLOCKING_MODE      ("common_clock"),  //string; "common_clock", "independent_clock" 
  .MEMORY_INIT_FILE   ("none"),          //string; "none" or "&lt;filename&gt;.mem" 
  .MEMORY_INIT_PARAM  (""    ),          //string;
  .USE_MEM_INIT       (1),               //integer; 0,1
  .WAKEUP_TIME        ("disable_sleep"), //string; "disable_sleep" or "use_sleep_pin" 
  .MESSAGE_CONTROL    (0),               //integer; 0,1
  .ECC_MODE           ("no_ecc"),        //string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
  .AUTO_SLEEP_TIME    (0),               //Do not Change

  // Port A module parameters
  .READ_DATA_WIDTH_A  (32),              //positive integer
  .ADDR_WIDTH_A       (6),               //positive integer
  .READ_RESET_VALUE_A ("0"),             //string
  .READ_LATENCY_A     (2),               //non-negative integer

  // Port B module parameters
  .READ_DATA_WIDTH_B  (32),              //positive integer
  .ADDR_WIDTH_B       (6),               //positive integer
  .READ_RESET_VALUE_B ("0"),             //string
  .READ_LATENCY_B     (2)                //non-negative integer

) xpm_memory_dprom_inst (

  // Common module ports
  .sleep          (1'b0),

  // Port A module ports
  .clka           (clka),
  .rsta           (rsta),
  .ena            (ena),
  .regcea         (regcea),
  .addra          (addra),
  .injectsbiterra (1'b0),  //do not change
  .injectdbiterra (1'b0),  //do not change
  .douta          (douta),
  .sbiterra       (),      //do not change
  .dbiterra       (),      //do not change

  // Port B module ports
  .clkb           (clkb),
  .rstb           (rstb),
  .enb            (enb),
  .regceb         (regceb),
  .addrb          (addrb),
  .injectsbiterrb (1'b0),  //do not change
  .injectdbiterrb (1'b0),  //do not change
  .doutb          (doutb),
  .sbiterrb       (),      //do not change
  .dbiterrb       ()       //do not change

);

// End of xpm_memory_dprom instance declaration

				</Template>
				<Template label="Single Port ROM" treetype="template">
/*
XPM_MEMORY instantiation template for single port ROM configurations
Refer to the targeted device family architecture libraries guide for XPM_MEMORY documentation
=======================================================================================================================

Parameter usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Parameter name       | Data type          | Restrictions, if applicable                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_SIZE          | Integer            | Must be integer multiple of READ_DATA_WIDTH_A                           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the total memory array size, in bits.                                                                       |
| For example, enter 65536 for a 2kx32 ROM.                                                                           |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_PRIMITIVE     | String             | Must be "auto", "distributed", or "block"                               |
|---------------------------------------------------------------------------------------------------------------------|
| Designate the memory primitive (resource type) to use:                                                              |
|   "auto": Allow Vivado Synthesis to choose                                                                          |
|   "distributed": Distributed memory                                                                                 |
|   "block": Block memory                                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_FILE     | String             | Must be exactly "none" or the name of the file (in quotes)              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "none" (including quotes) for no memory initialization, or specify the name of a memory initialization file:|
|   Enter only the name of the file with .mem extension, including quotes but without path (e.g. "my_file.mem").      |
|   File format must be ASCII and consist of only hexadecimal values organized into the specified depth by            |
|   narrowest data width generic value of the memory.  See the Memory File (MEM) section for more                     |
|   information on the syntax. Initialization of memory happens through the file name specified only when parameter   |
|   MEMORY_INIT_PARAM value is equal to "".                                                                           |                                                                                       |
|   When using XPM_MEMORY in a project, add the specified file to the Vivado project as a design source.              |
+---------------------------------------------------------------------------------------------------------------------+
| MEMORY_INIT_PARAM   | String             | Must be exactly "" or the string of hex characters (in quotes)           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "" or "0" (including quotes) for no memory initialization through parameter, or specify the string          |
| containing the hex characters.Enter only hex characters and each location separated by delimiter(,).                |
| Parameter format must be ASCII and consist of only hexadecimal values organized into the specified depth by         |
| narrowest data width generic value of the memory.  For example, if the narrowest data width is 8, and the depth of  |
| memory is 8 locations, then the parameter value should be passed as shown below.                                    |
|   parameter MEMORY_INIT_PARAM = "AB,CD,EF,1,2,34,56,78"                                                             |
|                                  |                   |                                                              |
|                                  0th                7th                                                             |
|                                location            location                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| USE_MEM_INIT         | Integer             | Must be 0 or 1                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the generation of below message and 0 to disable the generation of below message completely.    |
| Note: This message gets generated only when there is no Memory Initialization specified either through file or      |
| Parameter.                                                                                                          |
|    INFO : MEMORY_INIT_FILE and MEMORY_INIT_PARAM together specifies no memory initialization.                       |
|    Initial memory contents will be all 0's                                                                          |
+---------------------------------------------------------------------------------------------------------------------+
| WAKEUP_TIME          | String             | Must be "disable_sleep" or "use_sleep_pin"                              |
|---------------------------------------------------------------------------------------------------------------------|
| Specify "disable_sleep" to disable dynamic power saving option, and specify "use_sleep_pin" to enable the           |
| dynamic power saving option                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
| ECC_MODE             | String              | Must be "no_ecc", "encode_only", "decode_only"                         |
|                                            | or "both_encode_and_decode".                                           |
|---------------------------------------------------------------------------------------------------------------------|
| Specify ECC mode on applicable ports of the memory primitive (ECC with Initialization is currently not supported)   |
+---------------------------------------------------------------------------------------------------------------------+
| AUTO_SLEEP_TIME      | Integer             | Must be 0                                                              |
|---------------------------------------------------------------------------------------------------------------------|
| Must be set to 0                                                                                                    |
|   0 : Disable auto-sleep feature                                                                                    |
+---------------------------------------------------------------------------------------------------------------------+
| MESSAGE_CONTROL      | Integer            | Must be 0 or 1                                                          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify 1 to enable the dynamic message reporting such as collision warnings, and 0 to disable the message reporting|
+---------------------------------------------------------------------------------------------------------------------+
| READ_DATA_WIDTH_A    | Integer            | Must be &gt; 0                                                             |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A read data output port douta, in bits.                                               |
+---------------------------------------------------------------------------------------------------------------------+
| ADDR_WIDTH_A         | Integer            | Must be &gt;= ceiling of log2(MEMORY_SIZE/READ_DATA_WIDTH_A)               |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the width of the port A address port addra, in bits.                                                        |
| Must be large enough to access the entire memory from port A, i.e. &gt;= $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A).        |
+---------------------------------------------------------------------------------------------------------------------+
| READ_RESET_VALUE_A   | String             |                                                                         |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the reset value of the port A final output register stage in response to rsta input port is assertion.      |
| As this parameter is a string, please specify the hex values inside double quotes. As an example,                   |
| If the read data width is 8, then specify READ_RESET_VALUE_A = "EA";                                                |
+---------------------------------------------------------------------------------------------------------------------+
| READ_LATENCY_A       | Integer             | Must be &gt;= 0 for distributed memory, or &gt;= 1 for block memory          |
|---------------------------------------------------------------------------------------------------------------------|
| Specify the number of register stages in the port A read data pipeline. Read data output to port douta takes this   |
| number of clka cycles.                                                                                              |
| To target block memory, a value of 1 or larger is required: 1 causes use of memory latch only; 2 causes use of      |
| output register. To target distributed memory, a value of 0 or larger is required: 0 indicates combinatorial output.|
| Values larger than 2 synthesize additional flip-flops that are not retimed into memory primitives.                  |
+---------------------------------------------------------------------------------------------------------------------+

Port usage table, organized as follows:
+---------------------------------------------------------------------------------------------------------------------+
| Port name      | Direction | Size, in bits                         | Domain | Sense       | Handling if unused      |
|---------------------------------------------------------------------------------------------------------------------|
| Description                                                                                                         |
+---------------------------------------------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------------------+
| sleep          | Input     | 1                                     |        | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| sleep signal to enable the dynamic power saving feature.                                                            |
+---------------------------------------------------------------------------------------------------------------------+
| clka           | Input     | 1                                     |        | Rising edge | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock signal for port A.                                                                                            |
+---------------------------------------------------------------------------------------------------------------------+
| rsta           | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Reset signal for the final port A output register stage.                                                            |
| Synchronously resets output port douta to the value specified by parameter READ_RESET_VALUE_A.                      |
+---------------------------------------------------------------------------------------------------------------------+
| ena            | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Memory enable signal for port A.                                                                                    |
| Must be high on clock cycles when read operations are initiated. Pipelined internally.                              |
+---------------------------------------------------------------------------------------------------------------------+
| regcea         | Input     | 1                                     | clka   | Active-high | Tie to 1'b1             |
|---------------------------------------------------------------------------------------------------------------------|
| Clock Enable for the last register stage on the output data path.                                                   |
+---------------------------------------------------------------------------------------------------------------------+
| addra          | Input     | ADDR_WIDTH_A                          | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Address for port A read operations.                                                                                 |
+---------------------------------------------------------------------------------------------------------------------+
| injectsbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Do not change from the provided value.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| injectdbiterra | Input     | 1                                     | clka   | Active-high | Tie to 1'b0             |
|---------------------------------------------------------------------------------------------------------------------|
| Do not change from the provided value.                                                                              |
+---------------------------------------------------------------------------------------------------------------------+
| douta          | Output   | READ_DATA_WIDTH_A                      | clka   |             | Required                |
|---------------------------------------------------------------------------------------------------------------------|
| Data output for port A read operations.                                                                             |
+---------------------------------------------------------------------------------------------------------------------+
| sbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate single bit error occurrence on the data output of port A.                                 |
+---------------------------------------------------------------------------------------------------------------------+
| dbiterra       | Output   | 1                                      | clka   | Active-high | Leave open              |
|---------------------------------------------------------------------------------------------------------------------|
| Status signal to indicate double bit error occurrence on the data output of port A.                                 |
+---------------------------------------------------------------------------------------------------------------------+
*/

//  xpm_memory_sprom    : In order to incorporate this function into the design, the following instance declaration
//       Verilog        : needs to be placed in the body of the design code.  The default values for the parameters
//       instance       : may be changed to meet design requirements.  The instance name (xpm_memory_sprom)
//     declaration      : and/or the port declarations within the parenthesis may be changed to properly reference and
//         code         : connect this function to the design.  All inputs and outputs must be connected.

//  &lt;--Cut the following instance declaration and paste it into the design--&gt;

// xpm_memory_sprom: Single Port ROM
// Xilinx Parameterized Macro, Version 2016.4
xpm_memory_sprom # (

  // Common module parameters
  .MEMORY_SIZE        (2048),           //positive integer
  .MEMORY_PRIMITIVE   ("auto"),         //string; "auto", "distributed", or "block";
  .MEMORY_INIT_FILE   ("none"),         //string; "none" or "&lt;filename&gt;.mem" 
  .MEMORY_INIT_PARAM  (""    ),         //string;
  .USE_MEM_INIT       (1),              //integer; 0,1
  .WAKEUP_TIME        ("disable_sleep"),//string; "disable_sleep" or "use_sleep_pin" 
  .MESSAGE_CONTROL    (0),              //integer; 0,1
  .ECC_MODE           ("no_ecc"),       //string; "no_ecc", "encode_only", "decode_only" or "both_encode_and_decode" 
  .AUTO_SLEEP_TIME    (0),              //Do not Change

  // Port A module parameters
  .READ_DATA_WIDTH_A  (32),             //positive integer
  .ADDR_WIDTH_A       (6),              //positive integer
  .READ_RESET_VALUE_A ("0"),            //string
  .READ_LATENCY_A     (2)               //non-negative integer

) xpm_memory_sprom_inst (

  // Common module ports
  .sleep          (1'b0),

  // Port A module ports
  .clka           (clka),
  .rsta           (rsta),
  .ena            (ena),
  .regcea         (regcea),
  .addra          (addra),
  .injectsbiterra (1'b0),  //do not change
  .injectdbiterra (1'b0),  //do not change
  .douta          (douta),
  .sbiterra       (),      //do not change
  .dbiterra       ()       //do not change

);

// End of xpm_memory_sprom instance declaration

				</Template>
			</SubFolder>
		</SubFolder>
	</Folder>
	<Folder label="User Templates" language="Verilog" treetype="folder" utallowed="true">
	</Folder>
</RootFolder>
