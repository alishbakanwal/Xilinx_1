##Calculate the number of mem files required
##TODO::Only single rank memories are supported yet
proc get_number_of_mem_files { Component_width Mig_width } {
  if { $Mig_width < $Component_width} {
    puts "ERROR::Component Width must be greater than equal to the MIG Data Width\n"
    return 0
  }
  set n_mem_files [expr {$Mig_width/$Component_width} ]
  return $n_mem_files
}

#Split the data of mem file generated by vivado into multiple mem files
proc split_mem_files { Component_width Mig_width orig_mem prefix output_dir } {
  set n_mem_files [get_number_of_mem_files $Component_width $Mig_width]
 
  if { $n_mem_files == 0 } {
    return
  }

  set fp [open $orig_mem r]
  set mem_file_count  [expr {$n_mem_files - 1}];
  array set mem_data_array {}

  for {set i 0} {$i < $n_mem_files} {incr i} {
    set mem_data_array($i) ""
    set file_name [file join $output_dir ${prefix}_int_ddr_$i\.mem]
    set fileId($i) [open $file_name "w"]
  }

  while { [gets $fp data] >= 0} {
    set find [string range $data 0 1]
    set print_to_files 1
    set stripped_data [string map {" " ""} $data]
    set stripped_data [string trim $stripped_data]
    set length [string length $stripped_data]
    if {$length != 0} {
      if {$find == "//"} {
        #do nothing
        set print_to_files 0
      } elseif {$find == "@0"} {
         set addr [string range $stripped_data 1 $length-1]
         set addr 0x$addr
         set n_files [format 0x%x $n_mem_files]
         set addr [format @0%x [expr {$addr / $n_files} ]]
         set addr [string toupper $addr]
         set mem_file_count [expr {$n_mem_files-1}]
         set print_to_files 1
      } else {
        set char_for_each_mem  [ expr {$Component_width / 4} ]
        for {set i 0} {$i < $length} {incr i $char_for_each_mem} {
          set mem_data_array($mem_file_count) [concat $mem_data_array($mem_file_count)[string range $stripped_data $i [expr {$i+$char_for_each_mem-1} ]]] 
          if {$mem_file_count == 0} {
            set mem_file_count [expr {$n_mem_files-1}]
          } else {
            set mem_file_count [expr {$mem_file_count - 1}]
          }
        }
        set print_to_files 2
      }
      for {set i 0} {$i < $n_mem_files} {incr i} {
        if {$print_to_files == 0} {
          break
        } elseif {$print_to_files == 1} {
          puts $fileId($i) $mem_data_array($i)
          set mem_data_array($i) ""
          puts $fileId($i) $addr
        } else {
          if {[string length $mem_data_array($i)] >= [expr {$Component_width * 2}]} {
           set s_length [string length $mem_data_array($i)] 
           for {set j 0} {$j < $s_length} {incr j [expr {$Component_width*2}]} {
            if {[string length $mem_data_array($i)] < [expr {$Component_width*2}]} {
              break
            }
            puts $fileId($i) [string range $mem_data_array($i) 0 [expr {$Component_width*2 -1}]]
            set mem_data_array($i) [string range $mem_data_array($i) [expr {$Component_width * 2}] [string length $mem_data_array($i)]]
           }
          }

        }
      }
    }
  }
  for {set i 0} {$i < $n_mem_files} {incr i} {
    puts $fileId($i) $mem_data_array($i)
    set mem_data_array($i) ""
    close $fileId($i)
  }
} 

#Byte swaping and Word reversing
proc prep_mem {mem_file optiona optionb output_file Component_width} {
set swap $optiona
set out_file $output_file
set pipe_swap $optionb
set mem $mem_file
set fp [open $mem r]
set fileId [open $out_file "w"]
if {$swap == "swap"} {
 if {$pipe_swap == "rev"} {
  puts $fileId "//This is a byte and word swapped version of $mem"
 } else {
  puts $fileId "//This is a byte swapped version of $mem"
 }
 puts $fileId "@0"
 while { [gets $fp data] >= 0 } {
  set length [string length $data]
  set find [string range $data 0 1]
 
  if {$length != 0} {
   if {$find == "//" || $find == "@0"} {
    #puts $data
   } else {
    set temp [string map {" " ""} $data]
    set temp_data ""
    for {set i 0} {$i < $length} {incr i 8} {
        set byte0 [string range $temp $i+6 $i+7]
        set byte1 [string range $temp $i+4 $i+5]
        set byte2 [string range $temp $i+2 $i+3]
        set byte3 [string range $temp $i+0 $i+1]
        set word [concat $byte1$byte0$byte3$byte2]
        set temp_data [concat $temp_data $word] 
    }
    
    if {$pipe_swap == "rev"} {
     set req_word ""
     set m_word ""
     set stripped_temp_data [string map {" " ""} $temp_data]
     for {set i 0} {$i < $length} {incr i [expr {$Component_width * 2}]} {
      for {set j [expr {$Component_width/4 -1}]} {$j >= 0} {set j [expr {$j - 1}]} {
        set word [string range $stripped_temp_data [expr {$i + 8*$j}] [expr {$i + 8*$j + 7}]]
        set req_word [concat $req_word$word]
      }
     }
     puts $fileId $req_word
    } else {
     puts $fileId $temp_data
    }
    
        
   }
  }

 }
}
close $fp
close $fileId

}


proc gen_ddr_mem_files {Component_width Mig_width orig_mem prefix output_directory} {
   split_mem_files $Component_width $Mig_width $orig_mem $prefix $output_directory        
   set n_mem_file [get_number_of_mem_files $Component_width $Mig_width]

   for {set i 0} {$i < $n_mem_file} {incr i} {
     prep_mem [file join $output_directory ${prefix}_int_ddr_$i\.mem] swap rev [file join $output_directory ${prefix}_ddr_$i\.mem] $Component_width
   }
}

# XSIP watermark, do not delete 67d7842dbbe25473c3c32b93c0da8047785f30d78e8a024de1b57352245f9689
